#ifndef _HC_NET_SDK_H_
#define _HC_NET_SDK_H_

#ifndef _WINDOWS_
#if (defined(_WIN32) || defined(_WIN64))
#include <winsock2.h>
        #include <windows.h>
#endif
#endif

#ifndef __PLAYRECT_defined
#define __PLAYRECT_defined
typedef struct __PLAYRECT
{
    int x;
    int y;
    int uWidth;
    int uHeight;
}PLAYRECT;
#endif

#if (defined(_WIN32)) //windows
#define NET_DVR_API  extern "C" __declspec(dllimport)
    typedef  unsigned __int64   UINT64;
    typedef  signed   __int64   INT64;
#elif defined(__linux__) || defined(__APPLE__) //linux
#define  BOOL  int
typedef  unsigned int       DWORD;
typedef  unsigned short     WORD;
typedef  unsigned short     USHORT;
typedef  short              SHORT;
typedef  int                LONG;
typedef  unsigned char      BYTE;
typedef  unsigned int       UINT;
typedef  void*              LPVOID;
typedef  void*              HANDLE;
typedef  unsigned int*      LPDWORD;
typedef  unsigned long long UINT64;
typedef  signed long long   INT64;

#ifndef TRUE
#define TRUE  1
#endif
#ifndef FALSE
#define FALSE 0
#endif
#ifndef NULL
#define NULL 0
#endif

#define __stdcall
#define CALLBACK

#define NET_DVR_API extern "C"
typedef unsigned int   COLORKEY;
typedef unsigned int   COLORREF;

#ifndef __HWND_defined
#define __HWND_defined
#if defined(__linux__)
typedef unsigned int HWND;
#else
typedef void* HWND;
#endif
#endif

#ifndef __HDC_defined
#define __HDC_defined
#if defined(__linux__)
typedef struct __DC
{
    void*   surface;        //SDL Surface
    HWND    hWnd;           //HDC window handle
}DC;
typedef DC* HDC;
#else
typedef void* HDC;
#endif
#endif

typedef struct tagInitInfo
{
    int uWidth;
    int uHeight;
}INITINFO;
#endif

//Macro definition
#define MAX_NAMELEN			        16		//DVR's local Username
#define MAX_RIGHT			        32		//Authority permitted by Device (1- 12 for local authority,  13- 32 for remote authority)
#define NAME_LEN			        32      //Username length
#define PASSWD_LEN			        16      //Password length
#define MAX_PASSWD_LEN_EX		    64      //Password length 64 bit
#define GUID_LEN					16      //GUID length
#define DEV_TYPE_NAME_LEN			24      //Device name length
#define SERIALNO_LEN		        48      //SN length
#define MACADDR_LEN			        6       //Length of MAC address
#define MAC_ADDRESS_NUM             48      //MAC Address num
#define MAX_SENCE_NUM               16      //scene Num
#define RULE_REGION_MAX             128     //Rule Region num
#define MAX_ETHERNET		        2       //Configurable Ethernet of device
#define MAX_NETWORK_CARD            4       //Configurable Network card of device
#define PATHNAME_LEN                128     //length of path name
#define MAX_PRESET_V13              16      //Preset number
#define  MAX_TEST_COMMAND_NUM       32
#define MAX_NUMBER_LEN              32      //number length
#define MAX_NAME_LEN                128     //device name length
#define MAX_INDEX_LED               8       //LED Index 2013-11-19
#define    MAX_CUSTOM_DIR           64      //Custom Dir Max Length
#define URL_LEN_V40                 256     //max URL Length


#define CLOUD_NAME_LEN              48      //Cloud storage server username length
#define CLOUD_PASSWD_LEN            48      //Cloud storage server Password length

#define MAX_SENSORNAME_LEN          64      //Sensor Name Len
#define MAX_SENSORCHAN_LEN          32      //Sensor Channel Len
#define MAX_DESCRIPTION_LEN         32      //Description Len
#define MAX_DEVNAME_LEN_EX          64      //Device Name Len
#define NET_SDK_MAX_FILE_PATH       256     //File path len
#define MAX_TMEVOICE_LEN            64      //TME Voice Len

#define MAX_NUM_INPUT_BOARD         512     //the maximum number of input board
#define  MAX_SHIPSDETE_REGION_NUM    8       // Ship detection area maximum number list
//led controler
#define  MAX_LEN_TEXT_CONTENT    128
#define  MAX_NUM_INPUT_SOURCE_TEXT    32
#define  MAX_NUM_OUTPUT_CHANNEL  512

#define MAX_RES_NUM_ONE_VS_INPUT_CHAN  8
#define MAX_VS_INPUT_CHAN_NUM  16

#define MAX_LEN_OSD_CONTENT  256
#define MAX_NUM_OSD_ONE_SUBWND  8
#define MAX_NUM_SPLIT_WND  64
#define MAX_NUM_OSD 8

//2013-11-19
#define MAX_DEVNAME_LEN             32      //Device Name
#define MAX_LED_INFO                256     //The screen font display information
#define MAX_TIME_LEN                32      //Time Max Len
#define MAX_CARD_LEN                24      //Card Max Len
#define MAX_OPERATORNAME_LEN        32      //OperatorName Max Len

#define THERMOMETRY_ALARMRULE_NUM   40       //Thermometry Alarm rule Number
#define MAX_THERMOMETRY_REGION_NUM  40      //Thermometry Region Num
#define MAX_THERMOMETRY_DIFFCOMPARISON_NUM  40 //Thermometry Temperature difference Num
#define MAX_SHIPS_NUM               20      //Ships Num

#define ASYN_LOGIN_SUCC                1
#define ASYN_LOGIN_FAILED            0


#define MAX_TIMESEGMENT_V30	        8       //Maximum number of time segments in 9000 DVR's guard schedule
#define MAX_TIMESEGMENT		        4       //Maximum number of time segments in 8000 DVR's guard schedule
#define MAX_SHELTERNUM			    4       //Maximum number of mask areas in 8000 DVR
#define MAX_DAYS				    7       //The number of days in a week
#define MAX_ACCESSORY_CARD         256      //The maximum length parts board information
#define PHONENUMBER_LEN			    32      //Maximum length of PPPOE number
#define MAX_ICR_NUM                 8       //ITC Maximum ICR Preset Point number
#define MAX_VEHICLEFLOW_INFO                       24       //ITC maximum vehicleflow info number
#define MAX_SHELTERNUM                4       //Maximum number of mask areas in 8000 DVR
#define MAX_DAYS                    7       //The number of days in a week
#define PHONENUMBER_LEN                32      //Maximum length of PPPOE number


#define MAX_DISKNUM_V30                33        //Maximum disk number in 9000 DVR,  including 16 internal SATA disks,  1 eSTAT disk and 16 NFS disks
#define MAX_DISKNUM                    16      //Maximum disk number in 8000 DVR
#define MAX_DISKNUM_V10                8       //used in 1.2 or earlier version

#define MAX_WINDOW_V30                32      //9000 maximum number of local display windows
#define MAX_WINDOW_V40                64      //Netra 2.3.1 extern
#define MAX_WINDOW                    16      //8000 maximum number of local display windows
#define MAX_VGA_V30                    4       //9000 maximum number of VGA
#define MAX_VGA                        1       //8000 maximum number of VGA

#define MAX_USERNUM_V30                32      //Maximum number of 9000 DVR users
#define MAX_USERNUM                    16      //Maximum number of 8000 DVR users
#define MAX_EXCEPTIONNUM_V30        32      //Maximum number of exceptions handled by 9000 DVR
#define MAX_EXCEPTIONNUM            16      //Maximum number of exceptions handled by 8000 DVR
#define MAX_LINK                    6       //Maximum number of video connections to 8000's single channel
#define MAX_ITC_EXCEPTIONOUT        32      //Maximun number of ITC exception Out
#define MAX_SCREEN_DISPLAY_LEN        512        //Screen characters in length

#define MAX_DECPOOLNUM                4       //Maximum loop decoding number supported by each decoding channel of single channel decoder
#define MAX_DECNUM                    4       //Maximum decoding channel number of single channel decoder (only has one channel,  others are reserved)
#define MAX_TRANSPARENTNUM            2       //Maximum number of Transparent channel in single channel decoder
#define MAX_CYCLE_CHAN                16      //Maximum number of loop channels in single channel decoder
#define MAX_CYCLE_CHAN_V30          64      //Maximum number of loop channels in single channel decoder (extend)
#define MAX_DIRNAME_LENGTH            80      //Maximum number of directory name
#define MAX_WINDOWS                    16      //Maximum number of windows

#define MAX_STRINGNUM_V30            8        //Maximum number of OSD lines in 9000 DVR
#define MAX_STRINGNUM                4       //Maximum number of OSD lines in 8000 DVR
#define MAX_STRINGNUM_EX            8       //8000 customized extensions
#define MAX_AUXOUT_V30                16      //9000 maximum number of AUX output ports
#define MAX_AUXOUT                    4       //8000 maximum number of AUX output ports
#define MAX_HD_GROUP                16      //9000 maximum number of hard disk groups
#define MAX_HD_GROUP_V40            32      // maximum number of hard disk groups (256NVR)
#define MAX_NFS_DISK                8       //8000 maximum number of NFS disks

#define IW_ESSID_MAX_SIZE            32      //SSID length of WIFI
#define IW_ENCODING_TOKEN_MAX        32      //Maximum bytes of WIFI security Key
#define MAX_SERIAL_NUM                64        //Maximum number of Transparent channel
#define MAX_DDNS_NUMS                10      //Maximum number of DDNS in 9000
#define MAX_DOMAIN_NAME                64        //Maximum Domain Name length
#define MAX_EMAIL_ADDR_LEN            48        //Maximum Email Address length
#define MAX_EMAIL_PWD_LEN            32      //Maximum Email password length
#define MAX_SLAVECAMERA_NUM         8       //Maximum SlaveCamera Number
#define MAX_CALIB_NUM               6       //Maximum Calib Num
#define MAX_CALIB_NUM_EX            20      //Maximum Calib Num Express
#define MAX_LEDDISPLAYINFO_LEN      1024    //Maximum LedDisplayInfo Len
#define MAX_PEOPLE_DETECTION_NUM    8       //Maximum People Detection Region Number

#define MAXPROGRESS                    100     //Maximum percent while playing back
#define MAX_SERIALNUM                2       //Serial Port supported by 8000 DVR,  1- 232,  2- 485
#define CARDNUM_LEN                    20      //Card number length
#define CARDNUM_LEN_OUT                32      //Card number length for outer
#define MAX_VIDEOOUT_V30            4       //9000 DVR analog video output number.
#define MAX_VIDEOOUT                2       //8000 DVR analog video output number

#define MAX_PRESET_V30                256        // 9000 Preset number of PTZ
#define MAX_TRACK_V30                256        // 9000 Track number of PTZ
#define MAX_CRUISE_V30                256        // 9000 Cruise number of PTZ
#define MAX_PRESET                    128        // 8000 Preset number of PTZ
#define MAX_TRACK                    128        // 8000 Track number of PTZ
#define MAX_CRUISE                    128        // 8000 Cruise number of PTZ

#define MAX_PRESET_V40                300        /* PTZ Max Support Preset Num */
#define MAX_CRUISE_POINT_NUM        128     /* Max Support Cruise Point Num */
#define MAX_CRUISEPOINT_NUM_V50     256     //Max Support Cruise Point V50 Num

#define CRUISE_MAX_PRESET_NUMS        32         // Maximum number of Cruise points in one Cruise
#define MAX_FACE_PIC_NUM            30      //Face Pictrue Num
#define LOCKGATE_TIME_NUM           4       //Lock Gate Num

#define MAX_SERIAL_PORT             8       // Maximum number of RS232 supported by 9000 DVR
#define MAX_PREVIEW_MODE            8       // Maximum number of display layout mode;  single windows/4 windows/9 windows/16 windows/...
#define MAX_MATRIXOUT               16      // Maximum number of analog matrix output
#define LOG_INFO_LEN                11840   // Additional information of Log
#define DESC_LEN                    16      // String length of PTZ description
#define PTZ_PROTOCOL_NUM            200     // Maximum number of PTZ protocols in 9000 DVR
#define IPC_PROTOCOL_NUM            50      // Maximum number of ipc protocols in 9000 DVR

#define MAX_AUDIO                    1       //Number of talk channels in 8000 DVR
#define MAX_AUDIO_V30                2       //Number of talk channels in 9000 DVR
#define MAX_CHANNUM                    16      //Maximum number of video/audio channels in 8000 DVR
#define MAX_ALARMIN                    16      //Maximum number of alarm input channels in 8000 DVR
#define MAX_ALARMOUT                4       //Maximum number of alarm output channels in 8000 DVR
//9000 IP Camera
#define MAX_ANALOG_CHANNUM          32      //32 analog channels in total
#define MAX_ANALOG_ALARMOUT         32      //32 analog alarm output channels intotal
#define MAX_ANALOG_ALARMIN          32      //32 analog alarm input channels intotal
#define MAX_IP_DEVICE               32      //9000 DVR can connect 32 IP devices
#define MAX_IP_DEVICE_V40           64      //Maximum number of IP devices that can be added, the value is 64, including IVMS-2000
#define MAX_IP_CHANNEL              32      //9000 DVR can connect 32 IP channels
#define MAX_IP_ALARMIN              128     //Maximum number of alarm input channels that can be added
#define MAX_IP_ALARMOUT             64      //Maximum number of alarm output channels that can be added
#define MAX_IP_ALARMIN_V40          4096    //Maximum number of alarm input channels that can be added
#define MAX_IP_ALARMOUT_V40         4096    //Maximum number of alarm output channels that can be added

#define MAX_RECORD_FILE_NUM         20        //max file number for back , cd write or delete

//SDK_V31 ATM
#define MAX_ACTION_TYPE                12        //Maximum action number of the transactions added
#define MAX_ATM_PROTOCOL_NUM        256     //Maximum protocol number of each input sort
#define ATM_CUSTOM_PROTO            1025    //user- defined protocol
#define ATM_PROTOCOL_SORT           4       //number of ATM protocol segment
#define ATM_DESC_LEN                32      //Length of the ATM description string
// SDK_V31 ATM

/*Maximum channels number including analog channels and IP channels */
#define MAX_IPV6_LEN                  64      //MAX IPv6 Address Len
#define MAX_EVENTID_LEN             64      //MAX EventID Len

#define INVALID_VALUE_UINT32         0xffffffff   // Invalid Value
#define MAX_CHANNUM_V40             512
#define MAX_MULTI_AREA_NUM          24

#define MAX_SINGLE_FTPPICNAME_LEN       20 //The largest single FTP channel names
#define MAX_CAMNAME_LEN                 32 //The channel name
#define MAX_FTPNAME_NUM                 12 //Number of TFP name


#define COURSE_NAME_LEN                32
#define INSTRUCTOR_NAME_LEN            16
#define COURSE_DESCRIPTION_LEN        256
#define MAX_TIMESEGMENT_V40            16

#define MAX_MIX_CHAN_NUM        16        //max mixed channel number
#define MAX_LINE_IN_CHAN_NUM    16        //max line in channel number
#define MAX_MIC_CHAN_NUM        16        //max mic channel number
#define INQUEST_CASE_NO_LEN        64        //inquest case number length
#define INQUEST_CASE_NAME_LEN    64        //inquest case name length
#define CUSTOM_INFO_LEN            64        //custom information length
#define INQUEST_CASE_LEN        64        //inquest case information length

#define MAX_FILE_ID_LEN         128
#define MAX_PIC_NAME_LEN        128 //picture name len

#define MAX_CHANNUM_V30                ( MAX_ANALOG_CHANNUM + MAX_IP_CHANNEL )   //64
#define MAX_ALARMOUT_V40             (MAX_IP_ALARMOUT_V40 +MAX_ANALOG_ALARMOUT) //4128
#define MAX_ALARMOUT_V30               ( MAX_ANALOG_ALARMOUT + MAX_IP_ALARMOUT ) //96
#define MAX_ALARMIN_V30                ( MAX_ANALOG_ALARMIN + MAX_IP_ALARMIN )   //160
#define MAX_ALARMIN_V40             (MAX_IP_ALARMIN_V40 +MAX_ANALOG_ALARMOUT) //4128
#define MAX_ANALOG_ALARM_WITH_VOLT_LIMIT    16 //max analog alarm num with limited volt

#define MAX_ROIDETECT_NUM           8
#define MAX_LANERECT_NUM            5       //Max Lane rect num
#define MAX_FORTIFY_NUM                10      //Max number of channels to be fortified
#define MAX_INTERVAL_NUM            4       //Max number of interval
#define MAX_CHJC_NUM                3       //Max number of chars short for province of car
#define MAX_VL_NUM                    5       //Max number of virtual lines
#define MAX_DRIVECHAN_NUM            16      //max number of drive channels
#define MAX_COIL_NUM                3       //max number of coils
#define MAX_SIGNALLIGHT_NUM            6       //max number of signal lights
#define LEN_16                        16
#define LEN_32                        32
#define LEN_31                        31
#define MAX_CABINET_COUNT           8       //max number of cabinets
#define MAX_ID_LEN                  48
#define MAX_PARKNO_LEN              16
#define MAX_ALARMREASON_LEN         32
#define MAX_UPGRADE_INFO_LEN        48
#define MAX_CUSTOMDIR_LEN           32      //max Lenth of custom Dir
#define MAX_LED_INFO_LEN            512     //LED Info Len
#define MAX_VOICE_INFO_LEN          128     //Voice Info Len
#define MAX_LITLE_INFO_LEN          64      //Litle Info Len
#define MAX_CUSTOM_INFO_LEN         64      //Custom Info Len
#define MAX_PHONE_NUM_LEN           16      //Phone Num Len
#define MAX_APP_SERIALNUM_LEN       32      //App Serial Num Len

#define AUDIOTALKTYPE_G722            0
#define AUDIOTALKTYPE_G711_MU        1
#define AUDIOTALKTYPE_G711_A        2
#define AUDIOTALKTYPE_MP2L2         5
#define AUDIOTALKTYPE_G726            6
#define AUDIOTALKTYPE_AAC            7
#define AUDIOTALKTYPE_PCM             8

//packet type
#define FILE_HEAD            0 //file head
#define VIDEO_I_FRAME        1 //video I frame
#define VIDEO_B_FRAME        2 //video B frame
#define VIDEO_P_FRAME        3 //video P frame
#define AUDIO_PACKET        10 //audio packet
#define PRIVT_PACKET        11 //private packet
//E frame
#define HIK_H264_E_FRAME    (1 << 6)



#define MAX_TRANSPARENT_CHAN_NUM    4        //max transparent channels for every serial channel
#define MAX_TRANSPARENT_ACCESS_NUM  4        //max host access number for every lisening port

//ITS
#define MAX_PARKING_STATUS            8        //Park State: 0-no Car\A3\AC1-Car\A3\AC2-Press Line (highest priority), 3-Special Park Spaces
#define MAX_PARKING_NUM                4        //A channel 4 largest parking Spaces (from left to right an array of 0 ~ 3)

#define MAX_ITS_SCENE_NUM          16       //max ITS scene num
#define MAX_SCENE_TIMESEG_NUM      16       //max scene time segment num
#define MAX_IVMS_IP_CHANNEL        128      //max ip channels
#define DEVICE_ID_LEN              48       //device id len
#define MONITORSITE_ID_LEN         48       //monitor site id len
#define MAX_AUXAREA_NUM            16       //max auxiliary area num
#define MAX_SLAVE_CHANNEL_NUM      16       //max slave channel num
#define MAX_DEVDESC_LEN            64       //Device description information Len
#define MAX_SECRETKEY_LEN          512      //Secret Key Len
#define MAX_INDEX_CODE_LEN         64       //Index Code Len
#define MAX_ILLEGAL_LEN            64       //Illegal Len
#define ILLEGAL_LEN            32       //Illegal Len
#define CODE_LEN        64  //Authorization code
#define ALIAS_LEN       32  //Alias\A3\ACread only
//IPC
#define MAX_SCH_TASKS_NUM 10

#define MAX_SERVERID_LEN            64 //Max Server ID Len
#define MAX_SERVERDOMAIN_LEN        128 //Max Server Domain Name Len
#define MAX_AUTHENTICATEID_LEN      64 //Max Authenticate ID Len
#define MAX_AUTHENTICATEPASSWD_LEN  32 //Max Authenticate Passwd Len
#define MAX_SERVERNAME_LEN          64 //????????
#define MAX_COMPRESSIONID_LEN       64 //??ID?????
#define MAX_SIPSERVER_ADDRESS_LEN   128 //SIP??????????IP??
#define MAX_PlATE_NO_LEN         32   //Max Plate Number Len 2013-09-27
#define UPNP_PORT_NUM            12      //upnp port Number
#define MAX_NOTICE_NUMBER_LEN       32   //max notice number len
#define MAX_NOTICE_THEME_LEN        64   //max notice theme len
#define MAX_NOTICE_DETAIL_LEN       1024 //max notice detal len
#define MAX_NOTICE_PIC_NUM          6    //max notice pic num
#define MAX_DEV_NUMBER_LEN          32   //Max Device ID Len

#define HOLIDAY_GROUP_NAME_LEN          32  //holiday group name len
#define MAX_HOLIDAY_PLAN_NUM            16  //holiday max plan number
#define TEMPLATE_NAME_LEN               32  //plan template name len
#define MAX_HOLIDAY_GROUP_NUM           16   //plan template max group number
#define DOOR_NAME_LEN                   32  //door name len
#define STRESS_PASSWORD_LEN             8   //stress password len
#define SUPER_PASSWORD_LEN              8   //super password len
#define GROUP_NAME_LEN                  32  //group name len
#define GROUP_COMBINATION_NUM           8   //group combination number
#define MULTI_CARD_GROUP_NUM            4   //multi card group number
#define ACS_CARD_NO_LEN                 32  //access card No. len
#define CARD_PASSWORD_LEN               8   // card password len
#define MAX_DOOR_NUM                    32  //max door number
#define MAX_CARD_RIGHT_PLAN_NUM         4   //max card right plan number
#define MAX_GROUP_NUM_128               128 //The largest number of grou
#define MAX_CARD_READER_NUM             64  //max card reader number
#define MAX_SNEAK_PATH_NODE             8   //max sneak path node number
#define MAX_MULTI_DOOR_INTERLOCK_GROUP  8   //max multi door interlock group
#define MAX_INTER_LOCK_DOOR_NUM         8   //max inter lock door number
#define MAX_CASE_SENSOR_NUM             8   //max case sensor number
#define MAX_DOOR_NUM_256                256 //max door num
#define MAX_READER_ROUTE_NUM            16  //max reader route num
#define MAX_FINGER_PRINT_NUM            10  //max finger print num
#define MAX_CARD_READER_NUM_512            512 //max card reader num

#define ERROR_MSG_LEN                      32

#define PER_RING_PORT_NUM                2   //the port number of the ring
#define SENSORNAME_LEN                  32  //Sensor Name Len
#define MAX_SENSORDESCR_LEN             64  //Sensor Description Len
#define MAX_DNS_SERVER_NUM              2   //DNS Server Num

#define WEP_KEY_MAX_SIZE                32 //WEP Key Max Size
#define WEP_KEY_MAX_NUM                 4  //WEP Key Max Num
#define WPA_KEY_MAX_SIZE                64 //WPA Key Max Size

#define MAX_IDCODE_LEN                  128 //firmware code length
#define MAX_VERSIIN_LEN                 64  //max version length
#define MAX_IDCODE_NUM                  32  //max firmware code number
#define SDK_LEN_2048                    2048

#define RECT_POINT_NUM                    4

#define MAX_PUBLIC_KEY_LEN 512
#define CHIP_SERIALNO_LEN 32
#define ENCRYPT_DEV_ID_LEN        20
#define MAX_SEARCH_ID_LEN               36
#define TERMINAL_NAME_LEN               64
#define MAX_URL_LEN                     512
#define REGISTER_NAME_LEN               64
#define KEY_WORD_NUM             3 //key word number
#define KEY_WORD_LEN            128  //key word length
//optical fiber
#define MAX_PORT_NUM            64  //maximum port number
#define MAX_SINGLE_CARD_PORT_NO 4   //maximum port number of single card
#define MAX_FUNC_CARD_NUM       32  //maximum function card number
#define MAX_FC_CARD_NUM         33  //maximum card number
#define MAX_REMARKS_LEN         128 //port remarks length
#define NET_DEV_NAME_LEN        64  //The length of the device name
#define NET_DEV_TYPE_NAME_LEN  64  //Device type name length
//LED
#define MAX_OUTPUT_PORT_NUM                32    //maximum output port number
#define MAX_SINGLE_PORT_RECVCARD_NUM    64    //maximum receive card number of single port
#define MAX_GAMMA_X_VALUE                256    //maximum x value number of GAMMA table

#define ABNORMAL_INFO_NUM               4   //abnormal info num

#define PLAYLIST_NAME_LEN				64			//play list name length
#define PLAYLIST_ITEM_NUM				64			//play item nummber

//NVR
#define NET_SDK_MAX_LOGIN_PASSWORD_LEN           128 //login password len
#define NET_SDK_MAX_ANSWER_LEN                   256 //security answer length
#define NET_SDK_MAX_QUESTION_LIST_LEN            32//security question list length

/*******************Global Error Code**********************/
#define NET_DVR_NOERROR 					0	//No Error
#define NET_DVR_PASSWORD_ERROR 				1	//Username or Password error
#define NET_DVR_NOENOUGHPRI 				2	//Don't have enough authority
#define NET_DVR_NOINIT 						3	//have not Initialized
#define NET_DVR_CHANNEL_ERROR 				4	//Channel number error
#define NET_DVR_OVER_MAXLINK 				5	//Number of clients connecting to DVR beyonds the Maximum
#define NET_DVR_VERSIONNOMATCH				6	//Version is not matched
#define NET_DVR_NETWORK_FAIL_CONNECT		7	//Connect to server failed
#define NET_DVR_NETWORK_SEND_ERROR			8	//Send data to server failed
#define NET_DVR_NETWORK_RECV_ERROR			9	//Receive data from server failed
#define NET_DVR_NETWORK_RECV_TIMEOUT		10	//Receive data from server timeout
#define NET_DVR_NETWORK_ERRORDATA			11	//Transferred data has error
#define NET_DVR_ORDER_ERROR					12	//Wrong Sequence of invoking API
#define NET_DVR_OPERNOPERMIT				13	//No such authority.
#define NET_DVR_COMMANDTIMEOUT				14	//Execute command timeout
#define NET_DVR_ERRORSERIALPORT				15	//Serial port number error
#define NET_DVR_ERRORALARMPORT				16	//Alarm port error
#define NET_DVR_PARAMETER_ERROR 			17  //Parameters error
#define NET_DVR_CHAN_EXCEPTION				18	//Server channel in error status
#define NET_DVR_NODISK						19	//No hard disk
#define NET_DVR_ERRORDISKNUM				20	//Hard disk number error
#define NET_DVR_DISK_FULL					21	//Server's hard disk is full
#define NET_DVR_DISK_ERROR					22	//Server's hard disk error
#define NET_DVR_NOSUPPORT					23	//Server doesn't support
#define NET_DVR_BUSY						24	//Server is busy
#define NET_DVR_MODIFY_FAIL					25	//Server modification failed
#define NET_DVR_PASSWORD_FORMAT_ERROR		26	//Input format of Password error
#define NET_DVR_DISK_FORMATING				27	//Hard disk is formating,  cannot execute.
#define NET_DVR_DVRNORESOURCE				28	//DVR don't have enough resource
#define	NET_DVR_DVROPRATEFAILED				29  //DVR Operation failed
#define NET_DVR_OPENHOSTSOUND_FAIL 			30  //Open PC audio failed
#define NET_DVR_DVRVOICEOPENED 				31  //Server's talk channel is occupied
#define	NET_DVR_TIMEINPUTERROR				32  //Time input is not correct
#define	NET_DVR_NOSPECFILE					33  //Can't playback the file that does not exist in Server
#define NET_DVR_CREATEFILE_ERROR			34	//Create file error
#define	NET_DVR_FILEOPENFAIL				35  //Open file error
#define	NET_DVR_OPERNOTFINISH				36  //The previous operation is not finished yet
#define	NET_DVR_GETPLAYTIMEFAIL				37  //Get current playing time error
#define	NET_DVR_PLAYFAIL					38  //Playback error
#define NET_DVR_FILEFORMAT_ERROR			39  //Wrong file format
#define NET_DVR_DIR_ERROR					40	//Wrong directory
#define NET_DVR_ALLOC_RESOURCE_ERROR		41  //Assign resource error
#define NET_DVR_AUDIO_MODE_ERROR			42	//Audio card mode error
#define NET_DVR_NOENOUGH_BUF				43	//Buffer is too small
#define NET_DVR_CREATESOCKET_ERROR		 	44	//Create SOCKET error
#define NET_DVR_SETSOCKET_ERROR				45	//Setup SOCKET error
#define NET_DVR_MAX_NUM						46	//Reach the maximum number
#define NET_DVR_USERNOTEXIST				47	//User does not exist
#define NET_DVR_WRITEFLASHERROR				48  //Write to FLASH error
#define NET_DVR_UPGRADEFAIL					49  //DVR update failed
#define NET_DVR_CARDHAVEINIT				50  //Decoding Card has been initialized already
#define NET_DVR_PLAYERFAILED				51	//Invoke API of player library error
#define NET_DVR_MAX_USERNUM					52  //Reach the maximum number of DVR Users
#define NET_DVR_GETLOCALIPANDMACFAIL		53  //Failed to get Client software's IP or MAC address
#define NET_DVR_NOENCODEING					54	//No encoding on this channel
#define NET_DVR_IPMISMATCH					55	//IP address is not matched
#define NET_DVR_MACMISMATCH					56	//MAC address is not matched
#define NET_DVR_UPGRADELANGMISMATCH			57	//Update file has wrong language
#define NET_DVR_MAX_PLAYERPORT				58	//Reach the maximum player number
#define NET_DVR_NOSPACEBACKUP				59	//There is no enough space on the backup device
#define NET_DVR_NODEVICEBACKUP				60	//Failed to find the specified backup device
#define NET_DVR_PICTURE_BITS_ERROR			61	//Image has wrong color bit,  24 color only
#define NET_DVR_PICTURE_DIMENSION_ERROR		62	//Image size exceeds the maximum value;  smaller than 128*256
#define NET_DVR_PICTURE_SIZ_ERROR			63	//Image file exceeds the maximum size;  smaller than 100K
#define NET_DVR_LOADPLAYERSDKFAILED			64	//Failed to load the player SDK from current directory
#define NET_DVR_LOADPLAYERSDKPROC_ERROR		65	//Failed to find the API's entry in player SDK
#define NET_DVR_LOADDSSDKFAILED				66	//Failed to load the DSsdk from current directory
#define NET_DVR_LOADDSSDKPROC_ERROR		    67	//Failed to find the API's entry in DSsDK
#define NET_DVR_DSSDK_ERROR					68	//Failed to involve the API of DSsDK.dll
#define NET_DVR_VOICEMONOPOLIZE				69	//Audio card has been occupied exclusively
#define NET_DVR_JOINMULTICASTFAILED			70	//Join to multicast group error
#define NET_DVR_CREATEDIR_ERROR				71	//Failed to create log directory
#define NET_DVR_BINDSOCKET_ERROR			72	//Failed to bind socked error.
#define NET_DVR_SOCKETCLOSE_ERROR			73	//socket is disconnected,  that caused by network disconnected or unreachable destination mostly
#define NET_DVR_USERID_ISUSING			    74	//User ID is using when logout
#define NET_DVR_SOCKETLISTEN_ERROR			75	//Socket listen error
#define NET_DVR_PROGRAM_EXCEPTION			76	//Application error
#define NET_DVR_WRITEFILE_FAILED			77	//Failed to write file
#define NET_DVR_FORMAT_READONLY				78  //Forbidden to format read only disk
#define NET_DVR_WITHSAMEUSERNAME		    79  //Same user name already exists.
#define NET_DVR_DEVICETYPE_ERROR            80  //Device Model is not matched when import parameters
#define NET_DVR_LANGUAGE_ERROR              81  //Audio is not matched when import parameters
#define NET_DVR_PARAVERSION_ERROR           82  //Software version is not matched when import parameters
#define NET_DVR_IPCHAN_NOTALIVE             83  //IP Channels is off line when
#define NET_DVR_RTSP_SDK_ERROR                84    //Failed to load IPC communication library
#define NET_DVR_CONVERT_SDK_ERROR            85    //Failed to load stream format convertion library
#define NET_DVR_IPC_COUNT_OVERFLOW            86  //ip count overflow
#define NET_DVR_MAX_ADD_NUM                 87  //add label or other operation reach the maximum number
#define NET_DVR_PARAMMODE_ERROR             88  //Param Mode Error
//2009- 01- 04
#define NET_DVR_CODESPITTER_OFFLINE            89  //Videoplat: CodeSpitter is Offline
#define NET_DVR_BACKUP_COPYING                90  //Device is backuping
//2010-01-16
#define NET_DVR_CHAN_NOTSUPPORT             91  //Channel doesn't support

#define NET_DVR_CALLINEINVALID              92  // The height line location is too concentrated, or the length line is not inclined enough
#define NET_DVR_CALCANCELCONFLICT           93  // Cancel calibration conflict, if the rule and overall actual size filter have been set
#define NET_DVR_CALPOINTOUTRANGE            94     // Calibration point exceeds the range
#define NET_DVR_FILTERRECTINVALID           95  // The size filter does not meet the requirement
#define NET_DVR_DDNS_DEVOFFLINE             96  // Device hasn't registered to ddns
#define NET_DVR_DDNS_INTER_ERROR            97  // DDNS inter error
#define NET_DVR_FUNCTION_NOT_SUPPORT_OS     98  //This function don't support this OS.
#define NET_DVR_DEC_CHAN_REBIND             99  //Decode channel can not bind two or more display channel
#define NET_DVR_INTERCOM_SDK_ERROR          100 //Failed to load the Intercom SDK from current directory
#define NET_DVR_NO_CURRENT_UPDATEFILE       101 //NO Current UpdateFile
#define NET_DVR_USER_NOT_SUCC_LOGIN         102  //user is not login yet
#define NET_DVR_USE_LOG_SWITCH_FILE            103  //it is using log switch file
#define NET_DVR_POOL_PORT_EXHAUST            104  //Port pool is exhaust
#define    NET_DVR_PACKET_TYPE_NOT_SUPPORT        105    //The stream packet type is error

#define NET_DVR_IPPARA_IPID_ERROR           106  //IPID when IP access configuration is incorrect

#define NET_DVR_LOAD_HCPREVIEW_SDK_ERROR           107  //Load Preview COM Failed
#define NET_DVR_LOAD_HCVOICETALK_SDK_ERROR         108  //Load Voice talk COM Failed
#define NET_DVR_LOAD_HCALARM_SDK_ERROR             109  //Load Alarm COM Failed
#define NET_DVR_LOAD_HCPLAYBACK_SDK_ERROR          110  //Load Play back COM Failed
#define NET_DVR_LOAD_HCDISPLAY_SDK_ERROR           111  //Load Display COM Failed
#define NET_DVR_LOAD_HCINDUSTRY_SDK_ERROR          112  //Load Industry COM Failed
#define NET_DVR_LOAD_HCGENERALCFGMGR_SDK_ERROR     113  //Load General config mgr COM Failed
#define NET_DVR_LOAD_HCCOREDEVCFG_SDK_ERROR        114  //Load device core config COM Failed

#define NET_DVR_CORE_VER_MISMATCH                  121   //There is a mismatch between the component and core version
#define NET_DVR_CORE_VER_MISMATCH_HCPREVIEW        122   //There is a mismatch  between Live view component and core version.
#define NET_DVR_CORE_VER_MISMATCH_HCVOICETALK      123   //There is a mismatch  between voice component and core version
#define NET_DVR_CORE_VER_MISMATCH_HCALARM          124   //There is a mismatch  between alarm component and core version
#define NET_DVR_CORE_VER_MISMATCH_HCPLAYBACK       125   //There is a mismatch  between playback component and core version
#define NET_DVR_CORE_VER_MISMATCH_HCDISPLAY        126   //There is a mismatch  between display component and core version
#define NET_DVR_CORE_VER_MISMATCH_HCINDUSTRY       127   //There is a mismatch  between industrial application component and core version
#define NET_DVR_CORE_VER_MISMATCH_HCGENERALCFGMGR  128   //There is a mismatch  between General configuration management component and the core version

#define NET_DVR_COM_VER_MISMATCH_HCPREVIEW         136   //There is a mismatch  between Live view component and HCNetSDK version.
#define NET_DVR_COM_VER_MISMATCH_HCVOICETALK       137   //There is a mismatch  between voice component and HCNetSDK version
#define NET_DVR_COM_VER_MISMATCH_HCALARM           138   //here is a mismatch  between alarm component and HCNetSDK version
#define NET_DVR_COM_VER_MISMATCH_HCPLAYBACK        139   //There is a mismatch  between playback component and HCNetSDK version
#define NET_DVR_COM_VER_MISMATCH_HCDISPLAY         140   //There is a mismatch  between display component and HCNetSDK version
#define NET_DVR_COM_VER_MISMATCH_HCINDUSTRY        141   //There is a mismatch  between industrial application component and HCNetSDK version
#define NET_DVR_COM_VER_MISMATCH_HCGENERALCFGMGR   142   //There is a mismatch  between General configuration management component and the HCNetSDK version
#define NET_DVR_ALIAS_DUPLICATE                150    // Alias is duplicate  //2011-08-31 the configuration of new ddns accessing device by alias or serial number

#define    NET_DVR_INVALID_COMMUNICATION        151    //Invalid Communication
#define    NET_DVR_USERNAME_NOT_EXIST            152    //UserName is not exist
#define    NET_DVR_USER_LOCKED                    153 //UserName Locked
#define NET_DVR_INVALID_USERID              154 //Invalid User ID
#define NET_DVR_LOW_LOGIN_VERSION           155 //Low Login Version
#define NET_DVR_LOAD_LIBEAY32_DLL_ERROR     156 //load libeay32.dll failed
#define NET_DVR_LOAD_SSLEAY32_DLL_ERROR     157 //load ssleay32.dll failed
#define NET_ERR_LOAD_LIBICONV                       158 //load libiconv2 failed


#define NET_DVR_SERVER_NOT_EXIST         164 //can not find the server
#define NET_DVR_TEST_SERVER_FAIL_CONNECT            165    //fail connect with test server
#define NET_DVR_NAS_SERVER_INVALID_DIR                166    //NAS server mount fail\A3\ACinvalid directory
#define NET_DVR_NAS_SERVER_NOENOUGH_PRI                167    //NAS server mount fail\A3\ACno authority
#define NET_DVR_EMAIL_SERVER_NOT_CONFIG_DNS            168    //sever not configure DNS\A1\A3
#define    NET_DVR_EMAIL_SERVER_NOT_CONFIG_GATEWAY        169    //Email server not configure gateway
#define    NET_DVR_TEST_SERVER_PASSWORD_ERROR            170    //the password of the test server is error
#define    NET_DVR_EMAIL_SERVER_CONNECT_EXCEPTION_WITH_SMTP    171    //device connect exception with smtp server
#define    NET_DVR_FTP_SERVER_FAIL_CREATE_DIR            172    //FTP server create directory fail
#define    NET_DVR_FTP_SERVER_NO_WRITE_PIR                173    //FTP server not have write authority
#define    NET_DVR_IP_CONFLICT                            174    //IP conflict
#define NET_DVR_INSUFFICIENT_STORAGEPOOL_SPACE      175  //No free space for the storage pool
#define NET_DVR_STORAGEPOOL_INVALID                 176  //The storage pool of the cloud server is invalid, no configured storage pool or the storage pool ID is incorrect.
#define NET_DVR_EFFECTIVENESS_REBOOT                177  //Effectiveness Reboot
#define NET_ERR_ANR_ARMING_EXIST                    178  //ANR arming is already established.
#define NET_ERR_UPLOADLINK_EXIST                    179  //Upload Link is already established.
#define NET_ERR_INCORRECT_FILE_FORMAT               180  //Incorrect file format
#define NET_ERR_INCORRECT_FILE_CONTENT              181  //Incorrect file content
#define NET_ERR_MAX_HRUDP_LINK                       182               //HRUDP limit the number of connections over equipment
// RAID error code
#define RAID_ERROR_INDEX                    200
#define NET_DVR_NAME_NOT_ONLY               (RAID_ERROR_INDEX + 0)  // Existing name
#define NET_DVR_OVER_MAX_ARRAY              (RAID_ERROR_INDEX + 1 ) // Number of arrays has reached its limit
#define NET_DVR_OVER_MAX_VD                 (RAID_ERROR_INDEX + 2 ) // Number of virtual disks  has reached its limit
#define NET_DVR_VD_SLOT_EXCEED              (RAID_ERROR_INDEX + 3 ) // Virtual disk slot is full
#define NET_DVR_PD_STATUS_INVALID           (RAID_ERROR_INDEX + 4 ) // Physical disk for rebuilding array is with error status
#define NET_DVR_PD_BE_DEDICATE_SPARE        (RAID_ERROR_INDEX + 5 ) // Physical disk for rebuilding array is specified as spare drive
#define NET_DVR_PD_NOT_FREE                 (RAID_ERROR_INDEX + 6 ) // Physical disk for rebuilding array is not idle
#define NET_DVR_CANNOT_MIG2NEWMODE          (RAID_ERROR_INDEX + 7 ) // Unable to migrate from the current array type to the new array type
#define NET_DVR_MIG_PAUSE                   (RAID_ERROR_INDEX + 8 ) // The migration operation has been paused
#define NET_DVR_MIG_CANCEL                  (RAID_ERROR_INDEX + 9 ) // The migration operation has been canceled
#define NET_DVR_EXIST_VD                    (RAID_ERROR_INDEX + 10) // Operation failed! Please delete the virtual disk existed in the array first
#define NET_DVR_TARGET_IN_LD_FUNCTIONAL     (RAID_ERROR_INDEX + 11) // Target physical disk is part of the virtual disk and is functional
#define NET_DVR_HD_IS_ASSIGNED_ALREADY      (RAID_ERROR_INDEX + 12) // Specified physical disk is assigned to a virtual disk
#define NET_DVR_INVALID_HD_COUNT            (RAID_ERROR_INDEX + 13) // Number of physical disks doesn't fit the specified RAID level
#define NET_DVR_LD_IS_FUNCTIONAL            (RAID_ERROR_INDEX + 14) // Specified virtual disk is functional
#define NET_DVR_BGA_RUNNING                 (RAID_ERROR_INDEX + 15) // BGA is running
#define NET_DVR_LD_NO_ATAPI                 (RAID_ERROR_INDEX + 16) // Can not create virtual disk with ATAPI drive
#define NET_DVR_MIGRATION_NOT_NEED          (RAID_ERROR_INDEX + 17) // Migration is not necessary
#define NET_DVR_HD_TYPE_MISMATCH            (RAID_ERROR_INDEX + 18) // Physical disks are not of the same type
#define NET_DVR_NO_LD_IN_DG                 (RAID_ERROR_INDEX + 19) // No virtual disk exist on the specified array
#define NET_DVR_NO_ROOM_FOR_SPARE           (RAID_ERROR_INDEX + 20) // Disk space is too small to be assigned as spare drive
#define NET_DVR_SPARE_IS_IN_MULTI_DG        (RAID_ERROR_INDEX + 21) // Disk is already assigned as a spare drive for an array
#define NET_DVR_DG_HAS_MISSING_PD           (RAID_ERROR_INDEX + 22) // Disk is missing from an array
// x86 64bit nvr 2012-02-04
#define NET_DVR_NAME_EMPTY                    (RAID_ERROR_INDEX + 23) /*Name is empty*/
#define NET_DVR_INPUT_PARAM                    (RAID_ERROR_INDEX + 24) /*Input param is wrong*/
#define NET_DVR_PD_NOT_AVAILABLE            (RAID_ERROR_INDEX + 25) /*Physics disk is not available*/
#define NET_DVR_ARRAY_NOT_AVAILABLE            (RAID_ERROR_INDEX + 26) /*Array is not available*/
#define NET_DVR_PD_COUNT                    (RAID_ERROR_INDEX + 27) /*Physics disk number is wrong*/
#define NET_DVR_VD_SMALL                    (RAID_ERROR_INDEX + 28) /*Virtual disk is small*/
#define NET_DVR_NO_EXIST                    (RAID_ERROR_INDEX + 29) /*Raid No exist*/
#define NET_DVR_NOT_SUPPORT                    (RAID_ERROR_INDEX + 30) /*Operation not support*/
#define NET_DVR_NOT_FUNCTIONAL                 (RAID_ERROR_INDEX + 31) /*Raid is not functional*/
#define NET_DVR_DEV_NODE_NOT_FOUND            (RAID_ERROR_INDEX + 32) /*Virtual disk device node is no exist*/
#define NET_DVR_SLOT_EXCEED                    (RAID_ERROR_INDEX + 33) /*Slot is exceed*/
#define NET_DVR_NO_VD_IN_ARRAY                (RAID_ERROR_INDEX + 34) /*Virtual disk is not exist in array*/
#define NET_DVR_VD_SLOT_INVALID                (RAID_ERROR_INDEX + 35) /*Virtual disk slot is invalid*/
#define NET_DVR_PD_NO_ENOUGH_SPACE            (RAID_ERROR_INDEX + 36) /*Physics disk is no enough space*/
#define NET_DVR_ARRAY_NONFUNCTION            (RAID_ERROR_INDEX + 37) /*Only functional raid can move*/
#define NET_DVR_ARRAY_NO_ENOUGH_SPACE        (RAID_ERROR_INDEX + 38) /*Array is no enough space*/
#define NET_DVR_STOPPING_SCANNING_ARRAY        (RAID_ERROR_INDEX + 39) /*Pull disk or scan array is processing*/
#define NET_DVR_NOT_SUPPORT_16T             (RAID_ERROR_INDEX + 40) /*Not support 16T*/
#define NET_DVR_ARRAY_FORMATING             (RAID_ERROR_INDEX + 41) /*Array formating*/
#define NET_DVR_QUICK_SETUP_PD_COUNT        (RAID_ERROR_INDEX + 42) /*at least three idle wheel cfg*/

#define    NET_DVR_ERROR_DEVICE_NOT_ACTIVATED    250//device not activated
#define  NET_DVR_ERROR_RISK_PASSWORD          251 //risk password
#define    NET_DVR_ERROR_DEVICE_HAS_ACTIVATED    252//device has activated already

// Intelligence error code
#define VCA_ERROR_INDEX                     300 // VCA error index
#define NET_DVR_ID_ERROR                    (VCA_ERROR_INDEX + 0)   // Configuration ID is illegal.
#define NET_DVR_POLYGON_ERROR               (VCA_ERROR_INDEX + 1)   // Polygon does not match requirement.
#define NET_DVR_RULE_PARAM_ERROR            (VCA_ERROR_INDEX + 2)   // Rule parameter is illegal.
#define NET_DVR_RULE_CFG_CONFLICT           (VCA_ERROR_INDEX + 3)   // Configuration conflict.
#define NET_DVR_CALIBRATE_NOT_READY         (VCA_ERROR_INDEX + 4)   // Calibration not ready.
#define NET_DVR_CAMERA_DATA_ERROR           (VCA_ERROR_INDEX + 5)   // Camera parameter is illegal.
#define NET_DVR_CALIBRATE_DATA_UNFIT        (VCA_ERROR_INDEX + 6)    // Not tilt enough, not fit to calibrate.
#define NET_DVR_CALIBRATE_DATA_CONFLICT    (VCA_ERROR_INDEX + 7)    // Calibration error.
#define NET_DVR_CALIBRATE_CALC_FAIL         (VCA_ERROR_INDEX + 8)    // Failed to calculate camera calibration parameter.
#define    NET_DVR_CALIBRATE_LINE_OUT_RECT        (VCA_ERROR_INDEX + 9)    // The input calibrating line exceeds the external rectangle sample.
#define NET_DVR_ENTER_RULE_NOT_READY        (VCA_ERROR_INDEX + 10)  // Enter rule not ready.
#define NET_DVR_AID_RULE_NO_INCLUDE_LANE    (VCA_ERROR_INDEX + 11)    // It does not include lane in the traffic event rule (especial for traffic jam or driving against the traffic).
#define NET_DVR_LANE_NOT_READY                (VCA_ERROR_INDEX + 12)    // Lane not ready.
#define NET_DVR_RULE_INCLUDE_TWO_WAY        (VCA_ERROR_INDEX + 13)    // There are two different directions in event rule.
#define NET_DVR_LANE_TPS_RULE_CONFLICT      (VCA_ERROR_INDEX + 14)  // The lane conflicts with the data rule.
#define NET_DVR_NOT_SUPPORT_EVENT_TYPE      (VCA_ERROR_INDEX + 15)  // Event type is not support.
#define NET_DVR_LANE_NO_WAY                 (VCA_ERROR_INDEX + 16)  // Lane has not direction.
#define NET_DVR_SIZE_FILTER_ERROR           (VCA_ERROR_INDEX + 17)  // Size filter is error.
#define NET_DVR_LIB_FFL_NO_FACE             (VCA_ERROR_INDEX + 18)  // Picture of feature point location has not face.
#define NET_DVR_LIB_FFL_IMG_TOO_SMALL       (VCA_ERROR_INDEX + 19)  // Picture of feature point location is too small.
#define NET_DVR_LIB_FD_IMG_NO_FACE          (VCA_ERROR_INDEX + 20)  // Picture of single detect has not face.
#define NET_DVR_LIB_FACE_TOO_SMALL          (VCA_ERROR_INDEX + 21)  // Face is too small when modeling.
#define NET_DVR_LIB_FACE_QUALITY_TOO_BAD    (VCA_ERROR_INDEX + 22)  // Face quality is too bad when modeling.
#define NET_DVR_KEY_PARAM_ERR               (VCA_ERROR_INDEX + 23)  //Key parameter is error.
#define NET_DVR_CALIBRATE_DATA_ERR          (VCA_ERROR_INDEX + 24)  //Calibrate data is error.
#define NET_DVR_CALIBRATE_DISABLE_FAIL      (VCA_ERROR_INDEX + 25)  //Disable calibrate has failed.
#define NET_DVR_VCA_LIB_FD_SCALE_OUTRANGE   (VCA_ERROR_INDEX + 26)  //Filter scale is out range.
#define NET_DVR_LIB_FD_REGION_TOO_LARGE     (VCA_ERROR_INDEX + 27)  //Region is too big.
#define NET_DVR_TRIAL_OVERDUE               (VCA_ERROR_INDEX + 28) //Trial overdue.
#define NET_DVR_CONFIG_FILE_CONFLICT        (VCA_ERROR_INDEX + 29) //Config file conflict.

#define NET_DVR_FR_FPL_FAIL                 (VCA_ERROR_INDEX + 30)   //Feature points location is error in face recognition
#define NET_DVR_FR_IQA_FAIL                 (VCA_ERROR_INDEX + 31)   //Image quality assessment is error in face recognition
#define NET_DVR_FR_FEM_FAIL                 (VCA_ERROR_INDEX + 32)   //Feature extract & match error in face recognition
#define NET_DVR_FPL_DT_CONF_TOO_LOW         (VCA_ERROR_INDEX + 33)   //Detection confidence is too low in feature points location
#define NET_DVR_FPL_CONF_TOO_LOW            (VCA_ERROR_INDEX + 34)   //Confidence is too low in feature points location
#define NET_DVR_E_DATA_SIZE                 (VCA_ERROR_INDEX + 35)  //Size of model data error
#define NET_DVR_FR_MODEL_VERSION_ERR        (VCA_ERROR_INDEX + 36)  //Model version is error
#define NET_DVR_FR_FD_FAIL                  (VCA_ERROR_INDEX + 37)  //Face detection error in face recognition
#define NET_DVR_FA_NORMALIZE_ERR            (VCA_ERROR_INDEX + 38)  //Face attribute normalize error

#define NET_DVR_DOG_PUSTREAM_NOT_MATCH      (VCA_ERROR_INDEX + 39)  //Pustream and softdog are mismatched
#define NET_DVR_DEV_PUSTREAM_NOT_MATCH      (VCA_ERROR_INDEX + 40)  //Pustream device version is error
#define NET_DVR_PUSTREAM_ALREADY_EXISTS     (VCA_ERROR_INDEX + 41)  //The pustream has existence
#define NET_DVR_SEARCH_CONNECT_FAILED       (VCA_ERROR_INDEX + 42)  //Failed to connect face retrieval device
#define NET_DVR_INSUFFICIENT_DISK_SPACE     (VCA_ERROR_INDEX + 43)  //Storage space is insufficient
#define NET_DVR_DATABASE_CONNECTION_FAILED  (VCA_ERROR_INDEX + 44)  //Failed to connect database
#define NET_DVR_DATABASE_ADM_PW_ERROR       (VCA_ERROR_INDEX + 45)  //Username or password is error for database
#define NET_DVR_DECODE_YUV                  (VCA_ERROR_INDEX + 46)  //Failed to decode image
#define NET_DVR_IMAGE_RESOLUTION_ERROR      (VCA_ERROR_INDEX + 47)  //Image resolution is unreasonable
#define NET_DVR_CHAN_WORKMODE_ERROR         (VCA_ERROR_INDEX + 48)  //Channel workmode error

#define NET_DVR_RTSP_ERROR_NOENOUGHPRI              401  // no authoration: when server return 401\A3\ACRTSP return it.
#define NET_DVR_RTSP_ERROR_ALLOC_RESOURCE           402  // fail to alloc resource
#define NET_DVR_RTSP_ERROR_PARAMETER                403  // parameter error.
#define NET_DVR_RTSP_ERROR_NO_URL                   404  // can't find the url. when server return 404\A3\ACRTSP return it.
#define NET_DVR_RTSP_ERROR_FORCE_STOP               406  // user force to stop.
#define NET_DVR_RTSP_GETPORTFAILED                  407  // rtsp get port failed

#define NET_DVR_RTSP_DESCRIBERROR                   410  // rtsp describe communicate error
#define NET_DVR_RTSP_DESCRIBESENDTIMEOUT            411  // Sending signal "DECRIBE" is timeout
#define NET_DVR_RTSP_DESCRIBESENDERROR                412  // Failed to send signal "DECRIBE"
#define NET_DVR_RTSP_DESCRIBERECVTIMEOUT            413  // Receiving signal "DECRIBE" is timeout
#define NET_DVR_RTSP_DESCRIBERECVDATALOST            414  // Receiving data of signal "DECRIBE" error
#define NET_DVR_RTSP_DESCRIBERECVERROR                415  // Failed to receive signal "DECRIBE"
#define NET_DVR_RTSP_DESCRIBESERVERERR                416  // Signal "DECRIBE" server returns the error

#define NET_DVR_RTSP_SETUPERROR                        420  // rtsp setup communicate error
#define NET_DVR_RTSP_SETUPSENDTIMEOUT                421  // Sending signal "SETUP" is timeout
#define NET_DVR_RTSP_SETUPSENDERROR                    422  // Sending signal "SETUP" error
#define NET_DVR_RTSP_SETUPRECVTIMEOUT                423  // Receiving signal "SETUP" is timeout
#define NET_DVR_RTSP_SETUPRECVDATALOST                424  // Receiving data of signal "SETUP" error
#define NET_DVR_RTSP_SETUPRECVERROR                    425  // Failed to receive signal "SETUP"
#define NET_DVR_RTSP_OVER_MAX_CHAN                    426  // It exceeds the max connection number, or no enough resource. when server return 453\A3\ACRTSP return it.
#define NET_DVR_RTSP_SETUPSERVERERR                    427  // Signal "SETUP" server returns the error

#define NET_DVR_RTSP_PLAYERROR                        430  // rtsp play communicate error
#define NET_DVR_RTSP_PLAYSENDTIMEOUT                431  // Sending signal "PLAY" is timeout
#define NET_DVR_RTSP_PLAYSENDERROR                    432  // Sending signal "PLAY" error
#define NET_DVR_RTSP_PLAYRECVTIMEOUT                433  // Receiving signal "PLAY" is timeout
#define NET_DVR_RTSP_PLAYRECVDATALOST                434  // Receiving data of signal "PLAY" error
#define NET_DVR_RTSP_PLAYRECVERROR                    435  // Failed to receive signal "PLAY"
#define NET_DVR_RTSP_PLAYSERVERERR                    436  // Signal "PLAY" server returns the error

#define NET_DVR_RTSP_TEARDOWNERROR                    440  // rtsp teardown communicate error
#define NET_DVR_RTSP_TEARDOWNSENDTIMEOUT            441  // Sending signal "TEARDOWN" is timeout
#define NET_DVR_RTSP_TEARDOWNSENDERROR                442  // Sending signal "TEARDOWN" error
#define NET_DVR_RTSP_TEARDOWNRECVTIMEOUT            443  // Receiving signal "TEARDOWN" is timeout
#define NET_DVR_RTSP_TEARDOWNRECVDATALOST            444  // Receiving data of signal "TEARDOWN" error
#define NET_DVR_RTSP_TEARDOWNRECVERROR                445  // Failed to receive signal "TEARDOWN"
#define NET_DVR_RTSP_TEARDOWNSERVERERR                446  // Signal "TEARDOWN" server returns the error

#define NET_PLAYM4_NOERROR                            500     // No error
#define    NET_PLAYM4_PARA_OVER                        501     // Input parameter is invalid;
#define NET_PLAYM4_ORDER_ERROR                        502     // The order of the function to be called is error.
#define    NET_PLAYM4_TIMER_ERROR                        503     // Create multimedia clock failed;
#define NET_PLAYM4_DEC_VIDEO_ERROR                    504     // Decode video data failed.
#define NET_PLAYM4_DEC_AUDIO_ERROR                    505     // Decode audio data failed.
#define    NET_PLAYM4_ALLOC_MEMORY_ERROR                506     // Allocate memory failed.
#define NET_PLAYM4_OPEN_FILE_ERROR                    507     // Open the file failed.
#define NET_PLAYM4_CREATE_OBJ_ERROR                    508     // Create thread or event failed
#define NET_PLAYM4_CREATE_DDRAW_ERROR                509     // Create DirectDraw object failed.
#define NET_PLAYM4_CREATE_OFFSCREEN_ERROR            510     // Failed when creating off- screen surface.
#define NET_PLAYM4_BUF_OVER                            511     // Buffer is overflow
#define NET_PLAYM4_CREATE_SOUND_ERROR                512     // Failed when creating audio device.
#define    NET_PLAYM4_SET_VOLUME_ERROR                    513     // Set volume failed
#define NET_PLAYM4_SUPPORT_FILE_ONLY                514     // The function only support play file.
#define NET_PLAYM4_SUPPORT_STREAM_ONLY                515     // The function only support play stream.
#define NET_PLAYM4_SYS_NOT_SUPPORT                    516     // System not support.
#define NET_PLAYM4_FILEHEADER_UNKNOWN                517     // No file header.
#define NET_PLAYM4_VERSION_INCORRECT                518     // The version of decoder and encoder is not adapted.
#define NET_PALYM4_INIT_DECODER_ERROR                519     // Initialize decoder failed.
#define NET_PLAYM4_CHECK_FILE_ERROR                    520     // The file data is unknown.
#define NET_PLAYM4_INIT_TIMER_ERROR                    521     // Initialize multimedia clock failed.
#define    NET_PLAYM4_BLT_ERROR                        522     // BLT failed.
#define NET_PLAYM4_UPDATE_ERROR                        523     // Update failed.
#define NET_PLAYM4_OPEN_FILE_ERROR_MULTI            524  // Open file error,  stream type is multi
#define NET_PLAYM4_OPEN_FILE_ERROR_VIDEO            525  // Open file error,  stream type is video
#define NET_PLAYM4_JPEG_COMPRESS_ERROR                526  // JPEG compress error
#define NET_PLAYM4_EXTRACT_NOT_SUPPORT                527     // Don't support the version of this file.
#define NET_PLAYM4_EXTRACT_DATA_ERROR                528     // Extract video data failed.

//convert error
#define  NET_CONVERT_ERROR_NOT_SUPPORT          581  //convert not support

//audio intercom error
#define  NET_AUDIOINTERCOM_OK                   600
#define  NET_AUDIOINTECOM_ERR_NOTSUPORT         601 //not support
#define  NET_AUDIOINTECOM_ERR_ALLOC_MEMERY      602 //alloc memery error
#define  NET_AUDIOINTECOM_ERR_PARAMETER            603 //param error
#define  NET_AUDIOINTECOM_ERR_CALL_ORDER        604 //call order error
#define  NET_AUDIOINTECOM_ERR_FIND_DEVICE       605 //can not find device error
#define  NET_AUDIOINTECOM_ERR_OPEN_DEVICE       606 // open device error
#define  NET_AUDIOINTECOM_ERR_NO_CONTEXT        607 // no context error
#define  NET_AUDIOINTECOM_ERR_NO_WAVFILE        608 //no Wav file error
#define  NET_AUDIOINTECOM_ERR_INVALID_TYPE      609 // invalid type error
#define  NET_AUDIOINTECOM_ERR_ENCODE_FAIL       610 //encode fail error
#define  NET_AUDIOINTECOM_ERR_DECODE_FAIL       611 //decode fail error
#define  NET_AUDIOINTECOM_ERR_NO_PLAYBACK       612 //play back error
#define  NET_AUDIOINTECOM_ERR_DENOISE_FAIL      613 //denoise fail error
#define  NET_AUDIOINTECOM_ERR_UNKOWN            619 //unKown Error

#define NET_QOS_OK                                    700                        // No error
#define NET_QOS_ERROR                                (NET_QOS_OK - 1)        // Qos error
#define NET_QOS_ERR_INVALID_ARGUMENTS                (NET_QOS_OK - 2)        // Invalid arguments
#define NET_QOS_ERR_SESSION_NOT_FOUND                (NET_QOS_OK - 3)        // Session net found
#define NET_QOS_ERR_LIB_NOT_INITIALIZED                (NET_QOS_OK - 4)        // Lib not initialized
#define NET_QOS_ERR_OUTOFMEM                        (NET_QOS_OK - 5)        // Out of memory
#define NET_QOS_ERR_PACKET_UNKNOW                    (NET_QOS_OK - 10)        // Packet unknown
#define NET_QOS_ERR_PACKET_VERSION                    (NET_QOS_OK - 11)        // Packet version error
#define NET_QOS_ERR_PACKET_LENGTH                    (NET_QOS_OK - 12)        // Packet length error
#define NET_QOS_ERR_PACKET_TOO_BIG                    (NET_QOS_OK - 13)        // Packet too big
#define NET_QOS_ERR_SCHEDPARAMS_INVALID_BANDWIDTH    (NET_QOS_OK - 20)        // Schedule parameters invalid bandwidth
#define NET_QOS_ERR_SCHEDPARAMS_BAD_FRACTION        (NET_QOS_OK - 21)        // Schedule parameters bad fraction
#define NET_QOS_ERR_SCHEDPARAMS_BAD_MINIMUM_INTERVAL (NET_QOS_OK - 22)        // Schedule parameters bad minimum interval

#define NET_ERROR_TRUNK_LINE                         711    //sub system has been used as trunk line
#define NET_ERROR_MIXED_JOINT                         712    //mixed jointing is not allowed
#define NET_ERROR_DISPLAY_SWITCH                     713    //can not switch display channel
#define NET_ERROR_USED_BY_BIG_SCREEN                 714    //decode resource had been used by big screen
#define NET_ERROR_USE_OTHER_DEC_RESOURCE             715    //can not use other sub systems' decode resource
#define NET_ERROR_DISP_MODE_SWITCH                     716    //display mode is switching
#define NET_ERROR_SCENE_USING                         717    //scene is using
#define NET_ERR_NO_ENOUGH_DEC_RESOURCE               718    //no enough decode resource
#define NET_ERR_NO_ENOUGH_FREE_SHOW_RESOURCE         719    //no enough free show resource
#define NET_ERR_NO_ENOUGH_VIDEO_MEMORY               720    //no enough video memory
#define NET_ERR_MAX_VIDEO_NUM                        721    //reach max video number
#define NET_ERR_WIN_COVER_FREE_SHOW_AND_NORMAL       722    //window can not cover free show window and normal window
#define NET_ERR_FREE_SHOW_WIN_SPLIT                  723    //free show window can not split
#define NET_ERR_INAPPROPRIATE_WIN_FREE_SHOW          724    //the window can not free show
#define NET_DVR_TRANSPARENT_WIN_NOT_SUPPORT_SPLIT    725    //transparent window not support split
#define NET_DVR_SPLIT_WIN_NOT_SUPPORT_TRANSPARENT    726    //split window not support transparent
#define NET_ERR_MAX_LOGO_NUM                         727    //reach max logo number
#define NET_ERR_MAX_WIN_LOOP_NUM                     728    //reach max window loop number
#define NET_ERR_VIRTUAL_LED_VERTICAL_CROSS           729    //virtual LED can not cross screen vertically
#define NET_ERR_MAX_VIRTUAL_LED_HEIGHT               730    //virtual LED height overlimit
#define NET_ERR_VIRTUAL_LED_ILLEGAL_CHARACTER        731    //illegal character in virtual LED
#define NET_ERR_BASEMAP_NOT_EXIST                    732    //base map is not existed
#define NET_ERR_LED_NOT_SUPPORT_VIRTUAL_LED          733    //LED screen does not support virtual LED
#define NET_ERR_LED_RESOLUTION_NOT_SUPPORT           734    //LED resolution not support
#define NET_ERR_PLAN_OVERDUE                         735    //plan is overdue, can not be called
#define NET_ERR_PROCESSER_MAX_SCREEN_BLK            736 //the number of screen which a single processor across reach limnit

#define NET_ERR_TERMINAL_BUSY                         780    //terminal busy, it is in the meeting

#define NET_ERR_DATA_RETURNED_ILLEGAL                 790   //the data returned from device is illegal
#define NET_DVR_FUNCTION_RESOURCE_USAGE_ERROR         791    //Equipment other resource-intensive function, cause the function could not be opened

#define NET_DVR_DEV_NET_OVERFLOW                     800    // Over the ability of the device network
#define NET_DVR_STATUS_RECORDFILE_WRITING_NOT_LOCK   801    // Can't lock because the file being recording.
#define NET_DVR_STATUS_CANT_FORMAT_LITTLE_DISK       802    // Can't format little disk.

//N+1
#define NET_SDK_ERR_REMOTE_DISCONNECT                803 //Remote disconnect
#define NET_SDK_ERR_RD_ADD_RD                        804 //Redaunt device can't add redaunt device
#define NET_SDK_ERR_BACKUP_DISK_EXCEPT                805 //Backup disk exception
#define NET_SDK_ERR_RD_LIMIT                        806 //Redaunt device is up to limit
#define NET_SDK_ERR_ADDED_RD_IS_WD                    807 //Added redaunt device is work device
#define NET_SDK_ERR_ADD_ORDER_WRONG                    808 //Added order is wrong
#define NET_SDK_ERR_WD_ADD_WD                        809 //Work device can't add work device
#define NET_SDK_ERR_WD_SERVICE_EXCETP                810 //Work device cvr service exception
#define NET_SDK_ERR_RD_SERVICE_EXCETP                811 //Redaunt device cvr service exception
#define NET_SDK_ERR_ADDED_WD_IS_RD                    812 //Added work device is redaunt device
#define NET_SDK_ERR_PERFORMANCE_LIMIT                813 //Perormance limit
#define NET_SDK_ERR_ADDED_DEVICE_EXIST                814 //Added device exist

//Inquest
#define NET_SDK_ERR_INQUEST_RESUMING                815 //Inquest resuming
#define NET_SDK_ERR_RECORD_BACKUPING                816 //Record backuping
#define NET_SDK_ERR_DISK_PLAYING                    817 //Disk playing
#define NET_SDK_ERR_INQUEST_STARTED                    818 //Inquest started
#define NET_SDK_ERR_LOCAL_OPERATING                    819 //Local operating
#define NET_SDK_ERR_INQUEST_NOT_START                820 //Inquest not start
//netra3.1.0
#define NET_SDK_ERR_CHAN_AUDIO_BIND                 821 //chan bind aduio error or no bind
//netra3.1.2
#define NET_DVR_N_PLUS_ONE_MODE                     822 //Current equipment is N +1 mode
#define NET_DVR_CLOUD_STORAGE_OPENED                823 //Cloud storage mode is open

#define NET_DVR_ERR_OPER_NOT_ALLOWED                824   //N+0 status\A3\ACnot allowed
#define NET_DVR_ERR_NEED_RELOCATE                    825   //need relocate

//trial host error
#define NET_SDK_ERR_IR_PORT_ERROR                   830 //ir port error
#define NET_SDK_ERR_IR_CMD_ERROR                    831 //ir cmd error
#define NET_SDK_ERR_NOT_INQUESTING                  832 //Device in non-trial condition
#define NET_SDK_ERR_INQUEST_NOT_PAUSED              833 //Device in non-pause condition
#define NET_DVR_CHECK_PASSWORD_MISTAKE_ERROR        834 //Check the password mistake
#define NET_DVR_CHECK_PASSWORD_NULL_ERROR           835 //Check the password can't null
#define NET_DVR_UNABLE_CALIB_ERROR                  836  //Unable to calibrate currently
#define NET_DVR_PLEASE_CALIB_ERROR                  837//Please finish the calibration first
#define NET_DVR_ERR_PANORAMIC_CAL_EMPTY             838 //No panorama image for PanoVu camera calibration in flash.
#define NET_DVR_ERR_CALIB_FAIL_PLEASEAGAIN          839 //(Calibration failed. Please calibrate again.)
#define NET_DVR_ERR_DETECTION_LINE                  840 //(Please set detection line again. The detection line should be within the red count area.)
#define NET_DVR_ERR_TURN_OFF_IMAGE_PARA             841 //Please turn off the image parameters switch first.
#define NET_ERR_ALARM_INPUT_OCCUPIED   845  //Alarm Input No. A<-1 is used to trigger vehicle capture.
#define NET_ERR_CUT_INPUTSTREAM_OVERLIMIT       	900 //cut input stream signal overlimit
#define NET_ERR_WINCHAN_IDX							 901	// Window index error
#define NET_ERR_WIN_LAYER							 902	// Window Layer	error
#define NET_ERR_WIN_BLK_NUM							 903	// Window Block error
#define NET_ERR_OUTPUT_RESOLUTION					 904	// Output resolution error
#define NET_ERR_LAYOUT								 905	// Layout Index error
#define NET_ERR_INPUT_RESOLUTION    				 906    // Input  resolution error

#define NET_ERR_SUBDEVICE_OFFLINE                     907    // device is off-line
#define NET_ERR_NO_DECODE_CHAN                         908    // no decode channel for use
#define NET_ERR_MAX_WINDOW_ABILITY                     909    // no enough resource for openning window
#define NET_ERR_ORDER_ERROR                             910    // order error

#define NET_ERR_PLAYING_PLAN                        911    //plan is running
#define NET_ERR_DECODER_USED                        912    //decoder is using
#define    NET_ERR_OUTPUT_BOARD_DATA_OVERFLOW            913    // data is overflow on the output board
#define    NET_ERR_SAME_USER_NAME                        914    // the same user name
#define    NET_ERR_INVALID_USER_NAME                    915    // invalid user name
#define    NET_ERR_MATRIX_USING                        916    // the matrix is using
#define    NET_ERR_DIFFERENT_CHAN_TYPE                    917    // the channel type is different
#define    NET_ERR_INPUT_CHAN_BINDED                    918    // input channel is binded the other matrix channel
#define    NET_ERR_BINDED_OUTPUT_CHAN_OVERFLOW            919    // output channels that are using is over max
#define    NET_ERR_MAX_SIGNAL_NUM                        920    // signal number is overflow
#define NET_ERR_INPUT_CHAN_USING                    921    // input channel(signal)is using
#define NET_ERR_MANAGER_LOGON                         922    //manager logon ,operate failed
#define NET_ERR_USERALREADY_LOGON                     923    //the user already logon,operate failed
#define NET_ERR_LAYOUT_INIT                         924    //plan is init,operate failed
#define    NET_ERR_BASEMAP_SIZE_NOT_MATCH                925    //the size of basemap is not match
#define NET_ERR_WINDOW_OPERATING                    926    // the window is executing another action, the operate failed
#define NET_ERR_SIGNAL_UPLIMIT                        927 // there are too many windows base on this signal.
#define NET_ERR_SIGNAL_MAX_ENLARGE_TIMES            928 // can not enlarge signal to the specified times
#define NET_ERR_ONE_SIGNAL_MULTI_CROSS              929 // one signal can not cross screen two times
#define NET_ERR_ULTRA_HD_SIGNAL_MULTI_WIN           930 // ultra HD signal can not on window two times
#define  NET_ERR_MAX_VIRTUAL_LED_WIDTH              931 //The width of Virtual LED is larger than limit value
#define  NET_ERR_MAX_VIRTUAL_LED_WORD_LEN           932 //The character number of virtual LED is larger than limit value
#define	 NET_ERR_SINGLE_OUTPUTPARAM_CONFIG			933//not support single output parameter configure
#define  NET_ERR_MULTI_WIN_BE_COVER     			934// multi windows be cover
#define  NET_ERR_WIN_NOT_EXIST						935//window  does not exist
#define  NET_ERR_WIN_MAX_SIGNALSOURCE				936// the signal source number of the window is over the limit
#define  NET_ERR_MULTI_WIN_MOVE						937// move the multi window
#define  NET_ERR_MULTI_WIN_YPBPR_SDI				938 // the YPBPR and SDI signal source  doesn't support 9/16 split
#define  NET_ERR_DIFF_TYPE_OUTPUT_MIXUSE			939  //difference type input board mix
#define  NET_ERR_SPLIT_WIN_CROSS					940  //split the cross window
#define  NET_ERR_SPLIT_WIN_NOT_FULL_SCREEN			941  //split the not full screen window
#define  NET_ERR_SPLIT_WIN_MANY_WIN					942  //split the window that only has single output
#define  NET_ERR_WINDOW_SIZE_OVERLIMIT              943   //window size over limit
#define  NET_ERR_INPUTSTREAM_ALREADY_JOINT       	944    //input signal is already in joint
#define  NET_ERR_JOINT_INPUTSTREAM_OVERLIMIT      	945    //joint input signal number overlimit

#define  NET_ERR_LED_RESOLUTION                        946  //LED resolution greater than output resolution
#define  NET_ERR_JOINT_SCALE_OVERLIMIT              947  //joint scale overlimit
#define  NET_ERR_INPUTSTREAM_ALREADY_DECODE            948  //input signal is already decoding
#define  NET_ERR_INPUTSTREAM_NOTSUPPORT_CAPTURE     949  //input signal does not support picture capture
#define  NET_ERR_JOINT_NOTSUPPORT_SPLITWIN            950  //joint signal can not show in multi split window

#define NET_ERR_MAX_WIN_OVERLAP                     951    //reach max allowed window overlap number
#define NET_ERR_STREAMID_CHAN_BOTH_VALID            952 //stream ID and channel cannot be valid both
#define NET_ERR_NO_ZERO_CHAN                        953 //device does not have zero channel
#define NEED_RECONNECT                                955 //need reconnect
#define NET_ERR_NO_STREAM_ID                        956 //stream ID does not exist
#define NET_DVR_TRANS_NOT_START                        957 //transcoding has not started
#define NET_ERR_MAXNUM_STREAM_ID                    958 //reach max stream ID number
#define NET_ERR_WORKMODE_MISMATCH                    959 //work mode mismatch
#define NET_ERR_MODE_IS_USING                        960 //already work in the selected mode
#define NET_ERR_DEV_PROGRESSING                        961 //device is progressing
#define NET_ERR_PASSIVE_TRANSCODING                    962 //passive transcoding
#define NET_ERR_RING_NOT_CONFIGURE                   964 //ring net not configed
#define NET_ERR_RING_NOT_CONFIGURE       			964 //ring net not configed

#define NET_ERR_CLOSE_WINDOW_FIRST                    971  //when switching full frame rate show must close the window of the wall
#define NET_ERR_SPLIT_WINDOW_NUM_NOT_SUPPORT        972  //input source of DVI/DP/HDMI/HDBase_T does not support 9/16 under full frame rate show
#define NET_ERR_REACH_ONE_SIGNAL_PREVIEW_MAX_LINK   973  //reach max link number of one signal preview echo
#define NET_ERR_ONLY_SPLITWND_SUPPORT_AMPLIFICATION  974  //only a split screen window  support child window amplification
#define NET_DVR_ERR_WINDOW_SIZE_PLACE  975  //Wrong window position.
#define NET_DVR_ERR_RGIONAL_RESTRICTIONS  976  //Screen distance exceeds the limit.
#define NET_ERR_WNDZOOM_NOT_SUPPORT  977  //single window does not support child window full screen
#define NET_ERR_LED_SCREEN_SIZE  978  //LED  screen width or height is not correct
#define NET_ERR_OPEN_WIN_IN_ERROR_AREA  979  //open a window in the illegal area, the area can not include LED screen and LCD screen
#define NET_ERR_TITLE_WIN_NOT_SUPPORT_MOVE  980  //tile pattern does not support roaming
#define NET_ERR_TITLE_WIN_NOT_SUPPORT_COVER  981  //tile pattern does not support layer covering
#define NET_ERR_TITLE_WIN_NOT_SUPPORT_SPLIT  982  //tile pattern does not support split screen
#define NET_DVR_LED_WINDOWS_ALREADY_CLOSED  983  //the resolution of LED area output changes, the device has already closed all LED windows in this area
#define NET_DVR_ERR_CLOSE_WINDOWS  984  //Operation failed. Close the window first.
#define NET_DVR_ERR_MATRIX_LOOP_ABILITY            985 //Beyond the cycle decoding capacity.
#define NET_DVR_ERR_MATRIX_LOOP_TIME           986 //Invalid cycle decoding time.
#define NET_DVR_ERR_LINKED_OUT_ABILITY           987 //No more linked camera can be added.
#define NET_ERR_REACH_SCENE_MAX_NUM     	988 //scene to upper limit
#define NET_ERR_SCENE_MEM_NOT_ENOUGH    	989 //insufficient memory to new scene
#define NET_ERR_RESOLUTION_NOT_SUPPORT_ODD_VOUT     990     //odd video output channel not support the resolution
#define NET_ERR_RESOLUTION_NOT_SUPPORT_EVEN_VOUT    991     //even video output channel not support the resolution

//ability analyze error
#define XML_ABILITY_NOTSUPPORT                      1000  //not support
#define        XML_ANALYZE_NOENOUGH_BUF                1001        //no enough buf
#define        XML_ANALYZE_FIND_LOCALXML_ERROR            1002        //can not find local xml
#define        XML_ANALYZE_LOAD_LOCALXML_ERROR            1003        //local local xml error
#define        XML_NANLYZE_DVR_DATA_FORMAT_ERROR        1004        //device ability data format error
#define        XML_ANALYZE_TYPE_ERROR                    1005        //ability type error
#define        XML_ANALYZE_XML_NODE_ERROR                1006        //XML ability node format error
#define XML_INPUT_PARAM_ERROR                       1007  //input parameter error

#define NET_DVR_ERR_RETURNED_XML_DATA  1008  //XML data error returned from device

//Civil Error Code\A3\A81100\A1\AB1200\A3\A9
#define NET_ERR_PLT_USERID                          1100 //Verification platform Userid Error
#define NET_ERR_TRANS_CHAN_START                    1101 //Operation failed because of the transparent channel is open.
#define NET_ERR_DEV_UPGRADING                        1102 //Device Upgrading
#define NET_ERR_MISMATCH_UPGRADE_PACK_TYPE          1103 //Upgrade Pack Type Mismatch
#define NET_ERR_DEV_FORMATTING                      1104 //Device Formatting
#define NET_ERR_MISMATCH_UPGRADE_PACK_VERSION       1105 //Upgrade Pack Version Mismatch

#define NET_DVR_LOGO_OVERLAY_WITHOUT_UPLOAD_PIC     1110 //logo overlay failed\A3\ACwithout Upload Picture success

//2012-10-16 Error of alarmhost \A3\A81200~1300\A3\A9
#define NET_ERR_SEARCHING_MODULE                    1201 // It is searching external modules
#define NET_ERR_REGISTERING_MODULE                  1202 // It is registering external modules
#define NET_ERR_GETTING_ZONES                        1203 // It is getting zone config parameters
#define NET_ERR_GETTING_TRIGGERS                    1204 // It is getting trigger config parameters
#define NET_ERR_ARMED_STATUS                        1205 // Armed status
#define    NET_ERR_PROGRAM_MODE_STATUS                    1206 // Program status
#define    NET_ERR_WALK_TEST_MODE_STATUS                1207 // Walk test status
#define    NET_ERR_BYPASS_STATUS                        1208 // Bypass status
#define NET_ERR_DISABLED_MODULE_STATUS                1209 // Function disabled
#define    NET_ERR_NOT_SUPPORT_OPERATE_ZONE            1210 // Not support operate zone
#define NET_ERR_NOT_SUPPORT_MOD_MODULE_ADDR            1211 // Not support mod module address
#define NET_ERR_UNREGISTERED_MODULE                    1212 // External is not registered
#define NET_ERR_PUBLIC_SUBSYSTEM_ASSOCIATE_SELF        1213 // Public subsystem can not associate itself
#define NET_ERR_EXCEEDS_ASSOCIATE_SUBSYSTEM_NUM        1214 // It is exceeds associate numbers
#define NET_ERR_BE_ASSOCIATED_BY_PUBLIC_SUBSYSTEM    1215 // The subsystem is associate by the public subsystem
#define    NET_ERR_ZONE_FAULT_STATUS                    1216 // Zone is fault status
#define  NET_ERR_SAME_EVENT_TYPE                    1217 // There is same event type in "Event cause alarm out on" and "Event cause alarm out off"
#define NET_ERR_ZONE_ALARM_STATUS                    1218 // zone is alarm status
#define NET_ERR_EXPANSION_BUS_SHORT_CIRCUIT            1219 // expansion bus short circuit
#define NET_ERR_PWD_CONFLICT                        1220  //password conflict
#define NET_ERR_PWD_CONFLICT                        1220  //password conflict
#define NET_ERR_DETECTOR_GISTERED_BY_OTHER_ZONE     1221
#define NET_ERR_DETECTOR_GISTERED_BY_OTHER_PU       1222
#define NET_ERR_DETECTOR_DISCONNECT                 1223

#define NET_ERR_GET_ALL_RETURN_OVER                    1300  //get all the returns number overrun
#define NET_ERR_RESOURCE_USING                      1301  //information resources are in use and cannot be modified
#define NET_ERR_FILE_SIZE_OVERLIMIT                    1302  //the size of file is overlimit
//information publish server error code
#define NET_ERR_MATERIAL_NAME                       1303  //the name of the material illegal
#define NET_ERR_MATERIAL_NAME_LEN                   1304  //material name length is illegal
#define NET_ERR_MATERIAL_REMARK                     1305  //the remarks of the material is illegal
#define NET_ERR_MATERIAL_REMARK_LEN                 1306  //material remarks length is illegal
#define NET_ERR_MATERIAL_SHARE_PROPERTY             1307  //material shared property is illegal
#define NET_ERR_UNSUPPORT_MATERIAL_TYPE             1308  //material type is not supported
#define NET_ERR_MATERIAL_NOT_EXIST                  1309  //material does not exist
#define NET_ERR_READ_FROM_DISK                      1310  //failed to read material from the hard disk file
#define NET_ERR_WRITE_TO_DISK                       1311  //write material files to the hard drive failure
#define NET_ERR_WRITE_DATA_BASE                     1312  //write material database failure

//screen interactive error code
#define    NET_ERR_MAX_SCREEN_CTRL_NUM                    1351  //the number of control connections to screen is limited
#define    NET_ERR_FILE_NOT_EXIST                        1352  //the file is not exist
#define NET_ERR_THUMBNAIL_NOT_EXIST                    1353  //the thumbnail is not exist
#define NET_ERR_DEV_OPEN_FILE_FAIL                    1354  //the device failed to open the file
#define NET_ERR_SERVER_READ_FILE_FAIL                1355  //the screen server failed to read the file
#define NET_ERR_FILE_SIZE                            1356  //file size error
#define    NET_ERR_FILE_NAME                            1357  //file name error, file name is empty or illegal

//2012-12-20 ITC ERROR(1400-1499)
#define NET_DVR_ERR_LANENUM_EXCEED                  1400  //Lane number exceed
#define NET_DVR_ERR_PRAREA_EXCEED                   1401  //Area exceed
#define NET_DVR_ERR_LIGHT_PARAM                     1402  //Light parameter error
#define NET_DVR_ERR_LANE_LINE_INVALID               1403  //Lane line invalid
#define NET_DVR_ERR_STOP_LINE_INVALID               1404  //Stop line invalid
#define NET_DVR_ERR_LEFTORRIGHT_LINE_INVALID        1405  //Left or right line invalid
#define NET_DVR_ERR_LANE_NO_REPEAT                  1406  //Lane NO. repeat
#define NET_DVR_ERR_PRAREA_INVALID                  1407  //Area invalid
#define NET_DVR_ERR_LIGHT_NUM_EXCEED                1408  //Light number exceed
#define NET_DVR_ERR_SUBLIGHT_NUM_INVALID            1409  //Sublight number invalid
#define NET_DVR_ERR_LIGHT_AREASIZE_INVALID          1410  //Light area size invalid
#define NET_DVR_ERR_LIGHT_COLOR_INVALID             1411  //Light color invalid
#define NET_DVR_ERR_LIGHT_DIRECTION_INVALID         1412  //Light direction invalid
#define NET_DVR_ERR_LACK_IOABLITY                    1413  //IO ablity invalid

#define NET_DVR_ERR_FTP_PORT                        1414  //FTP port error
#define NET_DVR_ERR_FTP_CATALOGUE                   1415  //FTP catalogue error
#define NET_DVR_ERR_FTP_UPLOAD_TYPE                    1416  //FTP upload type error
#define NET_DVR_ERR_FLASH_PARAM_WRITE                1417  //Setting param flash write error
#define NET_DVR_ERR_FLASH_PARAM_READ                1418  //Getting param flash read error
#define NET_DVR_ERR_PICNAME_DELIMITER                1419  //Pic name delimiter error
#define NET_DVR_ERR_PICNAME_ITEM                    1420  //Pic name item error
#define NET_DVR_ERR_PLATE_RECOGNIZE_TYPE            1421  //Plate recognize type error
#define NET_DVR_ERR_CAPTURE_TIMES                    1422  //Capture times error
#define NET_DVR_ERR_LOOP_DISTANCE                    1423  //Loop distance error
#define NET_DVR_ERR_LOOP_INPUT_STATUS                1424  //Loop input status error
#define NET_DVR_ERR_RELATE_IO_CONFLICT                1425  //Related IO conflict
#define NET_DVR_ERR_INTERVAL_TIME                    1426  //Interval time error
#define NET_DVR_ERR_SIGN_SPEED                        1427  //Sign speed error
#define NET_DVR_ERR_PIC_FLIP                        1428  //Flip is used
#define NET_DVR_ERR_RELATE_LANE_NUMBER                1429  //Related lane number error
#define NET_DVR_ERR_TRIGGER_MODE                    1430  //Trigger mode error
#define NET_DVR_ERR_DELAY_TIME                        1431  //Delay time error
#define NET_DVR_ERR_EXCEED_RS485_COUNT                1432  //Exceed RS485 count
#define NET_DVR_ERR_RADAR_TYPE                        1433  //Radar type error
#define NET_DVR_ERR_RADAR_ANGLE                        1434  //Radar angle error
#define NET_DVR_ERR_RADAR_SPEED_VALID_TIME            1435  //Radar speed valid time error
#define NET_DVR_ERR_RADAR_LINE_CORRECT                1436  //Radar line correct error
#define NET_DVR_ERR_RADAR_CONST_CORRECT                1437  //Radar const correct error
#define NET_DVR_ERR_RECORD_PARAM                    1438  //Record param error
#define NET_DVR_ERR_LIGHT_WITHOUT_COLOR_AND_DIRECTION        1439  //Light number and other param error
#define NET_DVR_ERR_LIGHT_WITHOUT_DETECTION_REGION            1440  //Light number and detection region error
#define NET_DVR_ERR_RECOGNIZE_PROVINCE_PARAM                1441  //Plate recognize Province param error

#define NET_DVR_ERR_SPEED_TIMEOUT                 1442    //IO Speed TimeOut Param error
#define NET_DVR_ERR_NTP_TIMEZONE                  1443    //NTP TimeZone Param error
#define NET_DVR_ERR_NTP_INTERVAL_TIME             1444    //NTP Interval Time error
#define NET_DVR_ERR_NETWORK_CARD_NUM              1445    //Network Card Num error
#define NET_DVR_ERR_DEFAULT_ROUTE                 1446    //Default Route error
#define NET_DVR_ERR_BONDING_WORK_MODE             1447    //Banding Work Mode error
#define NET_DVR_ERR_SLAVE_CARD                    1448    //Slave Card error
#define NET_DVR_ERR_PRIMARY_CARD                  1449    //Primary Card error
#define NET_DVR_ERR_DHCP_PPOE_WORK                1450    //DHCP and PPOE not Meanwhile start
#define NET_DVR_ERR_NET_INTERFACE                 1451    //Net Interface invalid
#define NET_DVR_ERR_MTU                           1452    //MTU Param invalid
#define NET_DVR_ERR_NETMASK                       1453    //Netmask address invalid
#define NET_DVR_ERR_IP_INVALID                    1454    //IP address invalid
#define NET_DVR_ERR_MULTICAST_IP_INVALID          1455    //Multicast IP address invalid
#define NET_DVR_ERR_GATEWAY_INVALID               1456    //Gateway address invalid
#define NET_DVR_ERR_DNS_INVALID                   1457    //DNS Param invalid
#define NET_DVR_ERR_ALARMHOST_IP_INVALID          1458    //AlarmHost IP invalid
#define NET_DVR_ERR_IP_CONFLICT                   1459    //IP address Conflict
#define NET_DVR_ERR_NETWORK_SEGMENT               1460    //IP not support Multi Network segment
#define NET_DVR_ERR_NETPORT                       1461    //NetPort param error
#define NET_DVR_ERR_PPPOE_NOSUPPORT               1462  //Unsupport Pppoe
#define NET_DVR_ERR_DOMAINNAME_NOSUPPORT          1463  //Not Support Domain
#define NET_DVR_ERR_NO_SPEED                      1464  //Speed Not Enabled
#define NET_DVR_ERR_IOSTATUS_INVALID              1465  //IO Status invalidIO
#define NET_DVR_ERR_BURST_INTERVAL_INVALID        1466  //Burst Interval invalid
#define NET_DVR_ERR_RESERVE_MODE                  1467  //Reserve Mode invalid
#define NET_DVR_ERR_LANE_NO                       1468  //Lane No error
#define NET_DVR_ERR_COIL_AREA_TYPE                1469  //Coil Area Type error
#define NET_DVR_ERR_TRIGGER_AREA_PARAM            1470  //Trigger Area Param error
#define NET_DVR_ERR_SPEED_LIMIT_PARAM             1471  //Speed Limit Param error
#define NET_DVR_ERR_LANE_PROTOCOL_TYPE            1472  //Lane Protocol Type error
#define NET_DVR_ERR_INTERVAL_TYPE                 1473  //Capture Interval Type error
#define NET_DVR_ERR_INTERVAL_DISTANCE             1474  //Capture Interval Distance error
#define NET_DVR_ERR_RS485_ASSOCIATE_DEVTYPE       1475  //Rs485 Associate DevType error
#define NET_DVR_ERR_RS485_ASSOCIATE_LANENO        1476  //Rs485 Associate LaneNo error
#define NET_DVR_ERR_LANENO_ASSOCIATE_MULTIRS485   1477  //LaneNo Associate MulitRs485 error
#define NET_DVR_ERR_LIGHT_DETECTION_REGION        1478  //Light Detection Region error
#define NET_DVR_ERR_DN2D_NOSUPPORT            1479  //Not Support Capture Frame 2D Noise Reduction
#define NET_DVR_ERR_IRISMODE_NOSUPPORT        1480  //Not Support IRIS Mode
#define NET_DVR_ERR_WB_NOSUPPORT              1481  //Not Support White Balance Mode
#define NET_DVR_ERR_IO_EFFECTIVENESS          1482  //IO Effectiveness invalid
#define NET_DVR_ERR_LIGHTNO_MAX               1483  //Access Detector Lights Red / Yellow Overrun
#define NET_DVR_ERR_LIGHTNO_CONFLICT          1484  //Access Detector Lights Red / Yellow Conflict
#define NET_DVR_ERR_CANCEL_LINE                1485  //Trigger straight line error
#define NET_DVR_ERR_STOP_LINE               1486  //Subject line area stop line error
#define NET_DVR_ERR_RUSH_REDLIGHT_LINE      1487  //Red light trigger lines error
#define NET_DVR_ERR_IOOUTNO_MAX             1488  //IO output port number of cross-border
#define NET_DVR_ERR_IOOUTNO_AHEADTIME_MAX    1489  //IO output port ahead of time overrun
#define NET_DVR_ERR_IOOUTNO_IOWORKTIME      1490  //IO output effective duration overrun
#define NET_DVR_ERR_IOOUTNO_FREQMULTI       1491  //IO Output No Freqmulti error
#define NET_DVR_ERR_IOOUTNO_DUTYRATE        1492  //IO Output No Dutyrate error
#define NET_DVR_ERR_VIDEO_WITH_EXPOSURE     1493  //To exposure flash onset, work does not support video
#define NET_DVR_ERR_PLATE_BRIGHTNESS_WITHOUT_FLASHDET   1494  //Plate flash brightness is automatically enabled only under license onset luminance compensation mode

#define NET_DVR_ERR_RECOGNIZE_TYPE_PARAM            1495 //Identify the types of illegal license plate recognition parameters (such as cars, car, back, forward, vehicle logo recognition etc.)
#define NET_DVR_ERR_PALTE_RECOGNIZE_AREA_PARAM      1496 //Brand identification card recognition area configuration parameter illegal judgment error
#define NET_DVR_ERR_PORT_CONFLICT                   1497 //Port Conflict
#define NET_DVR_ERR_LOOP_IP                         1498 //IP cannot be the loopback address
#define NET_DVR_ERR_DRIVELINE_SENSITIVE             1499 //Driveline sensitivity error.


#define NET_ERR_VQD_TIME_CONFLICT                    1500 //VQD Diagnostic period conflicts
#define NET_ERR_VQD_PLAN_NO_EXIST                    1501 //VQD Diagnostic plan does not exist
#define NET_ERR_VQD_CHAN_NO_EXIST                    1502 //VQD Monitoring point does not exist
#define NET_ERR_VQD_CHAN_MAX                        1503 //VQD Have reached the maximum number of plans
#define NET_ERR_VQD_TASK_MAX                        1504 //VQD Have reached the maximum number of Task


//ITC new Err Code(1600~1900)
#define NET_DVR_ERR_EXCEED_MAX_CAPTURE_TIMES        1600 //Capture times exceed 2 in flash mode.
#define NET_DVR_ERR_REDAR_TYPE_CONFLICT             1601 //Radar type conflict.
#define NET_DVR_ERR_LICENSE_PLATE_NULL              1602 //License Plate is Null
#define NET_DVR_ERR_WRITE_DATABASE                  1603 //Write Database Error
#define NET_DVR_ERR_LICENSE_EFFECTIVE_TIME          1604 //License Plate Effective Time Error
#define NET_DVR_ERR_PRERECORDED_STARTTIME_LONG      1605 //The pre recorded start time is greater than the number of illegal capture
#define NET_DVR_ERR_TRIGGER_RULE_LINE               1606 //Trigger rule line error
#define NET_DVR_ERR_LEFTRIGHT_TRIGGERLINE_NOTVERTICAL 1607 //Left and right trigger line is not vertical
#define NET_DVR_ERR_FLASH_LAMP_MODE                 1608 //Flash lamp mode error
#define NET_DVR_ERR_ILLEGAL_SNAPSHOT_NUM            1609 //Illegal capture number error
#define NET_DVR_ERR_ILLEGAL_DETECTION_TYPE          1610 //Illegal detection type error
#define NET_DVR_ERR_POSITIVEBACK_TRIGGERLINE_HIGH   1611 //Positive back to trigger line height error
#define NET_DVR_ERR_MIXEDMODE_CAPTYPE_ALLTARGETS    1612 //Mixed mode only supports capture type all targets

#define NET_DVR_ERR_CARSIGNSPEED_GREATERTHAN_LIMITSPEED  1613//Car sign speed Greaterthan limit Speed
#define NET_DVR_ERR_BIGCARSIGNSPEED_GREATERTHAN_LIMITSPEED  1614//Big Car sign speed Greaterthan limit Speed
#define NET_DVR_ERR_BIGCARSIGNSPEED_GREATERTHAN_CARSIGNSPEED  1615//Big Car sign speed Greaterthan car sign Speed
#define NET_DVR_ERR_BIGCARLIMITSPEED_GREATERTHAN_CARLIMITSPEED  1616//Big Car limit speed Greaterthan car limit Speed
#define NET_DVR_ERR_BIGCARLOWSPEEDLIMIT_GREATERTHAN_CARLOWSPEEDLIMIT  1617//Big Car low speed limit Greaterthan car low speed limit
#define NET_DVR_ERR_CARLIMITSPEED_GREATERTHAN_EXCEPHIGHSPEED  1618//Car limit speed Greaterthan car exception high speed
#define NET_DVR_ERR_BIGCARLIMITSPEED_GREATERTHAN_EXCEPHIGHSPEED  1619//Big car limit speed Greaterthan car exception high speed
#define NET_DVR_ERR_STOPLINE_MORETHAN_TRIGGERLINE  1620//Stopping more than straight lines trigger lines

//ACS Err Code
#define NET_ERR_TIME_OVERLAP                        1900 //time segment overlap
#define NET_ERR_HOLIDAY_PLAN_OVERLAP                1901 //holiday plan overlap
#define NET_ERR_CARDNO_NOT_SORT                     1902 //not sort card No.
#define NET_ERR_CARDNO_NOT_EXIST                    1903 //card No. inexist
#define NET_ERR_ILLEGAL_CARDNO                      1904 //card No. illegal
#define NET_ERR_ZONE_ALARM                          1905 //zone be arming
#define NET_ERR_ZONE_OPERATION_NOT_SUPPORT          1906 //zone don't support this operate
#define NET_ERR_INTERLOCK_ANTI_CONFLICT             1907 //interlock and anti conflict
#define NET_ERR_DEVICE_CARD_FULL                    1908 //card full(max 100 thousand)
#define NET_ERR_HOLIDAY_GROUP_DOWNLOAD              1909 //holiday group download error
#define NET_ERR_LOCAL_CONTROL_OFF					1910 //local control off
#define NET_ERR_LOCAL_CONTROL_DISADD				1911 //local control disadd
#define NET_ERR_LOCAL_CONTROL_HASADD				1912 //local control hasadd
#define NET_ERR_LOCAL_CONTROL_DOORNO_CONFLICT		1913 //local control doorNO conflict
#define NET_ERR_LOCAL_CONTROL_COMMUNICATION_FAIL	1914 //local control communication fail
#define NET_ERR_OPERAND_INEXISTENCE  				1915 //operand inexistence
#define NET_ERR_LOCAL_CONTROL_OVER_LIMIT  		    1916 //local control over limit
#define NET_ERR_DOOR_OVER_LIMIT  		   			1917 //door over limit
#define NET_ERR_ALARM_OVER_LIMIT  		   			1918 //alarm over limit
#define NET_ERR_LOCAL_CONTROL_ADDRESS_INCONFORMITY_TYPE  	1919 //local control address inconformity type

//VIS Error Code
#define NET_DVR_ERR_OUTDOOR_COMMUNICATION            1950 //communication the door machine  abnormality
#define NET_DVR_ERR_ROOMNO_UNDEFINED                1951 //not configured  room No.
#define NET_DVR_ERR_NO_CALLING            1952 //no calling
#define NET_DVR_ERR_RINGING                1953 //rining
#define NET_DVR_ERR_IS_CALLING_NOW        1954 //calling
#define NET_DVR_ERR_NO_CALLING		                1952 //no call
#define NET_DVR_ERR_RINGING				            1953 //ring the bell
#define NET_DVR_ERR_IS_CALLING_NOW		            1954 //is calling now
#define NET_DVR_ERR_LOCK_PASSWORD_WRONG             1955//Intelligent lock password mistake
#define NET_DVR_ERR_CONTROL_LOCK_FAILURE            1956//Switch lock failure
#define NET_DVR_ERR_CONTROL_LOCK_OVERTIME           1957//Switch lock timeout
#define NET_DVR_ERR_LOCK_DEVICE_BUSY                1958//Intelligent lock device is busy
#define NET_DVR_ERR_UNOPEN_REMOTE_LOCK_FUNCTION     1959//Remote lock function is not open



#define NET_DVR_ERR_FILE_NOT_COMPLETE               2100     // File not complete
#define NET_DVR_ERR_IPC_EXIST                       2101    //IPC is exist
#define NET_DVR_ERR_ADD_IPC                         2102    //The channle has alread be added
#define NET_DVR_ERR_OUT_OF_RES                      2103    //Band is limited
#define NET_DVR_ERR_CONFLICT_TO_LOCALIP             2104    //IP address is conflict
#define NET_DVR_ERR_IP_SET                          2105    //IP address is illegal
#define NET_DVR_ERR_PORT_SET                        2106    //port is illeagl

#define NET_ERR_WAN_NOTSUPPORT                      2107     //not in the same WLAN/ not support securityquestion config or export GUID
#define NET_ERR_MUTEX_FUNCTION                      2108     //mutex function error
#define NET_ERR_QUESTION_CONFIGNUM                  2109     //security question amount error

//Thermal error codes\A3\A83001 - 3500\A3\A9
#define NET_DVR_ERR_NOTSUPPORT_DEICING              3001    //Notsupport Deicing
#define NET_DVR_ERR_THERMENABLE_CLOSE               3002    //Thermometry basic param enabled close
#define NET_DVR_ERR_NOTMEET_DEICING                 3003    //The current temperature does not meet the manual de icing on the open condition
#define NET_DVR_ERR_PANORAMIC_LIMIT_OPERATED        3004    //Panoramic maps and limit cannot be operated at the same time
/*******************Global Error Code end**********************/

/*************************************************
Return value of NET_DVR_IsSupport () ,
the definition of bit 1 to bit 9 is below and TRUE means support
**************************************************/
#define NET_DVR_SUPPORT_DDRAW            0x01  // Support DIRECTDRAW,  otherwise Player can't work
#define NET_DVR_SUPPORT_BLT                0x02  // Display adapter supports BLT,  otherwise Player can't work
#define NET_DVR_SUPPORT_BLTFOURCC        0x04  // BLT supports color conversion,  otherwise,  Player will do RGB conversion in software mode;
#define NET_DVR_SUPPORT_BLTSHRINKX        0x08  // BLT supports X- coordinate shrink,  otherwise,  Player will do it in software mode;
#define NET_DVR_SUPPORT_BLTSHRINKY        0x10  // BLT supports Y- coordinate shrink,  otherwise,  Player will do it in software mode;
#define NET_DVR_SUPPORT_BLTSTRETCHX        0x20  // BLT supports X- coordinate expand,  otherwise,  Player will do it in software mode;
#define NET_DVR_SUPPORT_BLTSTRETCHY        0x40  // BLT supports Y- coordinate expand,  otherwise,  Player will do it in software mode;
#define NET_DVR_SUPPORT_SSE                0x80  // CPU supports SSE commands, Intel Pentium3 or higher version supports SSE;
#define NET_DVR_SUPPORT_MMX                0x100 // CPU supports MMX commands, Intel Pentium3 or higher version supports MMX

/**********************PTZ Commands begin*************************/
#define LIGHT_PWRON        2    // Switch on light
#define WIPER_PWRON        3    // Switch on Wiper
#define FAN_PWRON        4    // Switch on Fan
#define HEATER_PWRON    5    // Switch on Heater
#define AUX_PWRON1        6    // Switch on auxiliary equipment 1
#define AUX_PWRON2        7    // Switch on auxiliary equipment 2
#define SET_PRESET        8    // Configure Preset
#define CLE_PRESET        9    // Clean Preset

#define ZOOM_IN            11    // Zoom in
#define ZOOM_OUT        12    // Zoom out
#define FOCUS_NEAR      13  // Focus in
#define FOCUS_FAR       14  // Focus out
#define IRIS_OPEN       15  // Iris open
#define IRIS_CLOSE      16  // Iris close

#define TILT_UP            21    // PTZ tilt up
#define TILT_DOWN        22    // PTZ tilt down
#define PAN_LEFT        23    // PTZ pan left
#define PAN_RIGHT        24    // PTZ pan right
#define UP_LEFT            25    // PTZ turn up and left
#define UP_RIGHT        26    // PTZ turn up and right
#define DOWN_LEFT        27    // PTZ turn down and left
#define DOWN_RIGHT        28    // PTZ turn down and right
#define PAN_AUTO        29    // PTZ auto pan

#define FILL_PRE_SEQ    30    // Add preset to sequence
#define SET_SEQ_DWELL    31    // Set cruise point's residence time
#define SET_SEQ_SPEED    32    // Set cruise point
#define CLE_PRE_SEQ        33    // Delete preset from sequence
#define STA_MEM_CRUISE    34    // Start recording trace
#define STO_MEM_CRUISE    35    // Stop recoding trace
#define RUN_CRUISE        36    // Start Cruise
#define RUN_SEQ            37    // Start Sequence
#define STOP_SEQ        38    // Stop Sequence
#define GOTO_PRESET        39    // Go to preset
#define DEL_SEQ         43  // delete cruise path
#define STOP_CRUISE            44    // stop cruise
#define DELETE_CRUISE        45    // delete cruise
#define DELETE_ALL_CRUISE    46    // delete all cruise

#define PAN_CIRCLE      50  // PTZ of the SS speed automatic circle scanning
#define DRAG_PTZ        51  // PTZ drag
#define LINEAR_SCAN     52  /* Area scanning */ //2014-03-15
#define CLE_ALL_PRESET  53   /* Clean All Preset */
#define CLE_ALL_SEQ     54   /* Clean All Seq */
#define CLE_ALL_CRUISE  55   /* Clean All Cruise */

#define POPUP_MENU        56 /* Operation  Menu */

#define TILT_DOWN_ZOOM_IN    58    /* PTZ tilt down & Zoom in */
#define TILT_DOWN_ZOOM_OUT  59  /* PTZ tilt down & Zoom out */
#define PAN_LEFT_ZOOM_IN    60  /* PTZ pan left & Zoom in*/
#define PAN_LEFT_ZOOM_OUT   61  /* PTZ pan left & Zoom out*/
#define PAN_RIGHT_ZOOM_IN    62  /* PTZ pan right & Zoom in*/
#define PAN_RIGHT_ZOOM_OUT  63  /* PTZ pan right & Zoom out */
#define UP_LEFT_ZOOM_IN     64  /* PTZ turn up and left & Zoom in*/
#define UP_LEFT_ZOOM_OUT    65  /* PTZ turn up and left & Zoom Out*/
#define UP_RIGHT_ZOOM_IN    66  /* PTZ turn up and right & Zoom in*/
#define UP_RIGHT_ZOOM_OUT   67  /* PTZ turn up and right & Zoom Out*/
#define DOWN_LEFT_ZOOM_IN   68  /* PTZ turn down and left & Zoom in */
#define DOWN_LEFT_ZOOM_OUT  69  /* PTZ turn down and left & Zoom Out */
#define DOWN_RIGHT_ZOOM_IN    70  /* PTZ turn down and right & Zoom in */
#define DOWN_RIGHT_ZOOM_OUT    71  /* PTZ turn down and right & Zoom Out */
#define TILT_UP_ZOOM_IN        72    /* PTZ tilt up & Zoom in */
#define TILT_UP_ZOOM_OUT    73    /* PTZ tilt up & Zoom out */

#define DVR_VEHICLE_CONTROL_LIST   0x1 //Vehicle black and white list data type (data type) 2013-11-04
/**********************PTZ Commands end*************************/

/*************************************************
Play Control Commands
Macro Definition
NET_DVR_PlayBackControl
NET_DVR_PlayControlLocDisplay
NET_DVR_DecPlayBackCtrl
**************************************************/
#define NET_DVR_PLAYSTART        1  // Start Play
#define NET_DVR_PLAYSTOP        2  // Stop Play
#define NET_DVR_PLAYPAUSE        3  // Pause Play
#define NET_DVR_PLAYRESTART        4  // Restore Play
#define NET_DVR_PLAYFAST        5  // Play faster
#define NET_DVR_PLAYSLOW        6  // Play slower
#define NET_DVR_PLAYNORMAL        7  // Normal Speed
#define NET_DVR_PLAYFRAME        8  // Play frame by frame
#define NET_DVR_PLAYSTARTAUDIO    9  // Open audio
#define NET_DVR_PLAYSTOPAUDIO    10 // Close audio
#define NET_DVR_PLAYAUDIOVOLUME    11 // Adjust volume
#define NET_DVR_PLAYSETPOS        12 // Change the playback progress
#define NET_DVR_PLAYGETPOS        13 // Get the playback progress
#define NET_DVR_PLAYGETTIME        14 // Get the played time (available when playback by time)
#define NET_DVR_PLAYGETFRAME    15 // Get the played frame number (available when playback by file)
#define NET_DVR_GETTOTALFRAMES  16 // Get total frame number of current file (available when playback by file)
#define NET_DVR_GETTOTALTIME    17 // Get total time of current file (available when playback by file)
#define NET_DVR_THROWBFRAME        20 // Discard B frame
#define NET_DVR_SETSPEED        24 // Setup stream speed
#define NET_DVR_KEEPALIVE        25 // Keep connection with server (if callback is blocked,  send it every 2 second)
#define NET_DVR_PLAYSETTIME        26 // Set playback position according to absolute time
#define NET_DVR_PLAYGETTOTALLEN    27 // Get total time length of all the detected files under playback by time mode
#define NET_DVR_PLAY_FORWARD    29 //change stream from reverse to forward
#define NET_DVR_PLAY_REVERSE    30 //change stream from froward to reverse
#define NET_DVR_SET_DECODEFFRAMETYPE 31 //Set decode frame type
#define NET_DVR_SET_TRANS_TYPE        32    //Set Transcodeing Type
#define NET_DVR_PLAY_CONVERT    33 //playback decode
#define NET_DVR_START_DRAWFRAME 34 //start draw I Frame
#define NET_DVR_STOP_DRAWFRAME  35 //stop draw I Frame
#define NET_DVR_CHANGEWNDRESOLUTION   36    //change wnd size



#define PLAYM4_DECODE_NORMAIL              0   //normal
#define PLAYM4_DECODE_KEY_FRAME            1   //decode I frame
#define PLAYM4_DECODE_NONE                 2   //none
#define PLAYM4_DECODE_TEMPORAL_LAYER_0     3   // half
#define PLAYM4_DECODE_TEMPORAL_LAYER_1     4   //a quarter


//Remote Key//
/* key value send to CONFIG program */
#define KEY_CODE_1        1
#define KEY_CODE_2        2
#define KEY_CODE_3        3
#define KEY_CODE_4        4
#define KEY_CODE_5        5
#define KEY_CODE_6        6
#define KEY_CODE_7        7
#define KEY_CODE_8        8
#define KEY_CODE_9        9
#define KEY_CODE_0        10
#define KEY_CODE_POWER    11
#define KEY_CODE_MENU    12
#define KEY_CODE_ENTER    13
#define KEY_CODE_CANCEL 14
#define KEY_CODE_UP        15
#define KEY_CODE_DOWN    16
#define KEY_CODE_LEFT    17
#define KEY_CODE_RIGHT    18
#define KEY_CODE_EDIT    19
#define KEY_CODE_ADD    20
#define KEY_CODE_MINUS    21
#define KEY_CODE_PLAY    22
#define KEY_CODE_REC    23
#define KEY_CODE_PAN    24
#define KEY_CODE_M        25
#define KEY_CODE_A        26
#define KEY_CODE_F1        27
#define KEY_CODE_F2        28

/* for PTZ control */
#define KEY_PTZ_UP_START     KEY_CODE_UP
#define KEY_PTZ_UP_STOP         32

#define KEY_PTZ_DOWN_START     KEY_CODE_DOWN
#define KEY_PTZ_DOWN_STOP     33

#define KEY_PTZ_LEFT_START     KEY_CODE_LEFT
#define KEY_PTZ_LEFT_STOP     34

#define KEY_PTZ_RIGHT_START  KEY_CODE_RIGHT
#define KEY_PTZ_RIGHT_STOP     35

#define KEY_PTZ_AP1_START     KEY_CODE_EDIT /* Iris+ */
#define KEY_PTZ_AP1_STOP     36

#define KEY_PTZ_AP2_START     KEY_CODE_PAN /* Iris-  */
#define KEY_PTZ_AP2_STOP     37

#define KEY_PTZ_FOCUS1_START KEY_CODE_A /* Focus+ */
#define KEY_PTZ_FOCUS1_STOP  38

#define KEY_PTZ_FOCUS2_START KEY_CODE_M /* Focus-  */
#define KEY_PTZ_FOCUS2_STOP  39

#define KEY_PTZ_B1_START     40 /* Zoom+ */
#define KEY_PTZ_B1_STOP         41

#define KEY_PTZ_B2_START     42 /* Zoom-  */
#define KEY_PTZ_B2_STOP         43

//New in 9000
#define KEY_CODE_11             44
#define KEY_CODE_12             45
#define KEY_CODE_13             46
#define KEY_CODE_14             47
#define KEY_CODE_15             48
#define KEY_CODE_16             49

/*************************Parameter Configure Commands begin*******************************/
//Used for NET_DVR_SetDVRConfig and NET_DVR_GetDVRConfig,  pay attention to corresponding Structure

#define NET_DVR_GET_DEVICECFG        100        //Get DVR Parameters
#define NET_DVR_SET_DEVICECFG        101        //Set DVR Parameters
#define NET_DVR_GET_NETCFG            102        //Get Network Parameters
#define NET_DVR_SET_NETCFG            103        //Set Network Parameters
#define NET_DVR_GET_PICCFG            104        //Get Image Parameters
#define NET_DVR_SET_PICCFG            105        //Set Image Parameters
#define NET_DVR_GET_COMPRESSCFG        106        //Get Compression Parameters
#define NET_DVR_SET_COMPRESSCFG        107        //Set Compression Parameters
#define NET_DVR_GET_RECORDCFG        108        //Get Record Parameters
#define NET_DVR_SET_RECORDCFG        109        //Set Record Parameters
#define NET_DVR_GET_DECODERCFG        110        //Get PTZ Parameters
#define NET_DVR_SET_DECODERCFG        111        //Set PTZ Parameters
#define NET_DVR_GET_RS232CFG         112        //Get RS232 Parameters
#define NET_DVR_SET_RS232CFG        113        //Set RS232 Parameters
#define NET_DVR_GET_ALARMINCFG         114        //Get Alarm In Parameters
#define NET_DVR_SET_ALARMINCFG        115        //Set Alarm In Parameters
#define NET_DVR_GET_ALARMOUTCFG     116        //Get Alarm Out Parameters
#define NET_DVR_SET_ALARMOUTCFG        117        //Set Alarm Out Parameters
#define NET_DVR_GET_TIMECFG         118        //Get DVR time
#define NET_DVR_SET_TIMECFG            119        //Set DVR time
#define NET_DVR_GET_PREVIEWCFG         120        //Get Local Preview Parameters
#define NET_DVR_SET_PREVIEWCFG        121        //Set Local Preview Parameters
#define NET_DVR_GET_VIDEOOUTCFG     122        //Get Video Output Parameters
#define NET_DVR_SET_VIDEOOUTCFG        123        //Set Video Output Parameters
#define NET_DVR_GET_USERCFG         124        //Get User Parameters
#define NET_DVR_SET_USERCFG            125        //Set User Parameters
#define NET_DVR_GET_EXCEPTIONCFG     126        //Get Exception Parameters
#define NET_DVR_SET_EXCEPTIONCFG    127        //Set Exception Parameters
#define NET_DVR_GET_ZONEANDDST        128        //Get Time Zone & DST Parameters
#define NET_DVR_SET_ZONEANDDST        129        //Set Time Zone & DST Parameters
#define NET_DVR_GET_SHOWSTRING        130        //Get OSD Parameters
#define NET_DVR_SET_SHOWSTRING        131        //Set OSD Parameters
#define NET_DVR_GET_EVENTCOMPCFG    132        //Get Event Record Parameters
#define NET_DVR_SET_EVENTCOMPCFG    133        //Set Event Record  Parameters

#define NET_DVR_GET_FTPCFG            134        //get ftp parameters
#define NET_DVR_SET_FTPCFG            135        //set ftp parameters

#define NET_DVR_GET_AUXOUTCFG        140        //Get External Alarm Configuration
#define NET_DVR_SET_AUXOUTCFG        141        //Set External Alarm Configuration
#define NET_DVR_GET_PREVIEWCFG_AUX     142        //Get - S device dual output parameters
#define NET_DVR_SET_PREVIEWCFG_AUX    143        //Set - S device dual output parameters

#define NET_DVR_GET_PASSWORD_MANAGE_CFG 144		//get password manage parameters
#define NET_DVR_SET_PASSWORD_MANAGE_CFG	145		//set password manage parameters
#define NET_DVR_UNLOCK_USER 			146		//unlock user
#define NET_DVR_GET_SECURITY_CFG 	    147		//Get Security parameters
#define NET_DVR_SET_SECURITY_CFG 	    148		//Set Security parameters
#define	NET_DVR_GET_LOCKED_INFO_LIST	149		//get all locked info


/*********************************Intelligence APIs Begin***************************************/

//VCA  (NET_VCA_RULECFG)
#define NET_DVR_SET_RULECFG                    152  //Set rule of VCA
#define NET_DVR_GET_RULECFG                    153     //Get rule of VCA
//Track parameters of Speed dome (NET_DVR_TRACK_CFG)
#define NET_DVR_SET_TRACK_CFG                160  //Set Speed dome config
#define NET_DVR_GET_TRACK_CFG                161  //Get Speed dome config

//Config Commands for Getting Stream
#define NET_DVR_SET_IVMS_STREAMCFG            162     //Set IVMS Parameter for getting stream
#define NET_DVR_GET_IVMS_STREAMCFG            163     //Get IVMS Parameter

//Intelligent control parameter
#define NET_DVR_SET_VCA_CTRLCFG                164     //Set intelligent control parameter
#define NET_DVR_GET_VCA_CTRLCFG                165     //Get intelligent control parameter

//Mask Area,  NET_VCA_MASK_REGION_LIST
#define NET_DVR_SET_VCA_MASK_REGION            166     //Set Mask Area
#define NET_DVR_GET_VCA_MASK_REGION            167     //Get Mask Area

//Get/Set Enter ATM Region Commands,  NET_VCA_ENTER_REGION
#define NET_DVR_SET_VCA_ENTER_REGION        168     //Set region parameter
#define NET_DVR_GET_VCA_ENTER_REGION        169     //Get region parameter

//NET_VCA_LINE_SEGMENT_LIST
#define NET_DVR_SET_VCA_LINE_SEGMENT 170     //set vca line segment
#define NET_DVR_GET_VCA_LINE_SEGMENT 171     //get vca line segment

// ivms mask region,  NET_IVMS_MASK_REGION_LIST
#define NET_DVR_SET_IVMS_MASK_REGION        172     //SetIVMS mask region parameter
#define NET_DVR_GET_IVMS_MASK_REGION        173     //GetIVMS mask region parameter
// ivms enter detecting region,  NET_IVMS_ENTER_REGION
#define NET_DVR_SET_IVMS_ENTER_REGION        174     //Set IVMS enter region parameter
#define NET_DVR_GET_IVMS_ENTER_REGION        175     //Get IVMS enter region parameter

//IVMS VCA Config Commands
#define NET_DVR_SET_IVMS_BEHAVIORCFG        176    //Set IVMS VCA rule
#define NET_DVR_GET_IVMS_BEHAVIORCFG        177    //Get IVMS VCA rule

// IVMS Playback Search
#define NET_DVR_IVMS_SET_SEARCHCFG            178     //SetIVMS Playback Search parameter
#define NET_DVR_IVMS_GET_SEARCHCFG            179       //GetIVMS Playback Search parameter

// SDK_V35
#define NET_DVR_SET_POSITION_TRACK            180  // Set track scene configuration info
#define NET_DVR_GET_POSITION_TRACK            181  // Get track scene configuration info

#define NET_DVR_SET_CALIBRATION                182  // Set calibration info
#define NET_DVR_GET_CALIBRATION                183  // Get calibration info

#define NET_DVR_SET_PDC_RULECFG                184  // Set PDC counting rule
#define NET_DVR_GET_PDC_RULECFG                185  // Get PDC counting rule

#define NET_DVR_SET_PU_STREAMCFG            186  // Set PU stream configuration info
#define NET_DVR_GET_PU_STREAMCFG            187  // Get PU stream configuration info

#define NET_VCA_SET_IVMS_BEHAVIOR_CFG        192  // Set IVMS VCA without time period settings
#define NET_VCA_GET_IVMS_BEHAVIOR_CFG        193  // Get IVMS VCA without time period settings

//Global Target Size filter
#define NET_VCA_SET_SIZE_FILTER                194  //Set global target size filter
#define NET_VCA_GET_SIZE_FILTER                195  //Get global target size filter

#define NET_DVR_SET_TRACK_PARAMCFG            196  // Set local menu rules of speed dome
#define NET_DVR_GET_TRACK_PARAMCFG            197  // Get local menu rules of speed dome

#define NET_DVR_SET_DOME_MOVEMENT_PARAM        198  // Set movement parameters of speed dome
#define NET_DVR_GET_DOME_MOVEMENT_PARAM        199  // Get movement parameters of speed dome

/**************************************Intelligent APIs Begin**********************************/

#define NET_DVR_GET_PICCFG_EX        200        //Get Image Parameters  (Extended)
#define NET_DVR_SET_PICCFG_EX        201        //Set Image Parameters  (Extended)
#define NET_DVR_GET_USERCFG_EX         202        //Get User Parameters (Extended)
#define NET_DVR_SET_USERCFG_EX        203        //Set User Parameters (Extended)
#define NET_DVR_GET_COMPRESSCFG_EX    204        //Get Compression Parameters  (Extended)
#define NET_DVR_SET_COMPRESSCFG_EX    205        //Set Compression Parameters  (Extended)


#define NET_DVR_GET_NETAPPCFG        222        //Get Network Application Parameters NTP/DDNS/EMAIL
#define NET_DVR_SET_NETAPPCFG        223        //Set Network Application Parameters NTP/DDNS/EMAIL
#define NET_DVR_GET_NTPCFG            224        //Get Network Application Parameters NTP
#define NET_DVR_SET_NTPCFG            225        //Set Network Application Parameters NTP
#define NET_DVR_GET_DDNSCFG            226        //Get Network Application Parameters DDNS
#define NET_DVR_SET_DDNSCFG            227        //Set Network Application Parameters DDNS

//Corresponding with NET_DVR_EMAILPARA
#define NET_DVR_GET_EMAILCFG        228        //Get EMAIL Configuration
#define NET_DVR_SET_EMAILCFG        229        //Set EMAIL Configuration

#define NET_DVR_GET_NFSCFG            230        // NFS disk configuration
#define NET_DVR_SET_NFSCFG            231        // NFS disk configuration

#define NET_DVR_GET_SHOWSTRING_EX    238        //Get Extended OSD Parameters
#define NET_DVR_SET_SHOWSTRING_EX    239        //Set Extended OSD Parameters
#define NET_DVR_GET_NETCFG_OTHER    244        //Get Network Parameters
#define NET_DVR_SET_NETCFG_OTHER    245        //Set Network Parameters

//NET_DVR_EMAILCFG
#define NET_DVR_GET_EMAILPARACFG    250        //Get EMAIL parameters
#define NET_DVR_SET_EMAILPARACFG    251        //Setup EMAIL parameters


#define NET_DVR_GET_DDNSCFG_EX        274        //Get Extended DDNS Parameters
#define NET_DVR_SET_DDNSCFG_EX        275        //Set Extended DDNS Parameters


#define    NET_DVR_SET_PTZPOS            292        //Set PTZ Position
#define    NET_DVR_GET_PTZPOS            293        //Get PTZ Position
#define    NET_DVR_GET_PTZSCOPE        294        //Get PTZ Scope

#define NET_DVR_GET_AP_INFO_LIST                    305//Get wireless network resource settings
#define NET_DVR_SET_WIFI_CFG                        306    //Set wireless parameters for IP device
#define NET_DVR_GET_WIFI_CFG                        307    //Get wireless parameters for IP device
#define NET_DVR_SET_WIFI_WORKMODE                    308    //Set the network interface working mode of IP device
#define NET_DVR_GET_WIFI_WORKMODE                    309    //Get the network interface working mode of IP device
#define    NET_DVR_GET_WIFI_STATUS                        310    //Get wireless status for IP device

/*********************************Intelligent Traffic Event Begin***************************************/
#define NET_DVR_GET_REFERENCE_REGION        400     // Get reference region
#define NET_DVR_SET_REFERENCE_REGION        401     //Set reference region

#define NET_DVR_GET_TRAFFIC_MASK_REGION     402     //Get traffic event mask region
#define NET_DVR_SET_TRAFFIC_MASK_REGION     403     //Set traffic event mask region

// #define NET_DVR_GET_SCENE_MODE           404     // Get scenario mode
// #define NET_DVR_SET_SCENE_MODE           405     // Set scenario mode

#define NET_DVR_SET_AID_RULECFG             404     // Set traffic event rule parameters
#define NET_DVR_GET_AID_RULECFG             405     // Get traffic event rule parameters

#define NET_DVR_SET_TPS_RULECFG             406     // Set traffic rule statistics
#define NET_DVR_GET_TPS_RULECFG             407     // Get traffic rule statistics

#define NET_DVR_SET_LANECFG                    408        // Set traffic lane rules
#define    NET_DVR_GET_LANECFG                     409        // Get traffic lane rules
#define NET_DVR_GET_VCA_RULE_COLOR_CFG      410     // Get VCA Rule Relate Color Config
#define NET_DVR_SET_VCA_RULE_COLOR_CFG      411     // Set VCA Rule Relate Color Config
#define NET_DVR_GET_SWITCH_LAMP_CFG         412     // Get Switch lamp Config
#define NET_DVR_SET_SWITCH_LAMP_CFG         413     // Set Switch lamp Config


/*********************************Intelligent traffic events end***************************************/
#define NET_DVR_SET_FACEDETECT_RULECFG      420      // Set face detection rule
#define NET_DVR_GET_FACEDETECT_RULECFG      421      // Get face detection rule

#define NET_DVR_SET_VEHICLE_RECOG_TASK      422      // Set Vehicle two recognition tasks
#define NET_DVR_GET_VEHICLE_RECOG_TASK      423      // Get Vehicle two recognition tasks

#define NET_DVR_SET_TIMECORRECT                432      //set time corrrect(only operation,not configure)
#define    NET_DVR_GET_CONNECT_LIST            433         //get connect list
/***************************DS9000 New Commands (_V30)  begin *****************************/
//Network (NET_DVR_NETCFG_V30)
#define NET_DVR_GET_NETCFG_V30                1000     //Get  Network  Parameters
#define NET_DVR_SET_NETCFG_V30                1001     //Set  Network  Parameters

//Image (NET_DVR_PICCFG_V30)
#define NET_DVR_GET_PICCFG_V30                1002     //Get Image Parameters
#define NET_DVR_SET_PICCFG_V30                1003     //Set Image Parameters

//Record (NET_DVR_RECORD_V30)
#define NET_DVR_GET_RECORDCFG_V30            1004        //Get Record Parameters
#define NET_DVR_SET_RECORDCFG_V30            1005     //Set Record Parameters

//User (NET_DVR_USER_V30)
#define NET_DVR_GET_USERCFG_V30             1006     //Get User Parameters
#define NET_DVR_SET_USERCFG_V30                1007     //Set User Parameters

//Record (NET_DVR_RECORD_V40)
#define NET_DVR_GET_RECORDCFG_V40            1008    //Get Record Parameters(Extended)
#define NET_DVR_SET_RECORDCFG_V40            1009    //Set Record Parameters(Extended)

//9000DDNS Config (NET_DVR_DDNSPARA_V30)
#define NET_DVR_GET_DDNSCFG_V30                1010     //Get DDNS  (9000Extended)
#define NET_DVR_SET_DDNSCFG_V30                1011     //Set DDNS  (9000Extended)

//EMAIL  (NET_DVR_EMAILCFG_V30)
#define NET_DVR_GET_EMAILCFG_V30            1012     //Get EMAIL Configuration
#define NET_DVR_SET_EMAILCFG_V30            1013     //Set EMAIL Configuration

#define NET_DVR_GET_NETCFG_V50     1015    //Get network parameter configuration (V50)
#define NET_DVR_SET_NETCFG_V50     1016    //Set network parameter configuration (V50)

#define NET_GET_CRUISEPOINT_V40                1018     //Get CruisePoint V40

//Cruise  (NET_DVR_CRUISE_PARA)
#define NET_DVR_GET_CRUISE                    1020
#define NET_DVR_SET_CRUISE                    1021


//Alarm input   (NET_DVR_ALARMINCFG_V30)
#define NET_DVR_GET_ALARMINCFG_V30            1024
#define NET_DVR_SET_ALARMINCFG_V30            1025

//Alarm output   (NET_DVR_ALARMOUTCFG_V30)
#define NET_DVR_GET_ALARMOUTCFG_V30            1026
#define NET_DVR_SET_ALARMOUTCFG_V30            1027

//Video output   (NET_DVR_VIDEOOUT_V30)
#define NET_DVR_GET_VIDEOOUTCFG_V30            1028
#define NET_DVR_SET_VIDEOOUTCFG_V30            1029

//OSD   (NET_DVR_SHOWSTRING_V30)
#define NET_DVR_GET_SHOWSTRING_V30            1030
#define NET_DVR_SET_SHOWSTRING_V30            1031

//Exception   (NET_DVR_EXCEPTION_V30)
#define NET_DVR_GET_EXCEPTIONCFG_V30        1034
#define NET_DVR_SET_EXCEPTIONCFG_V30        1035

//RS232   (NET_DVR_RS232CFG_V30)
#define NET_DVR_GET_RS232CFG_V30            1036
#define NET_DVR_SET_RS232CFG_V30            1037

//Structure of Setting Network Hard Disk Drive   (NET_DVR_NET_DISKCFG struct)
#define    NET_DVR_GET_NET_DISKCFG                1038        //Get the configuration of Network Hard Disk Drive
#define    NET_DVR_SET_NET_DISKCFG                1039        //Set the configuration of Configuring Network Hard Disk Drive


//Encoding   (NET_DVR_COMPRESSIONCFG_V30)
#define NET_DVR_GET_COMPRESSCFG_V30            1040
#define NET_DVR_SET_COMPRESSCFG_V30            1041

//RS485   (NET_DVR_DECODERCFG_V30)
#define NET_DVR_GET_DECODERCFG_V30            1042        //Get Decoder Parameters
#define NET_DVR_SET_DECODERCFG_V30            1043        //Set Decoder parameters

//Preview   (NET_DVR_PREVIEWCFG_V30)
#define NET_DVR_GET_PREVIEWCFG_V30            1044        //Get Preview Parameters
#define NET_DVR_SET_PREVIEWCFG_V30            1045        //Set Preview Parameters

//AUX Preview  (NET_DVR_PREVIEWCFG_AUX_V30)
#define NET_DVR_GET_PREVIEWCFG_AUX_V30        1046        //Get AUX Preview Parameters
#define NET_DVR_SET_PREVIEWCFG_AUX_V30        1047        //Set AUX Preview Parameters

//IP Channel Configuration  (NET_DVR_IPPARACFG)
#define NET_DVR_GET_IPPARACFG                1048        //Get IP Channel Configuration info
#define NET_DVR_SET_IPPARACFG                1049        //Set IP Channel Configuration info

//IP Alarm In Configuration  (NET_DVR_IPALARMINCFG)
#define NET_DVR_GET_IPALARMINCFG            1050        //Get IP Alarm In Configuration info
#define NET_DVR_SET_IPALARMINCFG            1051        //Set IP Alarm In Configuration info

//IP Alarm Out Configuration  (NET_DVR_IPALARMOUTCFG)
#define NET_DVR_GET_IPALARMOUTCFG            1052        //Get IP Alarm Out Configuration info
#define NET_DVR_SET_IPALARMOUTCFG            1053        //Set IP Alarm Out Configuration info

//HD management Configuration  (NET_DVR_HDCFG)
#define NET_DVR_GET_HDCFG                    1054        //Get HD management Configuration
#define NET_DVR_SET_HDCFG                    1055        //Get HD management Configuration

//HD Group Configuration  (NET_DVR_HDGROUP_CFG)
#define NET_DVR_GET_HDGROUP_CFG                1056        //Get HD Group Configuration Parameters
#define NET_DVR_SET_HDGROUP_CFG                1057        //Set HD Group Configuration Parameters

//Device AudioTalk Configuration (NET_DVR_COMPRESSION_AUDIO)
#define NET_DVR_GET_COMPRESSCFG_AUD            1058        //Get AudioTalk Configuration Parameters
#define NET_DVR_SET_COMPRESSCFG_AUD            1059        //Set AudioTalk Configuration Parameters

//2008- 08- 25
//IP Camera parameter (NET_DVR_IPPARACFG_V31 struct)
#define NET_DVR_GET_IPPARACFG_V31            1060        //Get IP device parameter
#define NET_DVR_SET_IPPARACFG_V31            1061        //Set IP device parameter

//Channel resource configuration(NET_DVR_IPPARACFG_V40 structure)
#define NET_DVR_GET_IPPARACFG_V40            1062        // Get IP device parameter V40
#define NET_DVR_SET_IPPARACFG_V40            1063        // Set IP device parameter V40



//2009- 10- 26 snap device begin

#define NET_DVR_GET_CCDPARAMCFG              1067       //Get IPC CCD parameters
#define NET_DVR_SET_CCDPARAMCFG              1068       //Set IPC CCD parameters

#define NET_DVR_GET_IOINCFG                     1070       //Get I0 input parameters
#define NET_DVR_SET_IOINCFG                     1071        //Set IO input parameters

#define NET_DVR_GET_IOOUTCFG                 1072       //Get I0 output parameters
#define NET_DVR_SET_IOOUTCFG                 1073        //Set IP output parameters

#define NET_DVR_GET_FLASHCFG                 1074       //Get io flash parameters
#define NET_DVR_SET_FLASHCFG                 1075        //Set io flash parameters

#define NET_DVR_GET_LIGHTSNAPCFG             1076       //Get light parameters
#define NET_DVR_SET_LIGHTSNAPCFG             1077        //Set light parameters

#define NET_DVR_GET_MEASURESPEEDCFG             1078       //Get measure speed parameters
#define NET_DVR_SET_MEASURESPEEDCFG             1079        //Set measure speed parameters

#define NET_DVR_GET_IMAGEOVERLAYCFG             1080       //Get image overlay parameters
#define NET_DVR_SET_IMAGEOVERLAYCFG             1081       //Set image overlay parameters

#define NET_DVR_GET_SNAPCFG                     1082       //Get single IO parameters
#define NET_DVR_SET_SNAPCFG                     1083       //Set single IO parameters

#define NET_DVR_GET_VTPPARAM                 1084       //Get virtual circuit parameters
#define NET_DVR_SET_VTPPARAM                 1085       //Set virtual circuit parameters

#define NET_DVR_GET_SNAPENABLECFG             1086       //Get snap enable parameters
#define NET_DVR_SET_SNAPENABLECFG             1087       //Set snap enable parameters

#define NET_DVR_GET_POSTEPOLICECFG           1088       //Get police parameters
#define NET_DVR_SET_POSTEPOLICECFG           1089       //Set police parameters

#define NET_DVR_GET_JPEGCFG_V30                 1090        //Get JPEG parameters
#define NET_DVR_SET_JPEGCFG_V30                 1091        //Set JPEG parameters

#define NET_DVR_GET_SPRCFG                     1092       //Get configuration of license plate recognition
#define NET_DVR_SET_SPRCFG                     1093       //Set configuration of license plate recognition

#define NET_DVR_GET_PLCCFG                   1094       //Get brightness compensation configuration of license plate
#define NET_DVR_SET_PLCCFG                   1095       //Set brightness compensation configuration of license plate

#define NET_DVR_GET_DEVICESTATECFG           1096       //Get current status of device
#define NET_DVR_SET_CALIBRATE_TIME           1097       //Set calibrate time
#define NET_DVR_GET_CALIBRATE_TIME           1098       //Get calibrate time

#define NET_DVR_GET_DEVICECFG_V40             1100       //Get extended device parameters
#define NET_DVR_SET_DEVICECFG_V40             1101       //Set extended device parameters

#define NET_DVR_GET_ZEROCHANCFG              1102        //Get Zero channel compression parameters
#define NET_DVR_SET_ZEROCHANCFG               1103        //Set Zero channel compression parameters

#define NET_DVR_GET_ZERO_PREVIEWCFG_V30      1104       //Get Zero channel live view parameters
#define NET_DVR_SET_ZERO_PREVIEWCFG_V30      1105       //Set Zero channel live view parameters


#define NET_DVR_SET_ZERO_ZOOM                 1106       //Set Zero channel zoom configuration
#define NET_DVR_GET_ZERO_ZOOM                 1107       //Get Zero channel zoom configuration

//2010- 04- 13 Add NAT configuration
#define    NET_DVR_NATASSOCIATECFG_GET          1110       //Get NAT function configuration info
#define    NET_DVR_NATASSOCIATECFG_SET             1111       //Set NAT function configuration info

#define NET_DVR_GET_SNMPCFG                    1112       //Get SNMP parameters
#define NET_DVR_SET_SNMPCFG                   1113       //Set SNMP parameters

#define NET_DVR_GET_SNMPCFG_V30                1114        //Get SNMPv30 parameters
#define NET_DVR_SET_SNMPCFG_V30               1115        //Set SNMPv30 parameters

//2010- 06- 01 Video Management System alarm configuration
#define    NET_DVR_VIDEOPLATFORMALARMCFG_GET      1130       //Get Video Management System alarm configuration
#define    NET_DVR_VIDEOPLATFORMALARMCFG_SET     1131       //Set Video Management System alarm configuration

#define NET_DVR_GET_RAID_ADAPTER_INFO        1134       //Get RAID adapter's information
#define NET_DVR_SET_RAID_ADAPTER_INFO        1135       //Get adapter information
//Big Screen Splice
#define    NET_DVR_MATRIX_BIGSCREENCFG_GET         1140       //Get Parameter
#define    NET_DVR_MATRIX_BIGSCREENCFG_SET         1141        //Set Parameter

#define NET_DVR_GET_MB_PLATFORMPARA             1145        //Get platform parameter
#define NET_DVR_SET_MB_PLATFORMPARA             1146        //Set platform parameter
#define NET_DVR_GET_MB_DEVSTATUS             1147        //Get mobile device status

#define  NET_DVR_GET_DECODER_JOINT_CHAN         1151
#define  NET_DVR_SET_DECODER_JOINT_CHAN         1152
//Multi network card parameter
#define NET_DVR_GET_NETCFG_MULTI             1161        //Get multi network card parameter
#define NET_DVR_SET_NETCFG_MULTI             1162        //Set multi network card parameter
#define NET_DVR_GET_NETCFG_MULTI_V50         1163        //Get multi network card parameter\A3\A8group\A3\A9
#define NET_DVR_SET_NETCFG_MULTI_V50         1164        //Set multi network card parameter\A3\A8group\A3\A9

#define NET_DVR_GET_CMSPARA                     1170       //Get CMS CFG
#define NET_DVR_SET_CMSPARA                     1171       //Set CMS CFG
#define NET_DVR_GET_DIALSTATUS                 1172       //Get Dial Status
#define NET_DVR_GET_SMSRELATIVEPARA             1173       //Get SMS Relative CFG
#define NET_DVR_SET_SMSRELATIVEPARA             1174       //Set SMS Relative CFG
#define NET_DVR_GET_PINSTATUS                 1175       //Get Pin Status
#define NET_DVR_SET_PINCMD                     1176       //Set PIN CMD

#define NET_DVR_SET_SENSOR_CFG                 1180       //Set sensor parameter
#define NET_DVR_GET_SENSOR_CFG                 1181       //Get sensor parameter
#define NET_DVR_SET_ALARMIN_PARAM             1182        //Set alarm input parameter
#define NET_DVR_GET_ALARMIN_PARAM             1183        //Get alarm input parameter
#define NET_DVR_SET_ALARMOUT_PARAM             1184        //Set alarm output parameter
#define NET_DVR_GET_ALARMOUT_PARAM             1185        //Get alarm output parameter
#define NET_DVR_SET_SIREN_PARAM                 1186        //Set siren parameter
#define NET_DVR_GET_SIREN_PARAM                 1187        //Get siren parameter
#define NET_DVR_SET_ALARM_RS485CFG             1188        //Set alarm host RS-485 parameter
#define NET_DVR_GET_ALARM_RS485CFG             1189        //Get alarm host RS-485 parameter
#define NET_DVR_GET_ALARMHOST_MAIN_STATUS     1190        //Get alarm host main status
#define NET_DVR_GET_ALARMHOST_OTHER_STATUS     1191        //Get alarm host other status
#define NET_DVR_SET_ALARMHOST_ENABLECFG         1192        //Set alarm host enable status
#define NET_DVR_GET_ALARMHOST_ENABLECFG         1193        //Get alarm host enable status
#define NET_DVR_SET_ALARM_CAMCFG             1194        //Set configation of video integrated platform alarm triggering CAM operation
#define NET_DVR_GET_ALARM_CAMCFG             1195        //Get configation of video integrated platform alarm triggering CAM operation
#define NET_DVR_GET_GATEWAY_CFG              1196       //Get gateway configuration
#define NET_DVR_SET_GATEWAY_CFG              1197       //Set gateway configuration
#define NET_DVR_GET_ALARMDIALMODECFG         1198        //Get alarm dial parameter
#define NET_DVR_SET_ALARMDIALMODECFG         1199        //Set alarm dial parameter

#define    NET_DVR_SET_WINCFG                        1202//set windows cfg

#define NET_DVR_GET_ALARMHOSTDIALSETUPMODE     1204        //Get alarm dial setup mode
#define NET_DVR_SET_ALARMHOSTDIALSETUPMODE     1205        //Set alarm dial setup mode

//video alarm host V1.3
#define NET_DVR_SET_SUBSYSTEM_ALARM             1210        //Set system alarm
#define NET_DVR_GET_SUBSYSTEM_ALARM             1211        //get system alarm
#define NET_DVR_GET_WHITELIST_ALARM             1215        //set whitelist alarm
#define NET_DVR_SET_WHITELIST_ALARM             1216        //get whitelist alarm
#define    NET_DVR_GET_ALARMHOST_MODULE_LIST     1222        //get All module
#define NET_DVR_SET_PRIOR_ALARM                 1223        //set prior alarm
#define NET_DVR_GET_PRIOR_ALARM                 1224        //set prior alarm
#define NET_DVR_SET_TAMPER_ALARMIN_PARAM     1225        // set tamper alarm in param
#define NET_DVR_GET_TAMPER_ALARMIN_PARAM     1226        // get tamper alarm in param

#define NET_DVR_GET_HOLIDAY_PARAM_CFG        1240       //Get holiday parameter
#define NET_DVR_SET_HOLIDAY_PARAM_CFG        1241       //Set holiday parameter

#define NET_DVR_GET_MOTION_HOLIDAY_HANDLE    1242       //Get holiday alarm handling mode of motion detection
#define NET_DVR_SET_MOTION_HOLIDAY_HANDLE    1243       //Set holiday alarm handling mode of motion detection

#define NET_DVR_GET_VILOST_HOLIDAY_HANDLE    1244       //Get holiday alarm handling mode of video signal lost
#define NET_DVR_SET_VILOST_HOLIDAY_HANDLE    1245       //Set holiday alarm handling mode of video signal lost

#define NET_DVR_GET_HIDE_HOLIDAY_HANDLE      1246       //Get holiday alarm handling mode of video tampering
#define NET_DVR_SET_HIDE_HOLIDAY_HANDLE      1247       //Set holiday alarm handling mode of video tampering

#define NET_DVR_GET_ALARMIN_HOLIDAY_HANDLE   1248       //Get holiday alarm handling mode of alarm input
#define NET_DVR_SET_ALARMIN_HOLIDAY_HANDLE   1249       //Set holiday alarm handling mode of alarm input

#define NET_DVR_GET_ALARMOUT_HOLIDAY_HANDLE  1250       //Get holiday alarm handling mode of alarm output
#define NET_DVR_SET_ALARMOUT_HOLIDAY_HANDLE  1251       //Set holiday alarm handling mode of alarm output

#define NET_DVR_GET_HOLIDAY_RECORD           1252       //Get holiday recording parameter
#define NET_DVR_SET_HOLIDAY_RECORD           1253       //Set holiday recording parameter

#define NET_DVR_GET_NETWORK_BONDING          1254       //Get BONDING network card parameter
#define NET_DVR_SET_NETWORK_BONDING          1255       //Set BONDING network card parameter

#define NET_DVR_GET_LINK_STATUS              1256       //Get link status of channel

#define NET_DVR_GET_DISK_QUOTA_CFG           1278       //Get disk quota configuration
#define NET_DVR_SET_DISK_QUOTA_CFG           1279       //Set disk quota configuration

#define NET_DVR_GET_JPEG_CAPTURE_CFG         1280       //Get capture configuration
#define NET_DVR_SET_JPEG_CAPTURE_CFG         1281       //Set capture configuration

#define NET_DVR_GET_SCHED_CAPTURECFG         1282       //Get capture schedule configuration
#define NET_DVR_SET_SCHED_CAPTURECFG         1283       //Set capture schedule configuration

#define NET_DVR_GET_VGA_PREVIEWCFG           1284       //Get VGA preview configuration
#define NET_DVR_SET_VGA_PREVIEWCFG           1285       //Set VGA preview configuration

#define NET_DVR_GET_VIDEO_INPUT_EFFECT       1286       //Get the video effect
#define NET_DVR_SET_VIDEO_INPUT_EFFECT       1287       //Set the video effect

#define NET_DVR_GET_STORAGE_SERVER_SWITCH     1290       //Get Storage Server Switch
#define NET_DVR_SET_STORAGE_SERVER_SWITCH     1291       //Set Storage Server Switch

#define NET_DVR_GET_OPTICAL_CHANNEL             1300        //Get coder subsystem optical channel relation
#define NET_DVR_SET_OPTICAL_CHANNEL             1301        //Set coder subsystem optical channel relation
#define NET_DVR_GET_FIBER_CASCADE             1302        //Get fiber cascade mode
#define NET_DVR_SET_FIBER_CASCADE             1303        //Set fiber cascade mode
#define NET_DVR_GET_SPARTAN_STATUS             1304        //Get spatan status
#define NET_DVR_SET_SPARTAN_STATUS             1305        //Set spatan status
#define NET_DVR_GET_ETHERNET_CHANNEL         1306        //Get ethernet channel configuration
#define NET_DVR_SET_ETHERMET_CHANNEL         1307        //Set ethernet channel configuration
#define NET_DVR_OPTICAL_REBOOT                 1320        //Reboot optical transceiver
#define NET_DVR_SET_AUDIOCHAN_CFG            1321        //set audio switch configuration
#define NET_DVR_GET_AUDIOCHAN_CFG            1322        //get audio switch configuration

//SDI1.0
#define NET_DVR_SET_MATRIX_BASE_CFG             1332     //set SDI matrix base config
#define NET_DVR_GET_MATRIX_BASE_CFG             1333     //get SDI matrix base config
#define NET_DVR_SWITCH_MATRIX_IO                1334     //switch matrix the relation of input and ouput
#define NET_DVR_GET_MATRIX_IO_RELATION          1335     //get matrix IO relation

#define    NET_DVR_V6PSUBSYSTEMARAM_GET         1501        //get V6 subsystem config
#define    NET_DVR_V6PSUBSYSTEMARAM_SET         1502        //set V6 subsystem config
#define    NET_DVR_GET_ALLWINCFG                 1503        //get screen window information
#define    NET_DVR_BIGSCREENASSOCIATECFG_GET     1511 //get big screen associate information
#define    NET_DVR_BIGSCREENASSOCIATECFG_SET     1512 //et big screen associate information

#define    NET_DVR_GETSCREENINFO                 1601        //Get big screen information
#define    NET_DVR_SETSCREENINFO                 1602        //Set big screen information
#define    NET_DVR_GET_SCREEN_WINCFG             1603        //Get single window parameter
#define    NET_DVR_LAYOUTLIST_GET                  1605        //Get layout list
#define    NET_DVR_SET_LAYOUTCFG                 1606        //Set layout
#define    NET_DVR_LAYOUTCTRL                     1607        //Layout control\A3\AC1-open\A3\AC2-close
#define    NET_DVR_INPUTLIST_GET                 1608        //Get signal source list
#define    NET_DVR_SET_INPUTSTREAMCFG             1609        //Set signal source
#define    NET_DVR_OUTPUT_SET                     1610        //Set output parameter
#define    NET_DVR_OUTPUT_GET                     1611        //Get output parameter
//2011-11-2
#define    NET_DVR_SET_OSDCFG                     1612        //Set OSD parameter
#define    NET_DVR_GET_OSDCFG                     1613        //Get OSD parameter
#define    NET_DVR_BIGSCREEN_GETSERIAL             1614        //Get serial information
#define    NET_DVR_GET_PLANLIST                1615        //get plan list
#define    NET_DVR_SET_PLAN                    1616        //set plan
#define    NET_DVR_CTRL_PLAN                    1617        //control plan
#define    NET_DVR_GET_DEVICE_RUN_STATUS        1618        //get the running status of the device
#define NET_DVR_GET_EXTERNAL_MATRIX_CFG        1619        //get matrix config
#define    NET_DVR_SET_EXTERNAL_MATRIX_CFG        1620        //set matrix config
#define    NET_DVR_GET_OUTPUT_SCREEN_RELATION    1621        //get the relation of screen and output channel
#define    NET_DVR_SET_OUTPUT_SCREEN_RELATION    1622        //set the relation of screen and output channel
#define NET_DVR_GET_VCS_USER_CFG            1623        //get user config
#define    NET_DVR_SET_VCS_USER_CFG            1624        //set user config
#define    NET_DVR_CONTROL_SCREEN                1625        //control screen
/********************************dvcs begin****************************/
/*1650~1700*/
#define NET_DVR_GET_DEV_BASEINFO             1650        // get single sub device base information
#define NET_DVR_SET_DEV_BASEINFO             1651        // set single sub device base information
#define NET_DVR_GET_DEV_NETINFO                 1652        // get single sub device net information
#define NET_DVR_SET_DEV_NETINFO                 1653        // set single sub device net information
#define NET_DVR_GET_SIGNAL_SOURCE_INFO         1654        // get signal source information
#define NET_DVR_SET_SIGNAL_SOURCE_INFO         1655        // set signal source information
#define NET_DVR_ADJUST_PIC_V40                 1656        // adjust picture
#define NET_DVR_RESTORE_V40                     1657        // restore default
#define    NET_DVR_SET_NET_SIGNAL                 1658        // set net signal
#define NET_DVR_REBOOT_V40                     1659        // reboot
#define NET_DVR_CONTROL_PICTURE_V41             1660        // control picture
#define NET_DVR_GET_AUTO_REBOOT_CFG          1710       // get auto reboot config
#define NET_DVR_SET_AUTO_REBOOT_CFG          1711       // set auto reboot config


#define     NET_DVR_GET_TRUNK_USE_STATE     1713    //Get trunk use state
#define     NET_DVR_SET_PTZ_CTRL_INFO         1714    //Set PTZ control information
#define     NET_DVR_GET_PTZ_CTRL_INFO         1715    //Get PTZ control information
#define     NET_DVR_GET_PTZ_STATUS             1716    //Get PTZ status
#define        NET_DVR_GET_DISP_ROUTE_LIST        1717    //Get disp route list

#define NET_DVR_GET_DEC_RESOURCE_LIST			1720//get available decode resource list
#define NET_DVR_SET_DEC_RESOURCE_LIST			1721//pre alloc decode resource
#define NET_DVR_GET_DEC_YUV						1722//get decode channel relate YUV
#define NET_DVR_SET_DEC_YUV						1723//set  decode channel relate YUV
#define NET_DVR_GET_DEC_RESOUCE					1724//apply decode resource
#define NET_DVR_FREE_DEC_RESOURCE				1725//release decode resource

#define NET_DVR_SET_VIDEOWALLDISPLAYMODE        1730    //set video wall display mode
#define NET_DVR_GET_VIDEOWALLDISPLAYMODE        1731    //get video wall display mode
#define NET_DVR_GET_VIDEOWALLDISPLAYNO          1732    //get No. of video wall display channels
#define    NET_DVR_SET_VIDEOWALLDISPLAYPOSITION    1733    //set the position of each display channel
#define    NET_DVR_GET_VIDEOWALLDISPLAYPOSITION    1734    //get the position of each display channel
#define NET_DVR_GET_VIDEOWALLWINDOWPOSITION     1735    //get the position of each window on the video wall
#define NET_DVR_SET_VIDEOWALLWINDOWPOSITION     1736    //set the position of each window on the video wall
#define    NET_DVR_VIDEOWALLWINDOW_CLOSEALL        1737    //close all windows on the video wall
#define    NET_DVR_SET_VIRTUALLED                    1738    //set virtual led config
#define    NET_DVR_GET_VIRTUALLED                    1739    //get virtual led config
#define NET_DVR_GET_IMAGE_CUT_MODE              1740    //get the mode of image cut
#define NET_DVR_SET_IMAGE_CUT_MODE              1741    //set the mode of image cut
#define NET_DVR_GET_USING_SERIALPORT            1742    //get current using serial port
#define NET_DVR_SET_USING_SERIALPORT            1743    //set current using serial port
#define NET_DVR_SCENE_CONTROL                   1744    //scene control
#define NET_DVR_GET_CURRENT_SCENE               1745    //get current scene
#define NET_DVR_GET_VW_SCENE_PARAM              1746    //get video wall scene parameter
#define NET_DVR_SET_VW_SCENE_PARAM              1747    //set video wall scene parameter
#define NET_DVR_DISPLAY_CHANNO_CONTROL          1748    //display channel No. display control
#define NET_DVR_GET_WIN_DEC_INFO                1749    //get window decode information
#define NET_DVR_RESET_VIDEOWALLDISPLAYPOSITION  1750  //Cancel the TV wall output interface binding
#define NET_DVR_SET_VW_AUDIO_CFG                1752    //set audio configure
#define    NET_DVR_GET_VW_AUDIO_CFG                1753    //get audio configure
#define NET_DVR_GET_GBT28181_DECCHANINFO_CFG    1754    //get decode channel information in the device using GBT28181 protocol
#define NET_DVR_SET_GBT28181_DECCHANINFO_CFG    1755    //set decode channel information in the device using GBT28181 protocol
#define    NET_DVR_SET_MAINBOARD_SERIAL            1756    //set main board serial parameter
#define    NET_DVR_GET_MAINBOARD_SERIAL            1757    //get main board serial parameter
#define NET_DVR_GET_SUBBOARD_INFO               1758    //get sub board information
#define NET_DVR_GET_SUBBOARD_EXCEPTION          1759    //get exception sub board information

#define NET_DVR_GET_CAMERACHAN_SERIALCFG        1760   //get Camera related serial port configuration
#define NET_DVR_SET_CAMERACHAN_SERIALCFG        1761   //set Camera related serial port configuration
#define NET_DVR_GET_MATRIX_STATUS                1762   //get matrix status
#define    NET_SET_MULTIFUNCTION_SERIALCFG         1763   //set multi function serial port configuration
#define    NET_GET_MULTIFUNCTION_SERIALCFG            1764   //get multi function serial port configuration
#define NET_DVR_PTZ_3D_SPEED                    1765   //3D PTZ control with speed

#define NET_DVR_GET_SIGNAL_JOINT                1766   //get signal joint configuration
#define NET_DVR_SET_SIGNAL_JOINT                1767   //set signal joint configuration
#define NET_DVR_SIGNAL_CUT                        1768   //cut signal
#define NET_DVR_DYNAMIC_DECODE_BATCH            1769   //start batch dynamic decode
#define NET_DVR_DECSWITCH_SET_BATCH                1770   //batch decode switch set
#define NET_DVR_DECSWITCH_GET_BATCH                1771   //batch decode switch get
#define NET_DVR_GET_ALL_SIGNAL_JOINT            1772   //get all joint signal configuration
#define    NET_DVR_GET_PLAYING_PLAN                1773   //get current playing plan No.
#define NET_DVR_WALL_RELATION_GET                1774   //get device wall and real wall relation configuration
#define NET_DVR_WALL_RELATION_SET                1775   //set device wall and real wall relation configuration
#define    NET_DVR_SET_INPUTSTREAMCFG_V40            1776   //set input signal configuration
#define NET_DVR_PTZCFG_INPUTSTREAM_GET            1777   //get input signal PTZ configuration
#define NET_DVR_PTZCFG_INPUTSTREAM_SET            1778   //set input signal PTZ configuration
#define NET_DVR_SIGNAL_CUTPARAM_GET                1779   //get input signal cut parameter

#define NET_DVR_GET_SUBSYSTEM_NETCFG            1780    // Get Subsystem netcard parameter
#define NET_DVR_SET_SUBSYSTEM_NETCFG              1781    // Set Subsystem netcard parameter
#define    NET_DVR_DEL_SIGNAL_JOINT                1782    //delete joint signal

#define NET_DVR_GET_PICTURE_INFO				1783     //get picture information
#define NET_DVR_SET_PICTURE_INFO				1784     //set picture information
#define NET_DVR_GET_VIDEO_INFO					1785     //get video information
#define NET_DVR_SET_VIDEO_INFO					1786     //set video information
#define NET_DVR_SET_PLAYLIST					1787     //set play list
#define NET_DVR_GET_PLAYLIST					1788     //get play list
#define NET_DVR_GET_ALL_PLAYLIST				1789     //get all play list
#define NET_DVR_PLAYITEM_CONTROL				1790     //play item control
#define NET_DVR_SET_PLAYPLAN_TEMPLATE			1791     //set play plan
#define NET_DVR_GET_PLAYPLAN_TEMPLATE			1792     //get play plan
#define NET_DVR_GET_ALL_PLAYPLAN_TEMPLATE		1793	 //get all play plan
#define NET_DVR_SET_WINDOW_PLAYPLAN				1794     //set window's play plan
#define NET_DVR_GET_WINDOW_PLAYPLAN				1795     //get window's play plan
#define NET_DVR_TOPLAY_ITEM						1796     //assign play item
#define NET_DVR_DEVICE_PLAY_CONTROL				1797     //paly control
#define NET_DVR_GET_PLAY_INFO					1798     //get current play information
#define NET_DVR_GET_ALL_PICTURE_INFO			1799     //get all pictures's information
#define NET_DVR_GET_ALL_VIDEO_INFO				1800     //get all videos's information
#define NET_DVR_DELETE_VIDEO_FILE				1801     //delete video file

#define NET_DVR_GET_ALARMHOSTSUBSYSTEM_CFG	 2001		//	Get alarm subsystem
#define NET_DVR_SET_ALARMHOSTSUBSYSTEM_CFG	 2002		//	Set alarm subsystem
#define NET_DVR_GETEXTENDALARMININFO    	 2003		//	Get alarm info
#define NET_DVR_MODIFYALARMINNO 	         2004		//	mod alarm info

#define NET_DVR_GET_ALARMHOST_WIRELESS_NETWORK_CFG         2005        // Get GPRS info
#define    NET_DVR_SET_ALARMHOST_WIRELESS_NETWORK_CFG         2006        // Set GPRS info
#define    NET_DVR_GET_ALARMHOST_NETCFG         2007        // Get Net info
#define    NET_DVR_SET_ALARMHOST_NETCFG         2008        // Set Net info

#define     NET_DVR_GET_LED_SCREEN_CFG        2009    // Get LED Parameter
#define     NET_DVR_SET_LED_SCREEN_CFG        2010    // Set LED Parameter
#define     NET_DVR_GET_LED_CONTENT_CFG        2011    // Get LED Content
#define        NET_DVR_SET_LED_CONTENT_CFG        2012    // Set LED Content
#define     NET_DVR_TURNON_LED                2013    // turn on LED
#define     NET_DVR_TURNOFF_LED                2014    // turn off LED
#define     NET_DVR_GET_LED_TIMER_SWITCH    2015    // Get LED timer switch
#define     NET_DVR_SET_LED_TIMER_SWITCH    2016    // Set LED timer switch
#define     NET_DVR_SET_LED_BRIGHTNESS        2017    // set LED brightness
#define     NET_DVR_GET_LED_TIMER_BRIGHTNESS 2018    // set timer brightness
#define     NET_DVR_SET_LED_TIMER_BRIGHTNESS 2019    // get timer brightness
#define     NET_DVR_LED_CHECKTIME            2020    // LED checktime

//2009-2020\A3\AC2023 use for DS-19C08-JN V2.0
#define     NET_DVR_GET_ALARMHOST_AUDIO_ASSOCIATE_ALARM        2021 //Get audio associate alarm
#define     NET_DVR_SET_ALARMHOST_AUDIO_ASSOCIATE_ALARM        2022 //set audio associate alarm

#define        NET_DVR_GET_LED_STATUS            2023        //get LED status

#define NET_DVR_CLOSE_SUBSYSTEM_FAULT_ALARM        2027       // Close subsystem fault alarm
#define NET_DVR_SET_SUBSYSTEM_BYPASS            2028       // subsystem bypass
#define NET_DVR_CANCEL_SUBSYSTEM_BYPASS            2029       // subsystem bypass resume

#define  NET_DVR_GET_ALARMHOST_SUBSYSTEM_CFG_EX                2030            //Get subsystem external config parameter
#define     NET_DVR_SET_ALARMHOST_SUBSYSTEM_CFG_EX                2031            //Set subsystem external config parameter
#define  NET_DVR_GET_ALARMHOST_PRINTER_CFG                    2032            //Get Printer config parameter
#define     NET_DVR_SET_ALARMHOST_PRINTER_CFG                    2033            //Set Printer config parameter
#define     NET_DVR_GET_ALARMHOST_ZONE_LIST_IN_SUBSYSTEM        2034            //Get all zones in the subsystem
#define     NET_DVR_GET_ALARMHOST_TRIGGER_LIST                    2035            //Get all the triggers
#define     NET_DVR_ARM_ALARMHOST_SUBSYSTEM                    2036            //subsystem arm and disarm
#define     NET_DVR_GET_ALARMHOST_EVENT_TRIG_ALARMOUT_CFG        2037            //Get event cause alarm out config parameter
#define  NET_DVR_SET_ALARMHOST_EVENT_TRIG_ALARMOUT_CFG        2038            //Set event cause alarm out config parameter
#define     NET_DVR_GET_ALARMHOST_FAULT_CFG                    2039            //Get fault process config parameter
#define  NET_DVR_SET_ALARMHOST_FAULT_CFG                    2040            //Set fault process config parameter
#define  NET_DVR_SEARCH_ARMHOST_EXTERNAL_MODULE             2041            //Auto search
#define     NET_DVR_REGISTER_ALARMHOST_EXTERNAL_MODULE            2042            //Auto register
#define  NET_DVR_CLOSE_ALARMHOST_OVERALL_FAULT_ALARM         2043            //Close Overall fault alarm

#define NET_DVR_GET_SAFETYCABIN_WORK_MODE            2044 //get safety cabin work mode parameter
#define NET_DVR_SET_SAFETYCABIN_WORK_MODE            2045 //set safety cabin work mode parameter
#define NET_DVR_GET_SAFETYCABIN_PERSON_SIGNAL_CFG   2046 //get safety cabin person signal parameter
#define NET_DVR_SET_SAFETYCABIN_PERSON_SIGNAL_CFG   2047 //set safety cabin person signal parameter

#define  NET_DVR_GET_ALARMHOST_MODULE_CFG                    2048            // get module config
//#define  NET_DVR_SET_ALARMHOST_MODULE_CFG                    2049            // set module config

/********************************DS_19DXX v20 begin****************************/
#define     NET_DVR_GET_ALARMHOST_EXTERNAL_DEVICE_STATE        2050        //get external device state
#define  NET_DVR_SET_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE  2051        //set limit value
#define  NET_DVR_GET_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE  2052        //get limit value
#define  NET_DVR_GET_ALARMHOST_SENSOR_JOINT_CFG                2053        // get sensor joint config
#define  NET_DVR_SET_ALARMHOST_SENSOR_JOINT_CFG                2054        // set sensor joint config
#define     NET_DVR_SET_ALARMHOST_RS485_SLOT_CFG                2055        // set slot config
#define  NET_DVR_GET_ALARMHOST_RS485_SLOT_CFG                2056        // get slot config
/********************************DS_19DXX v20  end****************************/

/********************************DS_19DXX 104 protocol begin****************************/
#define NET_DVR_GET_ALL_VARIABLE_INFO      2057   // get all variable info
#define NET_DVR_GET_ALARM_POINT_CFG       2058   // get point config
#define NET_DVR_SET_ALARM_POINT_CFG       2059   // set point config
#define NET_DVR_GET_HISTORY_VALUE          2060   // get history value
#define NET_DVR_GET_ALARMHOST_ALARM_MODE  2061   // get alarm mode
#define NET_DVR_SET_ALARMHOST_ALARM_MODE  2062   // set alarm mode
/********************************DS_19DXX 104 protocol end****************************/

/*************************************DS-19D00-0402BN(0601BN) begin*************************************/
#define NET_DVR_GET_ALARMHOST_SENSOR_VALUE    2063   // get sensor value
/*************************************DS-19D00-0402BN(0601BN) end*************************************/

/*************************************alarm host 2.0 begin*************************************/
#define NET_DVR_GET_ALARMHOST_REPORT_CENTER_V40    2064   // get data report mode v30
#define NET_DVR_SET_ALARMHOST_REPORT_CENTER_V40    2065   // set data report mode v30
#define NET_DVR_GET_OUTPUT_SCHEDULE_RULECFG        2068   // get output schedule rule
#define NET_DVR_SET_OUTPUT_SCHEDULE_RULECFG     2069   // set output schedule rule
/************************************ alarm host2.0 end**************************************/

/*********************************EHOME begin******************************/
#define NET_DVR_GET_CMS_CFG                     2070
#define    NET_DVR_SET_CMS_CFG                        2071
#define NET_DVR_GET_PASSTHROUGH_CAP  2073
/*********************************EHOME end******************************/
#define NET_DVR_GET_ALARMHOST_MAIN_STATUS_V40    2072

/*************************************video alarm host v1.3 begin*************************************/
#define NET_DVR_GET_ALARM_CAPTRUE_CFG                 2074
#define    NET_DVR_SET_ALARM_CAPTRUE_CFG                2075
#define NET_DVR_GET_ONE_OUTPUT_SCH_RULECFG_V40        2078   // get one output schedule rule V40
#define NET_DVR_SET_ONE_OUTPUT_SCH_RULECFG_V40        2079   // set one output schedule rule V40
#define NET_DVR_GET_OUTPUT_SCHEDULE_RULECFG_V40        2080   // get output schedule rule V40
#define NET_DVR_SET_OUTPUT_SCHEDULE_RULECFG_V40     2081   // Set output schedule rule V40
#define  NET_DVR_ALARMHOST_CLOSE_SUBSYSTEM  2082  //close subsystem
/*************************************video alarm host v1.3 end**************************************/

#define NET_DVR_GET_WEEK_PLAN_CFG               2100    //get door status week plan config
#define NET_DVR_SET_WEEK_PLAN_CFG               2101    //set door status week plan config
#define NET_DVR_GET_DOOR_STATUS_HOLIDAY_PLAN    2102    //get door status holiday week plan config
#define NET_DVR_SET_DOOR_STATUS_HOLIDAY_PLAN    2103    //set door status holiday week plan config
#define NET_DVR_GET_DOOR_STATUS_HOLIDAY_GROUP   2104    //get door holiday group parameter
#define NET_DVR_SET_DOOR_STATUS_HOLIDAY_GROUP   2105    //set door holiday group parameter
#define NET_DVR_GET_DOOR_STATUS_PLAN_TEMPLATE   2106    //get door status plan template parameter
#define NET_DVR_SET_DOOR_STATUS_PLAN_TEMPLATE   2107    //set door status plan template parameter
#define NET_DVR_GET_DOOR_CFG                    2108    //get door parameter
#define NET_DVR_SET_DOOR_CFG                    2109    //set door parameter
#define NET_DVR_GET_DOOR_STATUS_PLAN            2110    //get door status plan parameter
#define NET_DVR_SET_DOOR_STATUS_PLAN            2111    //set door status plan parameter
#define NET_DVR_GET_GROUP_CFG                   2112    //get group parameter
#define NET_DVR_SET_GROUP_CFG                   2113    //set group parameter
#define NET_DVR_GET_MULTI_CARD_CFG              2114    //get multi card parameter
#define NET_DVR_SET_MULTI_CARD_CFG              2115    //set multi card parameter
#define NET_DVR_GET_CARD_CFG                    2116    //get card parameter
#define NET_DVR_SET_CARD_CFG                    2117    //set card parameter
#define NET_DVR_CLEAR_ACS_PARAM                    2118    //clear access card parameter
#define NET_DVR_GET_SNEAK_CFG                    2119    //get sneak parameter
#define NET_DVR_SET_SNEAK_CFG                   2120    //set sneak parameter
#define NET_DVR_GET_MULTI_DOOR_INTERLOCK_CFG    2121    //get multi door interlock parameter
#define NET_DVR_SET_MULTI_DOOR_INTERLOCK_CFG    2122    //set multi door interlock parameter
#define NET_DVR_GET_ACS_WORK_STATUS                2123    //get device work status
#define NET_DVR_GET_VERIFY_WEEK_PLAN            2124    //get reader card verfy week plan
#define NET_DVR_SET_VERIFY_WEEK_PLAN            2125    //set reader card verfy week plan
#define NET_DVR_GET_CARD_RIGHT_WEEK_PLAN        2126    //get card right week plan
#define NET_DVR_SET_CARD_RIGHT_WEEK_PLAN        2127    //set card right week plan
#define NET_DVR_GET_VERIFY_HOLIDAY_PLAN         2128    //get card reader verify holiday plan
#define NET_DVR_SET_VERIFY_HOLIDAY_PLAN         2129    //set card reader verify holiday plan
#define NET_DVR_GET_CARD_RIGHT_HOLIDAY_PLAN     2130    //get card right holiday plan
#define NET_DVR_SET_CARD_RIGHT_HOLIDAY_PLAN     2131    //set card right holiday plan
#define NET_DVR_GET_VERIFY_HOLIDAY_GROUP        2132    //get card reader verify holiday group
#define NET_DVR_SET_VERIFY_HOLIDAY_GROUP        2133    //set card reader verify holiday group
#define NET_DVR_GET_CARD_RIGHT_HOLIDAY_GROUP    2134    //get card right holiday group
#define NET_DVR_SET_CARD_RIGHT_HOLIDAY_GROUP    2135    //set card right holiday group
#define NET_DVR_GET_VERIFY_PLAN_TEMPLATE        2136    //get card reader verify plan template
#define NET_DVR_SET_VERIFY_PLAN_TEMPLATE        2137    //set card reader verify plan template
#define NET_DVR_GET_CARD_RIGHT_PLAN_TEMPLATE    2138    //get card right plan template
#define NET_DVR_SET_CARD_RIGHT_PLAN_TEMPLATE    2139    //set card right plan template
#define NET_DVR_GET_CARD_READER_CFG                2140    //get card reader parameter
#define NET_DVR_SET_CARD_READER_CFG             2141    //set card reader parameter
#define NET_DVR_GET_CARD_READER_PLAN            2142    //get card reader verify plan parameter
#define NET_DVR_SET_CARD_READER_PLAN            2143    //set card reader verify plan parameter
#define NET_DVR_GET_CASE_SENSOR_CFG                2144    //get case sensor parameter
#define NET_DVR_SET_CASE_SENSOR_CFG             2145    //set case sensor parameter
#define NET_DVR_GET_CARD_READER_ANTI_SNEAK_CFG  2146    //get card readfer anti sneak parameter
#define NET_DVR_SET_CARD_READER_ANTI_SNEAK_CFG  2147    //set card readfer anti sneak parameter
#define NET_DVR_GET_PHONE_DOOR_RIGHT_CFG        2148    //get phone door right parameter
#define NET_DVR_SET_PHONE_DOOR_RIGHT_CFG        2149    //set phone door right parameter
#define NET_DVR_GET_FINGERPRINT_CFG             2150    //get fingerprint parameter
#define NET_DVR_SET_FINGERPRINT_CFG             2151    //set fingerprint parameter
#define NET_DVR_DEL_FINGERPRINT_CFG             2152    //delete fingerprint parameter
#define NET_DVR_GET_EVENT_CARD_LINKAGE_CFG      2153    //get event card linkage parameter
#define NET_DVR_SET_EVENT_CARD_LINKAGE_CFG      2154    //set event card linkage parameter
#define NET_DVR_GET_ANTI_SNEAK_HOST_CFG            2155    //get anti sneak host parameter
#define NET_DVR_SET_ANTI_SNEAK_HOST_CFG         2156    //set anti sneak host parameter
#define NET_DVR_GET_READER_ANTI_SNEAK_HOST_CFG  2157    //get reader anti sneak host parameter
#define NET_DVR_SET_READER_ANTI_SNEAK_HOST_CFG  2158    //set reader anti sneak host parameter
#define NET_DVR_GET_ACS_CFG                     2159    //get acs parameter
#define NET_DVR_SET_ACS_CFG                     2160    //set acs parameter
#define NET_DVR_GET_CARD_PASSWD_CFG                2161    //get card passwd parameter
#define NET_DVR_SET_CARD_PASSWD_CFG             2162    //set card passwd parameter
#define NET_DVR_GET_CARD_USERINFO_CFG           2163    //get card userinfo cfg
#define NET_DVR_SET_CARD_USERINFO_CFG           2164    //set card userinfo cfg


#define NET_DVR_GET_ACS_EXTERNAL_DEV_CFG        2165   //get ACS external device parameter
#define NET_DVR_SET_ACS_EXTERNAL_DEV_CFG        2166   //set ACS external device parameter
#define NET_DVR_GET_PERSONNEL_CHANNEL_CFG        2167   //get personnel channel parameter
#define NET_DVR_SET_PERSONNEL_CHANNEL_CFG        2168   //set personnel channel parameter
#define NET_DVR_SET_PLATFORM_VERIFY_CFG         2169    //The result issued by platform authentication
#define NET_DVR_GET_PERSON_STATISTICS_CFG        2170   //Get the number of statistical parameters
#define NET_DVR_SET_PERSON_STATISTICS_CFG        2171   //Set the number of statistical parameters
#define NET_DVR_GET_ACS_SCREEN_DISPLAY_CFG        2172   //The screen for the string parameters
#define NET_DVR_SET_ACS_SCREEN_DISPLAY_CFG        2173   //String to use screen display parameters
#define NET_DVR_GET_GATE_TIME_CFG               2174    //Access channel gate time parameter
#define NET_DVR_SET_GATE_TIME_CFG               2175    //Setting up the staff channel gate time parameters
#define NET_DVR_GET_LOCAL_CONTROLLER_STATUS     2176	//Access to on-site controller state
#define NET_DVR_GET_ONLINE_LOCAL_CONTROLLER     2177	//Search online on the controller
#define NET_DVR_GET_CARD_CFG_V50                2178    //Parameters to acquire new CARDS (V50)
#define NET_DVR_SET_CARD_CFG_V50                2179    //Setting up the new parameters (V50)
#define NET_DVR_GET_ACS_WORK_STATUS_V50	        2180    //Access door host working condition (V50)
#define NET_DVR_GET_EVENT_CARD_LINKAGE_CFG_V50  2181    //Get event card number linkage configuration parameters (V50)
#define NET_DVR_SET_EVENT_CARD_LINKAGE_CFG_V50  2182    //Set up the event card number linkage configuration parameters (V50)

#define NET_DVR_GET_SAFETYCABIN_STATE            2197    //get safetycabin state
#define NET_DVR_GET_RS485_CASCADE_CFG            2198    //get Rs485 cascade cfg
#define NET_DVR_SET_RS485_CASCADE_CFG            2199    //set Rs485 cascade cfg

/*************************************video alarm host 2.0 begin*************************************/
#define NET_DVR_GET_REMOTECONTROLLER_PERMISION_CFG        2200    //get remotecontroller Permission config
#define NET_DVR_SET_REMOTECONTROLLER_PERMISION_CFG        2201    //set remotecontroller Permission config
#define NET_DVR_GET_KEYBOARD_CFG                        2202    //get keyborad config
#define NET_DVR_SET_KEYBOARD_CFG                        2203    //set keyborad config
#define    NET_DVR_GET_ALARMHOST_WIRELESS_BUSINNESS_INFO    2204    //wireless service query
#define    NET_DVR_GET_ALL_REMOTECONTROLLER_LIST            2205    //get all remote controller
#define    NET_DVR_GET_PREVIEW_DELAY_CFG                    2206    //get delay preview config
#define    NET_DVR_SET_PREVIEW_DELAY_CFG                    2207    //set delay preview config
#define NET_DVR_GET_ZONE_CHANNEL_LINKAGE_CFG            2208    //get alarm zone linkage channel config
#define NET_DVR_SET_ZONE_CHANNEL_LINKAGE_CFG            2209    //set alarm zone linkage channel config
#define NET_DVR_GET_CENTER_SERVER_CFG                    2210    //get alarm center server config
#define NET_DVR_SET_CENTER_SERVER_CFG                    2211    //set alarm center server config
/*************************************video alarm host 2.0 end*************************************/

/********************************energence alarm product V1.0.0 begin********************************/
#define NET_DVR_GET_EMERGENCE_ALARM_PRODUCT_CAP            2212    //get emergence alarm product ability
#define NET_DVR_GET_CALL_WAITTING_CFG_CAP                2213    //get call waiting configure ability
#define NET_DVR_GET_CALL_WAITTING_CFG                    2214    //get call waiting configure
#define NET_DVR_SET_CALL_WAITTING_CFG                    2215    //set call waiting configure
#define NET_DVR_GET_ALARM_LAMP_CFG_CAP                    2216    //get alarm lamp configure ability
#define NET_DVR_GET_ALARM_LAMP_CFG                        2217    //get alarm lamp configure
#define NET_DVR_SET_ALARM_LAMP_CFG                        2218    //set alarm lamp configure
#define NET_DVR_GET_VOICE_PROMPTION_CFG_CAP                2219    //get voice promption configure ability
#define NET_DVR_GET_VOICE_PROMPTION_CFG                    2220    //get voice promption configure
#define NET_DVR_SET_VOICE_PROMPTION_CFG                    2221    //set voice promption configure
#define NET_DVR_GET_EMERGENCE_ALARM_RESPONSE_CAP        2222    //get emergence alarm response ability
#define NET_DVR_EMERGENCE_ALARM_RESPONSE_CTRL            2223    //emergence alarm response ctrl
/********************************energence alarm product V1.0.0 end**********************************/

//net alarm host V2.2
#define NET_DVR_GET_ALARMHOST_NETCFG_V50                2224    //Get Net infoV50
#define NET_DVR_SET_ALARMHOST_NETCFG_V50                2225    //Set Net info V50
#define    NET_DVR_REGISTER_ALARM_RS485                    2226    //Re-register RS485

#define NET_DVR_GET_ALARMIN_PARAM_LIST					2227	//Get sector parameter list

#define NET_DVR_GET_ALARMHOST_OTHER_STATUS_V50		    2228
#define NET_DVR_GET_ALARMIN_ASSOCIATED_CHAN_LIST		2229

#define NET_DVR_GET_CARD_RIGHT_WEEK_PLAN_V50    2304  //Access card right V50 weeks plan parameters
#define NET_DVR_SET_CARD_RIGHT_WEEK_PLAN_V50    2305  //Set card right V50 weeks plan parameters

#define NET_DVR_GET_CARD_RIGHT_HOLIDAY_PLAN_V50    2310  //Access card right parameters V50 holiday plan
#define NET_DVR_SET_CARD_RIGHT_HOLIDAY_PLAN_V50    2311  //Set card right parameters V50 holiday plan

#define NET_DVR_GET_CARD_RIGHT_HOLIDAY_GROUP_V50      2316 //Access card right parameters V50 holiday group
#define NET_DVR_SET_CARD_RIGHT_HOLIDAY_GROUP_V50      2317 //Set card right parameters V50 holiday group

#define NET_DVR_GET_CARD_RIGHT_PLAN_TEMPLATE_V50     2322 //Access card right parameters V50 plan template
#define NET_DVR_SET_CARD_RIGHT_PLAN_TEMPLATE_V50     2323//Set card right parameters V50 plan template

/******************economical fingerprint access control product V1.0**************************/
#define NET_DVR_GET_SCHEDULE_INFO                       2500	//get schedule info
#define NET_DVR_GET_ATTENDANCE_SUMMARY_INFO             2501	//get attendance summary info
#define NET_DVR_GET_ATTENDANCE_RECORD_INFO              2502	//get attendance record info
#define NET_DVR_GET_ABNORMAL_INFO                       2503	//get abnormal
/******************economical fingerprint access control product V1.0**************************/

/*************************************vide acs integrated machine 1.0 begin**************************************/
#define NET_DVR_CAPTURE_FINGERPRINT_INFO                2504    //capture fingerprint info
/*************************************vide acs integrated machine 1.0 end**************************************/

#define NET_DVR_GET_ALL_ALARM_RS485CFG			2705
#define NET_DVR_GET_ALL_ALARMHOST_RS485_SLOT_CFG		2706
#define NET_DVR_GET_DEVICE_SELF_CHECK_STATE		2707
#define NET_DVR_GET_ALL_ALARM_POINT_CFG			2708
#define NET_DVR_GET_ALL_ALARM_SENSOR_CFG		2709
#define NET_DVR_GET_ALL_ALARM_SENSOR_JOINT		2710
#define NET_DVR_GET_AIR_CONDITION_PARAM			2711
#define NET_DVR_GET_OUT_SCALE_CFG				2712
#define NET_DVR_SET_OUT_SCALE_CFG				2713
#define NET_DVR_GET_ALARM_CHAN_ABLITITY			2714

#define NET_DVR_GET_ALARMCENTER_NETCFG            2715
#define NET_DVR_SET_ALARMCENTER_NETCFG            2716


#define NET_ITC_GET_TRIGGERCFG               3003       //Get trigger configuration
#define NET_ITC_SET_TRIGGERCFG               3004        //Set trigger configuration
#define NET_ITC_GET_IOOUT_PARAM_CFG             3005        //Get io out configuration(3.1)
#define NET_ITC_SET_IOOUT_PARAM_CFG             3006        //Set io out configuration(3.1)
#define NET_DVR_GET_CAMERA_SETUPCFG             3007        //Get the camera Erection Parameters
#define NET_DVR_SET_CAMERA_SETUPCFG             3008        //Set the camera Erection Parameters
#define NET_ITC_GET_TRIGGER_DEFAULTCFG       3013        //Get trigger default configuration
#define NET_DVR_GET_STATUS_DETECTCFG         3015        //Get status detect configuration
#define NET_DVR_SET_STATUS_DETECTCFG         3016        //Set statue detect configuration
#define NET_ITC_GET_VIDEO_TRIGGERCFG         3017        //Get video epolice configuration
#define NET_ITC_SET_VIDEO_TRIGGERCFG         3018        //Set video epolice configuration
#define NET_DVR_GET_TPS_ALARMCFG             3019        //Get traffic statistics alarm parameters
#define NET_DVR_SET_TPS_ALARMCFG             3020        //Set traffic statistics alarm parameters
#define NET_DVR_GET_REDAREACFG               3100        //Get red area configuration
#define NET_DVR_SET_REDAREACFG               3101        //Set red area configuration
#define    NET_DVR_GET_TEST_SPOT                 3102       //Get SPOT port the test total number of steps and the first steps
#define    NET_DVR_SET_TEST_SPOT                 3103       //Set SPOT port the test total number of steps and the first steps
#define NET_DVR_GET_CABINETCFG                 3104       //Get CabinetCfg Param
#define NET_DVR_SET_CABINETCFG                 3105       //Set CabinetCfg Param
#define NET_DVR_VEHICLE_CHECK_START             3106       //black list check data pass back
#define NET_DVR_SET_CAPTUREPIC_CFG             3107        //set capture picture param
#define NET_DVR_GET_CAPTUREPIC_CFG             3108        //get capture picture param
#define NET_DVR_SET_MOBILEPLATE_RECOG_CFG     3109        //set plate recognize parm
#define NET_DVR_GET_MOBILEPLATE_RECOG_CFG     3110        //get plate recognize parm
#define NET_DVR_SET_MOBILE_RADAR_CFG         3111        //set radar configure parm
#define NET_DVR_GET_MOBILE_RADAR_CFG         3112        //get radar configure parm
#define NET_DVR_SET_MOBILE_LOCALPLATECHK_CFG 3113        //set black list compare configure parm
#define NET_DVR_GET_MOBILE_LOCALPLATECHK_CFG 3114        //get black list compare configure parm

#define  NET_ITC_GET_ICRCFG                        3115   //Get ICR Param Cfg
#define  NET_ITC_SET_ICRCFG                        3116   //Set ICR Param Cfg
#define  NET_ITC_GET_RS485_ACCESSINFO            3117   //Get Rs485 Access Info
#define  NET_ITC_SET_RS485_ACCESSINFO            3118   //Set Rs485 Access Info
#define  NET_ITC_GET_EXCEPTIONCFG                 3119   //Get Exception Info Cfg
#define  NET_ITC_SET_EXCEPTIONCFG                3120   //Set Exception Info Cfg
#define  NET_ITC_GET_FTPCFG                        3121   //Get ITC  FTP Param Cfg
#define  NET_ITC_SET_FTPCFG                        3122   //Set ITC  FTP Param Cfg

//2013-11-04 PJ01R2013091201
#define  NET_DVR_VEHICLE_CONTROL_LIST_START     3123   //Vehicle Control List Start
#define  NET_DVR_GET_ALL_VEHICLE_CONTROL_LIST   3124   //Get Vehicle Control List
#define  NET_DVR_VEHICLE_DELINFO_CTRL            3125   //Delete Vehicle Info
#define  NET_DVR_GET_ENTRANCE_PARAMCFG            3126   //Get Entrance Param CFG
#define  NET_DVR_SET_ENTRANCE_PARAMCFG            3127   //Set Entrance Param CFG
#define  NET_DVR_BARRIERGATE_CTRL               3128   //Barrier Gate Ctrl
#define  NET_DVR_GATELAMP_CTRL                  3129   //Gate Lamp
#define  NET_DVR_GET_CURTRIGGERMODE             3130   //Get Cur Trigger Mode
#define  NET_DVR_GET_GPSDATACFG                    3131   //Get GPS Param
#define  NET_DVR_SET_GPSDATACFG                    3132   //Set GPS Param
#define  NET_DVR_VEHICLELIST_CTRL_START            3133   //Start Vehicle List Ctrl

//Capture trigger mode support association Alarm time and Upload Center
#define  NET_DVR_GET_GUARDCFG                   3134   //Get
#define  NET_DVR_SET_GUARDCFG                   3135   //Set

//Snap Picture Info
#define NET_DVR_GET_SNAPINFO_CFG                3136   //Get
#define NET_DVR_SET_SNAPINFO_CFG                3137   //Set

//Snap Picture Info Expansion
#define  NET_DVR_GET_SNAPINFO_CFG_V40           3138   //Get
#define  NET_DVR_SET_SNAPINFO_CFG_V40           3139   //Set

#define  NET_DVR_SET_CURTRIGGERMODE                3140   //Set device Current Trigger Mode (Only IPC/D)
#define     NET_DVR_GET_TRAFFIC_DATA                3141   //Get Traffic Data
#define     NET_DVR_GET_TRAFFIC_FLOW                3142   //Get Traffic Flow
#define  NET_DVR_PARKING_VEHICLE_SEND           3143   //Parking Vehicle Send
#define  NET_DVR_PARKING_CARD_SEND              3144   //Send Parking Card Info
#define     NET_DVR_PARKING_CARD_CTRL                3145    //Parking card control interface

#define    NET_DVR_GET_ALARMCTRL_CAPABILITIES        3146   //Get Alarm Ctrl Capabilties
#define    NET_DVR_SET_ALARMCTRL_CFG                3147   //Set Alarm Ctrl
#define    NET_DVR_GET_ALARMCTRL_CFG                3148   //Get Alarm Ctrl

#define NET_DVR_GET_AUDIO_INPUT              3201        //Get audio in info
#define NET_DVR_SET_AUDIO_INPUT              3202        //Set audio in info
#define NET_DVR_GET_CAMERA_DEHAZE_CFG        3203        //Get fog remove configuration
#define NET_DVR_SET_CAMERA_DEHAZE_CFG        3204        //Set fog remove configuration
#define NET_DVR_REMOTECONTROL_ALARM          3205        //remote control alarm
#define NET_DVR_REMOTECONTROL_DISALARM       3206        //remote control disalarm
#define NET_DVR_REMOTECONTROL_STUDY          3207        //remote control study
#define NET_DVR_WIRELESS_ALARM_STUDY         3208        //wireless alarm study
#define NET_IPC_GET_AUX_ALARMCFG             3209        //get aux alarm configuration
#define NET_IPC_SET_AUX_ALARMCFG             3210        //set aux alarm configuration
#define NET_DVR_GET_PREVIEW_DISPLAYCFG         3211        //Get preview shows the parameters
#define NET_DVR_SET_PREVIEW_DISPLAYCFG         3212        //Set preview shows the parameters
#define NET_DVR_REMOTECONTROL_PTZ            3213       //Remote control of PTZ
#define NET_DVR_REMOTECONTROL_PRESETPOINT    3214       //Remote Control preset point
#define NET_DVR_REMOTECONTROL_CRUISE         3215       //Remote control cruise

#define NET_DVR_GET_MULTI_STREAM_COMPRESSIONCFG  3216    //Get muti stream compressioncfg
#define NET_DVR_SET_MULTI_STREAM_COMPRESSIONCFG  3217    //Set muti stream compressioncfg

#define NET_DVR_GET_WPSCFG                     3218        //Get WPS configuration
#define NET_DVR_SET_WPSCFG                     3219        //Set WPS configuration
#define NET_DVR_WPS_CONNECT                  3220        //WPS connect
#define NET_DVR_GET_DEVICE_PIN               3221        //Get device PIN
#define NET_DVR_UPDATE_PIN                   3223        //Update device PIN
#define NET_DVR_GET_PRESETCFG                3224        //Get preset point parameters
#define NET_DVR_GET_PTZCRUISECFG             3225        //Get cruise path parameters
#define NET_DVR_GET_PRESET_NUM                 3226        //Access to preset point number
#define NET_DVR_GET_PTZCRUISE_NUM             3227        //Access to the cruise path number

#define NET_DVR_GET_MOTION_TRACK_CFG         3228        //Access to track parameters
#define NET_DVR_SET_MOTION_TRACK_CFG         3229        //Set the track parameter
#define NET_DVR_CLEAR_IPC_PARAM                 3230       //To empty the front-end parameters

#define NET_DVR_GET_IPADDR_FILTERCFG         3232        //Get IP address filter
#define NET_DVR_SET_IPADDR_FILTERCFG         3233        //Set IP address filter

#define NET_DVR_GET_LOGO_OVERLAYCFG             3234       //Get LOGO overlay configuration
#define NET_DVR_SET_LOGO_OVERLAYCFG             3235       //Set LOGO overlay configuration
#define NET_DVR_GET_IPV6_LIST                3236        //Get all IPV6 address of the network card information
#define NET_DVR_GET_AUDIOOUT_VOLUME          3237
#define NET_DVR_SET_AUDIOOUT_VOLUME          3238
#define NET_DVR_GET_FUZZY_UPGRADE            3239        //Get fuzzy matching information upgrade
#define NET_DVR_GET_BV_CORRECT_PARAM         3240        //Get the camera calibration parameters
#define NET_DVR_SET_BV_CORRECT_PARAM         3241        //Set the camera calibration parameters
#define NET_DVR_GET_OUTPUT_VIDEO_TYPE        3242        //Get Output Video Type
#define NET_DVR_SET_OUTPUT_VIDEO_TYPE        3243        //Set Output Video Type
#define NET_DVR_FISHEYE_CFG                  3244    //Create long link of fisheye
#define NET_DVR_GET_PTZ_POINT                3245    //Get ptz position
#define NET_DVR_SET_PTZ_POINT                3246    //Set ptz position
#define NET_DVR_REMOTECONTROL_DEV_PARAM      3247    //Set params of the logon device
#define NET_DVR_GET_FISHEYE_STREAM_STATUS    3248    //Get stream status of fisheye

#define NET_DVR_GET_GBT28181_ACCESS_CFG            3249 // Get GBT28181 Protocol Access Cfg
#define NET_DVR_SET_GBT28181_ACCESS_CFG            3250 // Set GBT28181 Protocol Access Cfg
#define NET_DVR_GET_GBT28181_CHANINFO_CFG        3251 // Get GBT28181 Protocol Access Dev Channel Info
#define NET_DVR_SET_GBT28181_CHANINFO_CFG        3252 // Set GBT28181 Protocol Access Dev Channel Info
#define NET_DVR_GET_GBT28181_ALARMINCFG            3253 // Get GBT28181 Protocol Access Alarm Info
#define NET_DVR_SET_GBT28181_ALARMINCFG            3254 // Set GBT28181 Protocol Access Alarm Info
#define NET_DVR_GET_ISP_CAMERAPARAMCFG            3255 // Get ISP Camera Info cfg
#define NET_DVR_SET_ISP_CAMERAPARAMCFG            3256 // Set ISP Camera Info cfg
#define NET_DVR_GET_DEVSERVER_CFG                3257 // Get DevServer cfg
#define NET_DVR_SET_DEVSERVER_CFG                3258 // Set DevServer cfg

//2013-11-25
#define    NET_DVR_GET_WIPERINFO_CFG                3259   //Get Wiper Info
#define    NET_DVR_SET_WIPERINFO_CFG                3260   //Set Wiper Info
#define NET_DVR_GET_TRACK_DEV_PARAM             3261   //Get Track Device Param
#define NET_DVR_SET_TRACK_DEV_PARAM             3262   //Set Track Device Param
#define NET_DVR_GET_PTZ_TRACK_PARAM             3263   //Get PTZ Track Param
#define NET_DVR_SET_PTZ_TRACK_PARAM             3264   //Set PTZ Track Param
#define NET_DVR_GET_CENTER_POINT_CFG            3265   //get center point parameters
#define NET_DVR_SET_CENTER_POINT_CFG            3266   //set center point parameters
#define NET_DVR_GET_CENTER_POINT_CFG_CAPABILITIES        3267    //get center point parameters capabilities
#define NET_DVR_GET_FISHEYE_CAPABILITIES        3268        //get fisheye capabilities

#define NET_DVR_GET_BASICPARAMCFG                3270 //Get the basic parameters of PTZ configuration information
#define NET_DVR_SET_BASICPARAMCFG                3271 //set the basic parameters of PTZ configuration information
#define NET_DVR_GET_PTZOSDCFG                    3272 //get PTZ OSD configuration parameter information
#define NET_DVR_SET_PTZOSDCFG                    3273 //Set PTZ OSD configuration parameter information
#define NET_DVR_GET_POWEROFFMEMCFG                3274 //get power down memory model parameter information
#define NET_DVR_SET_POWEROFFMEMCFG                3275 //set power down memory model parameter information
#define NET_DVR_GET_LIMITCFG                    3276 //get the limiting parameter configuration information
#define NET_DVR_SET_LIMITCFG                    3277 //set the limiting parameter configuration information
#define NET_DVR_PTZLIMIT_CTRL                    3278 //clearance limit parameter control

#define NET_DVR_PTZ_CLEARCTRL                    3279 //clear configuration information control interface
#define NET_DVR_GET_PRIORITIZECFG                3281 //get Haeundae priority configuration information
#define NET_DVR_SET_PRIORITIZECFG                3282 //set Haeundae priority configuration information
#define NET_DVR_PTZ_INITIALPOSITIONCTRL            3283 //zero azimuth control
#define NET_DVR_GET_PRIVACY_MASKSCFG            3285 //get privacy parameter
#define NET_DVR_SET_PRIVACY_MASKSCFG            3286 //set privacy parameter
#define NET_DVR_GET_PTZLOCKCFG                    3287 //get Haeundae lock information
#define NET_DVR_SET_PTZLOCKCFG                    3288 //set Haeundae lock information
#define NET_DVR_PTZ_ZOOMRATIOCTRL                3289 //set the tracking rate
#define NET_DVR_GET_PTZLOCKINFO                    3290 //get Haeundae locking seconds remaining
#define NET_DVR_GET_PRIVACY_MASKS_ENABLECFG        3291 //get the global enable
#define NET_DVR_SET_PRIVACY_MASKS_ENABLECFG        3292 //set the global enable
#define NET_DVR_GET_SMARTTRACKCFG                3293 //get acquisition intelligent motion tracking configuration information
#define NET_DVR_SET_SMARTTRACKCFG                3294 //set acquisition intelligent motion tracking configuration information
#define NET_DVR_GET_EPTZ_CFG                    3295 //get EPTZ parameters
#define NET_DVR_SET_EPTZ_CFG                    3296 //set EPTZ parameters
#define NET_DVR_GET_EPTZ_CFG_CAPABILITIES        3297 //get EPTZ parameters capabilities

#define NET_DVR_GET_LOW_LIGHTCFG            3303
#define NET_DVR_SET_LOW_LIGHTCFG            3304

#define NET_DVR_GET_FOCUSMODECFG            3305
#define NET_DVR_SET_FOCUSMODECFG            3306

#define NET_DVR_GET_INFRARECFG              3307
#define NET_DVR_SET_INFRARECFG              3308

#define NET_DVR_GET_AEMODECFG               3309
#define NET_DVR_SET_AEMODECFG               3310

#define NET_DVR_CONTROL_RESTORE_SUPPORT     3311   // Restore the front end of the default parameters (parameter capabilities, some front-end parameters to configure the associated recovery)
#define NET_DVR_CONTROL_RESTART_SUPPORT     3312

#define NET_DVR_CONTROL_PTZ_PATTERN         3313 //PTZ Pattern
#define NET_DVR_GET_PTZ_PARKACTION_CFG      3314       //Get PTZ Parkaction configuration
#define NET_DVR_SET_PTZ_PARKACTION_CFG      3315    //Set PTZ Parkaction configuration
#define NET_DVR_CONTROL_PTZ_MANUALTRACE     3316       //PTZ manual trace

#define NET_DVR_GET_ROI_DETECT_NUM            3349 //Get the number of ROI detection area number
#define NET_DVR_GET_ROI_DETECT                3350 //Get ROI detection area configuration
#define NET_DVR_SET_ROI_DETECT                3351 //Set ROI detection area configuration
#define NET_DVR_GET_FACE_DETECT                3352 //Get face detection configuration
#define NET_DVR_SET_FACE_DETECT                3353 //Set face detection configuration
#define NET_DVR_GET_CORRIDOR_MODE            3354 //Get corridor mode configuration
#define NET_DVR_SET_CORRIDOR_MODE            3355 //Set corridor mode configuration

//2013-07-16
#define NET_DVR_GET_SCENECHANGE_DETECTIONCFG    3356 //Get the scene change the alarm configuration
#define NET_DVR_SET_SCENECHANGE_DETECTIONCFG    3357 //Set the scene change the alarm configuration

#define NET_DVR_GET_TRAVERSE_PLANE_DETECTION    3360
#define NET_DVR_SET_TRAVERSE_PLANE_DETECTION    3361
#define NET_DVR_GET_FIELD_DETECTION             3362 //Get the field detection configuration
#define NET_DVR_SET_FIELD_DETECTION             3363 //Set the field detection configuration
#define NET_DVR_GET_DEFOCUSPARAM                3364 //Get the defouce detection configuration
#define NET_DVR_SET_DEFOCUSPARAM                3365 //Set the defouce detection configuration
#define NET_DVR_GET_AUDIOEXCEPTIONPARAM         3366 //Get the aduio exception configuration
#define NET_DVR_SET_AUDIOEXCEPTIONPARAM         3367 //Set the aduio exception configuration
#define NET_DVR_GET_CCDPARAMCFG_EX              3368 //Get the CCD configuration
#define NET_DVR_SET_CCDPARAMCFG_EX              3369 //Set the CCD configuration
#define NET_DVR_START_GET_INPUTVOLUME           3370 //Get the inputvolume

#define NET_DVR_SET_SCH_TASK                3380 //Set PTZ schdule tasks
#define NET_DVR_GET_SCH_TASK                3381 //Get PTZ schdule tasks
#define NET_DVR_SET_PRESET_NAME                3382 //Set the name of preset
#define NET_DVR_GET_PRESET_NAME                3383 //Get the name of preset
#define NET_DVR_SET_AUDIO_NAME                3384 //set the name of audio
#define NET_DVR_GET_AUDIO_NAME                3385  //get the name of audio

//[add] by zja 2013-10-29 10:55:31  IPC 5.1.4 resume initial tracking position
#define NET_DVR_RESUME_INITRACKPOS              3386  //resume initial tracking position

#define NET_DVR_NTP_SERVER_TEST                    3387    //NTP server test
#define    NET_DVR_NAS_SERVER_TEST                    3388    //NAS server test
#define    NET_DVR_EMAIL_SERVER_TEST                3389    //Email server test
#define    NET_DVR_FTP_SERVER_TEST                    3390    //FTP server test
#define    NET_DVR_IP_TEST                            3391    //IP conflict test
#define NET_DVR_GET_NET_DISKCFG_V40             3392 //Get net disk mount config v40
#define NET_DVR_SET_NET_DISKCFG_V40                3393 //Set net disk mount config v40

///20140220 IPC5.1.6 BEGIN
#define        NET_DVR_GET_IOOUT_CFG                3394    //    get supplement light configuration
#define        NET_DVR_SET_IOOUT_CFG                3395    //    set supplement light configuration

#define        NET_DVR_GET_SIGNAL_SYNC                3396    //     get signal light sync configuration
#define        NET_DVR_SET_SIGNAL_SYNC                3397    //     set signal light sync configuration

#define        NET_DVR_GET_EZVIZ_ACCESS_CFG        3398    //    get EZVIZ access configuration
#define        NET_DVR_SET_EZVIZ_ACCESS_CFG        3399    //    set EZVIZ access configuration
///20140220 IPC5.1.6 end

#define    NET_DVR_GET_SCHEDULE_AUTO_TRACK_CFG        3400    //get schedule auto tracking configuration
#define    NET_DVR_SET_SCHEDULE_AUTO_TRACK_CFG        3401    //set schedule auto tracking configuration
#define    NET_DVR_MAKE_I_FRAME                    3402    //Make I Frame

//PJ01D2013032803  2014-03-04
#define  NET_DVR_GET_ALARM_RELATE                3403   //Get Alarm Relate
#define  NET_DVR_SET_ALARM_RELATE                3404   //Set Alarm Relate


/************************* IPC5.1.7  Begin 2014-03-21****************************/
#define NET_DVR_GET_PDC_RULECFG_V42             3405    //Set Traffic statistics
#define NET_DVR_SET_PDC_RULECFG_V42             3406    //Get Traffic statistics
#define NET_DVR_GET_HEATMAP_CFG                 3407    //Set Heat Map
#define NET_DVR_SET_HEATMAP_CFG                 3408    //Get Heat Map
/************************* IPC5.1.7  End 2014-03-21*****************************/

#define NET_DVR_REMOTECONTROL_LINEARSCAN        3409    //Set the left and right boundary parameters 2014-03-15
#define NET_DVR_DPC_CTRL                        3410    //DPC Ctrl
#define NET_DVR_FFC_MANUAL_CTRL                 3411    //FFC Manual Ctrl
#define NET_DVR_FFC_BACKCOMP_CTRL               3412    //FFC Background Ctrl
#define NET_DVR_GET_FOCUSING_POSITION_STATE     3413    //Get Focusing Position State
#define NET_DVR_GET_PRIVATE_PROTOCOL_CFG        3414   //Get Private Protocol Cfg
#define NET_DVR_SET_PRIVATE_PROTOCOL_CFG        3415   //Set Private Protocol Cfg
#define NET_DVR_COMPLETE_RESTORE_CTRL           3420    //Complete Restore Ctrl

#define NET_DVR_CLOUDSTORAGE_SERVER_TEST        3421  //Cloud Storage Server Ctrl
#define NET_DVR_PHONE_NUM_TEST                  3422  //Phone Num Test
#define NET_DVR_GET_REMOTECONTROL_STATUS        3423  //Remote Control Status
#define NET_DVR_GET_MONITOR_LOCATION_INFO        3424  //Get Monitor Location Info
#define NET_DVR_SET_MONITOR_LOCATION_INFO        3425  //Set Monitor Location Info

#define    NET_DVR_GET_SMART_CAPABILITIES                3500    //get smart ability
#define    NET_DVR_GET_EVENT_TRIGGERS_CAPABILITIES        3501    //get event trigger ability
#define    NET_DVR_GET_REGION_ENTRANCE_CAPABILITIES    3502    //get region entrance detection ability
#define    NET_DVR_GET_REGION_ENTR_DETECTION            3503    //get region entrance detection configuration
#define    NET_DVR_SET_REGION_ENTR_DETECTION            3504    //set region entrance detection configuration
#define    NET_DVR_GET_REGION_ENTR_REGION                3505    //get region entrance detection single region configuration
#define    NET_DVR_SET_REGION_ENTR_REGION                3506    //set region entrance detection single region configuration
#define    NET_DVR_GET_REGION_ENTR_TRIGGER                3507    //get region entrance detection trigger configuration
#define    NET_DVR_SET_REGION_ENTR_TRIGGER                3508    //set region entrance detection trigger configuration
#define    NET_DVR_GET_REGION_ENTR_SCHEDULE            3509    //get region entrance detection arm schedule configuration
#define    NET_DVR_SET_REGION_ENTR_SCHEDULE            3510    //set region entrance detection arm schedule configuration
#define    NET_DVR_GET_REGION_EXITINT_CAPABILITIES        3511    //get region exit detection ability
#define    NET_DVR_GET_REGION_EXITING_DETECTION        3512    //get region exit detection configuration
#define    NET_DVR_SET_REGION_EXITING_DETECTION        3513    //set region exit detection configuration
#define    NET_DVR_GET_REGION_EXITING_REGION            3514    //get region exit detection single region configuration
#define    NET_DVR_SET_REGION_EXITING_REGION            3515    //set region exit detection single region configuration
#define    NET_DVR_GET_REGION_EXIT_TRIGGER                3516    //get region exit detection trigger configuration
#define    NET_DVR_SET_REGION_EXIT_TRIGGER                3517    //set region exit detection trigger configuration
#define    NET_DVR_GET_REGION_EXIT_SCHEDULE            3518    //get region exit detection arm schedule configuration
#define    NET_DVR_SET_REGION_EXIT_SCHEDULE            3519    //set region exit detection arm schedule configuration
#define    NET_DVR_GET_LOITERING_CAPABILITIES            3520    //get region loiter detection ability
#define    NET_DVR_GET_LOITERING_DETECTION                3521    //get region loiter detection configuration
#define    NET_DVR_SET_LOITERING_DETECTION                3522    //set region loiter detection configuration
#define    NET_DVR_GET_LOITERING_REGION                3523    //get region loiter detection single region configuration
#define    NET_DVR_SET_LOITERING_REGION                3524    //set region loiter detection single region configuration
#define    NET_DVR_GET_LOITERING_TRIGGER                3525    //get region loiter detection trigger configuration
#define    NET_DVR_SET_LOITERING_TRIGGER                3526    //set region loiter detection trigger configuration
#define    NET_DVR_GET_LOITERING_SCHEDULE                3527    //get region loiter detection arm schedule configuration
#define    NET_DVR_SET_LOITERING_SCHEDULE                3528    //set region loiter detection arm schedule configuration
#define    NET_DVR_GET_GROUPDETECTION_CAPABILITIES        3529    //get region group detection ability
#define    NET_DVR_GET_GROUP_DETECTION                    3530    //get region group detection configuration
#define    NET_DVR_SET_GROUP_DETECTION                    3531    //set region group detection configuration
#define    NET_DVR_GET_GROUPDETECTION_REGION            3532    //get region group detection single region configuration
#define    NET_DVR_SET_GROUPDETECTION_REGION            3533    //set region group detection single region configuration
#define    NET_DVR_GET_GROUPDETECTION_TRIGGER            3534    //get region group detection trigger configuration
#define    NET_DVR_SET_GROUPDETECTION_TRIGGER            3535    //set region group detection trigger configuration
#define    NET_DVR_GET_GROUPDETECTION_SCHEDULE            3536    //get region group detection arm schedule configuration
#define    NET_DVR_SET_GROUPDETECTION_SCHEDULE            3537    //set region group detection arm schedule configuration
#define    NET_DVR_GET_RAPIDMOVE_CAPABILITIES            3538    //get region rapid move detection ability
#define    NET_DVR_GET_RAPIDMOVE_DETECTION                3539    //get region rapid move detection configuration
#define    NET_DVR_SET_RAPIDMOVE_DETECTION                3540    //set region rapid move detection configuration
#define    NET_DVR_GET_RAPIDMOVE_REGION                3541    //get region rapid move detection single region configuration
#define    NET_DVR_SET_RAPIDMOVE_REGION                3542    //set region rapid move detection single region configuration
#define    NET_DVR_GET_RAPIDMOVE_TRIGGER                3543    //get region rapid move detection trigger configuration
#define    NET_DVR_SET_RAPIDMOVE_TRIGGER                3544    //set region rapid move detection trigger configuration
#define    NET_DVR_GET_RAPIDMOVE_SCHEDULE                3545    //get region rapid move detection arm schedule configuration
#define    NET_DVR_SET_RAPIDMOVE_SCHEDULE                3546    //set region rapid move detection arm schedule configuration
#define    NET_DVR_GET_PATKING_CAPABILITIES            3547    //get region park detection ability
#define    NET_DVR_GET_PARKING_DETECTION               3548    //get region park detection configuration
#define    NET_DVR_SET_PARKING_DETECTION                3549    //set region park detection configuration
#define    NET_DVR_GET_PARKING_REGION                    3550    //get region park detection single region configuration
#define    NET_DVR_SET_PARKING_REGION                    3551    //set region park detection single region configuration
#define    NET_DVR_GET_PARKING_TRIGGER                    3552    //get region park detection trigger configuration
#define    NET_DVR_SET_PARKING_TRIGGER                    3553    //set region park detection trigger configuration
#define    NET_DVR_GET_PARKING_SCHEDULE                3554    //get region park detection arm schedule configuration
#define    NET_DVR_SET_PARKING_SCHEDULE                3555    //set region park detection arm schedule configuration
#define    NET_DVR_GET_UNATTENDED_BAGGAGE_CAPABILITIES    3556    //get region unattended baggage detection ability
#define    NET_DVR_GET_UNATTENDED_BAGGAGE_DETECTION    3557    //get region unattended baggage detection configuration
#define    NET_DVR_SET_UNATTENDED_BAGGAGE_DETECTION    3558    //set region unattended baggage detection configuration
#define    NET_DVR_GET_UNATTENDED_BAGGAGE_REGION        3559    //get region unattended baggage detection single region configuration
#define    NET_DVR_SET_UNATTENDED_BAGGAGE_REGION        3560    //set region unattended baggage detection single region configuration
#define    NET_DVR_GET_UNATTENDED_BAGGAGE_TRIGGER        3561    //get region unattended baggage detection trigger configuration
#define    NET_DVR_SET_UNATTENDED_BAGGAGE_TRIGGER        3562    //set region unattended baggage detection trigger configuration
#define    NET_DVR_GET_UNATTENDED_BAGGAGE_SCHEDULE        3563    //get region unattended baggage detection arm schedule configuration
#define    NET_DVR_SET_UNATTENDED_BAGGAGE_SCHEDULE        3564    //set region unattended baggage detection arm schedule configuration
#define    NET_DVR_GET_ATTENDEDBAGGAGE_CAPABILITIES    3565    //get region attended baggage detection ability
#define    NET_DVR_GET_ATTENDEDBAGGAGE_DETECTION        3566    //get region attended baggage detection configuration
#define    NET_DVR_SET_ATTENDEDBAGGAGE_DETECTION        3567    //set region attended baggage detection configuration
#define    NET_DVR_GET_ATTENDEDBAGGAGE_REGION            3568    //get region attended baggage detection single region configuration
#define    NET_DVR_SET_ATTENDEDBAGGAGE_REGION            3569    //set region attended baggage detection single region configuration
#define    NET_DVR_GET_ATTENDEDBAGGAGE_TRIGGER            3570    //get region attended baggage detection trigger configuration
#define    NET_DVR_SET_ATTENDEDBAGGAGE_TRIGGER            3571    //set region attended baggage detection trigger configuration
#define    NET_DVR_GET_ATTENDEDBAGGAGE_SCHEDULE        3572    //get region attended baggage detection arm schedule configuration
#define    NET_DVR_SET_ATTENDEDBAGGAGE_SCHEDULE        3573    //set region attended baggage detection arm schedule configuration
#define    NET_DVR_GET_REGIONCLIP_CAPABILITIES            3574    //get region clip ability
#define    NET_DVR_GET_REGION_CLIP                     3575    //get region clip configuration
#define    NET_DVR_SET_REGION_CLIP                     3576    //set region clip configuration
#define    NET_DVR_GET_NETWORK_CAPABILITIES            3577    //get network ability
#define    NET_DVR_GET_WIRELESS_DIAL                     3578    //get wireless dial configuration
#define    NET_DVR_SET_WIRELESS_DIAL                     3579    //set wireless dial configuration
#define    NET_DVR_GET_WIRELESSDIAL_CAPABILITIES        3580    //get wireless dial configuration ability
#define    NET_DVR_GET_WIRELESSDIAL_SCHEDULE            3581    //get wireless dial schedule configuration
#define    NET_DVR_SET_WIRELESSDIAL_SCHEDULE            3582    //set wireless dial schedule configuration
#define    NET_DVR_GET_WIRELESSDIAL_STATUS             3583    //get wireless dial status
#define    NET_DVR_GET_REGION_ENTRANCE_SCHEDULE_CAPABILITIES    3584    //get region entrance detection arm schedule ability
#define    NET_DVR_GET_REGION_EXITING_SCHEDULE_CAPABILITIES    3585    //get region exit detection arm schedule ability
#define    NET_DVR_GET_LOITERING_SCHEDULE_CAPABILITIES    3586    //get region loiter detection arm schedule ability
#define    NET_DVR_GET_GROUP_SCHEDULE_CAPABILITIES    3587    //get region group detection arm schedule ability
#define    NET_DVR_GET_RAPIDMOVE_SCHEDULE_CAPABILITIES    3588    //get region rapid move detection arm schedule ability
#define    NET_DVR_GET_PARKING_SCHEDULE_CAPABILITIES    3589    //get region park detection arm schedule ability
#define    NET_DVR_GET_UNATTENDEDBAGGAGE_SCHEDULE_CAPABILITIES    3590    //get region unattended baggage detection arm schedule ability
#define    NET_DVR_GET_ATTENDEDBAGGAGE_SCHEDULE_CAPABILITIES    3591    //get region attended baggage detection arm schedule ability
#define    NET_DVR_GET_WIRELESSDIAL_SCHEDULE_CAPABILITIES    3592    //get wireless dial schedule ability
#define    NET_DVR_WIRELESSDIAL_CONNECT    3593    //control connect wireless dial

#define    NET_DVR_GET_LITESTORAGE                    3594
#define    NET_DVR_SET_LITESTORAGE                    3595
#define    NET_DVR_GET_LITESTORAGE_CAPABILITIES    3596

#define    NET_DVR_GET_VEHICLE_CAPABILITIES    3597
#define    NET_DVR_GET_VEHICLE_CALIBRATION     3598

#define    NET_DVR_GET_SLAVECAMERA_CAPABILITIES    3599    //Get SlaveCamera IP Info Capabilities
#define    NET_DVR_GET_SLAVECAMERA                    3600    //Get SlaveCamera IP Info
#define    NET_DVR_SET_SLAVECAMERA                    3601    //Set SlaveCamera IP Info
#define    NET_DVR_GET_SLAVECAMERA_STATUS            3602    //Get SlaveCamera Link Status
#define    NET_DVR_GET_SLAVECAMERA_CALIB_CAPABILITIES    3603  //Get SlaveCamera Calib Capabilities
#define    NET_DVR_GET_SLAVECAMERA_CALIB            3604    //Get SlaveCamera Calib Param
#define    NET_DVR_SET_SLAVECAMERA_CALIB            3605    //Set SlaveCamera Calib Param
#define NET_DVR_GET_PHY_RATIO                    3606    //Get Physics Ratio Coordinate Info
#define NET_DVR_SET_PHY_RATIO                    3607    //Set Physics Ratio Coordinate Info
#define NET_DVR_GET_MASTERSLAVETRACKING_CAPABILITIES   3608  //Get MasterSlaveTracking Capabilities
#define    NET_DVR_SET_TRACKINGRATIO                3610    //Set SlaveCamera Tracking Ratio
#define    NET_DVR_GET_TRACKING                    3611    //Get tracking param
#define    NET_DVR_SET_TRACKING                    3612    //Set tracking param
#define    NET_DVR_GET_TRACKING_CAPABILITIES        3613    //Get tracking param capabilities
#define    NET_DVR_GET_SLAVECAMERA_CALIB_V50        3614    //Get SlaveCamera Calib Param V50
#define    NET_DVR_SET_SLAVECAMERA_CALIB_V50        3615    //Set SlaveCamera Calib Param V50
#define    NET_DVR_SET_TRACKINGRATIO_MANUAL        3616    //Set Tracking Ratio Manual Coefficient
#define    NET_DVR_GET_TRACKINGRATIO_MANUAL        3617    //Get Tracking Ratio Manual Coefficient
#define    NET_DVR_SET_TRACK_INITPOSTION            3618    //Set Tracking InitPostion
#define    NET_DVR_GET_PTZ_CAPABILITIES            3619    //Get PTZ Capabilities

#define    NET_DVR_GET_THERMOMETRY_BASICPARAM_CAPABILITIES    3620 //Get Thermometry Basic Param capabilities
#define    NET_DVR_GET_THERMOMETRY_BASICPARAM      3621    //Get Thermometry Basic Param
#define    NET_DVR_SET_THERMOMETRY_BASICPARAM        3622    //Set Thermometry Basic Param
#define    NET_DVR_GET_THERMOMETRY_SCENE_CAPABILITIES    3623 //Get Thermometry Scene capabilities
#define    NET_DVR_GET_THERMOMETRY_PRESETINFO      3624    //Get Thermometry Preset Info
#define    NET_DVR_SET_THERMOMETRY_PRESETINFO        3625    //Set Thermometry Preset Info
#define    NET_DVR_GET_THERMOMETRY_ALARMRULE_CAPABILITIES    3626 //Get Thermometry Alarm Rule Capabilities
#define    NET_DVR_GET_THERMOMETRY_ALARMRULE       3627    //Get Thermometry Alarm Rule
#define    NET_DVR_SET_THERMOMETRY_ALARMRULE        3628    //Set Thermometry Alarm Rule
#define    NET_DVR_GET_REALTIME_THERMOMETRY        3629    //Get Realtime Thermometry
#define    NET_DVR_GET_THERMOMETRY_DIFFCOMPARISON  3630    //Get Thermometry Temperature difference
#define    NET_DVR_SET_THERMOMETRY_DIFFCOMPARISON    3631    //Set Thermometry Temperature difference
#define    NET_DVR_GET_THERMOMETRY_TRIGGER            3632    //Get Thermometry Trigger
#define    NET_DVR_SET_THERMOMETRY_TRIGGER            3633    //Set Thermometry Trigger

#define    NET_DVR_GET_THERMAL_CAPABILITIES        3634    //Get Thermal Capabilities
#define    NET_DVR_GET_FIREDETECTION_CAPABILITIES    3635    //Get FireDetection Capabilities
#define    NET_DVR_GET_FIREDETECTION               3636    //Get FireDetection
#define    NET_DVR_SET_FIREDETECTION               3637    //Set FireDetection
#define    NET_DVR_GET_FIREDETECTION_TRIGGER       3638    //Get FireDetection Trigger
#define    NET_DVR_SET_FIREDETECTION_TRIGGER        3639    //Set FireDetection Trigger

#define	NET_DVR_GET_OIS_CAPABILITIES            3640    //Get OIS Capabilities
#define	NET_DVR_GET_OIS_CFG                     3641    //Get OIS Info
#define	NET_DVR_SET_OIS_CFG                     3642    //Set OIS Info
#define	NET_DVR_GET_MACFILTER_CAPABILITIES      3643    //Get MAC Filter Capabilities
#define	NET_DVR_GET_MACFILTER_CFG               3644    //Get MAC Filter
#define	NET_DVR_SET_MACFILTER_CFG               3645    //Set MAC Filter
#define	NET_DVR_GET_EAGLEFOCUS_CALCFG_CAPABILITIES   3646    //Get Elagle Focus Calib Capabilities
#define	NET_DVR_GET_EAGLEFOCUSING_CALCFG        3647    //Get Elagle Focus Calib
#define	NET_DVR_SET_EAGLEFOCUSING_CALCFG        3648    //Set Elagle Focus Calib
#define	NET_DVR_GET_EAGLEFOCUSING_CFG_CAPABILITIES   3649   //Get Elagle Focus Capabilities
#define	NET_DVR_GET_EAGLEFOCUSING_CTRL          3650    //Get Elagle Focus
#define	NET_DVR_SET_EAGLEFOCUSING_CTRL          3651    //Set Elagle Focus
#define	NET_DVR_GET_PXOFFLINE_CAPABILITIES      3652	//PX Offline Configuration capabilities
#define	NET_DVR_SET_PXOFFLINE_CFG	            3653	//Set PX Offline Configuration
#define	NET_DVR_GET_PXOFFLINE_CFG	            3654	//Get PX Offline Configuration
#define	NET_DVR_GET_PAPERCHARGEINFO_CAPABILITIES  3655  //Get parking lot entrance ticket information capabilities
#define	NET_DVR_SET_PAPERCHARGEINFO	            3656	//Set parking lot entrance ticket information
#define	NET_DVR_GET_PARKINGSAPCE_CAPABILITIES	3657	//Get Parking sapce Capabilities
#define	NET_DVR_SET_PARKINGSAPCE_INFO	        3658	//Set Parking sapce Info
#define	NET_DVR_GET_PXMULTICTRL_CAPABILITIES	3659	//PX Multi Ctrl Configuration Capabilities
#define	NET_DVR_GET_CHARGEACCOUNT_CAPABILITIES	3661	//Get Charge Account Info Capabilities
#define	NET_DVR_SET_CHARGE_ACCOUNTINFO          3662	//Set Charge Account Info
#define	NET_DVR_SET_PXMULTICTRL_CFG	            3663	//Set PX Multi Ctrl Configuration
#define	NET_DVR_GET_PXMULTICTRL_CFG	            3664	//Get PX Multi Ctrl Configuration
#define	NET_DVR_GET_TME_CHARGERULE              3665	//Get Entrance Vehicle Card
#define	NET_DVR_SET_TME_CHARGERULE   	        3666	//Set Entrance Vehicle Card
#define	NET_DVR_GET_TME_CHARGERULE_CAPABILITIES 3667	//Get Entrance Vehicle Card Capabilities
#define	NET_DVR_GET_ILLEGALCARDFILTERING_CAPABILITIES  3668	//Get Illegal card filtering Capabilities
#define	NET_DVR_GET_ILLEGALCARDFILTERING_CFG    3669	//Get Illegal card filtering
#define	NET_DVR_SET_ILLEGALCARDFILTERING_CFG    3670	//Set Illegal card filtering
#define	NET_DVR_GET_LEDDISPLAY_CAPABILITIES	    3671	//Get LED Display Capabilities
#define	NET_DVR_SET_LEDDISPLAY_CFG              3672	//Set LED Display Cfg
#define	NET_DVR_GET_LEDDISPLAY_CFG              3673	//Get LED Display Cfg
#define	NET_DVR_GET_VOICEBROADCAST_CAPABILITIES	3674	//Get VoiceBroadcast Capabilities
#define	NET_DVR_SET_VOICEBROADCAST_CFG          3675	//Set VoiceBroadcast Cfg
#define	NET_DVR_GET_PAPERPRINTFORMAT_CAPABILITIES	3676//Get Paper Print Format Capabilities
#define	NET_DVR_GET_PAPERPRINTFORMAT_CFG	    3677    //Get Paper Print Format Cfg
#define	NET_DVR_SET_PAPERPRINTFORMAT_CFG	    3678    //Set Paper Print Format Cfg
#define	NET_DVR_GET_LOCkGATE_CAPABILITIES   	3679	//Get Lock Gate Capabilities
#define	NET_DVR_GET_LOCKGATE_CFG            	3680    //Get Lock Gate Cfg
#define	NET_DVR_SET_LOCKGATE_CFG	            3681    //Set Lock Gate Cfg
#define NET_DVR_GET_PARKING_DATASTATE		    3682    //Get Parking Data State
#define NET_DVR_SET_PARKING_DATASTATE           3683    //Set Parking Data State
#define    NET_DVR_GET_TME_CAPABILITIES            3684    //Get TME Capabilities

#define    NET_DVR_GET_TMEVOICE_CAPABILITIES       3686    //Get TME Voice Capabilities
#define    NET_DVR_SET_TMEVOICE_CFG                3687    //Set TME Voice CFG
#define    NET_DVR_GET_TMEVOICE_CFG                3688    //Get TME Voice CFG
#define	NET_DVR_DEL_TMEVOICE_CFG                3689    //Delete TME Voice CFG
#define	NET_DVR_GET_POSITION                    3698    //Get Soft Position Work Mode Param
#define	NET_DVR_SET_POSITION	                3699    //Set Soft Position Work Mode Param
#define	NET_DVR_GET_CENTRALIZEDCTRL_CAPABILITIES	3700//Get Centralized Ctrl Capbailities
#define	NET_DVR_GET_CENTRALIZEDCTRL	            3701    //Get Centralized Ctrl
#define	NET_DVR_SET_CENTRALIZEDCTRL          	3702    //Set Centralized Ctrl
#define	NET_DVR_GET_COMPASS_CAPABILITIES    	3703    //Get Compass Capabilities
#define	NET_DVR_GET_VANDALPROOFALARM          	3704    //Get Vandalproof Alarm
#define	NET_DVR_SET_VANDALPROOFALARM        	3705    //Set Vandalproof Alarm
#define	NET_DVR_COMPASS_CALIBRATE_CTRL	        3706    //Compass Calibrate Ctrl
#define	NET_DVR_COMPASS_NORTH_CTRL	            3707    //Compass North Ctrl
#define	NET_DVR_GET_AZIMUTHINFO	                3708    //Get Azimuth Info
#define    NET_DVR_GET_SATELLITETIME                3709    //Get Satellite positioning Cfg
#define    NET_DVR_SET_SATELLITETIME                3710    //Set Satellite positioning Cfg
#define    NET_DVR_GET_GISINFO                     3711    //Get DIS Info
#define    NET_DVR_GET_STREAMING_CAPABILITIES        3712    //Get Streaming Capabilities
#define    NET_DVR_GET_REFRESHFRAME_CAPABILITIES    3713    //Get Refresh Frame Capabilities
#define    NET_DVR_STREAMING_REFRESH_FRAME            3714    //Streaming Refresh Frame
#define    NET_DVR_FACECAPTURE_STATISTICS            3715    //Face Capture Statistic

#define    NET_DVR_GET_WIRELESSSERVER_CAPABILITIES    3716    //get wireless server capabilities
#define    NET_DVR_GET_WIRELESSSERVER                3717    //get wireless server
#define    NET_DVR_SET_WIRELESSSERVER                3718    //set wireless server
#define    NET_DVR_GET_CONNECT_LIST_CAPABILITIES    3719    //get connect list capabilities
#define    NET_DVR_GET_THSCREEN_CAPABILITIES        3720    //Get Thscreen capabilities
#define    NET_DVR_GET_THSCREEN                    3721    //Get Thscreen

#define    NET_DVR_GET_EXTERNALDEVICE_CAPABILITIES    3722    //Get External Device Capabilities
#define    NET_DVR_GET_EXTERNALDEVICE              3723    //Get External Device
#define    NET_DVR_SET_EXTERNALDEVICE                3724    //Set External Device
#define    NET_DVR_GET_LEDDISPLAYINFO_CAPABILITIES    3725   //Get Led Display Info Capabilities
#define    NET_DVR_SET_LEDDISPLAYINFO                3726   //Set Led Display Info
#define    NET_DVR_GET_SUPPLEMENTLIGHT_CAPABILITIES 3727   //get Builtin supplement Light Capabilities
#define    NET_DVR_GET_SUPPLEMENTLIGHT                 3728    //get Builtin supplement Light
#define    NET_DVR_SET_SUPPLEMENTLIGHT                 3729    //set Builtin supplement Light
#define    NET_DVR_SET_THSCREEN                     3730   //Set Thscreen
#define    NET_DVR_GET_LOWPOWER_CAPABILITIES        3731   //Get Low Power Capabilities
#define    NET_DVR_GET_LOWPOWER                     3732    //Get Low Power Cfg
#define    NET_DVR_SET_LOWPOWER                     3733    //Set Low Power Cfg
#define    NET_DVR_GET_ZOOMLINKAGE_CAPABILITIES     3734   //Get Zoom Linkage Capabilities
#define    NET_DVR_GET_ZOOMLINKAGE                     3735    //Get Zoom Linkage
#define    NET_DVR_SET_ZOOMLINKAGE                     3736    //Set Zoom Linkage
#define    NET_DVR_THSCREEN_TIMING                     3737    //ThScreen Timing

#define NET_DVR_GET_OSD_BATTERY_POWER_CFG        3741        //get osd battery power parameter
#define NET_DVR_SET_OSD_BATTERY_POWER_CFG        3742        //set osd battery power parameter
#define    NET_DVR_GET_OSD_BATTERY_POWER_CFG_CAPABILITIES    3743//get osd battery power parameter Capabilities
#define    NET_DVR_GET_VANDALPROOFALARM_TRIGGER    3744    //Get VandalProof alarm Trigger
#define    NET_DVR_SET_VANDALPROOFALARM_TRIGGER    3745    //Set VandalProof alarm Trigger
#define    NET_DVR_GET_PANORAMAIMAGE_CAPABILITIES    3746    //Get panorama image Capabilities
#define    NET_DVR_GET_PANORAMAIMAGE                3747    //Get panorama image param
#define    NET_DVR_SET_PANORAMAIMAGE                3748    //Set panorama image param
#define    NET_DVR_GET_STREAMENCRYPTION            3749    //Get Stream Encryption param
#define    NET_DVR_SET_STREAMENCRYPTION            3750    //Set Stream Encryption param
#define    NET_DVR_GET_STREAMENCRYPTION_CAPABILITIES 3751  //Get Stream Encryption Capabilities
#define    NET_DVR_GET_REVISE_GPS_CAPABILITIES     3752    //Get Revise GPS Capabilities
#define    NET_DVR_GET_REVISE_GPS                  3753    //Get Revise GPS CFG
#define    NET_DVR_SET_REVISE_GPS                  3754    //Set Revise GPS CFG
#define NET_DVR_GET_PDC_RECOMMEND                3755    //get PDC Recommend value
#define NET_DVR_REMOVE_FLASHSTORAGE                3756    //Remove PDC Flash Storage
#define    NET_DVR_GET_COUNTING_CAPABILITIES        3757    //get PDC(counting) capabilities
#define    NET_DVR_SET_SENSOR_ADJUSTMENT            3758    //Set Sensor Adjustment
#define    NET_DVR_GET_SENSOR_ADJUSTMENT_CAPABILITIES        3759    //Get Sensor Adjustment capabilities
#define    NET_DVR_GET_WIRELESSSERVER_FULLVERSION_CFG         3760    //Get wifi Cfg(Full Version)
#define    NET_DVR_SET_WIRELESSSERVER_FULLVERSION_CFG         3761    //Set wifi Cfg(Full Version)

#define    NET_DVR_GET_ONLINEUSER_INFO                3762    //get online user info
#define    NET_DVR_GET_SENSOR_ADJUSTMENT_INFO        3763    //get the sensor adjustment info
#define NET_DVR_SENSOR_RESET_CTRL               3764    //Sensor adjustment reset
#define    NET_DVR_GET_POSTRADAR_CAPABILITIES        3765    //Get Post Radar Capabilities
#define    NET_DVR_GET_POSTRADARSPEED_CFG          3766    //Get Post Radar Speed Cfg
#define    NET_DVR_SET_POSTRADARSPEED_CFG          3767    //Set Post Radar Speed Cfg
#define    NET_DVR_GET_POSTRADARSPEED_RECOM_CFG    3768    //Get Post Radar Speed Recom Cfg
#define    NET_DVR_GET_POSTRADARPARAM_CFG          3769    //Get Post Radar Param Cfg
#define    NET_DVR_SET_POSTRADARPARAM_CFG          3770    //Set Post Radar Param Cfg
#define    NET_DVR_GET_POSTRADARPARAM_RECOM_CFG    3771    //Get Post Radar Param Recom Cfg
#define NET_DVR_GET_ENCRYPT_DEVICE_INFO         3772   //get encrypt device info
#define NET_DVR_GET_ANR_ARMING_HOST             3773  //Get offline continuingly host information
#define NET_DVR_GET_FIRMWARE_VERSION    3776    //GET firmware version
/********************************The IPC baseline FF license plate ****************************/
#define    NET_DVR_GET_FTP_CAPABILITIES         3782    //Access to FTP ability
#define    NET_DVR_GET_FTPUPLOAD_CFG             3783    //Get for FTP upload information structured parameters
#define    NET_DVR_SET_FTPUPLOAD_CFG             3784    //set the FTP upload information structured parameters
#define NET_DVR_GET_VEHICLE_INFORMATION         3785 //Get vehicle information
#define    NET_DVR_GET_DDNS_COUNTRY_ABILITY        3800    //Get DDNS country Ability
#define NET_DVR_GET_DEVICECFG_V50	3801	//Get equipment parameters V50
#define NET_DVR_SET_DEVICECFG_V50	3802	//Set equipment parameters V50

#define	NET_DVR_GET_SMARTCALIBRATION_CAPABILITIES    3900    //Get Smart behavior calibration filter size function Capabilities
#define NET_DVR_GET_TEMPERATURE_TRIGGER              3903    //Get Temperture trigger
#define NET_DVR_SET_TEMPERATURE_TRIGGER              3904    //Set Temperture trigger
#define	NET_DVR_GET_SMARTCALIBRATION_CFG             3910        //Get Smart behavior calibration filter size function
#define	NET_DVR_SET_SMARTCALIBRATION_CFG             3911        //Set Smart behavior calibration filter size function
#define NET_DVR_POST_SETUP_CALIB                     3912  //Set up calibration
#define NET_DVR_SET_POS_INFO_OVERLAY                 3913//Set the Pos information code superposition of flow control
#define NET_DVR_GET_POS_INFO_OVERLAY                 3914//Superposition of Pos information stream control
#define NET_DVR_GET_CAMERA_WORK_MODE                 3915  //Set the camera work mode parameters camera work mode
#define NET_DVR_SET_CAMERA_WORK_MODE                 3916  //Get the camera work mode parameters camera work mode
#define NET_DVR_GET_RESOLUTION_SWITCH_CAPABILITIES   3917  //get resolution switch capabilities
#define NET_DVR_GET_RESOLUTION_SWITCH                3918  //get resolution switch
#define NET_DVR_SET_RESOLUTION_SWITCH                3919  //set resolution switch
#define NET_DVR_GET_VEHICLLE_RESULT_CAPABILITIES     3951   //get the results of vehicle information ability
#define NET_DVR_GET_SOFTWARE_SERVICE_CAPABILITIES    3980//Get the ability of service
#define NET_DVR_GET_SOFTWARE_SERVICE                 3981//Get software service configuration
#define NET_DVR_SET_SOFTWARE_SERVICE                 3982//Set software and services
/********************************NVR_Prodection Line****************************/
#define NET_DVR_GET_MUTEX_FUNCTION              4353  //get mutex function information

#define NET_DVR_GET_SINGLE_CHANNELINFO          4360  //get single channel information
#define NET_DVR_GET_CHANNELINFO                 4361  //get channnel information
#define NET_DVR_CHECK_LOGIN_PASSWORDCFG             4362  //admin login password check
#define NET_DVR_GET_SINGLE_SECURITY_QUESTION_CFG        4363    //get single device security question
#define NET_DVR_SET_SINGLE_SECURITY_QUESTION_CFG        4364    //set single device security question
#define NET_DVR_GET_SECURITY_QUESTION_CFG       4365    //get device security question
#define NET_DVR_SET_SECURITY_QUESTION_CFG       4366    //set device security question
#define NET_DVR_GET_ONLINEUSERLIST_SC           4367  //remote get user login inf (short connect)

#define NET_DVR_GET_FACESNAPCFG              5001       //Get face snap configuration
#define NET_DVR_SET_FACESNAPCFG              5002       //Set face snap configuration
#define NET_DVR_GET_DEVACCESS_CFG            5005       //Get device access configuration
#define NET_DVR_SET_DEVACCESS_CFG            5006       //Set device access configuration
#define NET_DVR_GET_SAVE_PATH_CFG            5007       //Get storage information parameter
#define NET_DVR_SET_SAVE_PATH_CFG            5008       //Set storage information parameter
#define NET_VCA_GET_RULECFG_V41                 5011        //Get behavior analysis parameters (extended)
#define NET_VCA_SET_RULECFG_V41                 5012        //Set behavior analysis parameters (extended)
#define NET_DVR_GET_AID_RULECFG_V41          5013       //Get traffic event rule parameters(extended)
#define NET_DVR_SET_AID_RULECFG_V41          5014       //Set traffic event rule parameters(extended)
#define NET_DVR_GET_TPS_RULECFG_V41          5015       //Get traffic rule statistics(extended)
#define NET_DVR_SET_TPS_RULECFG_V41          5016       //Set traffic rule statistics(extended)
#define NET_VCA_GET_FACEDETECT_RULECFG_V41   5017       //Get ATM face detect analysis parameters(extended)
#define NET_VCA_SET_FACEDETECT_RULECFG_V41   5018       //Set ATM face detect analysis parameters(extended)
#define NET_DVR_GET_PDC_RULECFG_V41          5019       //Get PDC analysis parameters(extended)
#define NET_DVR_SET_PDC_RULECFG_V41          5020       //Set PDC analysis parameters(extended)
#define NET_DVR_GET_TRIAL_VERSION_CFG        5021       //Get trial version
#define NET_DVR_GET_VCA_CTRLINFO_CFG         5022       //Get vca ctrl info(extended)
#define NET_DVR_SET_VCA_CTRLINFO_CFG         5023       //Set vca ctrl info(extended)
#define NET_DVR_SYN_CHANNEL_NAME             5024       //Syn channel name
#define NET_DVR_GET_RESET_COUNTER            5025       //Get reset counter
#define NET_DVR_SET_RESET_COUNTER            5026       //Set reset counter
#define NET_DVR_GET_OBJECT_COLOR             5027       //Get object color attribute
#define NET_DVR_SET_OBJECT_COLOR             5028       //Set object color attribute
#define NET_DVR_GET_AUX_AREA                 5029       //Get auxiliary area list
#define NET_DVR_SET_AUX_AREA                 5030       //Set auxiliary area list
#define NET_DVR_GET_CHAN_WORKMODE            5031       //Get channel workmode
#define NET_DVR_SET_CHAN_WORKMODE            5032       //Set channel workmode
#define NET_DVR_GET_SLAVE_CHANNEL            5033       //Get slave channel parameters
#define NET_DVR_SET_SLAVE_CHANNEL            5034       //Set slave channel parameters
#define NET_DVR_GET_VQD_EVENT_RULE           5035       //Get VQD event rule
#define NET_DVR_SET_VQD_EVENT_RULE           5036       //Set VQD event rule
#define NET_DVR_GET_BASELINE_SCENE           5037       //Get baseline scene parameters
#define NET_DVR_SET_BASELINE_SCENE           5038       //Set baseline scene parameters
#define NET_DVR_CONTROL_BASELINE_SCENE       5039       //Operation on baseline scene
#define NET_DVR_SET_VCA_DETION_CFG             5040        //set vca detion cfg
#define NET_DVR_GET_VCA_DETION_CFG             5041        //get vca detion cfg
#define NET_DVR_GET_STREAM_ATTACHINFO_CFG    5042       //get stream attach parameters
#define NET_DVR_SET_STREAM_ATTACHINFO_CFG    5043       //set stream attach parameters

#define NET_DVR_GET_BV_CALIB_TYPE            5044       //Get Calib Type
#define NET_DVR_CONTROL_BV_SAMPLE_CALIB      5045       //Sample Calib
#define NET_DVR_GET_BV_SAMPLE_CALIB_CFG      5046       //Get Sample Calib Point
#define NET_DVR_GET_RULECFG_V42                 5049       //Get rule V42 of VCA
#define NET_DVR_SET_RULECFG_V42                 5050       //Set rule V42 of VCA
#define NET_DVR_SET_VCA_DETION_CFG_V40         5051       //set vca detion cfg
#define NET_DVR_GET_VCA_DETION_CFG_V40       5052       //get vca detion cfg
#define NET_DVR_SET_FLASH_CFG                5110       //Write data to the Flash test
/********************************ITS****************************/
//2014-12-03
#define    NET_DVR_GET_T1TEST_CFG   5053     //Production line test configuration interface (get)
#define    NET_DVR_SET_T1TEST_CFG   5054     //Production line test configuration interface (set)

#define NET_ITS_GET_OVERLAP_CFG_V50             5055       //Get Overlap Cfg V50
#define NET_ITS_SET_OVERLAP_CFG_V50             5056       //Set Overlap Cfg V50
#define NET_DVR_GET_PARKLAMP_STATE             5057       //Get  Access to parking signal status information
#define NET_DVR_GET_CLOUDSTORAGE_CFG         5058       //Gets the cloud storage configuration parameters
#define NET_DVR_SET_CLOUDSTORAGE_CFG         5059       //Sets the cloud storage configuration parameters

#define NET_ITS_GET_BASE_INFO                 5060        //Get ITS base information
#define NET_DVR_GET_SENSOR_INFO              5061       //Get Sensor Cfg
#define    NET_DVR_SET_SENSOR_SWITCH             5062       //Set Sensor Switch
#define NET_ITS_GET_IMGMERGE_CFG             5063        //Get image merge configuration
#define NET_ITS_SET_IMGMERGE_CFG             5064        //Set image merge configuration
#define NET_ITS_GET_UPLOAD_CFG                 5065        //Get upload data configuration
#define NET_ITS_SET_UPLOAD_CFG                 5066        //Set upload data configuration
#define    NET_DVR_GET_SENSOR_PORT_CAPABILITIES 5067       //Get Sensor Port Capabilities
#define NET_ITS_GET_WORKSTATE                 5069        //Get ITS work state
#define NET_ITS_GET_IPC_CHAN_CFG             5070        //Get ITS IPC channel configuration
#define NET_ITS_SET_IPC_CHAN_CFG             5071        //Set ITS IPC channel configuration
#define NET_ITS_GET_OVERLAP_CFG                 5072        //Get overlap configuration
#define NET_ITS_SET_OVERLAP_CFG                 5073        //Set overlap configuration
#define NET_DVR_GET_TRIGGEREX_CFG            5074       //Get Trigger Configuration
#define NET_DVR_SET_TRIGGEREX_CFG            5075       //Set Trigger Configuration
#define NET_ITS_GET_ROAD_INFO                 5076        //Get road information

#define NET_ITS_REMOTE_DEVICE_CONTROL         5077        //Set Remote device control
#define NET_ITS_GET_GATEIPC_CHAN_CFG         5078        //Get the synchronization host configuration
#define NET_ITS_SET_GATEIPC_CHAN_CFG         5079        //Set the synchronization host configuration
#define NET_ITS_TRANSCHAN_START              5080       //Start Synchronous data server
#define NET_ITS_GET_ECTWORKSTATE             5081       //Get the import and export terminal state
#define NET_ITS_GET_ECT_CHAN_INFO            5082       //Get the import and export terminal channel status
#define NET_DVR_GET_HEATMAP_RESULT           5083       //Get Heat Map 2014-03-21

//2013-11-19
#define NET_DVR_SET_ITS_EXDEVCFG             5084       //Set ITS CFG
#define NET_DVR_GET_ITS_EXDEVCFG             5085       //Get ITS CFG
#define NET_DVR_GET_ITS_EXDEVSTATUS             5086       //Get ITS Device Status
#define NET_DVR_SET_ITS_ENDEVCMD             5087       //Set ITS Control
#define NET_DVR_SET_ENISSUED_DATADEL         5088       //Set ITS Data Delete

#define NET_DVR_GET_PDC_RESULT               5089       //Passenger flow data query 2014-03-21

#define NET_ITS_GET_LAMP_CTRLCFG             5090       //Get inside and outside the lamp parameters
#define NET_ITS_SET_LAMP_CTRLCFG             5091       //Set inside and outside the lamp parameters
#define NET_ITS_GET_PARKSPACE_ATTRIBUTE_CFG  5092       //Get special parking space parameters
#define NET_ITS_SET_PARKSPACE_ATTRIBUTE_CFG  5093       //Set special parking space parameters
#define NET_ITS_SET_LAMP_EXTERNAL_CFG        5095       //Set external control configuration parameters
#define NET_ITS_SET_COMPEL_CAPTURE           5096       //Set the parking enforcement

#define  NET_DVR_SET_TIMESIGN_CFG            5097       //Set Custom Set Time Sign
#define  NET_DVR_GET_TIMESIGN_CFG            5098       //Get Custom Set Time Sign
#define NET_DVR_GET_SIGNALLAMP_STATUS        5099       //Signal lamp detection

#define NET_DVR_GET_MONITOR_PLAN_VQD         5100       //long connection to obtain diagnostic server program
#define NET_DVR_GET_MONITORID_VQD            5101       //long connection for monitoring points within the corresponding plan
#define NET_DVR_SET_MONITOR_INFO             5102       //monitoring points within the volume set plan
#define NET_DVR_DEL_MONITOR_PLAN_VQD         5103       //delete plan
#define NET_DVR_GET_MONITOR_VQD_STATUS       5104       //platform state to query the server for diagnosis
#define NET_DVR_GET_RECORD_INFO              5105       //access to resources pictures inquiries
#define NET_DVR_GET_MONITOR_VQDCFG           5106       //Get server monitoring points
#define NET_DVR_SET_MONITOR_VQDCFG           5107       //set server monitoring points
#define NET_DVR_SET_MONITOR_PLAN_VQDCFG      5108       //settings management plan (individual plan)

#define NET_DVR_SCENE_CHANGE_UPDATE             5109        //scene change update

#define NET_DVR_GET_CALIBRATE_POINT          5153       //Normalized coordinate transformation (Shot the ball linkage equipment external interactive command code Baseline code does not realize, prevent conflict, submitted to the baseline )

#define NET_DVR_GET_SCENE_CFG                5201       //Get scene configuration
#define NET_DVR_SET_SCENE_CFG                5202       //Set scene configuration
#define NET_DVR_GET_SCENE_REFERENCE_REGION   5203       //Get scene reference region
#define NET_DVR_SET_SCENE_REFERENCE_REGION   5204       //Set scene reference region
#define NET_DVR_GET_SCENE_CALIBRATION        5205       //Get scene calibration
#define NET_DVR_SET_SCENE_CALIBRATION        5206       //Set scene calibration
#define NET_DVR_GET_SCENE_MASK_REGION        5207       //Get scene mask region
#define NET_DVR_SET_SCENE_MASK_REGION        5208       //Set scene mask region
#define    NET_DVR_GET_SCENE_LANECFG             5209       //Get scene lane rule parameters
#define NET_DVR_SET_SCENE_LANECFG             5210       //Set scene lane rule parameters
#define NET_DVR_GET_SCENE_AID_RULECFG        5211       //Get scene traffic event rule parameters
#define NET_DVR_SET_SCENE_AID_RULECFG        5212       //Set scene traffic event rule parameters
#define NET_DVR_GET_SCENE_TPS_RULECFG        5213       //Get scene traffic rule statistics
#define NET_DVR_SET_SCENE_TPS_RULECFG        5214       //Set scene traffic rule statistics
#define NET_DVR_GET_SCENE_TIME_CFG           5215       //Get scene effective time configuration
#define NET_DVR_SET_SCENE_TIME_CFG           5216       //Set scene effective time configuration
#define NET_DVR_GET_FORENSICS_MODE           5217       //Get forensics mode
#define NET_DVR_SET_FORENSICS_MODE           5218       //Set forensics mode
#define NET_DVR_FORCESTOP_FORENSICS_CTRL     5219       //Force stop Forensics Ctrl

#define NET_DVR_GET_ALARM_PROCESS_CFG           5220
#define NET_DVR_SET_ALARM_PROCESS_CFG           5221
#define NET_DVR_GET_BLACKLIST_ALARM_INFO        5222
#define NET_DVR_GET_STORAGE_RESOURCE_CFG        5225
#define NET_DVR_SET_STORAGE_RESOURCE_CFG        5226
#define NET_DVR_DEL_BLACKLIST_ALARM_RECORD        5227
#define NET_DVR_SET_BLACKLIST_GROUP_INFO        5229
#define NET_DVR_DEL_BLACKLIST_GROUP_INFO        5230
#define NET_DVR_GET_BLACKLIST_GROUP_INFO        5231
#define NET_DVR_SET_BLACKLIST_GROUP_RECORD_CFG    5232
#define NET_DVR_GET_BLACKLIST_GROUP_RECORD_CFG    5234
#define NET_DVR_DEL_BLACKLIST_GROUP_RECORD_CFG    5235
#define    NET_DVR_GET_AREA_MONITOR_CFG            5236
#define    NET_DVR_SET_AREA_MONITOR_CFG            5237
#define    NET_DVR_DEL_AREA_MONITOR_CFG            5238
#define NET_DVR_RETRIEVAL_SNAP_RECORD            5240
#define NET_DVR_GET_ALARMLIST                    5241
#define NET_DVR_DETECT_IMAGE                    5242
#define NET_DVR_GET_SNAP_RECORD                 5243
#define NET_DVR_DEL_SNAP_RECORD                 5244
#define NET_DVR_GET_FACE_RECORD                 5245
#define NET_DVR_SET_FACE_RECORD                    5246
#define NET_DVR_DEL_FACE_RECORD                    5247
#define NET_DVR_GET_FACE_DATABASE                5248
#define NET_DVR_SET_FACE_DATABASE                5249
#define NET_DVR_DEL_FACE_DATABASE                5250
#define NET_DVR_RETRIEVAL_FACE_DATABASE            5251
#define NET_DVR_SET_BLACKLIST_REL_DEV_CFG        5252
#define NET_DVR_DEL_BLACKLIST_REL_DEV            5253

//NVR which has 64 IPC: Get the information of disk raid.
#define NET_DVR_GET_DISK_RAID_INFO             6001       //Get the information of disk raid
#define NET_DVR_SET_DISK_RAID_INFO             6002       //Set the information of disk raid
#define NET_DVR_GET_DVR_SYNCHRONOUS_IPC      6005       //Set the parameter which is used to synchronise IPC.
#define NET_DVR_SET_DVR_SYNCHRONOUS_IPC      6006       //Get the parameter which is used to synchronise IPC.
#define NET_DVR_SET_DVR_IPC_PASSWD             6008        //Set the password of IPC.
#define NET_DVR_GET_DEVICE_NET_USING_INFO     6009        //Get the using information of device net.
#define NET_DVR_SET_DVR_IPC_NET              6012        //Set the IP of IPC.
#define NET_DVR_GET_RECORD_CHANNEL_INFO      6013        //Get record channel information
#define NET_DVR_SET_RECORD_CHANNEL_INFO      6014        //Set record channel information

#define NET_DVR_MOUNT_DISK                     6015       // Mount disk
#define NET_DVR_UNMOUNT_DISK                 6016       // Unmount disk

// CVR
#define NET_DVR_GET_STREAM_SRC_INFO             6017        //Get stream source information
#define NET_DVR_SET_STREAM_SRC_INFO             6018        //Set stream source information
#define NET_DVR_GET_STREAM_RECORD_INFO         6019        //Get stream record information
#define NET_DVR_SET_STREAM_RECORD_INFO         6020        //Set stream record information
#define NET_DVR_GET_STREAM_RECORD_STATUS     6021        //Get stream record status
#define NET_DVR_SET_STREAM_RECORD_STATUS     6022        //Set stream record status
#define NET_DVR_GET_STREAM_INFO                 6023        //Get stream ID info
#define NET_DVR_GET_STREAM_SRC_INFO_V40         6024       //Get stream source information Expend
#define NET_DVR_SET_STREAM_SRC_INFO_V40       6025       //Set stream source information Expend
#define NET_DVR_GET_RELOCATE_INFO            6026       //Get N+0 relocate info
#define NET_DVR_START_GOP_INFO_PASSBACK      6032       //VCA or Smart Info Pass Back
#define NET_DVR_GET_CHANS_RECORD_STATUS_CFG  6035       //Get Chan Record Status
#define NET_DVR_SET_CHANS_RECORD_STATUS_CFG  6036       //Set Chan Record Status


//NVR\A3\BA96xx
#define NET_DVR_GET_IP_ALARM_GROUP_NUM         6100
#define NET_DVR_GET_IP_ALARM_IN                 6101
#define NET_DVR_GET_IP_ALARM_OUT             6102
//9000 v2.2
#define NET_DVR_GET_FTPCFG_SECOND             6103          //Get FTP parameter to which upload the picture
#define NET_DVR_SET_FTPCFG_SECOND             6104          //Set FTP parameter to which upload the picture

#define NET_DVR_GET_DEFAULT_VIDEO_EFFECT     6105        //Get default video effect
#define NET_DVR_SET_VIDEO_EFFECT             6106       //Set video effect

#define NET_DVR_DEL_INVALID_DISK             6107       // Delete invalid disk

#define NET_DVR_GET_DRAWFRAME_DISK_QUOTA_CFG 6109        //Get disk quota of frame extracting channel
#define NET_DVR_SET_DRAWFRAME_DISK_QUOTA_CFG 6110        //Set disk quota of frame extracting channel

#define NET_DVR_GET_NAT_CFG                  6111       //Get NAT parameter
#define NET_DVR_SET_NAT_CFG                  6112       //Set NAT parameter

#define NET_DVR_GET_AES_KEY                  6113       //Get device's AES key

#define NET_DVR_GET_POE_CFG                  6114        //Get POE parameter
#define NET_DVR_SET_POE_CFG                  6115        //Set POE parameter

#define NET_DVR_GET_CUSTOM_PRO_CFG           6116        //Get customized protocol parameter
#define NET_DVR_SET_CUSTOM_PRO_CFG           6117        //Set customized protocol parameter

#define NET_DVR_GET_STREAM_CABAC             6118        //Get Stream CABAC
#define NET_DVR_SET_STREAM_CABAC             6119        //Set Stream CABAC

#define NET_DVR_GET_ESATA_MINISAS_USAGE_CFG     6120        //Get eSATA & miniSAS usage
#define NET_DVR_SET_ESATA_MINISAS_USAGE_CFG     6121        //Set eSATA & miniSAS usage

#define NET_DVR_GET_HDCFG_V40                 6122        //Get hard disk info
#define NET_DVR_SET_HDCFG_V40                 6123        //Set hard disk info

#define NET_DVR_GET_POE_CHANNEL_ADD_MODE     6124        //Get POE channel add mode
#define NET_DVR_SET_POE_CHANNEL_ADD_MODE     6125        //Set POE channel add mode

#define NET_DVR_GET_DIGITAL_CHANNEL_STATE    6126        //Get digital channel state


#define   NET_DVR_GET_BONJOUR_CFG           6127
#define   NET_DVR_SET_BONJOUR_CFG           6128


#define NET_DVR_GET_SOCKS_CFG                6130
#define NET_DVR_SET_SOCKS_CFG                  6131

#define    NET_DVR_GET_QOS_CFG                    6132
#define NET_DVR_SET_QOS_CFG                    6133

#define NET_DVR_GET_HTTPS_CFG                6134
#define NET_DVR_SET_HTTPS_CFG                6135

#define NET_DVR_GET_WD1_CFG                 6136     //get WD1 Enable status
#define NET_DVR_SET_WD1_CFG                 6137     //set WD1 Enable status

#define NET_DVR_CREATE_CERT                 6138
#define NET_DVR_DELETE_CERT                 6139


#define NET_DVR_GET_RECORD_LOCK_PERCENTAGE    6140        //Get record lock percentage
#define NET_DVR_SET_RECORD_LOCK_PERCENTAGE  6141        //Set record lock percentage

#define NET_DVR_CMD_TRIGGER_PERIOD_RECORD    6144        //Comand trigger period record
#define NET_DVR_UPLOAD_CERT                 6145
#define NET_DVR_DOWNLOAD_CERT               6146
#define NET_DVR_GET_CERT                    6147

#define NET_DVR_GET_POS_FILTER_CFG                6148    //Get POS Filter Cfg
#define NET_DVR_SET_POS_FILTER_CFG                6149    //Set POS Filter Cfg
#define NET_DVR_GET_CONNECT_POS_CFG                6150    //Get DVR and POS Connect Cfg
#define NET_DVR_SET_CONNECT_POS_CFG                6151    //Set DVR and POS Connect Cfg
#define NET_DVR_GET_CHAN_FILTER_CFG                6152    //Get Filter and Channel Relationship
#define NET_DVR_SET_CHAN_FILTER_CFG                6153    //Set Filter and Channel Relationship


#define NET_DVR_GET_FTPCFG_V40                6162    //Get FTP information
#define NET_DVR_SET_FTPCFG_V40                6163    //Set FTP information

#define NET_DVR_GET_MONTHLY_RECORD_DISTRIBUTION 6164
#define NET_DVR_GET_ACCESS_DEVICE_CHANNEL_INFO  6165
#define NET_DVR_GET_PREVIEW_SWITCH_CFG            6166
#define NET_DVR_SET_PREVIEW_SWITCH_CFG            6167

//Netra3.0.0
#define NET_DVR_GET_N_PLUS_ONE_WORK_MODE            6168    //Get N+1 work mode
#define NET_DVR_SET_N_PLUS_ONE_WORK_MODE            6169    //Set N+1 work mode

#define NET_DVR_GET_HD_STATUS                         6170    //Get HD status
#define NET_DVR_SET_HD_STATUS                         6171    //Set HD status

#define NET_DVR_IMPORT_IPC_CFG_FILE                    6172    //Import ip access config file
#define NET_DVR_EXPORT_IPC_CFG_FILE                    6173    //Export ip access config file
#define NET_DVR_UPGRADE_IPC                            6174    //Upgrade ip channel

#define NET_DVR_GET_RAID_BACKGROUND_TASK_SPEED        6175
#define NET_DVR_SET_RAID_BACKGROUND_TASK_SPEED        6176



//marvell 256 NVR
#define NET_DVR_GET_EXCEPTIONCFG_V40                6177    //Get Exception Cfg
#define NET_DVR_SET_EXCEPTIONCFG_V40                6178    //Set Exception Cfg
#define NET_DVR_GET_PICCFG_V40                      6179    //Get Picture Param Cfg
#define NET_DVR_SET_PICCFG_V40                      6180    //Set Picture Param Cfg
#define NET_DVR_GET_ALARMINCFG_V40                  6181    //Get AlarmIn Cfg
#define NET_DVR_SET_ALARMINCFG_V40                  6182    //Set AlarmIn Cfg
#define NET_DVR_GET_IPALARMINCFG_V40                6183    //Get IP AlarmIn Cfg
#define NET_DVR_GET_IPALARMOUTCFG_V40               6185    //Set IP AlarmIn Cfg
#define NET_DVR_GET_USERCFG_V40                     6187    //Get User Cfg
#define NET_DVR_SET_USERCFG_V40                     6188    //Set User Cfg
#define NET_DVR_GET_WORK_STATUS                     6189    //Get Device Work Status
#define NET_DVR_GET_JPEG_CAPTURE_CFG_V40            6190    //Get JPEG Capture Cfg
#define NET_DVR_SET_JPEG_CAPTURE_CFG_V40            6191    //Set JPEG Capture Cfg
#define NET_DVR_GET_HDGROUP_CFG_V40                 6192    //Get HD Group Cfg
#define NET_DVR_SET_HDGROUP_CFG_V40                 6193    //Set HD Group Cfg
#define NET_DVR_GET_SMD_HOLIDAY_HANDLE              6194    //Get SMD holiday handle cfg
#define NET_DVR_SET_SMD_HOLIDAY_HANDLE              6195    //Set SMD holiday handle cfg
#define NET_DVR_GET_PIC_MODEL_CFG                   6196    //Get picture model cfg
#define NET_DVR_SET_PIC_MODEL_CFG                   6197    //Set picture model cfg
#define NET_DVR_START_LOCAL_MOUSE_EVENT             6198
#define NET_DVR_START_SIMULARE_MOUSE_EVENT          6199
#define NET_DVR_GET_ACCESS_CAMERA_INFO        6201        // Get access camera information
#define NET_DVR_SET_ACCESS_CAMERA_INFO      6202        // Set access camera information
#define NET_DVR_PULL_DISK                    6203        // Pull disk
#define NET_DVR_SCAN_RAID                    6204        // Scan raid

// CVR 2.0.X
#define NET_DVR_GET_USER_RIGHT_CFG                6210        // Get user right
#define NET_DVR_SET_USER_RIGHT_CFG                6211        // Set user right

#define NET_DVR_ONE_KEY_CONFIG                    6212        // CVR One key config
#define NET_DVR_RESTART_SERVICE                    6213        // Restart service

#define NET_DVR_GET_MAX_MACHINE_NUM_CFG            6214        // Get max machine
#define NET_DVR_SET_MAX_MACHINE_NUM_CFG            6215        // Set max machine

#define NET_DVR_ADD_DEVICE                        6216        //N+1 Add device
#define NET_DVR_DEL_DEVICE                        6217        //N+1 Del device

#define NET_DVR_GET_DATA_CALLBACK_CFG            6218        // Get data callback config
#define NET_DVR_SET_DATA_CALLBACK_CFG            6219        // Set data callback config

#define NET_DVR_CLONE_LUN                        6220    //Clone Lun
#define NET_DVR_EXPAND_LUN                        6221    //Expand Lun

#define NET_DVR_GET_N_PLUS_ONE_DEVICE_INFO        6222    //Get N+1 device infomation
#define NET_DVR_MODIFY_DVR_NET_DISK                6223    //Mod DVR net disk
//#define NET_DVR_DEL_DVR_NET_DISK                6224    //Delete DVR net disk

#define NET_DVR_CREATE_NAS                        6225    //Create NAS
#define NET_DVR_DELETE_NAS                        6226    //Delete NAS

#define NET_DVR_OPEN_ISCSI                         6227    //Open iSCSI
#define NET_DVR_CLOSE_ISCSI                        6228    //Close iSCSI

#define NET_DVR_GET_FC                            6229    //Get FC info
#define NET_DVR_OPEN_FC                             6230    //Open FC
#define NET_DVR_CLOSE_FC                         6231    //Close FC

#define NET_DVR_ONE_KEY_CONFIG_SAN                6232  // One key config SAN

//CVR2.3.2

#define NET_DVR_RECORD_CHECK                        6233  //check record integrity
#define NET_DVR_ADD_RECORD_PASSBACK_TASK_MANUAL        6234  //add record passback task
#define NET_DVR_GET_ALL_RECORD_PASSBACK_TASK_MANUAL    6235  //get all record passback task
#define NET_DVR_RECORD_PASSBACK_TASK_MANUAL_CTRL    6236  //record passback control
#define NET_DVR_DEL_RECORD_PASSBACK_TASK_MANUAL        6237  //delete record passback task
#define NET_DVR_GET_RECORD_PASSBACK_PLAN_CFG        6238  //get reocrd passback plan config
#define NET_DVR_SET_RECORD_PASSBACK_PLAN_CFG        6239  //set reocrd passback plan config
#define NET_DVR_GET_DEV_STORAGE_CFG                    6240  //get device storage config
#define NET_DVR_GET_ONLINE_USER_CFG                    6241  //get online user config
#define NET_DVR_GET_RECORD_SEGMENT_CFG                6242  //get all record segment

#define NET_DVR_GET_REC_PASSBACK_TASK_EXECUTABLE    6243    //search manual passback task executable
#define NET_DVR_GET_STREAM_MEDIA_CFG                6244    //get record passback by stream config\A3\A8stream ID\A3\A9
#define NET_DVR_SET_STREAM_MEDIA_CFG                6245    //set record passback by stream config\A3\A8stream ID\A3\A9
#define NET_DVR_GET_USERCFG_V50                     6246  //get User config V50
#define NET_DVR_SET_USERCFG_V50                     6247  //set User config V50

#define NET_DVR_GET_RECORD_PASSBACK_BASIC_CFG_CAP	6248  //get ability to function based configuration CVR comes back
#define NET_DVR_GET_RECORD_PASSBACK_BASIC_CFG		6249  //get CVR back function based configuration
#define NET_DVR_SET_RECORD_PASSBACK_BASIC_CFG		6250  //set CVR back function based configuration
#define NET_DVR_ONE_KEY_CONFIG_V50			        6251  //one key configuration CVR (V50)
#define NET_DVR_GET_RACM_CAP						6252  //get the total capacity (RACM)
#define NET_DVR_GET_THUMBNAILS						6253  //download time interval thumbnail (support flow ID)
#define NET_DVR_ADD_RECORD_PASSBACK_TASK_MANUAL_V50		6254  //add record passback task (V50)
#define NET_DVR_GET_RECORD_PASSBACK_HISTORY_PLAN_CFG_CAP	6255  //Get CVR back history record planning ability
#define NET_DVR_GET_RECORD_PASSBACK_HISTORY_PLAN_CFG		6256  //Get CVR back history record planning configuration
#define NET_DVR_SET_RECORD_PASSBACK_HISTORY_PLAN_CFG		6257  //Set CVR back history record planning configuration


#define NET_DVR_GET_RECORD_PACK			     	6301    //Get video package parameters
#define NET_DVR_SET_RECORD_PACK				    6302    //Set video package parameters
#define NET_DVR_GET_CLOUD_STORAGE_CFG           6303 	//Get Dev Cur Work Mode
#define NET_DVR_SET_CLOUD_STORAGE_CFG           6304    //Set Dev Cur Work Mode
#define NET_DVR_GET_GOP_INFO                    6305    //Get GOP Info
#define NET_DVR_GET_PHY_DISK_INFO               6306    //Get physical disk info

#define NET_DVR_GET_RECORDING_AUTO_TRACK_CFG    6307    //Get SDI config
#define NET_DVR_SET_RECORDING_AUTO_TRACK_CFG    6308    //Set SDI config

#define NET_DVR_GET_RECORDING_PUBLISH_CFG        6309  //Get one key publish info
#define NET_DVR_SET_RECORDING_PUBLISH_CFG        6310  //Set one key publish info

#define NET_DVR_RECORDING_ONEKEY_CONTROL        6311  //recording host control

#define NET_DVR_GET_RECORDING_END_TIME        6312  //get recording remaining time

#define NET_DVR_RECORDING_PUBLISH                6313  //one key publish record

#define NET_DVR_GET_CURRICULUM_CFG            6314    //Get course config
#define NET_DVR_SET_CURRICULUM_CFG            6315    //Set course config

#define NET_DVR_GET_COURSE_INDEX_CFG        6316    //Get course index
#define NET_DVR_SET_COURSE_INDEX_CFG        6317  //Set course index

#define    NET_DVR_GET_PPT_CHANNEL                6318    //get PPT channel
#define    NET_DVR_GET_PPT_DETECT_CFG            6319    //get PPT detect param
#define    NET_DVR_SET_PPT_DETECT_CFG            6320    //set PPT detect param

#define NET_DVR_GET_RECORDINGHOST_CFG        6321    //Get record host config
#define NET_DVR_SET_RECORDINGHOST_CFG        6322    //Set record host config
#define NET_DVR_GET_BACKUP_RECORD_CFG           6323    //Get backup record Cfg
#define NET_DVR_SET_BACKUP_RECORD_CFG           6324    //Set backup record Cfg


#define NET_DVR_GET_AUDIO_ACTIVATION_CFG        6326    //get audio activation cfg
#define NET_DVR_SET_AUDIO_ACTIVATION_CFG        6327    //set audio activation cfg
#define NET_DVR_GET_DECODERCFG_V40              6328    //get decodercfg v40
#define NET_DVR_SET_DECODERCFG_V40                6329    //set decodercfg v40

#define NET_DVR_INFRARED_OUTPUT_CONTROL         6330   //infrared output control
#define NET_DVR_GET_INFRARED_CMD_NAME_CFG       6331   //get infrared cmd name cfg
#define NET_DVR_SET_INFRARED_CMD_NAME_CFG       6332   //set infrared cmd name cfg
#define NET_DVR_START_INFRARED_LEARN            6333   //infrared learn
#define NET_DVR_GET_TRIAL_SYSTEM_CFG            6334   //get trial system cfg
#define NET_DVR_SET_CASE_INFO                    6335    //case info
#define NET_DVR_GET_TRIAL_MICROPHONE_STATUS        6336  //get microphone status
#define NET_DVR_SET_TRIAL_MICROPHONE_STATUS        6337  //set microphone status
#define NET_DVR_GET_TRIAL_HOST_STATUS            6338  //get trial host status
#define NET_DVR_GET_LAMP_OUT                    6339  //get lamp out
#define NET_DVR_SET_LAMP_OUT                    6340  //set lamp out
#define NET_DVR_LAMP_REMOTE_CONTROL                6341  // LAMP control
#define NET_DVR_REMOTE_CONTROL_PLAY                6342  //remote control
#define NET_DVR_GET_LOCAL_INPUT_CFG                6343  //get local input cfg
#define NET_DVR_SET_LOCAL_INPUT_CFG                6344  //set local input cfg
#define NET_DVR_GET_CASE_INFO                    6345  //get case info

#define NET_DVR_INQUEST_GET_CDW_STATUS         6350
#define NET_DVR_GET_MIX_AUDIOIN_CFG             6351  //Get mix audioin Cfg
#define NET_DVR_SET_MIX_AUDIOIN_CFG             6352  //Set mix audioin Cfg
#define NET_DVR_GET_MIX_AUDIOOUT_CFG            6353  //Get mix audioout Cfg
#define NET_DVR_SET_MIX_AUDIOOUT_CFG            6354  //Set mix audioout Cfg
#define NET_DVR_GET_AUDIOIN_VOLUME_CFG          6355  //Get AudioIn Volume Cfg
#define NET_DVR_SET_AUDIOIN_VOLUME_CFG          6356  //Set AudioIn Volume Cfg
#define NET_DVR_GET_AREA_MASK_CFG               6357  //Get Mask Area Cfg
#define NET_DVR_SET_AREA_MASK_CFG               6358  //Set Mask Area Cfg
#define NET_DVR_GET_AUDIO_DIACRITICAL_CFG       6359  //Get Audio Diacritical Cfg
#define NET_DVR_SET_AUDIO_DIACRITICAL_CFG       6360  //Set Audio Diacritical Cfg
#define NET_DVR_GET_WIFI_DHCP_ADDR_CFG          6361  //Get WIFI DHCP addr Cfg
#define NET_DVR_SET_WIFI_DHCP_ADDR_CFG          6362  //Set Get WIFI DHCP addr
#define NET_DVR_GET_WIFI_CLIENT_LIST_INFO       6363  //Get Wifi Client List
#define NET_DVR_REMOTECONTROL_POWER_ON            6364  //remote  control power on
#define NET_DVR_GET_MULTISTREAM_RELATION_CHAN_CFG      6365  //Get Multi Stream relate Channel Cfg
#define NET_DVR_SET_MULTISTREAM_RELATION_CHAN_CFG     6366  //Set Multi Stream relate Channel Cfg
#define NET_DVR_GET_VIDEOOUT_RESOLUTION_CFG        6367  //Get Local videoout resolution Cfg
#define NET_DVR_SET_VIDEOOUT_RESOLUTION_CFG        6368  //Set Local videoout resolution Cfg
#define NET_DVR_GET_AUDIOOUT_VOLUME_CFG         6369 //Get AudioOut Volume Cfg
#define NET_DVR_SET_AUDIOOUT_VOLUME_CFG         6370 //Set AudioOut Volume Cfg
#define NET_DVR_INQUEST_PAUSE_CDW               6371  //pause CDW
#define NET_DVR_INQUEST_RESUME_CDW              6372  //Resume CDW
#define NET_DVR_GET_INPUT_CHAN_CFG              6373  //Get Input Channel Cfg
#define NET_DVR_SET_INPUT_CHAN_CFG              6374  //Set Input Channel Cfg

#define NET_DVR_GET_INQUEST_MIX_AUDIOIN_CFG        6375    //Get inquest mix audioIn Cfg
#define NET_DVR_SET_INQUEST_MIX_AUDIOIN_CFG        6376    //Set inquest mix audioIn Cfg
#define    NET_DVR_CASE_INFO_CTRL                    6377    //case info control
#define NET_DVR_GET_INQUEST_USER_RIGHT            6378    //Get inquest user right Cfg
#define NET_DVR_SET_INQUEST_USER_RIGHT            6379    //Set inquest user right Cfg
#define NET_DVR_GET_INQUEST_CASE_INFO            6380    //Get inquest case info
#define NET_DVR_SET_INQUEST_CASE_INFO            6381    //Set inquest case info

#define    NET_DVR_GET_FILM_MODE_CFG               6387    //Get Film Mode Cfg
#define    NET_DVR_SET_FILM_MODE_CFG               6388    //Set Film Mode Cfg
#define    NET_DVR_GET_FILM_MODE_CFG_CAP            6389    //Set Film Mode Capabilities

#define    NET_DVR_GET_DIRECTED_STRATEGY_CFG       6390    //Get Directed Strategy Cfg
#define    NET_DVR_SET_DIRECTED_STRATEGY_CFG        6391    //Set Directed Strategy Cfg
#define    NET_DVR_GET_DIRECTED_STRATEGY_CFG_CAP    6392    //Get Directed Strategy Capabilities
#define    NET_DVR_GET_FRAME_CFG                    6393    //Get Frame Cfg
#define    NET_DVR_SET_FRAME_CFG                    6394    //Set Frame Cfg
#define    NET_DVR_GET_FRAME_CFG_CAP                6395    //Get Frame Capabilities

#define    NET_DVR_GET_AUDIO_EFFECTIVE_CFG            6396    //Get Audio Effective Cfg
#define    NET_DVR_SET_AUDIO_EFFECTIVE_CFG            6397    //Set Audio Effective Cfg
#define    NET_DVR_GET_AUDIO_EFFECTIVE_CFG_CAP        6398    //Get Audio Effective Capabilities
#define    NET_DVR_GET_RECORD_VIDEO_CFG              6399    //Get Record Video Cfg
#define    NET_DVR_SET_RECORD_VIDEO_CFG            6400    //Set Record Video Cfg


#define NET_DVR_GET_OUTPUT_CFG              6401       //get output config
#define NET_DVR_SET_OUTPUT_CFG              6402       //set output config
#define NET_DVR_CODER_DISPLAY_START         6403       //start display
#define NET_DVR_CODER_DISPLAY_STOP          6404       //stop display
#define NET_DVR_GET_WINDOW_STATUS           6405       //get display window status

#define NET_DVR_GET_VQD_LOOP_DIAGNOSE_CFG   6406        //Get VQD Loop Diagnose Cfg
#define NET_DVR_SET_VQD_LOOP_DIAGNOSE_CFG   6407        //Set VQD Loop Diagnose Cfg
#define NET_DVR_GET_VQD_DIAGNOSE_INFO       6408        //Manually get VQD diagnose info

#define    NET_DVR_RECORDING_PUBLISH_FILE            6421        //Set Recording Publish File
#define    NET_DVR_GET_RECORDING_PUBLISH_FILE_CAP    6422        //Get Recording Publish File Capabilities
#define    NET_DVR_GET_PUBLISH_PROGRESS            6423           //Get Publish Progress
#define    NET_DVR_GET_RECORD_VIDEO_CFG_CAP    6424        //Get Record Video Capabilities
#define    NET_DVR_GET_RTMP_CFG                6425        //Get RTMP Cfg
#define    NET_DVR_SET_RTMP_CFG                6426        //Set RTMP Cfg
#define    NET_DVR_GET_RTMP_CFG_CAP            6427        //Get RTMP Capabilities
#define    NET_DVR_DEL_BACKGROUND_PIC                6428        //Delect BackGround Picture
#define    NET_DVR_GET_BACKGROUND_PIC_CFG            6429    //Get BackGround Picture
#define    NET_DVR_GET_BACKGROUND_PIC_INFO            6430        //Get BackGround Picture Info
#define    NET_DVR_SET_BACKGROUND_PIC_INFO            6431        //Set BackGround Picture Info
#define    NET_DVR_GET_BACKGROUND_PIC_INFO_CAP      6432           //Get BackGround Picture Info Capabilities
#define    NET_DVR_GET_RECORD_HOST_CAP                6433        //Get Record Host Capabilities
#define NET_DVR_GET_COURSE_LIST                 6434    //get course list
#define    NET_DVR_GET_RECORD_STATUS                6435 //get record status
#define    NET_DVR_MANUAL_CURRICULUM_CONTROL        6436    //manual curriculum control
#define    NET_DVR_GET_IMAGE_DIFF_DETECTION_CFG        6437    //get image diff detection cfg
#define    NET_DVR_SET_IMAGE_DIFF_DETECTION_CFG        6438    //set image diff detection cfg
#define    NET_DVR_GET_IMAGE_DIFF_DETECTION_CFG_CAP    6439    //get image diff detection cfg Capabilities
#define    NET_DVR_GET_RECORDING_PUBLISH_FILE_INFO    6440    //get recording publish file cfg
#define    NET_DVR_SET_RECORDING_PUBLISH_FILE_INFO    6441    //set recording publish file cfg
#define    NET_DVR_GET_RECORDING_PUBLISH_FILE_INFO_CAP        6442    //get recording publish file cfg Capabilities
#define    NET_DVR_MANUAL_CURRICULUM_CONTROL_CAP        6443    //get manual curriculum control Capabilities
#define NET_DVR_GET_STATISTIC_DATA_LIST             6444    //get list statistics

#define    NET_DVR_GET_DEVICE_LAN_ENCODE        6501        //get device language encode format
#define NET_DVR_GET_GBT28181_SERVICE_CFG        6503    //Get GB28181 Server Cfg
#define NET_DVR_SET_GBT28181_SERVICE_CFG        6504    //Set GB28181 Server Cfg
#define NET_DVR_GET_GBT28181_SERVICE_CAPABILITIES 6505  //Get GB28181 Server Capabilities

#define NET_DVR_GET_CLOUD_URL               6506    //get cloud storage url
#define NET_DVR_GET_CLOUD_URL_CAP           6507    //get cloud storage url-ability
#define NET_DVR_GET_CLOUD_CFG               6508    //get cloud storage configure parameter
#define NET_DVR_SET_CLOUD_CFG               6509    //set cloud storage configure parameter
#define NET_DVR_GET_CLOUD_CFG_CAP           6510    //get cloud storage configure parameter-ability
#define NET_DVR_GET_CLOUD_UPLOADSTRATEGY    6511    //get cloud storage upload strategy
#define NET_DVR_SET_CLOUD_UPLOADSTRATEGY    6512    //set cloud storage upload strategy
#define NET_DVR_GET_CLOUDSTORAGE_UPLOADSTRATEGY_CAP     6513    //cloud storage upload strategy-ability

#define    NET_DVR_GET_VIDEO_IMAGE_DB_CFG        6601        //Get Video Image DB CFG
#define    NET_DVR_SET_VIDEO_IMAGE_DB_CFG        6602        //Set Video Image DB CFG
#define    NET_DVR_GET_VIDEO_IMAGE_DB_CFG_CAP    6603        //Get Video Image DB CFG Capabilities
#define    NET_DVR_GET_FILE_INFO_BY_ID            6604        //Get File Info
#define    NET_DVR_QUERY_FILE_INFO_CAP            6605        //Get File Info Capabilities
#define    NET_DVR_DEL_FILE_FROM_DB            6606        //Del File From DB
#define    NET_DVR_GET_VIDEO_IMAGE_DB_CAP        6607        //Get Video All Capabilities

#define NET_DVR_GET_FIGURE	                6610        //Get Figure picture

#define    NET_DVR_SYNC_IPC_PASSWD                  6621    //Sync IPC PASSWORD
#define    NET_DVR_GET_VEHICLE_BLACKLST_SCHEDULE 6622    //Get Blacklist schedule
#define    NET_DVR_SET_VEHICLE_BLACKLST_SCHEDULE 6623    //Set Blacklist schedule
#define    NET_DVR_GET_VEHICLE_WHITELST_SCHEDULE 6624    //Get Whitelist schedule
#define    NET_DVR_SET_VEHICLE_WHITELST_SCHEDULE 6625    //Set Whitelist schedule

#define    NET_DVR_GET_VEHICLE_BLACKLIST_EVENT_TRIGGER     6626    //Get black list event
#define    NET_DVR_SET_VEHICLE_BLACKLIST_EVENT_TRIGGER     6627    //Set black list event

#define    NET_DVR_GET_VEHICLE_WHITELIST_EVENT_TRIGGER     6628    //Get white list event
#define    NET_DVR_SET_VEHICLE_WHITELIST_EVENT_TRIGGER     6629    //Set white list event


#define    NET_DVR_GET_TRAFFIC_CAP                         6630    //Get traffic cap
#define    NET_DVR_GET_VEHICLE_ALLLIST_EVENT_TRIGGER     6631    //Get All VehicleList Event Trigger Cfg
#define    NET_DVR_SET_VEHICLE_ALLLIST_EVENT_TRIGGER     6632    //Set All VehicleList Event Trigger Cfg
#define    NET_DVR_GET_VEHICLE_OTHERLIST_EVENT_TRIGGER     6633    //Get Other VehicleList Event Trigger Cfg
#define    NET_DVR_SET_VEHICLE_OTHERLIST_EVENT_TRIGGER     6634    //Set Other VehicleList Event Trigger Cfg

#define    NET_DVR_GET_STORAGEDETECTION_EVENT_TRIGGER     6635    //Get Storage Detection Event Trigger
#define    NET_DVR_SET_STORAGEDETECTION_EVENT_TRIGGER     6636    //Set Storage Detection Event Trigger
#define    NET_DVR_GET_STORAGEDETECTION_SCHEDULE_CAPABILITIES    6637    //Get Storage Detection Schedule Capabilities
#define    NET_DVR_GET_STORAGEDETECTION_SCHEDULE         6638    //Get Storage Detection Schedule
#define    NET_DVR_SET_STORAGEDETECTION_SCHEDULE         6639    //Set Storage Detection Schedule
#define    NET_DVR_GET_STORAGEDETECTION_STATE             6640    //Get Storage Detection State

#define    NET_DVR_GET_FACECAPTURE_EVENT_TRIGGER         6641    //Get Face Capture Event Trigger
#define    NET_DVR_SET_FACECAPTURE_EVENT_TRIGGER         6642    //Set Face Capture Event Trigger
#define    NET_DVR_GET_FACECAPTURE_SCHEDULE_CAPABILITIES 6643    //Get Face Capture Schedule Capabilities
#define    NET_DVR_GET_FACECAPTURE_SCHEDULE             6644    //Get Face Capture Schedule
#define    NET_DVR_SET_FACECAPTURE_SCHEDULE             6645    //Set Face Capture Schedule
#define    NET_DVR_GET_STORAGEDETECTION_RWLOCK             6646    //Get Storage Detection RwLock
#define    NET_DVR_GET_STORAGEDETECTION_RWLOCK_CAPABILITIES    6647    //Get Storage Detection RwLock Capabilities
#define    NET_DVR_SET_STORAGEDETECTION_RWLOCK             6648    //Set Storage Detection RwLock
#define    NET_DVR_GET_PTZTRACKSTATUS                     6649    //Get Ptz Track Status


#define    NET_DVR_SET_STORAGEDETECTION_UNLOCK             6653    //Set Storage Detection UnLock
#define    NET_DVR_GET_STORAGEDETECTION_UNLOCK_CAPABILITIES    6654    //Get Storage Detection UnLock Capabilities

#define    NET_DVR_SET_SHIPSDETECTION_CFG                 6655    //Set the ship detection parameter configuration
#define    NET_DVR_GET_SHIPSDETECTION_CFG                 6656    //Get ship detection parameter configuration
#define    NET_DVR_GET_SHIPSDETECTION_CAPABILITIES         6657    //Get ship detection parameters configuration ability
#define    NET_DVR_GET_SHIPSDETECTION_COUNT               6658    //Get ships counting information
#define    NET_DVR_SHIPSCOUNT_DELETE_CTRL                  6659   //Empty vessels counting information

#define    NET_DVR_GET_BAREDATAOVERLAY_CAPABILITIES     6660   //Get Bare Data Overlay Capablities
#define    NET_DVR_SET_BAREDATAOVERLAY_CFG                 6661    //Set Bare Data Overlay Cfg
#define    NET_DVR_GET_BAREDATAOVERLAY_CFG                 6662    //Get Bare Data Overlay Cfg
#define    NET_DVR_GET_SHIPSDETECTION_SCHEDULE             6663    //Get ship detection protection time configuration
#define    NET_DVR_SET_SHIPSDETECTION_SCHEDULE             6664    //Set the ship detection protection time configuration
#define NET_DVR_GET_SHIPSDETECTION_EVENT_TRIGGER     6665    //Get ships to detect linkage configuration
#define    NET_DVR_SET_SHIPSDETECTION_EVENT_TRIGGER     6666    //Set the ship detection linkage configuration
#define    NET_DVR_GET_SHIPSDETECTION_SCHEDULE_CAPABILITIES    6667    //Get ship detection protection time ability

#define    NET_DVR_FIRE_FOCUSZOOM_CTRL                  6670   //Fire Focus Zoom Ctrl
#define	NET_DVR_GET_FIREDETECTION_SCHEDULE_CAPABILITIES	6671 //Get fire detection protection time ability
#define	NET_DVR_GET_FIREDETECTION_SCHEDULE	6672	//Get fire detection protection time configuration
#define	NET_DVR_SET_FIREDETECTION_SCHEDULE	6673	//Set fire detection protection time configuration
#define    NET_DVR_GET_MANUALRANGING_CAPABILITIES    6675    //Get Manual Rangin Capbailities


#define    NET_DVR_SET_MANUALRANGING           6677        //Set Manual Rangin
#define    NET_DVR_GET_MANUALDEICING_CAPABILITIES    6678    //Get Manual Deicing capabilities
#define    NET_DVR_SET_MANUALDEICING           6679        //Set Manual Deicing
#define    NET_DVR_GET_MANUALDEICING           6680        //Get Manual Deicing

#define NET_DVR_GET_PTZABSOLUTEEX_CAPABILITIES  6695    //GET absolute PTZ ex cability
#define NET_DVR_GET_PTZABSOLUTEEX               6696    //GET absolute PTZ ex config
#define NET_DVR_SET_PTZABSOLUTEEX               6697    //SET absolute PTZ ex config

#define	NET_DVR_GET_CRUISE_CAPABILITIES              6698	//Get equipment cruise mode configuration
#define	NET_DVR_GET_CRUISE_INFO                      6699	//Get equipment cruise mode
#define	NET_DVR_GET_TEMP_HUMI_CAPABILITIES           6700	//Get temperature and humidity real-time ability
#define  NET_DVR_GET_TEMP_HUMI_INFO                  6701   //Get temperature and humidity real-time

#define	NET_DVR_GET_MANUALTHERM_INFO                 6706   //Get manual temperature measurement in real time
#define	NET_DVR_GET_MANUALTHERM_CAPABILITIES	     6707   //Get manual measuring temperature real-time ability
#define	NET_DVR_SET_MANUALTHERM                      6708 	//Set manual temperature measurement data

//NVR - 96000
#define	NET_DVR_GET_ACCESSORY_CARD_INFO_CAPABILITIES	6709 //Accessories plate information ability
#define	NET_DVR_GET_ACCESSORY_CARD_INFO		            6710 //For accessories plate information

#define	NET_DVR_GET_THERMINTELL_CAPABILITIES	        6711 //Get thermal intelligent configuration capbailities
#define	NET_DVR_GET_THERMINTELL                         6712 //Get thermal intelligent configuration parameters
#define	NET_DVR_SET_THERMINTELL                         6713 //Set thermal intelligent configuration parameters
#define NET_GET_CRUISEPOINT_V50                         6714     //Cruise Point V50
#define	NET_DVR_GET_MANUALTHERM_BASIC_CAPABILITIES	    6715   //Get temperature measuring basic parameters configuration manually
#define	NET_DVR_SET_MANUALTHERM_BASICPARAM              6716 	//Set the manual temperature measuring basic parameters
#define	NET_DVR_GET_MANUALTHERM_BASICPARAM              6717 	//Get the manual temperature measuring basic parameters

#define	NET_DVR_GET_FIRESHIELDMASK_CAPABILITIES	        6718

#define NET_DVR_GET_HIDDEN_INFORMATION_CAPABILITIES    6720 //The allocation of hidden information capacity
#define NET_DVR_GET_HIDDEN_INFORMATION                 6721 //get Hidden information parameters
#define NET_DVR_SET_HIDDEN_INFORMATION                 6722 //Set the hidden information parameters

#define	NET_DVR_SET_FIRESHIELDMASK_CFG                  6723
#define	NET_DVR_GET_FIRESHIELDMASK_CFG                  6724
#define	NET_DVR_GET_SMOKESHIELDMASK_CAPABILITIES	        6725
#define	NET_DVR_SET_SMOKESHIELDMASK_CFG                     6726
#define	NET_DVR_GET_SMOKESHIELDMASK_CFG                     6727

#define	NET_DVR_GET_AREASCAN_CAPABILITIES	              6728
#define	NET_DVR_SET_AREASCAN_CFG                          6729
#define	NET_DVR_GET_AREASCAN_CFG                          6730

#define	NET_DVR_DEL_AREASCAN_CFG                          6731
#define	NET_DVR_AREASCAN_INIT_CTRL                        6732
#define	NET_DVR_AREASCAN_CONFIRM_CTRL                     6733
#define	NET_DVR_AREASCAN_STOP_CTRL                        6734
#define	NET_DVR_SAVE_SCANZOOM_CTRL                        6735
#define	NET_DVR_GET_SCANZOOM_CTRL                         6736
#define	NET_DVR_DEL_FIRESHIELDMASK_CTRL                   6737
#define	NET_DVR_DEL_SMOKESHIELDMASK_CTRL                  6738

#define	NET_DVR_GET_DENSEFOG_EVENT_TRIGGER	 6740	//Get dense fog to detect linkage configuration
#define	NET_DVR_SET_DENSEFOG_EVENT_TRIGGER	 6741	//Set dense fog to detect linkage configuration
#define	NET_DVR_SET_DENSEFOGDETECTION_CFG	6742	//Get dense fog to detect parameters configuration
#define	NET_DVR_GET_DENSEFOGDETECTION_CFG	6743	//Set dense fog to detect parameters configuration
#define	NET_DVR_GET_DENSEFOGDETECTION_CAPABILITIES	6744	//Get dense fog to detect parameters configuration capacity

#define	NET_DVR_GET_THERMOMETRY_SCHEDULE_CAPABILITIES	6750 //Get Temperature detection protection time ability
#define	NET_DVR_GET_THERMOMETRY_SCHEDULE	6751	//Get Temperature detection protection time configuration
#define	NET_DVR_SET_THERMOMETRY_SCHEDULE	6752	//SetTemperature detection protection time configuration
#define	NET_DVR_GET_TEMPERTURE_SCHEDULE_CAPABILITIES	6753 //Get differential protection time ability
#define	NET_DVR_GET_TEMPERTURE_SCHEDULE	6754	//Get differential protection time configuration
#define	NET_DVR_SET_TEMPERTURE_SCHEDULE	6755	//SetDifferential protection time configuration
#define NET_DVR_GET_SEARCH_LOG_CAPABILITIES	    6756	//Log types support ability
#define	NET_DVR_GET_VEHICLEFLOW	6758	//Get vehicle flow configuration
#define NET_DVR_GET_IPADDR_FILTERCFG_V50		6759  //Get IP address filter configuration
#define NET_DVR_SET_IPADDR_FILTERCFG_V50	    6760  //Get IP address filter configuration
#define	NET_DVR_GET_TEMPHUMSENSOR_CAPABILITIES	6761//Get temperature and humidity sensor capabilities
#define	NET_DVR_GET_TEMPHUMSENSOR	6762	//Get temprature and humidity sensor configuration
#define	NET_DVR_SET_TEMPHUMSENSOR	6763	//Set temprature and humidity sensor configuration

#define NET_DVR_GET_MB_POWERCTRLPARA		    8000//get start control parm
#define	NET_DVR_SET_MB_POWERCTRLPARA		    8001//set start control parm
#define NET_DVR_GET_AUTOBACKUPPARA			    8002//get auto backup parm
#define NET_DVR_SET_AUTOBACKUPPARA			    8003//set auto backup parm
#define NET_DVR_GET_MB_GPSPARA				    8004//get GPS parm
#define NET_DVR_SET_MB_GPSPARA				    8005//set GPS parm
#define NET_DVR_GET_MB_SENSORINPARA			    8006//get SENSOR parm
#define NET_DVR_SET_MB_SENSORINPARA			    8007//set SENSOR parm
#define NET_DVR_GET_GSENSORPARA				    8008//get GSENSOR parm
#define NET_DVR_SET_GSENSORPARA				    8009//set GSENSORparm
#define NET_DVR_GET_MB_DOWNLOADSVRPARA		    8010//get load server parm
#define NET_DVR_SET_MB_DOWNLOADSVRPARA		    8011//set load server parm
#define NET_DVR_GET_PLATERECOG_PARA			    8012//get License plate recognition parm
#define NET_DVR_SET_PLATERECOG_PARA			    8013//set License plate recognition parm
#define NET_DVR_GET_ENFORCESYS_PARA			    8014//get Vehicle inspection parm
#define NET_DVR_SET_ENFORCESYS_PARA		    	8015//set Vehicle inspection parm
#define NET_DVR_GET_GPS_DATA					8016 //get GPS parm
#define NET_DVR_GET_ANALOG_ALARMINCFG			8017//get analog alarm in parm
#define NET_DVR_SET_ANALOG_ALARMINCFG			8018//set analog alarm in parm

#define NET_DVR_GET_SYSTEM_CAPABILITIES         8100 //Access to system capacity of the equipment
#define NET_DVR_GET_EAGLEEYE_CAPABILITIES       8101 //Acquire equipment eagle eye
#define NET_DVR_GET_SLAVECAMERA_CALIB_V51       8102    //get camera calibration configuration V51
#define NET_DVR_SET_SLAVECAMERA_CALIB_V51       8103    //set the camera calibration configuration V51
#define NET_DVR_SET_GOTOSCENE                   8105  //Set the main camera to the specified scenario ID

//I, K, E series NVR product upgrade
#define NET_DVR_GET_PTZ_NOTIFICATION        8201//Get multi-channel linkage PTZ events
#define NET_DVR_SET_PTZ_NOTIFICATION        8202//Set multi-channel linkage PTZ events
/*****************************video start****************************/
#define    NET_DVR_MATRIX_WALL_SET                    9001  //set video wall configuration
#define    NET_DVR_MATRIX_WALL_GET                    9002  //get video wall configuration
#define    NET_DVR_WALLWIN_GET                        9003  //get video wall window configuration
#define    NET_DVR_WALLWIN_SET                        9004  //set video wall window configuration
#define    NET_DVR_WALLWINPARAM_SET                9005  //set video wall related parameter
#define    NET_DVR_WALLWINPARAM_GET                9006  //get video wall related parameter
#define NET_DVR_WALLSCENEPARAM_GET                9007  //get scene parameter
#define NET_DVR_WALLSCENEPARAM_SET                9008  //set scene parameter
#define NET_DVR_MATRIX_GETWINSTATUS             9009  //get window decode status
#define    NET_DVR_GET_WINASSOCIATEDDEVINFO        9010  //get resource information associated with the window in video wall
#define    NET_DVR_WALLOUTPUT_GET                    9011  //get output configuration
#define    NET_DVR_WALLOUTPUT_SET                    9012  //set output configuration
#define NET_DVR_GET_UNITEDMATRIXSYSTEM          9013  //get video platform united system info
#define NET_DVR_GET_WALL_CFG                    9014  //get wall param
#define NET_DVR_SET_WALL_CFG                    9015  //set wall param
#define NET_DVR_CLOSE_ALL_WND                    9016  //close all window
#define NET_DVR_SWITCH_WIN_TOP                  9017  //move window to top layer
#define NET_DVR_SWITCH_WIN_BOTTOM               9018  //move window to bottom layer
#define    NET_DVR_CLOSE_ALL_WND_V41                9019  //close all windows in the wall
#define    NET_DVR_GET_WALL_WINDOW_V41                9020  //get windows in the wall
#define    NET_DVR_SET_WALL_WINDOW_V41                9021  //set windows in the wall
#define    NET_DVR_GET_CURRENT_SCENE_V41            9022  //get current scene
#define    NET_DVR_GET_WALL_SCENE_PARAM_V41        9023  //get wall scene
#define    NET_DVR_SET_WALL_SCENE_PARAM_V41        9024  //set wall scene
#define NET_DVR_GET_MATRIX_LOGO_CFG             9025  //set logo configuration
#define NET_DVR_SET_MATRIX_LOGO_CFG             9026  //get logo configuration
#define NET_DVR_GET_WIN_LOGO_CFG                9027  //get window logo configuration
#define NET_DVR_SET_WIN_LOGO_CFG                9028  //set window logo configuration
#define NET_DVR_DELETE_LOGO                     9029  //delete logo
#define NET_DVR_SET_DISPLAY_EFFECT_CFG            9030  //set display effect v41
#define NET_DVR_GET_DISPLAY_EFFECT_CFG            9031  //get display effect v41
#define NET_DVR_DEC_PLAY_REMOTE_FILE            9032  //decoder play remote file
#define NET_DVR_GET_WIN_ZOOM_STATUS             9033  //get window electronic enlargement status
#define NET_DVR_GET_ALL_MATRIX_LOGOCFG          9034  //get all logos' configuration
/*****************************video end******************************/

/***********************************LCD Screen begin********************************/
#define NET_DVR_SIMULATE_REMOTE_CONTROL         9035    //Simulate Remote Control 2013-09-05
#define NET_DVR_SET_SCREEN_SIGNAL_CFG			9036	//Set Screen Signal CFG
#define	NET_DVR_GET_SCREEN_SIGNAL_CFG			9037	//Get Screen Signal CFG
#define NET_DVR_SET_SCREEN_SPLICE_CFG  			9038	//Set Screen Splice CFG
#define	NET_DVR_GET_SCREEN_SPLICE_CFG			9039	//Get Screen Splice CFG
#define NET_DVR_GET_SCREEN_FAN_WORK_MODE 		9040	//Get Screen Fan Work Mode
#define NET_DVR_SET_SCREEN_FAN_WORK_MODE 		9041	//Set Screen Fan Work Mode
//#define NET_DVR_UPGRADE_LCD  					9042	//LCD Upgrade
#define NET_DVR_SHOW_SCREEN_WORK_STATUS  		9044	//Show Screen Work Status
#define NET_DVR_GET_VGA_CFG  					9045	//Get VGA
#define NET_DVR_SET_VGA_CFG  					9046	//Set VGA
#define NET_DVR_GET_SCREEN_MENU_CFG				9048    //Get Screen Menu
#define NET_DVR_SET_SCREEN_MENU_CFG  			9049	//Set Screen Menu
#define NET_DVR_SET_SCREEN_DISPLAY_CFG  	    9050	//set screen display CFG 2013-08-28
#define	NET_DVR_GET_SCREEN_DISPLAY_CFG	        9051	//get screen display CFG 2013-08-28
#define NET_DVR_SET_FUSION_CFG			        9052    //set picture fusion configuration
#define NET_DVR_GET_FUSION_CFG        	        9053    //get picture fusion configuration
#define NET_DVR_SET_PIP_CFG  					9060	//Set Pip Cfg
#define	NET_DVR_GET_PIP_CFG						9061	//Get Pip Cfg
#define NET_DVR_SET_DEFOG_LCD  					9073	//Set Defog
#define	NET_DVR_GET_DEFOG_LCD					9074	//Get Defog
#define NET_DVR_SHOW_IP  						9075	//Show IP
#define NET_DVR_SCREEN_MAINTENANCE_WALL			9076	//Screen Maintenance Wall
#define NET_DVR_SET_SCREEN_POS  				9077	//Set Screen Pos
#define	NET_DVR_GET_SCREEN_POS					9078	//Get Screen Pos
/***********************************LCD Screen end********************************/

/*******************************LCD Screen V1.2 begin******************************************/
#define    NET_DVR_SCREEN_INDEX_SET                9079    //Set screen index parameter
#define    NET_DVR_SCREEN_INDEX_GET                9080    //Get screen index parameter
#define NET_DVR_SCREEN_SPLICE_SET               9081    //Set screen splice parameter
#define NET_DVR_SCREEN_SPLICE_GET               9082    //Get screen splice parameter
#define NET_DVR_SET_SCREEN_PARAM                9083    //Set screen parameter
#define NET_DVR_GET_SCREEN_PARAM                9084    //Get screen parameter
#define NET_DVR_SET_SWITCH_CFG                  9085    //Set time switch parameter
#define NET_DVR_GET_SWITCH_CFG                  9086    //Get time switch parameter
#define NET_DVR_SET_POWERON_DELAY_CFG           9087    //Set delay power on parameter
#define NET_DVR_GET_POWERON_DELAY_CFG           9088    //Get delay power on parameter
#define    NET_DVR_SET_SCREEN_POSITION                9089    //Set screen position
#define    NET_DVR_GET_SCREEN_POSITION                9090    //Get screen position
#define NET_DVR_SCREEN_SCENE_CONTROL            9091    //Screen scene control
#define NET_DVR_GET_CURRENT_SCREEN_SCENE        9092    //Get current screen index
#define NET_DVR_GET_SCREEN_SCENE_PARAM          9093    //Get screen scene parameter
#define NET_DVR_SET_SCREEN_SCENE_PARAM          9094    //Set screen scene parameter
#define NET_DVR_GET_EXTERNAL_MATRIX_RELATION    9095    //Get the relation input and output between external matrix

/*******************************LCD Screen V1.2 end ******************************************/

#define     NET_DVR_GET_LCD_AUDIO_CFG            9096     //Get LCDScreen Audio
#define     NET_DVR_SET_LCD_AUDIO_CFG            9097     //Set LCDScreen Audio
#define     NET_DVR_GET_LCD_WORK_STATE            9098     //Get LCD work state
#define     NET_DVR_GET_BOOT_LOGO_CFG            9099    //Get boot logo
#define     NET_DVR_SET_BOOT_LOGO_CFG            9100    //Set boot logo


#define NET_DVR_GET_STREAM_DST_COMPRESSIONINFO    9101  //get target compression information
#define NET_DVR_SET_STREAM_DST_COMPRESSIONINFO  9102  //set target compression information
#define NET_DVR_GET_STREAM_TRANS_STATUS            9103  //get stream transcode status
#define NET_DVR_GET_DEVICE_TRANS_STATUS            9104  //get device transcode status
#define NET_DVR_GET_ALLSTREAM_SRC_INFO          9105  //get all stream source information
#define NET_DVR_GET_BIG_SCREEN_AUDIO            9106  //get big screen audio information
#define NET_DVR_SET_BIG_SCREEN_AUDIO            9107  //set big screen audio information
#define NET_DVR_GET_DEV_WORK_MODE                9108  //get transcode device work mode
#define NET_DVR_SET_DEV_WORK_MODE                9109  //set transcode device work mode
#define NET_DVR_APPLY_TRANS_CHAN                9110  //apply transcode channel by stream ID
#define NET_DVR_GET_DISPCHAN_CFG                9111  //get display channel configure batch
#define NET_DVR_SET_DISPCHAN_CFG                9112  //set display channel configure batch
#define NET_DVR_GET_DEC_CHAN_STATUS                9113  //get decode channel status
#define NET_DVR_GET_DISP_CHAN_STATUS            9114  //get display channel status
#define NET_DVR_GET_ALARMIN_STATUS                9115  //get alarm in status
#define NET_DVR_GET_ALARMOUT_STATUS                9116  //get alarm out status
#define NET_DVR_GET_AUDIO_CHAN_STATUS            9117  //get audio channel status

#define  NET_DVR_GET_VIDEO_AUDIOIN_CFG            9118   //get Audio video input parameters
#define  NET_DVR_SET_VIDEO_AUDIOIN_CFG            9119   //set Audio video input parameters

#define    NET_DVR_SET_BASEMAP_CFG                    9120  //set basemap config
#define NET_DVR_GET_BASEMAP_CFG                    9121  //get basemap config
#define NET_DVR_GET_VIRTUAL_SCREEN_CFG          9122  //get virtual screen config
#define NET_DVR_SET_VIRTUAL_SCREEN_CFG          9123  //set virtual screen config
#define NET_DVR_GET_BASEMAP_WIN_CFG                9124  //get basemap window config
#define NET_DVR_SET_BASEMAP_WIN_CFG                9125  //set basemap window config
#define NET_DVR_DELETE_PICTURE                    9126  //delete basemap picture
#define NET_DVR_GET_BASEMAP_PIC_INFO            9127  //get basemap picture information
#define    NET_DVR_SET_BASEMAP_WIN_CFG_V40         9128  //set base map window configuration V40
#define NET_DVR_GET_BASEMAP_WIN_CFG_V40         9129  //get base map window configuration V40

#define NET_DVR_GET_DEC_VCA_CFG                    9130    //get the vca alarm configure from decoder
#define NET_DVR_SET_DEC_VCA_CFG                    9131    //set the vca alarm configure from decoder

#define NET_DVR_SET_VS_INPUT_CHAN_INIT_ALL  9132  //Initializes the virtual screen all input channels
#define NET_DVR_GET_VS_INPUT_CHAN_INIT_ALL  9133  //Get virtual screen all input channels initialization parameters
#define NET_DVR_GET_VS_INPUT_CHAN_INIT 9134  //Get virtual screen a single input channel initialization parameters
#define NET_DVR_GET_VS_INPUT_CHAN_CFG  9135  //Get virtual screen input channel configuration parameters

#define NET_DVR_GET_TERMINAL_CONFERENCE_STATUS	9136
#define NET_DVR_GET_TERMINAL_INPUT_CFG_CAP		9137
#define NET_DVR_GET_TERMINAL_INPUT_CFG			9138
#define NET_DVR_SET_TERMINAL_INPUT_CFG			9139

#define NET_DVR_GET_CONFERENCE_REGION_CAP        9140
#define NET_DVR_GET_CONFERENCE_REGION            9141
#define NET_DVR_SET_CONFERENCE_REGION            9142
#define NET_DVR_GET_TERMINAL_CALL_CFG_CAP        9143
#define NET_DVR_GET_TERMINAL_CALL_CFG            9144
#define NET_DVR_SET_TERMINAL_CALL_CFG            9145
#define NET_DVR_GET_TERMINAL_CTRL_CAP            9146
#define NET_DVR_TERMINAL_CTRL                    9147
#define    NET_DVR_GET_CALL_QUERY_CAP                9148
#define NET_DVR_GET_CALLINFO_BY_COND            9149
#define    NET_DVR_SET_FUSION_SCALE                9150    //set camera fusion scale
#define NET_DVR_GET_FUSION_SCALE                9151    //get camera fusion scale
#define NET_DVR_GET_VCS_CAP                        9152
#define NET_DVR_GET_TERMINAL_GK_CFG_CAP            9153    //get terminal register GK abilities
#define NET_DVR_GET_TERMINAL_GK_CFG                9154    //get terminal terminal register gk parameter
#define NET_DVR_SET_TERMINAL_GK_CFG                9155    //set terminal register gk parameter
#define NET_DVR_GET_MCU_CONFERENCESEARCH_CAP    9156    //get MCU conference search abilities
#define NET_DVR_SET_VS_INPUT_CHAN_CFG  9157  //Set virtual screen input channel configuration parameters
#define NET_DVR_GET_VS_NETSRC_CFG      9158  //Get virtual screen network source parameters
#define NET_DVR_SET_VS_NETSRC_CFG      9159  //Set virtual screen network source parameters
#define	NET_DVR_GET_LLDP_CFG	                9160    //set LLDP parameter
#define	NET_DVR_SET_LLDP_CFG	                9161    //get LLDP parameter
#define NET_DVR_GET_LLDP_CAP	                9162    //get LLDP abilities
#define	NET_DVR_GET_FIBER_CONVERT_BASIC_INFO	9163    //get fiber basic information
#define	NET_DVR_GET_FIBER_CONVERT_WORK_STATE	9164    //get fiber work status
#define	NET_DVR_GET_FIBER_CONVERT_TOPOLOGY      9165    //get fiber topology
#define	NET_DVR_GET_FC_PORT_REMARKS	            9166    //get fiber port remarks
#define	NET_DVR_SET_FC_PORT_REMARKS	            9167    //set fiber port remarks
#define NET_DVR_GET_PORT_REMARKS_CAP	        9168    //get fiber port remarks abilities

#define NET_DVR_GET_MCU_CONFERENCECONTROL_CAP   9169    //get MCU conference control abilities
#define NET_DVR_GET_MCU_TERMINALCONTROL_CAP     9170    //get MCU terminal control abilities
#define NET_DVR_GET_MCU_TERIMINALGROUP_CAP      9171    //get MCU terminal group abilities
#define NET_DVR_GET_MCU_TERMINAL_CAP            9174    //get MCU terminal ability
#define NET_DVR_GET_MCU_CONFERENCE_CAP          9175    //get MCU conference ability
#define NET_DVR_GET_MCU_GK_CFG_CAP              9176    //get MCUGK config ability
#define NET_DVR_GET_MCU_GK_SERVER_CAP           9177    //get MCUGK server ability

#define NET_DVR_GET_EDID_CFG_FILE_INFO  9178  //get EDID file information
#define NET_DVR_GET_EDID_CFG_FILE_INFO_LIST  9179  //get EDID file information list
#define NET_DVR_SET_EDID_CFG_FILE_INFO  9180  //set EDID file information
#define NET_DVR_DEL_EDID_CFG_FILE_INFO  9181  //delete EDID file information (include file)
#define NET_DVR_GET_EDID_CFG_FILE_INFO_CAP  9182  //get EDID file information capabilities

#define NET_DVR_GET_SUBWND_DECODE_OSD  9183  //get information on child window decoding OSD
#define NET_DVR_GET_SUBWND_DECODE_OSD_ALL  9184  //get information on all child window decoding OSD
#define NET_DVR_SET_SUBWND_DECODE_OSD  9185  //set information on child window decoding OSD
#define NET_DVR_GET_SUBWND_DECODE_OSD_CAP  9186  //get information on child window decoding OSD capabilities
#define NET_DVR_GET_DECODE_CHANNEL_OSD  9187  //get decode channel OSD info
#define NET_DVR_SET_DECODE_CHANNEL_OSD  9188  //set decode channel OSD info

#define NET_DVR_GET_OUTPUT_PIC_INFO             9200    //get output picture information
#define NET_DVR_SET_OUTPUT_PIC_INFO             9201    //set output picture information
#define NET_DVR_GET_OUTPUT_PIC_WIN_CFG          9202    //get output picture window parameter
#define NET_DVR_SET_OUTPUT_PIC_WIN_CFG          9203    //set output picture window parameter
#define NET_DVR_GET_OUTPUT_ALL_PIC_WIN_CFG      9204    //get all output picture window parameter
#define NET_DVR_DELETE_OUPUT_PIC                9205    //delete output picture
#define NET_DVR_GET_OUTPUT_OSD_CFG              9206    //get output OSD parameter
#define NET_DVR_SET_OUTPUT_OSD_CFG              9207    //set output OSD parameter
#define NET_DVR_GET_OUTPUT_ALL_OSD_CFG          9208    //get all the output OSD parameter
#define NET_DVR_GET_CHAN_RELATION               9209    //get encode relate resource
#define NET_DVR_SET_CHAN_RELATION               9210    //set encode relate resource
#define NET_DVR_GET_ALL_CHAN_RELATION           9211    //get all encode relate resource
#define  NET_DVR_GET_NS_RING_CFG                9212    //get fiber board ring configure
#define  NET_DVR_SET_NS_RING_CFG                   9213    //set fiber board ring configure
#define  NET_DVR_GET_NS_RING_STATUS              9214    //get fiber ring status
#define NET_DVR_GET_OPTICAL_PORT_INFO            9220    //get optical port information
#define NET_DVR_SET_OPTICAL_PORT_INFO            9221    //set optical port information
#define NET_DVR_GET_OPTICAL_CHAN_RELATE_CFG        9222    //get coder channel related optical port information
#define NET_DVR_SET_OPTICAL_CHAN_RELATE_CFG        9223    //set coder channel related optical port information
#define NET_DVR_GET_WIN_ROAM_SWITCH_CFG         9224    //Get roaming decoder window switch parameters
#define NET_DVR_SET_WIN_ROAM_SWITCH_CFG         9225    //Set roaming decoder window switch parameters
#define    NET_DVR_START_SCREEN_CRTL                9226    //Start Screen Control
#define    NET_DVR_GET_SCREEN_FLIE_LIST            9227    //Get the screen file list
#define    NET_DVR_GET_SCREEN_FILEINFO                9228    //Get screen file information parameters
#define    NET_DVR_SET_SCREEN_FILEINFO             9229    //Set screen file information parameters

/*******************************LED begin***************************************/
#define NET_DVR_GET_LED_OUTPUT_CFG                9230    //get led send card output parameters
#define NET_DVR_SET_LED_OUTPUT_CFG                9231    //set led send card output parameters
#define NET_DVR_GET_LED_OUTPUT_PORT_CFG            9232    //get led send card output port parameters
#define NET_DVR_SET_LED_OUTPUT_PORT_CFG            9233    //set led send card output port parameters
#define NET_DVR_GET_LED_DISPLAY_AREA_CFG        9234    //get led send card display area
#define NET_DVR_SET_LED_DISPLAY_AREA_CFG        9235    //set led send card display area
#define NET_DVR_GET_LED_PORT_CFG                9236    //get led send card port parameters
#define NET_DVR_SET_LED_PORT_CFG                9237    //set led send card port parameters
#define NET_DVR_GET_LED_DISPLAY_CFG                9238    //get led send card display parameters
#define NET_DVR_SET_LED_DISPLAY_CFG                9239    //set led send card display parameters
#define NET_DVR_GET_ALL_LED_PORT_CFG            9240    //get led all port parameters
#define NET_DVR_SAVE_LED_CONFIGURATION            9241    //save led configuration
#define NET_DVR_GET_LED_TEST_SIGNAL_CFG            9242    //get led test signal parameters
#define NET_DVR_SET_LED_TEST_SIGNAL_CFG            9243    //set led test signal parameters
#define NET_DVR_GET_LED_NOSIGNAL_CFG            9244    //get led no signal display parameters
#define NET_DVR_SET_LED_NOSIGNAL_CFG            9245    //set led no signal display parameters
#define NET_DVR_GET_LED_INPUT_CFG                9246    //get led send card input parameters
#define NET_DVR_SET_LED_INPUT_CFG                9247    //get led send card input parameters
#define NET_DVR_GET_LED_RECV_GAMMA_CFG            9248    //get receive card GAMMA table parameters
#define NET_DVR_SET_LED_RECV_GAMMA_CFG            9249    //set led receive card GAMMA table parameters
#define NET_DVR_GET_LED_RECV_CFG                9250    //get led receive card basic parameters
#define NET_DVR_SET_LED_RECV_CFG                9251    //set led receive card basic parameters
#define NET_DVR_GET_LED_RECV_ADVANCED_CFG        9252    //get led receive card advanced parameters
#define NET_DVR_SET_LED_RECV_ADVANCED_CFG        9253    //set led receive card advanced parameters
#define NET_DVR_GET_LED_SCREEN_DISPLAY_CFG        9254    //get led screen display parameters
#define NET_DVR_SET_LED_SCREEN_DISPLAY_CFG        9255    //set led screen display parameters
/*******************************LED end*****************************************/

#define    NET_DVR_GET_SCREEN_CONFIG               9260    //Get the server screen parameter
#define    NET_DVR_SET_SCREEN_CONFIG               9261    //Set the server screen parameter
#define NET_DVR_GET_SCREEN_CONFIG_CAP              9262    //Ability to screen server parameters were obtained

#define    NET_DVR_GET_SCHEDULE_PUBLISH_PROGRESS    9271    //get schedule publish progress
#define    NET_DVR_GET_PUBLISH_UPGRADE_PROGRESS    9272    //get info publish termal upgrade progress

#define NET_DVR_GET_INSERTPLAY_PROGRESS            9273    //get insert play progress

#define NET_DVR_GET_INPUT_BOARD_CFG                9281    //get input board configuration
#define NET_DVR_GET_INPUT_BOARD_CFG_LIST        9282    //get input board configuration list
#define NET_DVR_SET_INPUT_BOARD_CFG                9283    //set input board configuration

#define NET_DVR_GET_INPUT_SOURCE_TEXT_CAP    9284
#define NET_DVR_GET_INPUT_SOURCE_TEXT_CFG    9285
#define NET_DVR_GET_INPUT_SOURCE_TEXT_CFG_LSIT 9286
#define NET_DVR_SET_INPUT_SOURCE_TEXT_CFG    9287
#define NET_DVR_SET_INPUT_SOURCE_TEXT_CFG_LIST 9288
#define NET_DVR_GET_INPUT_SOURCE_RESOLUTION_CAP    9289
#define NET_DVR_GET_INPUT_SOURCE_RESOLUTION_CFG    9290
#define NET_DVR_GET_INPUT_SOURCE_RESOLUTION_CFG_LIST    9291
#define NET_DVR_SET_INPUT_SOURCE_RESOLUTION_CFG    9292
#define NET_DVR_SET_INPUT_SOURCE_RESOLUTION_CFG_LIST  9293
#define NET_DVR_GET_LED_AREA_INFO_LIST  9295
#define NET_DVR_GET_DISPINPUT_CFG  9296  //get display input parameters
#define NET_DVR_GET_DISPINPUT_CFG_LIST  9297  //get all display input parameters
#define NET_DVR_SET_DISPINPUT_CFG  9298  //set display input parameters
#define NET_DVR_GET_DISPINPUT_CFG_CAP  9299  //get display input parameters capabilities

#define NET_DVR_GET_CURRENT_VALID_PORT          9300    //get current valid port
#define    NET_DVR_SET_ONLINE_UPGRADE                9301    //allow the device upgrade online
#define NET_DVR_GET_ONLINEUPGRADE_PROGRESS      9302    //get online upgrade progress
#define    NET_DVR_GET_FIRMWARECODE                9303    //get firmware code
#define NET_DVR_GET_ONLINEUPGRADE_SERVER        9304    //get upgrade server status
#define NET_DVR_GET_ONLINEUPGRADE_VERSION       9305    //get new version information
#define NET_DVR_GET_RECOMMEN_VERSION            9306    //check the version is recommened
#define NET_DVR_GET_ONLINEUPGRADE_ABILITY       9309    //get the ability of online upgrade

#define NET_DVR_GET_RS485_WORK_MODE             10001 //get RS485 serial port work mode
#define NET_DVR_SET_RS485_WORK_MODE             10002 //set Rs485 serial port work mode
#define NET_DVR_GET_SPLITTER_TRANS_CHAN_CFG     10003 //get splitter transparent channel config
#define NET_DVR_SET_SPLITTER_TRANS_CHAN_CFG     10004 //set splitter transparent channel config








#define  NET_DVR_GET_SIP_CFG                    11001   //IP View get SIP config
#define  NET_DVR_SET_SIP_CFG                    11002   //IP View set SIP config
#define  NET_DVR_GET_IP_VIEW_DEVCFG                11003   //IP View get sub device config
#define  NET_DVR_SET_IP_VIEW_DEVCFG                11004   //IP View set sub device config
#define  NET_DVR_GET_IP_VIEW_AUDIO_CFG            11005   //IP View get audio config
#define  NET_DVR_SET_IP_VIEW_AUDIO_CFG            11006   //IP View set audio config
#define     NET_DVR_GET_IP_VIEW_CALL_CFG            11007   //IP View get call config
#define  NET_DVR_SET_IP_VIEW_CALL_CFG            11008   //IP View set call config
#define     NET_DVR_GET_AUDIO_LIMIT_ALARM_CFG        11009    //IP View get audio limit alarm config
#define     NET_DVR_SET_AUDIO_LIMIT_ALARM_CFG        11010    //IP View set audio limit alarm config
#define     NET_DVR_GET_BUTTON_DOWN_ALARM_CFG        11011    //IP View get button down alarm config
#define     NET_DVR_SET_BUTTON_DOWN_ALARM_CFG        11012    //IP View set button down alarm config

#define NET_DVR_GET_ISCSI_CFG                   11070      //Get ISCSI storage configuration protocol
#define NET_DVR_SET_ISCSI_CFG                   11071      //Set ISCSI storage configuration protocol
/*************************Parameter Configure Commands end*******************************/
#define NET_DVR_GET_SECURITYMODE                12004
//2013-11-21 Get Temperature Humidity
#define NET_DVR_GET_TEMP_HUMI                   12005

//2014-02-15 Civil IPC test project
#define  NET_DVR_SET_ALARMSOUNDMODE             12006   //Set Alarm Sound Mode
#define  NET_DVR_GET_ALARMSOUNDMODE             12007   //Get Alarm Sound Mode
#define    NET_DVR_SET_IPDEVICE_ACTIVATED       13000//activate ipc by nvr
#define NET_DVR_GET_DIGITAL_CHAN_SECURITY_STATUS    13001   //get ip device security status
#define    NET_DVR_GET_ACTIVATE_IPC_ABILITY     13003    //get ability of activate ipc by nvr

#define NET_DVR_GET_VIDEO_INTERCOM_DEVICEID_CFG  16001  //Get Video intercom DeviceID config
#define NET_DVR_SET_VIDEO_INTERCOM_DEVICEID_CFG  16002  //Set Video intercom DeviceID config
#define NET_DVR_SET_PRIVILEGE_PASSWORD           16003  //Get Privilege password
#define NET_DVR_GET_OPERATION_TIME_CFG           16004  //Get Opreation Time Config
#define NET_DVR_SET_OPERATION_TIME_CFG           16005  //Set Opreation Time Config
#define NET_DVR_GET_VIDEO_INTERCOM_RELATEDEV_CFG 16006  //Get related Device Config
#define NET_DVR_SET_VIDEO_INTERCOM_RELATEDEV_CFG 16007  //Set related Device Config
#define NET_DVR_REMOTECONTROL_NOTICE_DATA        16008  //Notice Data
#define NET_DVR_REMOTECONTROL_GATEWAY            16009  //remote control Gateway
#define NET_DVR_REMOTECONTROL_OPERATION_AUTH     16010  //Remote Control operation auth

#define NET_DVR_GET_VIDEO_INTERCOM_IOIN_CFG      16016  //Get IO In Cfg
#define NET_DVR_SET_VIDEO_INTERCOM_IOIN_CFG      16017  //Set IO In Cfg
#define NET_DVR_GET_VIDEO_INTERCOM_IOOUT_CFG     16018  //Get IO Out Cfg
#define NET_DVR_SET_VIDEO_INTERCOM_IOOUT_CFG     16019  //Set IO Out Cfg
#define NET_DVR_GET_ELEVATORCONTROL_CFG          16020  //Get Elevator control Cfg
#define NET_DVR_SET_ELEVATORCONTROL_CFG          16021  //Set Elevator control Cfg
#define NET_DVR_GET_VIDEOINTERCOM_STREAM         16022  //Get Stream Cfg
#define NET_DVR_SET_VIDEOINTERCOM_STREAM         16023  //Set Stream Cfg
#define NET_DVR_GET_WDR_CFG                      16024  //Get WDR Cfg
#define NET_DVR_SET_WDR_CFG                      16025  //Set WDR Cfg
#define NET_DVR_GET_VIS_DEVINFO                  16026  //Get VIS Device Info
#define NET_DVR_GET_VIS_REGISTER_INFO            16027  //Get VIS Register Info
#define NET_DVR_GET_ELEVATORCONTROL_CFG_V40      16028  //Get Elevator control Cfg V40
#define NET_DVR_SET_ELEVATORCONTROL_CFG_V40      16029  //Set Elevator control Cfg  V40
#define NET_DVR_GET_CALL_ROOM_CFG                 16030  //Get Room Call Config
#define NET_DVR_SET_CALL_ROOM_CFG                 16031  //Set Room Call Config
#define NET_DVR_VIDEO_CALL_SIGNAL_PROCESS        16032  //Video Call Signal Process
#define NET_DVR_GET_CALLER_INFO                  16033  //get caller info
#define NET_DVR_GET_CALL_STATUS                  16034  //get call status
#define NET_DVR_GET_SERVER_DEVICE_INFO           16035  //get server device infi
#define NET_DVR_SET_CALL_SIGNAL                  16036  //set call signal
#define NET_DVR_GET_VIDEO_INTERCOM_ALARM_CFG       16037    //get video intercom alarm cfg
#define NET_DVR_SET_VIDEO_INTERCOM_ALARM_CFG       16038    //set video intercom alarm cfg
#define NET_DVR_GET_RING_LIST                    16039    //get ring list

#define    NET_DVR_DEBUGINFO_START                     18000    //Debug Info Start
#define    NET_DVR_AUTO_TEST_START                     18001    //Start auto test

/***************************DS9000 New Commands (_V30)  end *****************************/
//[add] by zja 2013-10-29 10:47:57
#define NET_DVR_GET_SELFCHECK_RESULT        20000    //Get selfcheck status
#define NET_DVR_SET_TEST_COMMAND            20001    //Set test control command
#define NET_DVR_SET_TEST_DEVMODULE          20002    //set the contorl command of the hardware module
#define NET_DVR_GET_TEST_DEVMODULE          20003    //get the contorl command of the hardware module


#define NET_DVR_SET_AUTOFOCUS_TEST          20004    //Set Autofocus Test 2013-10-26
#define NET_DVR_CHECK_USER_STATUS           20005    //Detect the user is online
#define NET_DVR_GET_TEST_COMMAND            20010    //Get test control command
#define NET_DVR_GET_DIAL_SWITCH_CFG         20200    //Get Dial Switch
#define NET_DVR_SET_AGING_TRICK_SCAN          20201  //Set the tool parameters before and after aging
#define NET_DVR_GET_ECCENTRIC_CORRECT_STATE   20202  //Capture the eccentric calibration status

#define  NET_DVR_T1_TEST_CMD                     131073


// American branch office coustom
#define NET_DVR_GET_MEMU_OUTPUT_MODE         155649        //Get menu output mode
#define NET_DVR_SET_MEMU_OUTPUT_MODE         155650        //Set menu output mode


#define NET_DVR_GET_DEV_LOGIN_RET_INFO      16777200  //get device login return parameters

/*******************Return Value of File&Log Query API*************************/
#define NET_DVR_FILE_SUCCESS            1000    //Get log information
#define NET_DVR_FILE_NOFIND                1001    //No log
#define NET_DVR_ISFINDING                1002    //On searching
#define    NET_DVR_NOMOREFILE                1003    //No more files
#define    NET_DVR_FILE_EXCEPTION            1004    //Error on log query

//alarm of plate: NET_DVR_PLATE_RESULT

/*************Operation Exception**********************/
#define EXCEPTION_EXCHANGE                0x8000    //Network user exception
#define EXCEPTION_AUDIOEXCHANGE            0x8001    //Network voice talk exception
#define EXCEPTION_ALARM                    0x8002    //Alarm exception
#define EXCEPTION_PREVIEW                0x8003    //Network preview exception
#define EXCEPTION_SERIAL                0x8004    //Transparent channel exception
#define EXCEPTION_RECONNECT                0x8005    //Network preview reconnected
#define EXCEPTION_ALARMRECONNECT        0x8006    //Alarm reconnected
#define EXCEPTION_SERIALRECONNECT        0x8007    //Transparent channel reconnected
#define SERIAL_RECONNECTSUCCESS            0x8008    //Transparent reconnected success
#define EXCEPTION_PLAYBACK                0x8010    //Playback exception
#define EXCEPTION_DISKFMT                0x8011    //Hard Disk format exception
#define EXCEPTION_PASSIVEDECODE            0x8012  //Passive decode exception
#define EXCEPTION_EMAILTEST                0x8013  //Email test exception
#define EXCEPTION_BACKUP                0x8014  //Backup exception
#define PREVIEW_RECONNECTSUCCESS        0x8015  //Network preview reconnected successfully
#define ALARM_RECONNECTSUCCESS            0x8016  //Alarm reconnected successfully
#define RESUME_EXCHANGE                    0x8017    //User interaction resume

#define NETWORK_FLOWTEST_EXCEPTION      0x8018  // Network flow exception
//2011-11-24
#define EXCEPTION_PICPREVIEWRECONNECT    0x8019    //Picture Preview reconnect
#define PICPREVIEW_RECONNECTSUCCESS        0x8020    //Picture Preview reconnect successfully
#define EXCEPTION_PICPREVIEW            0x8021    //Picture Preview exception
#define    EXCEPTION_MAX_ALARM_INFO        0x8022    //too many alarm info
#define EXCEPTION_LOST_ALARM            0x8023    //lost alarm
#define EXCEPTION_PASSIVETRANSRECONNECT 0x8024  //Passive trans code reconnect
#define PASSIVETRANS_RECONNECTSUCCESS   0x8025  //Passive trans code reconnect success
#define EXCEPTION_PASSIVETRANS          0x8026  //Passive trans code exception

#define EXCEPTION_RELOGIN                0x8040    //User Relogin
#define RELOGIN_SUCCESS                    0x8041    //User Relogin Success
#define EXCEPTION_PASSIVEDECODE_RECONNNECT  0x8042  //Passive decode reconnect

#define EXCEPTION_RELOGIN_FAILED                0x8044   //Relogin failed\A3\ACstop relogin
#define EXCEPTION_PREVIEW_RECONNECT_CLOSED      0x8045   //stop preveiw reconnect
#define EXCEPTION_ALARM_RECONNECT_CLOSED        0x8046   //stop alarm reconnect
#define EXCEPTION_SERIAL_RECONNECT_CLOSED       0x8047   //stop serial reconnect
#define EXCEPTION_PIC_RECONNECT_CLOSED          0x8048   //stop picture reconnect
#define EXCEPTION_PASSIVE_DECODE_RECONNECT_CLOSED 0x8049 //stop passive decode reconnect
#define EXCEPTION_PASSIVE_TRANS_RECONNECT_CLOSED 0x804a  //stop passive transcoding reconnect
/********************Preview Callback Function*********************/
#define NET_DVR_SYSHEAD                    1    //System header
#define NET_DVR_STREAMDATA                2    //stream data
#define NET_DVR_AUDIOSTREAMDATA            3    //Audio Stream data
#define NET_DVR_STD_VIDEODATA            4    //Standard video stream data
#define NET_DVR_STD_AUDIODATA            5    //Standard audio stream data
#define NET_DVR_SDP                        6   //SDP data(valid for rtsp protocol)
#define NET_DVR_CHANGE_FORWARD            10  //stream change from reverse to forward
#define NET_DVR_CHANGE_REVERSE            11  //stream change from forward to reverse
#define NET_DVR_PLAYBACK_ALLFILEEND      12  //Play back All File End
#define NET_DVR_VOD_DRAW_FRAME              13  //vod draw Frame
#define NET_DVR_PRIVATE_DATA            112 //Private data

/******************************Abilities Set*********************************/
//Capabilities
#define DEVICE_SOFTHARDWARE_ABILITY   0x001  //Software / hardware abilities of the device
#define DEVICE_NETWORK_ABILITY        0x002  //Network abilities of the device
#define DEVICE_ENCODE_ALL_ABILITY     0x003  //Encode abilities of the device
#define    DEVICE_ENCODE_CURRENT         0x004  //Current encode ability of the device
#define IPC_FRONT_PARAMETER              0x005     //Network camera parameters
#define IPC_UPGRADE_DESCRIPTION          0x006     //Network camera upgrade info
#define DEVICE_RAID_ABILITY           0x007  //RAID
#define DEVICE_ENCODE_ALL_ABILITY_V20 0x008     //Encode abilities of the device 2.0
#define IPC_FRONT_PARAMETER_V20          0x009     //Network camera parameters 2.0
#define DEVICE_ALARM_ABILITY          0x00a  //alarm ability
#define DEVICE_DYNCHAN_ABILITY          0x00b  //device dyn channel ability
#define DEVICE_USER_ABILITY           0x00c  //user ability
#define DEVICE_NETAPP_ABILITY         0x00d  //net app ability
#define DEVICE_VIDEOPIC_ABILITY       0x00e  //video picture ability
#define DEVICE_JPEG_CAP_ABILITY       0x00f  //JPEG capture ability
#define DEVICE_SERIAL_ABILITY         0x010  //RS232 and RS485 ability
#define DEVICE_ABILITY_INFO              0x011     //Device common ability
#define STREAM_ABILITY                0x012  //Stream ability
#define SYSTEM_MANAGEMENT_ABILITY     0x013  //Device system management ability
#define IP_VIEW_DEV_ABILITY              0x014  //IP VIEW ability
#define VCA_DEV_ABILITY               0x100  //Intelligent analysis ability of the device
#define VCA_CHAN_ABILITY              0x110  //VCA ability of the device
#define MATRIXDECODER_ABILITY         0x200  //display and decoding ability of the multi-channel decoder
#define VIDEOPLATFORM_ABILITY         0x210  //Ability set of video management system
#define WALL_ABILITY                  0x212  //ability set of video wall
#define MATRIX_ABILITY                0x213  //ability set of SDI matrix
#define VIDEOPLATFORM_ABILITY_V40     0x230  //ability set of Multi-function Video Center
#define MATRIXDECODER_ABILITY_V41     0x260  //decoder ability
#define DECODER_ABILITY               0x261  //decoder ability
#define CODECARD_ABILITY              0x271  //coder card server ability
#define SNAPCAMERA_ABILITY            0x300  //Ability set for the camera
#define ITC_TRIGGER_MODE_ABILITY      0x301  //IPC Trigger mode ability
#define COMPRESSIONCFG_ABILITY        0x400  //Get compression parameter abilities
#define COMPRESSION_LIMIT             0x401  //get compression ability between main and sub stream
#define PIC_CAPTURE_ABILITY           0x402  //get picture capture ability
#define IT_DEVICE_ABILITY             0x501  //ITS ability
#define    SCREENCONTROL_ABILITY          0x600  //Ability of screen controller
#define    SCREENSERVER_ABILITY          0x610  //Ability of screen server
#define FISHEYE_ABILITY               0x700  //Fisheye ability
#define LCD_SCREEN_ABILITY              0x800     //Ability of LCD Screen
#define ACS_ABILITY                   0x801  //Ability of Access Control System
#define MERGEDEV_ABILITY              0x802  //Ability of merge code device
#define CAM_FUSION_ABILITY            0x803  //Camera fusion ability
#define OPTICAL_DEV_ACCESS_ABILITY    0x805  //Node optical device access ability
#define NET_RING_ABILITY              0x806     //Net ring ability
#define LED_ABILITY                      0x807     //LED screen ability
#define SCREEN_EXCHANGE_ABILITY       0x80b  //Screen interactive ability

//board exception type
//main type
#define EXCEPTION_MAJOR_MAINBOARD_BOOT                    0x1  //main board boot exception
//sub type
#define EXCEPTION_MINOR_PCIE_SCAN                        0x1  //PCIE scan exception
#define EXCEPTION_MINOR_DOWNLOAD_SUBBOARD                 0xa  //download sub board exception

//main type
#define EXCEPTION_MAJOR_SUBBOARD_BOOT                    0x2  //sub board boot exception
//sub type
#define EXCEPTION_MINOR_INEXISTENCE                       0x1  //sub board not found
#define EXCEPTION_MINOR_UBOOT_DOWNLOAD                  0xa  //uboot download exception
#define EXCEPTION_MINOR_UBOOT_INIT                      0xe  //uboot initialization fail
#define EXCEPTION_MINOR_ROOTFS_DOWNLOAD                 0x14  //rootfs.img download fail
#define EXCEPTION_MINOR_UIMAGE_DOWNLOAD                 0x19  //uImage download fail
#define EXCEPTION_MINOR_UBOOT_SETBOOTFLAG               0x1e  //uboot boot flags exception
#define EXCEPTION_MINOR_ROOTFS_BOOT_SUBBOARD            0x23  //rootfs boot exception
#define EXCEPTION_MINOR_NEED_FILE_FINISH                0x28  //sub board file transfer exception

//main type
#define EXCEPTION_MAJOR_SUBBOARD_HARDWARE                0x3  //sub board hardware exception
//sub type
#define EXCEPTION_MINOR_AD                               0x1  //AD exception
#define EXCEPTION_MINOR_DA                                 0xa  //DA exception
#define EXCEPTION_MINOR_TIMER                            0xb     //timer exception

//main type
#define EXCEPTION_MAJOR_FPGA                            0x4  //FPGA exception
//sub type
#define EXCEPTION_MINOR_IDLE                              0x1  //IDLE exception
#define EXCEPTION_MINOR_LANE                             0xa  //LANE exception
#define EXCEPTION_MINOR_REGISTER_ALL_F                     0xe  //FPGA register all F
#define EXCEPTION_MINOR_MEMORY_INIT_FAIL                 0x14 //FPGA memory initialization fail
//main type
#define EXCEPTION_MAJOR_DSP                                0x5  //DSP exception

//main type
#define EXCEPTION_MAJOR_ARM                                0x6  //ARM exception

//main type
#define EXCEPTION_MAJOR_BACKBOARD                        0x7  //back board exception
//sub type
#define EXCEPTION_MINOR_BACKBOARD_TYPE                   0x1  //get back board type fail
#define EXCEPTION_MINOR_SERDES                           0xa  //serdes exception
#define EXCEPTION_MINOR_CLOCK                             0xe  //clock exception
#define EXCEPTION_MINOR_SYNCH                             0x14 //synchronous signal exception


//main type
#define EXCEPTION_MAJOR_SUBBOARD_NET                    0x8  //sub board network exception
//sub type
#define EXCEPTION_MINOR_IP_CONFLICT                       0x1  //IP conflict
#define EXCEPTION_MINOR_DISCONNECT                         0x14 //network disconnect

//alarm callback
#define COMM_ALARM                      0x1100  //8000 Upload alarm message

//corresponding to NET_VCA_RULE_ALARM
#define COMM_ALARM_RULE                  0x1102  //VCA alarm info
#define COMM_ALARM_PDC                0x1103  //PDC alarm info
#define COMM_ALARM_AID                0x1110  //Traffic event alarm info
#define COMM_ALARM_VIDEOPLATFORM      0x1104  //Video Management System alarm
#define COMM_ALARM_ALARMHOST          0x1105  //Network alarm host alarm
#define COMM_ALARM_FACE               0x1106  //Face detection recognition alarm information
#define COMM_RULE_INFO_UPLOAD         0x1107  //Event data information upload
#define COMM_ALARM_AID                0x1110  //Traffic event alarm info
#define COMM_ALARM_TPS                0x1111  //Traffic statistics alarm info
#define COMM_UPLOAD_FACESNAP_RESULT   0x1112  //Upload face snap result
#define COMM_ALARM_TFS                0x1113  //Traffic forensic alarm info
#define COMM_ALARM_TPS_V41            0x1114  //Traffic statistics alarm info(extended)
#define COMM_ALARM_AID_V41            0x1115  //Traffic event alarm info(extended)
#define COMM_ALARM_VQD_EX             0x1116  //Video quality diagnosis alarm(extended)
#define COMM_SENSOR_VALUE_UPLOAD      0x1120  //Sensor data realtime upload
#define COMM_SENSOR_ALARM                0x1121  //Analog alarm upload
#define COMM_SWITCH_ALARM              0x1122
#define COMM_ALARMHOST_EXCEPTION      0x1123  //Alarm host exception alarm
#define COMM_ALARMHOST_SAFETYCABINSTATE 0x1125//SafetyCabin State
#define COMM_ALARMHOST_ALARMOUTSTATUS 0x1126  //Alarm Out Status
#define COMM_ALARMHOST_CID_ALARM       0x1127  // CID ALARM
#define    COMM_ALARMHOST_EXTERNAL_DEVICE_ALARM 0x1128    // external device alarm
#define COMM_ALARMHOST_DATA_UPLOAD    0x1129  //Alarm data upload
#define COMM_FACECAPTURE_STATISTICS_RESULT   0x112a  //face Capture Statistics Result
#define COMM_SCENECHANGE_DETECTION_UPLOAD    0x1130    //Scene change alarm upload 2013-7-16
#define COMM_CROSSLINE_ALARM                0x1131  //CrossLine Alram
#define COMM_UPLOAD_VIDEO_INTERCOM_EVENT     0x1132  //upload video intercon event
#define COMM_ALARM_VIDEO_INTERCOM               0x1133  //upload video intercon alarm
#define COMM_ALARM_AUDIOEXCEPTION     0x1150  //Aduio alarm info
#define COMM_ALARM_DEFOCUS            0x1151  //Defous alarm info

#define    COMM_TRADEINFO                  0x1500  //ATM DVR transaction information
//NET_DVR_PLATE_RESULT
#define COMM_UPLOAD_PLATE_RESULT      0x2800  //Uploaded License info
#define COMM_ITC_STATUS_DETECT_RESULT 0x2810  //status detect
#define COMM_IPC_AUXALARM_RESULT      0x2820  //PIR alarm\wireless alarm\callhelp alarm
#define COMM_SNAP_MATCH_ALARM         0x2902  //blacklist comparison result upload
#define COMM_ITS_PLATE_RESULT            0x3050  //ITS plate result upload
#define    COMM_ITS_TRAFFIC_COLLECT      0x3051  //ITS traffic collect upload
#define COMM_ITS_GATE_VEHICLE          0x3052  //Gate vehicle snapshot data upload
#define COMM_ITS_GATE_FACE            0x3053  //Gate vehicle Face data upload
#define COMM_ITS_GATE_COSTITEM          0x3054  //Gate Costitem 2013-11-19
#define COMM_ITS_GATE_HANDOVER          0x3055  //Gate Handover  2013-11-19
#define COMM_ITS_PARK_VEHICLE         0x3056  //Parking data upload
#define COMM_ITS_BLACKLIST_ALARM      0x3057  //BlackList data upload
#define COMM_VEHICLE_CONTROL_LIST_DSALARM    0x3058  //Vehicle Control List Alarm 2013-11-04
#define COMM_VEHICLE_CONTROL_ALARM           0x3059  //Vehicle Alarm 2013-11-04
#define COMM_FIRE_ALARM                      0x3060  //Fire Alarm 2013-11-04
#define COMM_ITS_GATE_ALARMINFO       0x3061      //ITS gate Alarm Info
#define COMM_VEHICLE_RECOG_RESULT     0x3062  //Upload a secondary result of the vehicle identification 2014-11-12
#define COMM_PLATE_RESULT_V50         0x3063  //Plate Result V50

#define COMM_GATE_CHARGEINFO_UPLOAD          0x3064  //Charge Info Upload
#define COMM_TME_VEHICLE_INDENTIFICATION     0x3065  //TME Vehicle upload
#define COMM_GATE_CARDINFO_UPLOAD            0x3066  //Entrance card information upload

#define COMM_ALARM_SENSORINFO_UPLOAD  0x3077  //Sensor Info Upload
#define COMM_ALARM_CAPTURE_UPLOAD      0x3078  //Capture Upload
#define COMM_ITS_RADARINFO            0x3079  //Radar Alarm Info

#define COMM_SIGNAL_LAMP_ABNORMAL     0x3080  //Signal Lamp Abnormal

#define COMM_ALARM_TPS_REAL_TIME      0x3081  //TPS Real Time
#define COMM_ALARM_TPS_STATISTICS     0x3082  //TPS Statistics

#define COMM_ALARM_V30                  0x4000  //9000 upload alarm message
#define COMM_IPCCFG                      0x4001  //9000 IPC configuration changed,  upload with push mode
#define COMM_IPCCFG_V31                  0x4002  //Initiative alarm upload when IPC connection configuration changes on 9000 device,  extended for 9000_1.1
#define COMM_IPCCFG_V40                  0x4003  //Alarm information upload when IPC connection configuration of IVMS-2000 or NVR changes
#define COMM_ALARM_DEVICE             0x4004
#define COMM_ALARM_CVR                  0x4005  //CVR 2.0.X alarm
#define COMM_ALARM_HOT_SPARE          0x4006  //Hot alarm exception(N+1 abnormal alarm)
#define COMM_ALARM_V40                  0x4007  //upload alarm message(Expend)
#define COMM_UPLOAD_HEATMAP_RESULT    0x4008 //Heat Map 2014-03-21
#define COMM_ALARM_DEVICE_V40         0x4009
#define COMM_ALARM_FACE_DETECTION     0x4010 //Face Detection
#define COMM_ALARM_TARGET_LEFT_REGION  0x4011 // Target left Region
#define COMM_GISINFO_UPLOAD           0x4012 //GIS Info upload
#define COMM_VANDALPROOF_ALARM        0x4013 // prevent damage
#define COMM_PEOPLE_DETECTION_UPLOAD  0x4014 //People Detection Upload
#define COMM_ALARM_STORAGE_DETECTION  0x4015 //Storge Detection Alarm
#define    COMM_ITS_ROAD_EXCEPTION          0x4500  //ITS road exception upload
#define    COMM_ITS_EXTERNAL_CONTROL_ALARM        0x4520 //External control Alarm
#define COMM_ALARM_SHIPSDETECTION      0x4521  //Ships Detection
#define COMM_FIREDETECTION_ALARM      0x4991  //Fire Detection Alarm
#define COMM_ALARM_DENSEFOGDETECTION    0x4992     //Fog Detection Alarm

#define    COMM_SCREEN_ALARM              0x5000  //Alarm type
#define COMM_DVCS_STATE_ALARM          0x5001  // alarm of dvcs
#define COMM_ALARM_ACS                  0x5002  //access card alarm
#define COMM_ALARM_FIBER_CONVERT      0x5003  //fiber convert alarm
#define COMM_ALARM_DEC_VCA            0x5010  //vca decode alarm
#define COMM_ALARM_LCD                  0x5011   //LCD alarm
#define COMM_CONFERENCE_CALL_ALARM      0x5012  //conference call alarm
#define COMM_ALARM_WALL_CONFERNECE  0x5015

#define COMM_DIAGNOSIS_UPLOAD         0x5100  //alarm of VQD
#define COMM_HIGH_DENSITY_UPLOAD      0x5101  //high density status upload

#define COMM_ID_INFO_ALARM                   0x5200  //id info alarm
#define COMM_PASSNUM_INFO_ALARM              0x5201  //pass number info alarm

#define COMM_THERMOMETRY_DIFF_ALARM   0x5211  //Thermometry Difference Alarm
#define COMM_THERMOMETRY_ALARM        0x5212  //Thermometry Alarm
#define COMM_PANORAMIC_LINKAGE_ALARM         0x5213  //Panoramic linkage Alarm

#define COMM_ALARM_VQD                0x6000  //VQD alarm up
#define COMM_PUSH_UPDATE_RECORD_INFO  0x6001  //Push mode record info upload
#define COMM_SWITCH_LAMP_ALARM        0x6002  //Swicth lamp Alarm
#define COMM_INQUEST_ALARM      0x6005  //Inquest alarm
#define COMM_GPS_STATUS_ALARM         0x6010  // GPS status upload

/* Device model*/
#define DVR                            1                //Undefined DVR
#define ATMDVR                        2                //ATM DVR
#define DVS                            3                //DVS
#define DEC                            4                //6001DI
#define ENC_DEC                        5                //6001FI
#define DVR_HC                        6                //8000HCI
#define DVR_HT                        7                //8000HTI
#define DVR_HF                        8                //8000HFI
#define DVR_HS                        9                //8000HSI DVR (no audio)
#define DVR_HTS                        10              //8016HTS DVR (no audio)
#define DVR_HB                        11              //HB DVR (SATA HD)
#define DVR_HCS                        12              //8000HCS DVR
#define DVS_A                        13              //DVS with ATA Hard disk
#define DVR_HC_S                    14              //8000HCI- S
#define DVR_HT_S                    15              //8000HTI- S
#define DVR_HF_S                    16              //8000HFI- S
#define DVR_HS_S                    17              //8000HSI- S
#define ATMDVR_S                    18              //ATM- S
#define DVR_7000H                    19                //7000HI Series
#define DEC_MAT                        20              //Multichannel Decoder
#define DVR_MOBILE                    21                //Mobile DVR
#define DVR_HD_S                    22              //8000HDI- S
#define DVR_HD_SL                    23                //8000HDI- SL
#define DVR_HC_SL                    24                //8000HCI- SL
#define DVR_HS_ST                    25                //8000HSI- ST
#define DVS_HW                        26              //6000HW
#define DS630X_D                    27                //DS630X_DI
#define DS640X_HD                    28                //DS640X_HDI
#define DS610X_D                    29              //610X Decoder
#define IPCAM                        30                //IP Camera
#define MEGA_IPCAM                    31                //Mega Pixels IP Camera
#define IPCAM_X62MF                    32                //862MF IP Camera
#define ITCCAM                      35              //ITC Camera
#define IVS_IPCAM                   36              //VCA ITC Camera
#define ZOOMCAM                     38              //ZOOM Camera
#define IPDOME                      40                 //IP Speed Dome
#define IPDOME_MEGA200              41                 //Mega Pixels IP Dome (2 million)
#define IPDOME_MEGA130              42                 //Mega Pixels IP Dome (1.3 million)
#define IPDOME_AI                   43              //IP AI Dome
#define TII_IPCAM                   44              //Thermal infrared imaging IP camera
#define IPTC_DOME                   45              /*IPTC Dome*/
#define DS_2DP_Z                    46              /*Spherical eagle eye (large) */
#define DS_2DP                      47              /*The spherical eagle eye (small) */
#define ITS_WMS                      48              /*Weighing data management server*/
#define IPMOD                        50                //IP Model
#define TRAFFIC_YTDOME              51              //Intelligence Cloud Terrace
#define TRAFFIC_RDDOME              52              //Radar Intelligence Cloud Terrace
#define IDS6101_HF_A                61              //61ATM
#define IDS6002_HF_B                62              //Tracked by two camera:  iDS6002- HF/B
#define IDS6101_HF_B                63              //VCA:  iDS6101- HF/B
#define IDS52XX                        64              //Intelligent Analysis:  IVMS
#define IDS90XX                        65                //9000 with intelligent function
#define IDS8104_AHL_S_HX            66              //Face Recognition ATM
#define IDS8104_AHL_S_H             67              //Private Face Recognition ATM
#define IDS91XX                        68                //9100 with intelligent function
#define IIP_CAM_B                   69              //intelligent behavior analyze IP camera
#define IIP_CAM_F                   70              //intelligent face analyze IP camera
#define DS71XX_H                    71                //DS71XXHI_S
#define DS72XX_H_S                    72                //DS72XXHI_S
#define DS73XX_H_S                    73                //DS73XXHI_S
#define DS72XX_HF_S                 74              //DS72XX_HF_S
#define DS73XX_HFI_S                75              //DS73XX_HFI_S
#define DS76XX_H_S                    76                //DVR, e.g. DS7604_HI_S
#define DS76XX_N_S                    77                //NVR, e.g. DS7604_NI_S
#define DS_TP3200_EC                   78              //DS_TP3200_EC
#define DS81XX_HS_S                    81                //DS81XX_HSI_S
#define DS81XX_HL_S                    82                //DS81XX_HLI_S
#define DS81XX_HC_S                    83                //DS81XX_HCI_S
#define DS81XX_HD_S                    84                //DS81XX_HDI_S
#define DS81XX_HE_S                    85                //DS81XX_HE_S
#define DS81XX_HF_S                    86                //DS81XX_HFI_S
#define DS81XX_AH_S                    87                //DS81XX_AHI_S
#define DS81XX_AHF_S                88                //DS81XX_AHFI_S
#define DS90XX_HF_S                    90              //DS90XX_HFI_S
#define DS91XX_HF_S                    91              //DS91XX_HFI_S
#define DS91XX_HD_S                    92              //91XXHDI- S (MD)
#define IDS90XX_A                    93                //9000 intelligent ATM
#define IDS91XX_A                    94                //9100 intelligent ATM
#define DS95XX_N_S                    95              //DS95XX_NI_S NVR with no output interfaces
#define DS96XX_N_SH                    96              //DS96XX_NI_SH NVR
#define DS90XX_HF_SH                97              //DS90XX_HFI_SH
#define DS91XX_HF_SH                98              //DS91XX_HFI_SH
#define DS_B10_XY                   100             //Video integrated platform Device Type (X: Encoder Number, Y: Decoder Number)
#define DS_6504HF_B10               101             //Video integrated platform Encoder
#define DS_6504D_B10                102             //Video integrated platform Decoder
#define DS_1832_B10                 103                //Video integrated platform code splitter
#define DS_6401HFH_B10              104             //Video integrated platform optical
#define DS_65XXHC                    105                //65XXHCI DVS
#define DS_65XXHC_S                    106                //65XXHCI- SATA DVS
#define DS_65XXHF                    107                //65XXHFI DVS
#define DS_65XXHF_S                    108                //65XXHFI- SATA DVS
#define DS_6500HF_B                 109             //DS- 6500 series rack mount DVS
#define IVMS_6200_C                 110             //IVMS- 6200 (/C)
#define IVMS_6200_B                 111             //IVMS- 6200 (/B)
#define DS_72XXHV_ST15                112                //72XXHVI_ST  Hi3515 DVR
#define DS_72XXHV_ST20                113                //72XXHVI_ST  Hi3520 DVR
#define IVMS_6200_T                    114             //IVMS- 6200 (/T)
#define IVMS_6200_BP                115             //IVMS- 6200 (/BP)
#define DS_81XXHC_ST                116                //DS_81XXHC_ST
#define DS_81XXHS_ST                117                //DS_81XXHS_ST
#define DS_81XXAH_ST                118                //DS_81XXAH_ST ATM
#define DS_81XXAHF_ST                119                //DS_81XXAHF_ST ATM
#define DS_66XXDVS                    120                //66XX DVS

#define DS_1964_B10                 121             /*DS-1964-B10*/
#define DS_B10N04_IN                122             /*DS-B10N04-IN*/
#define DS_B10N04_OUT                123             /*DS-B10N04-OUT */
#define DS_B10N04_INTEL             124             /*DS-B10N04-INTEL*/
#define DS_6408HFH_B10E_RM          125             //DS-6408HFH-B10E-RM
#define DS_B10N64F1_RTM             126             //DS-B10N64F1-RTM
#define DS_B10N64F1D_RTM            127             //DS-B10N64F1D-RTM
#define DS_B10_SDS                  128             //DS-B10-SDS
#define DS_B10_DS                   129             //DS-B10-DS
#define DS_6401HFH_B10V                130             //DS-6401HFH-B10V
#define DS_6504D_B10B               131             /*DS-6504D-B10B*/
#define DS_6504D_B10H               132             /*DS-6504D-B10H*/
#define DS_6504D_B10V               133             /*DS-6504D-B10V*/
#define DS_6408HFH_B10S                134             //DS-6408HFH-B10S
#define DS_18XX_N                      135             /* DS-18XX-N*/
#define DS_6504HF_B10F_CLASS        136                //DS-6504HF-B10F-CLASS

#define DS_18XX_PTZ                    141
#define DS_19AXX                    142
#define DS_19BXX                    143
#define DS_19CXX                    144
#define DS_19DXX                    145                //DS_19DXX
#define DS_19XX                     146             //DS_19XX
#define DS_19SXX                    147                //DS_19SXX
#define DS_1HXX                        148                //CS
#define DS_PEAXX                    149                //DS_PEAXX
#define DS_PWXX					    150
#define DS_PMXX                     151
#define DS_19DXX_S                  152

//2011-11-30
#define    DS_C10H                        161                /*CVCS*/
#define DS_C10N_BI                    162                //DVCS BNC processor
#define DS_C10N_DI                    163                //DVCS RGB processor
#define DS_C10N_SI                    164                //DVCS STREAM processor
#define DS_C10N_DO                    165                //DVCS DISP processor
#define DS_C10N_SERVER                166                //DVCS SERVER

#define IDS_8104_AHFL_S_H           171             //8104ATM
#define IDS_65XX_HF_A               172             //65 ATM
#define IDS90XX_HFI_RH              173             //9000 intelligent RH
#define IDS91XX_HFI_RH              174             //9100 intelligent RH
#define IDS_65XX_HF_B               175             //65 behavior analyze
#define IDS_65XX_HF_P               176             //65 plate recognize
#define IVMS_6200_F                 177             //IVMS-6200(/F)
#define IVMS_6200_A                 178             //IVMS-6200(/A)
#define IVMS_6200_F_S                 179             // IVMS-6200(/F_S)

#define DS90XX_HF_RH                181             //9000 RH
#define DS91XX_HF_RH                182             //9100 RH
#define DS72XXHVI_S                 183             //DVR DS-7204HVI-ST/SE
#define DS81XXHW_S                    185                //81 Resolution 960
#define DS81XXHW_ST                    186             //DS81XXHW_ST
#define DS91XXHW_ST                    187             //DS91XXHW_ST
#define DS91XX_ST                    188             //DS91XX_ST
#define DS81XX_ST                    189             //DS81XX_ST
#define DS81XXHX_ST                    190             //DS81XXHDI_ST,DS81XXHE_ST ky2012
#define DS73XXHX_ST                    191             //DS73XXHI_ST ky2012
#define DS81XX_SH                   192             //Inquest81SH,81SHF
#define DS81XX_SN                   193             //Inquest81SNL

#define DS96XXN_ST                  194             //NVR:DS96xxN_ST
#define DS86XXN_ST                  195             //NVR:DS86xxN_ST
#define DS80XXHF_ST                 196             //DVR:DS80xxHF_ST
#define DS90XXHF_ST                 197             //DVR:DS90xxHF_ST
#define DS76XXN_ST                  198             //NVR:DS76xxN_ST

#define ENCODER_SERVER                200                // ENCODER_SERVER
#define DECODER_SERVER              201             // DECODER_SERVER
#define PCNVR_SERVER                202             // PCNVR_SERVER
#define CVR_SERVER                  203             // CVR
#define DS_91XXHFH_ST                204             // 91HD-SDI
#define DS_66XXHFH                    205             // 66 decoder
#define    TRAFFIC_TS_SERVER            210                //ITS server
#define    TRAFFIC_VAR                    211                //ITS VAR
#define IPCALL                      212             //IP call
#define SAN_SERVER                  213                //SAN

#define DS_B11_M_CLASS                 301             /*Video platform B11*/
#define DS_B12_M_CLASS                  302             /*Video platform B12*/
#define DS_6504HF_B11_CLASS         303             /*inter encoder of video platform*/
#define DS_6504HF_B12_CLASS         304              /*inter encoder of video platform*/
#define  DS_6401HFH_B11V_CLASS         305     //VGA HD encoder
#define  DS_6401HFH_B12V_CLASS         306     //VGA HD encoder
#define  DS_6408HFH_B11S_CLASS         307     //SDI encoder
#define  DS_6408HFH_B12S_CLASS      308     //SDI encoder
#define  DS_6504D_B11H_CLASS        309   /*inter HD decoder of video platform*/
#define  DS_6504D_B11B_CLASS        310    /*inter SD decoder of video platform*/
#define  DS_6504D_B12B_CLASS        311       /*inter SD decoder of video platform*/
#define  DS_6504D_B11V_CLASS        312      /*inter VGA decoder of video platform*/
#define  DS_6504D_B12V_CLASS        313     /*inter VGA decoder of video platform*/
//B10
#define  DS_6401HFH_B10R_CLASS         314     //B10 RGB HD encoder
#define  DS_6401HFH_B10D_CLASS         315     //B10 DVI HD encoder
#define  DS_6401HFH_B10H_CLASS         316     //B10 HDMI HD encoder
//B11
#define  DS_6401HFH_B11R_CLASS         317     //B11 RGB HD encoder
#define  DS_6401HFH_B11D_CLASS         318     //B11 DVI HD encoder
#define  DS_6401HFH_B11H_CLASS         319     //B11 HDMI HD encoder
//B12
#define  DS_6401HFH_B12R_CLASS         320     //B12 RGB HD encoder
#define  DS_6401HFH_B12D_CLASS         321     //B12 DVI HD encoder
#define  DS_6401HFH_B12H_CLASS         322     //B12 HDMI HD encoder
#define  DS_65XXD_B10Ex_CLASS        323     //netra HD decoder
//B10 V2.1
#define  DS_6516HW_B10_CLASS        324     //netra encoder of B10
#define  DS_6401HFH_B10F_RX_CLASS   326        //optical interface encoder(support 1/2 optical access)
#define  DS_6502HW_B10F_RX_CLASS    327        //960H optical interface encoder(support 1/4/8 optical access)
#define  DS_6504D_B11Ex_CLASS        328     //netra HD decoder
#define  DS_6504D_B12Ex_CLASS        329     //netra HD decoder
#define  DS_6512_B11_CLASS            330     //netra encoder
#define  DS_6512_B12_CLASS            331     //netra encoder
#define  DS_6504D_B10H_CLASS        332     //inter HD decoder of video platform
#define  DS_65XXT_B10_CLASS         333     //transcoder of video platform
#define  DS_65XXD_B10_CLASS         335     //65XXD decoder of video platform
#define  DS_IVMSE_B10X_CLASS        336     //X86 service
#define  DS_6532D_B10ES_CLASS        337     //enhance decode board_SDI(b10)
#define  DS_6508HFH_B10ES_CLASS        338     //SDI encoder
#define  DS_82NCG_CLASS                340     //DS_82NCG
#define  DS_82VAG_CLASS                341     //DS_82VAG
#define  DS_1802XXF_B10_CLASS       342     //DS_1802XXF_B10
#define  iDS_6504_B10EVAC_CLASS     343     //intelligence sub system
#define  iDS_6504_B10EDEC_CLASS     344     //intelligence sub system
#define  DS_6402HFH_B10EV_CLASS     345     //netra encoder(VGA)
#define  DS_6402HFH_B10ED_CLASS     346     //netra encoder(DVI)
#define  DS_6402HFH_B10EH_CLASS     347     //netra encoder(HDMI)
#define  DS_6404HFH_B10T_RX_CLASS   348     //fiber access encoder
#define  DS_6504D_AIO_CLASS         349        //netra HD decoder
#define  DS_IVMST_B10_CLASS            350        //stream transform sub system
#define  DS_6402_AIO_CLASS          351     //netra encoder
#define  DS_iVMSE_AIO_CLASS         352     //x86 server sub system
#define  DS_AIO_M_CLASS             353     //Integrated machine


#define  DS_6508HF_B10E_CLASS        355        //BNC encoder
#define  DS_6404HFH_B10ES_CLASS        356        //SDI encoder
#define  DS_6402HFH_B10ER_CLASS        358        //RGB encoder
#define  DS_6404HFH_B10T_RM_CLASS    361        //fiber encoder
#define  DS_6516D_B10EB_CLASS        362        //BNC decoder
#define  DS_6516D_B10ES_CLASS        363        //SDI decoder

//DVI/HDMI/VGA free show decoder share one type
#define DS_6508D_B10FH_CLASS        364
#define DS_6508D_B10FD_CLASS        364
#define DS_6508D_B10FV_CLASS        364

#define  DS_6508_B11E_CLASS            365        //BNC encoder
#define  DS_6402_B11ES_CLASS        366        //SDI encoder
#define  DS_6402_B11EV_CLASS        367        //VGA encoder
#define  DS_6402_B11ER_CLASS        368        //RGB encoder
#define  DS_6402_B11ED_CLASS        369        //DVI encoder
#define  DS_6402_B11EH_CLASS        370        //HDMI encoder
#define  DS_6516D_B11EB_CLASS        371        //BNC decoder
#define  DS_6516D_B11ES_CLASS        372        //SDI decoder

#define  DS_6508_B12E_CLASS         373     //BNC encoder
#define     DS_6402_B12ES_CLASS        375        //SDI encoder
#define  DS_6402_B12EV_CLASS        376        //VGA encoder
#define  DS_6402_B12ER_CLASS        377        //RGB encoder
#define  DS_6402_B12ED_CLASS        378        //DVI encoder
#define  DS_6402_B12EH_CLASS        379        //HDMI encoder
#define  DS_6516D_B12EB_CLASS        380        //BNC decoder

#define  DS_iVMSE_AIO_8100x_CLASS   381     //iVMSE 8100X sub system
#define  DS_iVMSE_AIO_87x_CLASS     382     //iVMSE 87X sub system
#define  DS_6532D_B11ES_CLASS        384        //enhance decode board_SDI(b11)
#define  DS_6532D_B12ES_CLASS        385        //enhance decode board_SDI(b12)
#define  DS_B20_MSU_NP              400     //DS_B20_MSU_NP
#define  DS_6416HFH_B20S            401     //6416HFH_B20S encoder
#define  DS_6416HFH_B20_RM          402     //6416HFH_B20_RM encoder
#define  DS_6564D_B20D              403     //6564D_B20D decoder
#define  DS_6564D_B20H              404     //6564D_B20H decoder
#define  DS_6564D_B20V              405        //6564D_B20V decoder
#define  DS_6408HFH_B20V            407     //6408HFH_B20V encoder
#define  DS_MMC_B20_CLASS           408     //DS_MMC_B20_
#define  DS_CARD_CHIP_B20_CLASS     409     //DS_CARD_CHIP_B20
#define  DS_6564D_B20B_DEV_CLASS    410     //BNC decoder
#define  DS_6564D_B20S_DEV_CLASS    411     //SDI decoder
#define  DS_6532HF_B20B_DEV_CLASS   412     //BNC encoder
#define  DS_6408HFH_B20D_DEV_CLASS  413     //DVI encoder
#define  DS_6408HFH_B20H_DEV_CLASS  414     //HDMI encoder
#define  DS_IVMSE_B20_CLASS            415     //x86 server sub system
#define  DS_6402HFH_B20Y_DEV_CLASS  416     //YUV encoder
#define  DS_6508HW_B20_DEV_CLASS    417     //HW encoder
#define  DS_B20N128Fx_B20_DEV_CLASS 418     //cascade sub system
#define  DS_AIO_MCU_NP_DEV_CLASS    419     //AIO main board
#define  DS_6402_AIO_EV_DEV_CLASS   420     //VGA coder
#define  DS_6508D_AIO_EV_DEV_CLASS  421     //VGA decoder
#define  DS_6508D_AIO_ED_DEV_CLASS  422     //DVI decoder
#define  DS_6508D_AIO_EH_DEV_CLASS  423     //HDMI decoder
#define  DS_6508HD_B20F_DEV_CLASS    424     //enhanced decoder
#define  DS_6402HFH_B20ES_DEV_CLASS 425     //3G SID coder
#define  DS_6532D_B20_DEV_CLASS     426     //B20 decoder
#define  DS_IVMST_B20_DEV_CLASS     427     //X86 service sub system
#define  DS_6416HFH_B20DD_DEV_CLASS 428     //Dual link DVI coder
#define  DS_6441VS_B20_DEV_CLASS    429        //signal joint sub system
#define  DS_6404HFH_B20T_CLASS         431        //TVI coder
#define  DS_FS22_B20_DEV_CLASS         432        //fiber switcher sub system
#define  DS_IVMSE_B20UH_DEV_CLASS   433     //Ultra HD input sub system
#define  IDS_6524J_B20_DEV_CLASS    434
#define  IDS_6532B_B20_DEV_CLASS    435
#define  DS_6404HFH_B20Fx_DEV_CLASS 436        //node optical device input coder
#define  DS_N128x_B20Fy_CLASS        437     //cascade sub system
#define  DS_181600F_B20_CLASS        438     //net fiber sub system
#define  DS_6904UD_B20H_CLASS       439     //Ultra HD decoder
#define  DS_B21_MCU_NP_CLASS        440     //DS_B21_MCU_NP_CLASS
#define  DS_C10S                    501     //C10S Video Wall Controller
#define  DS_C10N_SDI                551        //SDI processor
#define  DS_C10N_BIW                552        //8 channels BNC processor
#define  DS_C10N_DON                553        //display processor
#define  DS_C10N_TVI                554     //TVI processor
#define  DS_C10N_DI2                555     //2 channels DVI processor
#define  DS_C10N_AUDIO_OUT          556     //DVI,HDMI,VGA display processor with audio output
#define  DS_C10N_AUDIO_IN           557     //DVI,HDMI,VGA processor with audio input

#define  DS_C20N                    570     //C20N server
#define  DS_C20N_BNC                571     //C20N BNC input device
#define  DS_C20N_DVI                572     //C20N DVI input device
#define  DS_C20N_DP                 573     //C20N DP input device
#define  DS_C20N_OUT                574     //output device

#define DS_19M00_MN                    601        //network module

#define DS64XXHD_T                    701        //64-T Decoder

#define DS_65XXD                    703     //65 Decoder
#define DS63XXD_T                    704        //63-T Decoder
#define DS_64XXHD_S                 706     //64XXHD-S Decoder
#define DS_68XXT                    707        //multi transcoder
#define DS_65XXD_T                  708     //65D-T Decoder
#define DS_65XXHD_T                 709     //65HD-T Decoder
#define DS_69XXUD                   710     //69XXUD Decoder
#define DS_65XXUD                   711     //65XXUD Decoder
#define DS_65XXUD_L                 712     //65XXUD_L Decoder
#define DS_65XXUD_T                 713     //65XXUD_T Decoder
#define DS_D20XX                    750     //LCD Screen
//SDI matrix
#define DS_C50S                     751     //SDI Matrix
#define DS_D50XX                    752     //LCD Screen
#define DS_D40                        760        //LED screen controller
#define DS_65VMXX                   770     //conference system server
#define DS_65VTXX                   771     //conference system terminal
#define    DS_65VTA                    772        //conference system Integrated terminal
#define DS_65VT_RX                  773     //Interactive teaching terminal
#define DS_CS_SERVER                800     //Virtual screen server
#define DS_68GAP_MCU                831     //video gap
#define DS_K260X                    850     //Access control system
#define DS_K1TXXX                   851     //
#define DS_K280X                    852     //
#define DS_K1T80X                   854     //
#define RAC_6X00                    856     //
#define DS_K2602_AX                 857     //
#define DS_K1T803F                  858     //
#define DS_K2700                    859     //
#define DS_K270X                    860     //
#define DS_K1T500S                  861     //
#define DS_K1A801F                  862     //
#define DS_6800M					900     //68M merger
#define DS_68NTH					901     //information publish device
#define DS_D60S                     902     //information publish server
#define    DS_D10                        931        //Rear-projection device
#define DS_3K0X_NM                    951        //Fiber Converter
#define DS_3E2328                    952     //100M Switches
#define DS_3E1528                    953     //1000M Switches
#define DS_D51OPSXX                 972     //OPS computer box
#define IP_PTSYS_MEGA200            1001    //IP_PTSYS_MEGA200
#define IPCAM_FISHEYE               1002    //Fisheye IP Camera
#define IPCAM_FISHEYE_E             1003    //Economic Fisheye IP Camera
#define IPCAM_365                    1010    //IPC CAM support 365 platform
#define IPCAM_R0                    1011    //IPC CAM support A5S platform
#define IPCAM_R1                    1012    //IPC CAM support 385 platform
#define IPCAM_R2                    1013    //IPC CAM support R2 platform
#define IPCAM_R3                    1014    //IPC CAM support 8127 platform
#define IPCAM_R4                    1015    //IPC CAM support S2 platform

#define IPDOME_365                    1110    //IPD CAM support 365 platform
#define IPDOME_R0                    1111    //IPD CAM support A5S platform
#define IPDOME_R1                    1112    //IPD CAM support 385 platform
#define IPDOME_R2                    1113    //IPD CAM support R2 platform
#define IPDOME_R3                    1114    //IPD CAM support 8127 platform
#define IPDOME_R4                    1115    //IPD CAM support S2 platform
#define ITCCAM_R3                    1211    //ITCCAM support 8127 platform

#define UAV_S                       1300    //Ummanned Aerial Vehicle \A8C Station

//Add Device Type 2013-11-19
#define  TRAFFIC_ECT                1400  //ECT Device Type
#define  TRAFFIC_PARKING_SERVER     1401  //Parking Server
#define  TRAFFIC_TME                1402  //Entrance control machine
// DVR
#define DS90XXHW_ST                    2001    // DS90XXHW_ST
#define DS72XXHX_SH                 2002    // DS-72xxHV_SH, DS-72xxHF-SH
#define DS_92XX_HF_ST                2003    // DS-92XX-HF-ST
#define DS_91XX_HF_XT                2004    // NETRET_9100DVR_HF_XT
#define DS_90XX_HF_XT               2005    // NETRET_9000DVR_HF_XT
#define DS_73XXHX_SH                2006    // NETRET_7300DVR_HX_SH
#define DS_72XXHFH_ST                2007    // NETRET_7200DVR_HFH_ST

//DS_67XX

#define DS_67XXHF_SATA              2008    // DS-67XXHF-SATA
#define DS_67XXHW                   2009    // DS-67XXHW
#define DS_67XXHW_SATA              2010    // DS-67XXHW-SATA
#define DS_67XXHF                   2011    // DS-67XXHF

//Netra2.3
#define DS_72XXHF_SV                 2012   // DS-72xxHF-SV
#define DS_72XXHW_SV                 2013   // DS-72xxHW-SV

#define DS_81XXHX_SH                2014   // NETRET_8100DVR_HX_SH

#define DS_71XXHX_SL                2015    // KY2013 DVR

#define DS_76XXH_ST                    2016    // Netra DS_76XXH_ST


#define DS_73XXHFH_ST               2017   //NETRET_7300HFH_ST
#define DS_81XXHFH_ST               2018   //NETRET_8100HFH_ST

#define DS_72XXHFH_SL                2019    //hi3521
#define DS_FDXXCGA_FLT                2020    //2 HD ATM

#define IDS_91XX_HF_ST_A            2100    //iDS-9100HF-ST/A
#define IDS_91XX_HF_ST_B            2101    //iDS-9100HF-ST/B
#define IDS_90XX_HF_ST_A            2102    //iDS-9000HF-ST/A
#define IDS_90XX_HF_ST_B            2103    //iDS-9000HF-ST/B
#define IDS_81XX_HF_ST_A            2104    //iDS-8100HF-ST/A
#define IDS_81XX_HF_ST_B            2105    //iDS-8100HF-ST/B
#define IDS_80XX_HF_ST_A            2106    //iDS-8000HF-ST/A
#define IDS_80XX_HF_ST_B            2107    //iDS-8000HF-ST/B
#define IDS_8104_AHFL_ST            2108    //iDS-8104-AHFL-ST
#define IDS_2CD6812F_C              2109    //iDS_2CD6812F_C


// NVR
#define DS_77XXN_ST                    2201            // Netra NVR DS-77XXHF-ST
#define DS_95XX_N_ST                2202            // Netra 95XXN_ST NVR
#define DS_85XX_N_ST                2203            // Netra 85XXN_ST NVR
#define DS_96XX_N_XT                2204            // NETRET_9600NVR_N_XT
#define DS_76XX_N_SE                2205            // NETRET_7600NVR_N_SE

//Inquest DVR
#define DS_86XXSN_SX                2206    // NETRET_8608NVR_SX\A3\ACInclude DS-8608SNL-SP\A1\A2DS-8608SNL-ST\A1\A2DS-8608SN-SP\A1\A2DS-8608SN-ST

//#define DS_96XX_N_RX                2207  //Netra DS-96XX-N-RX
#define DS_71XXN_SL                    2208  //8107 DS-71XXN-SL for civil use
#define CS_N1_1XX                    2209  //8107 CS_N1_1XX\A3\ACcivil

#define DS_71XXN_SN                    2210    //NETRET_71XX_N_SN
#define CS_N1_2XX                    2211    //NETRET_N1_2XX
#define DS_76XX_N_SHT                2212    //NETRET_76XX_N_SHT

#define DS_96XXX_N_E                2213    //NVR

#define    DS_76XXN_EX                    2214 /* HISI3535  76 78 Series NVR, Note: Includes 4,8,16 road E1 / N / P devic;  8,16, 32 road, / N / P device */
#define DS_77XXN_E4                    2215/* HISI3535  77 Series NVR,  Note: Includes 8,16, 32 road, / N / P device*/
#define DS_86XXN_E8                    2216/* HISI3535  86Series NVR, Includes 8,16 32 road, / N / P device*/
#define DS_9616N_H8                 2217   //DS_9616N_H8
#define DS_72XXHX_EX_GXY            2218   //72 series wireless DVR/NVR
#define DS_76XXN_EX_GXY             2219   //76 series wireless NVR
#define DS_72XXHXH_SH_21            2220   //  72XXHXH_SH_21
#define DS_72XXHXH_SH_31            2221  //  72XXHXH_SH_31
#define DS_73XXHXH_SH_31            2222  // 73XXHXH_SH_31
#define DS_81XXHXH_SH_31            2223  //  81XXHXH_SH_31
#define DS_71XXHXH_SH_21            2224  // 71XXHXH_SH_21
#define DS_71XXHXH_SH_31            2225  // 71XXHXH_SH_31
#define DS_NBXX_N_E1_X              2226  //NBXX_N_E1_X
#define DS_96XXN_FX                 2230
#define DS_86XXN_FX                 2231
#define DS_96XXXN_HX                2232

#define DS_86XXN_I                    2233    //DS_86XXN_I
#define DS_77XX_N_I                    2234    //DS_77XX_N_I
#define DS_76XX_N_I                    2235    //DS_76XX_N_I
#define DS_78XX_N_I                    2236    //DS_78XX_N_I
#define DS_96XXXN_IX                 2237    //DS-96XXX_N_I\A3\A8DS-96128N-I16\A1\A2DS-96128N-I24\A1\A2DS-96256N-I16\A1\A2DS-96256N-I24\A3\A9

#define DS_90XXHXH_XT               2238    //DS_90XXHXH_XT\A3\A8DS-9016HQH-XT\A3\A9

//PCNVR
#define PCNVR_IVMS_4200             2301    //PCNVR_IVMS_4200

#define IVMS_6200_TP                2401    //iVMS-6200/TP
#define IVMS_6200_TF                2402    //iVMS-6200/TF
#define IVMS_6200_D                 2403   //iVMS-6200(/D)
#define IDS_81XXAHW_ST              2405   //iDS-81xxAHW-ST
#define IDS_81XXAHW_SP              2406   //iDS-81xxAHW-SP
#define IDS_81XXAHWL_ST             2407   //iDS-81xxAHWL-ST
#define IDS_81XXAHWL_SP             2408   //iDS-81xxAHWL-SP
#define IDS_9616N_H8                2409   //iDS_9616N_H8
#define IVMS_6200_SMD               2500   //IVMS_6200_SMD

//HISI3531 ATM DVR
#define DS_81XXAHW_ST                2501
#define DS_81XXAHW_SP                2502
#define DS_81XXAHWL_ST                2503
#define DS_81XXAHWL_SP                2504

//TVI ATM
#define DS_81XXAHGH_E4                2601    //DS_81XXAHGH_E4

#define DS_6904UD_AIOE_H_CLASS      4002    //Integrated machine
#define DS_6402HFH_B21B_CLASS       4005    //B21 BNC coder
#define DS_6902UD_B21H_CLASS        4006    //B21 HDMI decoder
#define DS_6902UD_B21D_CLASS        4007    //B21 DVI decoder
#define DS_6902UD_B21V_CLASS        4008    //B21 VGA decoder
#define DS_6904UD_B20D_CLASS        4010    //B20 DVI decoder
#define DS_6904UD_B20V_CLASS        4011    //B20 VGA decoder
/**********************Device model end***********************/

/**********************Device Class begin**********************/

/* dvr 1-50 */
#define DEV_CLASS_DVR      1          //dvr
#define DEV_CLASS_INTERROGATION  2    //Interrogation
#define DEV_CLASS_SIMPLE_TRAIL  3    //simple trail
#define DEV_CLASS_TRAIL  4           //trail
#define DEV_CLASS_RECORD_PLAY  5     //record play
#define DEV_CLASS_ATM 6           //ATM

/* dvs 51-100 */
#define DEV_CLASS_DVS 51          //dvs

/* nvr 101-150 */
#define DEV_CLASS_NVR 101          //nvr

/* ipc 151-200 */
#define DEV_CLASS_GUN 151          //ipc gun
#define DEV_CLASS_BALL 152          //ipc ball
#define DEV_CLASS_SNAP 153          //snap
#define DEV_CLASS_INTELLI_TILT 154   //intrllt tilt
#define DEV_CLASS_FISH_EYE 155          //fish eye
#define DEV_CLASS_2DP_Z 156         //2DP_Z
#define DEV_CLASS_2DP 157   //2DP

/* CVR 201 - 250*/
#define DEV_CLASS_CVR 201          //CVR

/* Transfer & Display 251 - 300*/
#define DEV_CLASS_B20 251          //B20
#define DEV_CLASS_B10 252          //B10
#define DEV_CLASS_DECODER 253      //DECODER
#define DEV_CLASS_MATRIXMANAGEDEVICE 254      //MATRIXMANAGEDEVICE
#define DEV_CLASS_OTICAL 255      //OTICA
#define DEV_CLASS_CODESPITTER 256      //CODESPITTER
#define DEV_CLASS_ALARMHOST 257      //ALARMHOST
#define DEV_CLASS_MOVING_RING 258      //MOVING_RING
#define DEV_CLASS_CVCS 259      //CVCS
#define DEV_CLASS_DVCS 260      //DVCS
#define DEV_CLASS_TRANSCODER 261      //TRANSCODER
#define DEV_CLASS_LCD_SCREEN 262      //LCD SCREEN
#define DEV_CLASS_LED_SCREEN 263      //LED SCREEN
#define DEV_CLASS_MATRIX 264      //MATRIX
#define DEV_CLASS_CONFERENCE_SYSTEM 265      //CONFERENCE_SYSTEM
#define DEV_CLASS_INTERACTIVE_TEACH_TERMIANL  266      // interactive teaching terminal
#define DEV_CLASS_NET_GAP 267      //net gap
#define DEV_CLASS_MERGE 268      //merge
#define DEV_CLASS_REAR_PROJECTION 269      //rear projection
#define DEV_CLASS_SWITCH 270      //switch
#define DEV_CLASS_FIBER_CONVERTER 271      //fiber converter
#define DEV_CLASS_SCREEN_SERVER 272      //screen server
#define DEV_CLASS_SCE_SERVER 273      //SCE server

/* ALARM 301 - 350*/
#define DEV_CLASS_VIDEO_ALARM_HOST 301          //video alarm host
#define DEV_CLASS_NET_ALARM_HOST 302          //net alarm host
#define DEV_CLASS_ONE_KEY_ALARM 303      //one key alarm
#define DEV_CLASS_WIRELESS_ALARM_HOST 304      //wireless alarm host
#define DEV_CLASS_4G_NET 305      //4G net
#define DEV_CLASS_HOME_ALARM_HOST 306      //home alarm host

/* access control 351 - 400*/
#define DEV_CLASS_ACCESS_CONTROL 351          //access control

/* video intercom 401 - 450*/
#define DEV_CLASS_VIDEO_INTERCOM 401          //video intercom

/* UNNanned aerial vehicle 451 - 500*/
#define DEV_CLASS_UMMANNED_AERIAL_VEHICLE 451          //UNNanned aerial vehicle

/* mobile: 501-550*/
#define DEV_CLASS_MOBILE 501          //mobile

/* mobile vehicle: 551-600*/
#define DEV_CLASS_MOBILE_VEHICLE 551          //mobile vehicle

/* other class 65534 */
#define DEV_CLASS_DEFAULT 65534   //default
/**********************Device Class end**********************/

/************************DVR Log begin***************************/

/* Alarm */
//Main Type
#define MAJOR_ALARM                        0x1
//Hypo- Type
#define MINOR_ALARM_IN                    0x1   //Alarm input
#define MINOR_ALARM_OUT                    0x2   //Alarm output
#define MINOR_MOTDET_START                0x3   //Motion detection alarm start
#define MINOR_MOTDET_STOP                0x4   //Motion detection alarm stop
#define MINOR_HIDE_ALARM_START            0x5   //Mask alarm start
#define MINOR_HIDE_ALARM_STOP            0x6   //Mask alarm stop
#define MINOR_VCA_ALARM_START            0x7   //VCA alarm start
#define MINOR_VCA_ALARM_STOP            0x8   //VCA alarm stop
#define MINOR_ITS_ALARM_START           0x09  // Traffic event alarm start
#define MINOR_ITS_ALARM_STOP            0x0A  //Traffic event alarm stop
#define MINOR_NETALARM_START            0x0b  //Net alarm start
#define MINOR_NETALARM_STOP             0x0c  //Net alarm stop
//2012-4-5 IPC PIR\wireless\callhelp
#define MINOR_WIRELESS_ALARM_START        0x0e  /* wireless alarm start */
#define MINOR_WIRELESS_ALARM_STOP          0x0f /* wireless alarm stop */
#define MINOR_PIR_ALARM_START           0x10  /* PIR alarm start */
#define MINOR_PIR_ALARM_STOP               0x11  /* PIR alarm stop */
#define MINOR_CALLHELP_ALARM_START      0x12  /* callhelp start */
#define MINOR_CALLHELP_ALARM_STOP          0x13  /* callhelp stop */
#define MINOR_IPCHANNEL_ALARMIN_START   0x14  //IP channel alarm in start: It happens whenPCNVR receives the alarm in from its IP channel.After 10s,  "IP channel alarm in stop" happens if PCNVR can't receive it.
#define MINOR_IPCHANNEL_ALARMIN_STOP    0x15  //IP channel alarm in stop.
#define MINOR_DETECTFACE_ALARM_START    0x16  /* Face detection alarm start */
#define MINOR_DETECTFACE_ALARM_STOP      0x17  /* Face detection alarm stop */
#define MINOR_VQD_ALARM_START           0x18  //VQD alarm start
#define MINOR_VQD_ALARM_STOP            0x19  //VQD alarm stop
#define MINOR_VCA_SECNECHANGE_DETECTION 0x1a  //Sencne Change Detection 2013-07-16

#define MINOR_SMART_REGION_EXITING_BEGIN                0x1b  //Region Exiting Begin
#define MINOR_SMART_REGION_EXITING_END                  0x1c  //Region Exiting End
#define MINOR_SMART_LOITERING_BEGIN                     0x1d  //Loitering Begin
#define MINOR_SMART_LOITERING_END                       0x1e  //Loitering End

#define MINOR_VCA_ALARM_LINE_DETECTION_BEGIN            0x20
#define MINOR_VCA_ALARM_LINE_DETECTION_END                0x21
#define MINOR_VCA_ALARM_INTRUDE_BEGIN                      0x22  //field start
#define MINOR_VCA_ALARM_INTRUDE_END                           0x23  //field stop
#define MINOR_VCA_ALARM_AUDIOINPUT                        0x24   //Audio Exception
#define MINOR_VCA_ALARM_AUDIOABNORMAL                     0x25   //Voice ABNORMAL
#define MINOR_VCA_DEFOCUS_DETECTION_BEGIN                0x26  //defous detection start
#define MINOR_VCA_DEFOCUS_DETECTION_END                    0x27  //defous detection end
#define MINOR_EXT_ALARM                                    0x28             /*IPC External alarm*/
#define MINOR_VCA_FACE_ALARM_BEGIN                        0x29       /*face detect begin*/
#define MINOR_SMART_REGION_ENTRANCE_BEGIN               0x2a  //Region Entrance Begin
#define MINOR_SMART_REGION_ENTRANCE_END                 0x2b  //Region Entrance End
#define MINOR_SMART_PEOPLE_GATHERING_BEGIN              0x2c  //People Gathering Begin
#define MINOR_SMART_PEOPLE_GATHERING_END                0x2d  //People Gathering End
#define MINOR_SMART_FAST_MOVING_BEGIN                   0x2e  //Fast Moving Begin
#define MINOR_SMART_FAST_MOVING_END                     0x2f  //Fast Moving End

#define MINOR_VCA_FACE_ALARM_END                        0x30       /*face detect end*/
#define MINOR_VCA_SCENE_CHANGE_ALARM_BEGIN                0x31   /*scene change start*/
#define MINOR_VCA_SCENE_CHANGE_ALARM_END                0x32   /*scene change end*/
#define MINOR_VCA_ALARM_AUDIOINPUT_BEGIN                0x33   /*audio in put start*/
#define MINOR_VCA_ALARM_AUDIOINPUT_END                    0x34   /*audio in put end*/
#define MINOR_VCA_ALARM_AUDIOABNORMAL_BEGIN                0x35  /*audio abnormal start*/
#define MINOR_VCA_ALARM_AUDIOABNORMAL_END                0x36  /*audio abnormal end*/

#define MINOR_VCA_LECTURE_DETECTION_BEGIN               0x37  //Lecture Alarm Begin
#define MINOR_VCA_LECTURE_DETECTION_END                 0x38  //Lecture Alarm End
#define MINOR_VCA_SITDOWN_DETECTION                         0x38  //Sit Down Detection Alarm
#define MINOR_VCA_ALARM_AUDIOSTEEPDROP                  0x39  //Audio Decibel Steep Drop 2014-03-21
#define MINOR_VCA_ANSWER_DETECTION_BEGIN                0x3a //Answer Detection Begin
#define MINOR_VCA_ANSWER_DETECTION_END                  0x3b //Answer Detection End

#define MINOR_SMART_PARKING_BEGIN                       0x3c   //Parking Begin
#define MINOR_SMART_PARKING_END                         0x3d   //Parking End
#define MINOR_SMART_UNATTENDED_BAGGAGE_BEGIN            0x3e   //Unattended Baggage Begin
#define MINOR_SMART_UNATTENDED_BAGGAGE_END              0x3f   //Unattended Baggage End
#define MINOR_SMART_OBJECT_REMOVAL_BEGIN                0x40   //Object Removal Begin
#define MINOR_SMART_OBJECT_REMOVAL_END                  0x41   //Object Removal End
#define MINOR_SMART_VEHICLE_ALARM_START                 0x46   //Vehicle alarm Begin
#define MINOR_SMART_VEHICLE_ALARM_STOP                  0x47   //Vehicle alarm Begin
#define MINOR_THERMAL_FIREDETECTION                     0x48   //Fire Detection Begin
#define MINOR_THERMAL_FIREDETECTION_END                 0x49   //Fire Detection End
#define MINOR_SMART_VANDALPROOF_BEGIN                   0x50   //Vandalproof Detection Begin
#define MINOR_SMART_VANDALPROOF_END                     0x51   //Vandalproof Detection End

#define MINOR_THERMAL_SHIPSDETECTION                    0x5a   //Thermal Ship Detection
#define MINOR_THERMAL_THERMOMETRY_EARLYWARNING_BEGIN    0x5b   //Thermal Thermometry Early Warning Begin
#define MINOR_THERMAL_THERMOMETRY_EARLYWARNING_END      0x5c   //Thermal Thermometry Early Warning End
#define MINOR_THERMAL_THERMOMETRY_ALARM_BEGIN           0x5d   //Thermal Thermometry Alarm Begin
#define MINOR_THERMAL_THERMOMETRY_ALARM_END             0x5e   //Thermal Thermometry Alarm End
#define MINOR_THERMAL_THERMOMETRY_DIFF_ALARM_BEGIN      0x5f   //Thermal Thermometry diff Alarm Begin
#define MINOR_THERMAL_THERMOMETRY_DIFF_ALARM_END        0x60   //Thermal Thermometry diff Alarm End
#define MINOR_SMART_DENSEFOGDETECTION_BEGIN         0x6e  //Dense fog detection Begin
#define MINOR_SMART_DENSEFOGDETECTION_END        0x6f  //Dense fog detection End
//0x400-0x1000 access card alarm
#define MINOR_ALARMIN_SHORT_CIRCUIT                 0x400  //region short circuit
#define MINOR_ALARMIN_BROKEN_CIRCUIT                0x401  //region broken circuit
#define MINOR_ALARMIN_EXCEPTION                     0x402  //region exception
#define MINOR_ALARMIN_RESUME                        0x403  //region resume
#define MINOR_HOST_DESMANTLE_ALARM                  0x404  //region desmantle alarm
#define MINOR_HOST_DESMANTLE_RESUME                 0x405  //region desmantle resume
#define MINOR_CARD_READER_DESMANTLE_ALARM           0x406  //card reader desmantle alarm
#define MINOR_CARD_READER_DESMANTLE_RESUME          0x407  //card reader desmantle resume
#define MINOR_CASE_SENSOR_ALARM                     0x408  //case sensor alarm
#define MINOR_CASE_SENSOR_RESUME                    0x409  //case sensor resume
#define MINOR_STRESS_ALARM                          0x40a  //stress alarm
#define MINOR_OFFLINE_ECENT_NEARLY_FULL             0x40b  //offline ecent nearly full
#define MINOR_CARD_MAX_AUTHENTICATE_FAIL            0x40c  //card max authenticate fall
#define MINOR_SD_CARD_FULL                          0x40d  //SD card is full
#define MINOR_LINKAGE_CAPTURE_PIC                   0x40e  //lingage capture picture
#define MINOR_SECURITY_MODULE_DESMANTLE_ALARM        0x40f  //Door control security module desmantle alarm
#define MINOR_SECURITY_MODULE_DESMANTLE_RESUME        0x410  //Door control security module desmantle resume
#define MINOR_POS_START_ALARM                       0x411  //POS Start
#define MINOR_POS_END_ALARM                         0x412  //POS end
#define MINOR_FACE_IMAGE_QUALITY_LOW                0x413  //face image quality low
#define MINOR_FINGE_RPRINT_QUALITY_LOW              0x414  //finger print quality low
#define MINOR_FIRE_IMPORT_SHORT_CIRCUIT             0x415  //Fire import short circuit
#define MINOR_FIRE_IMPORT_BROKEN_CIRCUIT            0x416  //Fire import broken circuit
#define MINOR_FIRE_IMPORT_RESUME                    0x417  //Fire import resume
/*Exception */
//Main Type
#define MAJOR_EXCEPTION                    0x2
//Hypo- Type

#define MINOR_RAID_ERROR                0x20    /* RAID Exception */
#define MINOR_VI_LOST                    0x21  //Video loss
#define MINOR_ILLEGAL_ACCESS            0x22  //Illegal access
#define MINOR_HD_FULL                    0x23  //HD full
#define MINOR_HD_ERROR                    0x24  //HD error
#define MINOR_DCD_LOST                    0x25  //MODEM  off- line (Reserved)
#define MINOR_IP_CONFLICT                0x26  //IP conflict
#define MINOR_NET_BROKEN                0x27  //Network disconnected
#define MINOR_REC_ERROR                 0x28  //Record error
#define MINOR_IPC_NO_LINK               0x29  //IPC connection failed
#define MINOR_VI_EXCEPTION              0x2a  //Video input error  (for analog channel only)
#define MINOR_IPC_IP_CONFLICT           0x2b  //IPC IP conflict
#define MINOR_SENCE_EXCEPTION           0x2c  //Sence exception
#define MINOR_PIC_REC_ERROR             0x2d  //Snapshot error!
#define MINOR_VI_MISMATCH               0x2e  //Video format error.
#define MINOR_RESOLUTION_MISMATCH        0x2f    /*Resolution miamatch */

//2009- 12- 16 Add Video integrated platform Log Type
#define MINOR_FANABNORMAL                0x31  //Video integrated platform: fan abnormal
#define MINOR_FANRESUME                    0x32  //Video integrated platform: fan resume normal
#define MINOR_SUBSYSTEM_ABNORMALREBOOT    0x33  //Video integrated platform: 6467abnormal reboot
#define MINOR_MATRIX_STARTBUZZER        0x34  //Video integrated platform: dm6467 abnormal, start buzzer
//2010- 01- 22
#define MINOR_NET_ABNORMAL                0x35  //Net abnormal
#define MINOR_MEM_ABNORMAL                0x36  //Memory abnormal
#define MINOR_FILE_ABNORMAL                0x37  //File abnormal
#define MINOR_RS485_DEVICE_ABNORMAL        0x3a     /*RS485 connect status exception*/
#define MINOR_RS485_DEVICE_REVERT        0x3b    /*RS485 connect status exception recovry*/
#define MINOR_SCREEN_SUBSYSTEM_ABNORMALREBOOT   0x3c            //abnormal reboot
#define    MINOR_SCREEN_SUBSYSTEM_ABNORMALINSERT    0x3d            //sub board insert
#define    MINOR_SCREEN_SUBSYSTEM_ABNORMALPULLOUT    0x3e            //sub board pull out
#define    MINOR_SCREEN_ABNARMALTEMPERATURE        0x3f            //abnormal temperature
//2012-07-26
#define MINOR_HIGH_TEMPERATURE_PROTECT  0x40 //sub board high temperature protect
//Netra 2.2.2
#define MINOR_RECORD_OVERFLOW           0x41              //Record overflow
#define MINOR_DSP_ABNORMAL              0x42              //DSP abnormal
//Netra 3.0.0
#define MINOR_ANR_RECORD_FAIED                 0x43            /*ANR record failed*/
#define MINOR_SPARE_WORK_DEVICE_EXCEPT         0x44            /*Work device failed*/
#define MINOR_START_IPC_MAS_FAILED             0x45            /*Open IPC mas failed*/
#define MINOR_IPCM_CRASH                       0x46         /*IPCM crash*/
#define MINOR_POE_POWER_EXCEPTION              0x47         /*POE Power Exception*/
#define MINOR_UPLOAD_DATA_CS_EXCEPTION         0x48          //upload data to cs Exception/
#define MINOR_DIAL_EXCEPTION                   0x49
#define MINOR_AI_LOST                           0x52            /* audio lost */


#define MINOR_SYNC_IPC_PASSWD                   0x53        /* Sync IPC password exception */
#define MINOR_EZVIZ_OFFLINE                        0x54        /* EZVIZ Offline*/
#define MINOR_VQD_ABNORMAL                        0x55 //VQD anomalies
#define MINOR_ACCESSORIES_PLATE                0x57 //accessories abnormal plate
#define MINOR_KMS_EXPAMSION_DISK_LOST         0x58 // KMS Expansion disk lost
#define MINOR_ABNORMAL_PORT                 0x59 // Abnormal port

//0x400-0x1000 access card exception type
#define MINOR_DEV_POWER_ON                     0x400  //device power on
#define MINOR_DEV_POWER_OFF                    0x401  //device power off
#define MINOR_WATCH_DOG_RESET                  0x402  //watch dog reset
#define MINOR_LOW_BATTERY                      0x403  //low battery
#define MINOR_BATTERY_RESUME                   0x404  //battery resume
#define MINOR_AC_OFF                           0x405  //AC off
#define MINOR_AC_RESUME                        0x406  //AC resume
#define MINOR_NET_RESUME                       0x407  //Net resume
#define MINOR_FLASH_ABNORMAL                   0x408  //FLASH abnormal
#define MINOR_CARD_READER_OFFLINE              0x409  //card reader offline
#define MINOR_CARD_READER_RESUME               0x40a  //card reader resume
#define MINOR_INDICATOR_LIGHT_OFF              0x40b  //Indicator Light Off
#define MINOR_INDICATOR_LIGHT_RESUME           0x40c  //Indicator Light Resume
#define MINOR_CHANNEL_CONTROLLER_OFF           0x40d  //channel controller off
#define MINOR_CHANNEL_CONTROLLER_RESUME        0x40e  //channel controller resume
#define MINOR_SECURITY_MODULE_OFF               0x40f  //Door control security module off
#define MINOR_SECURITY_MODULE_RESUME           0x410  //Door control security module resume
#define MINOR_BATTERY_ELECTRIC_LOW             0x411  //battery electric low
#define MINOR_BATTERY_ELECTRIC_RESUME          0x412  //battery electric resume
#define MINOR_LOCAL_CONTROL_NET_BROKEN		   0x413  //Local control net broken
#define MINOR_LOCAL_CONTROL_NET_RSUME	       0x414  //Local control net resume
#define MINOR_MASTER_RS485_LOOPNODE_BROKEN     0x415  //Master RS485 loop node broken
#define MINOR_MASTER_RS485_LOOPNODE_RESUME     0x416  //Master RS485 loop node resume
#define MINOR_LOCAL_CONTROL_OFFLINE            0x417  //Local control offline
#define MINOR_LOCAL_CONTROL_RESUME             0x418  //Local control resume
#define MINOR_LOCAL_DOWNSIDE_RS485_LOOPNODE_BROKEN  0x419  //Local downside RS485 loop node broken
#define MINOR_LOCAL_DOWNSIDE_RS485_LOOPNODE_RESUME  0x41a  //Local downside RS485 loop node resume

#define MINOR_SUBSYSTEM_IP_CONFLICT        0x4000        //subsystem IP conflict
#define MINOR_SUBSYSTEM_NET_BROKEN        0x4001        //subsystem net broken
#define    MINOR_FAN_ABNORMAL                0x4002        //fan abnormal
#define    MINOR_BACKPANEL_TEMPERATURE_ABNORMAL        0x4003        //back panel abnormal
#define    MINOR_SDCARD_ABNORMAL                   0x4004  //SD Card Abnormal
#define    MINOR_SDCARD_DAMAGE                       0x4005  //SD Card Damage

/* Operation */
//Main Type
#define MAJOR_OPERATION                    0x3

#define MINOR_VCA_MOTIONEXCEPTION        0x29  //VCA detect exception


//Hypo- Type
#define MINOR_START_DVR                    0x41    /* Power On */
#define MINOR_STOP_DVR                    0x42    /* Power off */
#define MINOR_STOP_ABNORMAL                0x43    /* Illegal shut down */
#define MINOR_REBOOT_DVR                0x44    /*Local reboot DVR*/

#define MINOR_LOCAL_LOGIN                0x50    /* Login  (local)  */
#define MINOR_LOCAL_LOGOUT                0x51    /* Logout  (local) */
#define MINOR_LOCAL_CFG_PARM            0x52    /* Configuration  (local)  */
#define MINOR_LOCAL_PLAYBYFILE            0x53    /* Playback  (local)  */
#define MINOR_LOCAL_PLAYBYTIME            0x54    /* Playback or download by time  (local) */
#define MINOR_LOCAL_START_REC            0x55    /* Start record  (local)  */
#define MINOR_LOCAL_STOP_REC            0x56    /* Stop record  (local) */
#define MINOR_LOCAL_PTZCTRL                0x57    /* PTZ control  (local)  */
#define MINOR_LOCAL_PREVIEW                0x58    /* Preview  (local)  (Reserved) */
#define MINOR_LOCAL_MODIFY_TIME         0x59    /* Change time  (local)  (Reserved)  */
#define MINOR_LOCAL_UPGRADE                0x5a    /* Upgrade  (local)  */
#define MINOR_LOCAL_RECFILE_OUTPUT      0x5b    /* Backup  (local)  */
#define MINOR_LOCAL_FORMAT_HDD          0x5c    /* HD format (local)  */
#define MINOR_LOCAL_CFGFILE_OUTPUT      0x5d    /* Export Configuration  (local)  */
#define MINOR_LOCAL_CFGFILE_INPUT       0x5e    /* Import Configuration  (local)  */
#define MINOR_LOCAL_COPYFILE            0x5f    /* Backup file  (local)  */
#define MINOR_LOCAL_LOCKFILE            0x60    /* File lockup  (local) Reboot IPC  (local)  */
#define MINOR_LOCAL_UNLOCKFILE          0x61    /* File unlock  (local)  */
#define MINOR_LOCAL_DVR_ALARM           0x62    /* Clear/Trigger Alarm  (Local) */
#define MINOR_IPC_ADD                   0x63    /* Add IPC  (local)  */
#define MINOR_IPC_DEL                   0x64    /* Delete IPC  (local) */
#define MINOR_IPC_SET                   0x65    /* Set IPC  (local)  */
#define MINOR_LOCAL_START_BACKUP        0x66    /* local start backup file */
#define MINOR_LOCAL_STOP_BACKUP            0x67    /* local stop backup file*/
#define MINOR_LOCAL_COPYFILE_START_TIME 0x68    /* local backup: file start time*/
#define MINOR_LOCAL_COPYFILE_END_TIME    0x69    /* local backup: file end time*/
#define MINOR_LOCAL_ADD_NAS             0x6a    /* Add network hard disk in local configuration  (NFS/iSCSI) */
#define MINOR_LOCAL_DEL_NAS             0x6b    /* Delete network hard disk in local configuration  (NFS/iSCSI) */
#define MINOR_LOCAL_SET_NAS             0x6c    /* Set network hard disk in local configuration  (NFS/iSCSI) */
#define MINOR_LOCAL_RESET_PASSWD        0x6d    /* Local Resume Admin's Password*/

#define MINOR_REMOTE_LOGIN                0x70    /* Login  (remote) */
#define MINOR_REMOTE_LOGOUT                0x71    /* Logout   (remote)  */
#define MINOR_REMOTE_START_REC            0x72    /* Start record  (remote) */
#define MINOR_REMOTE_STOP_REC            0x73    /* Stop record   (remote)  */
#define MINOR_START_TRANS_CHAN            0x74    /* Start transparent channel  (remote)  */
#define MINOR_STOP_TRANS_CHAN            0x75    /* Stop transparent channel  (remote)  */
#define MINOR_REMOTE_GET_PARM            0x76    /* Get parameter  (remote) */
#define MINOR_REMOTE_CFG_PARM            0x77    /* configuration  (remote) */
#define MINOR_REMOTE_GET_STATUS         0x78    /* Get status  (remote)  */
#define MINOR_REMOTE_ARM                0x79    /* On guard   (remote)  */
#define MINOR_REMOTE_DISARM                0x7a    /* Disarm   (remote)  */
#define MINOR_REMOTE_REBOOT                0x7b    /* Reboot   (remote)  */
#define MINOR_START_VT                    0x7c    /* Start voice talk */
#define MINOR_STOP_VT                    0x7d    /* Stop voice talk */
#define MINOR_REMOTE_UPGRADE            0x7e    /* upgrade  (remote)  */
#define MINOR_REMOTE_PLAYBYFILE         0x7f    /* Playback by file name  (remote)  */
#define MINOR_REMOTE_PLAYBYTIME         0x80    /* Playback by time  (remote)  */
#define MINOR_REMOTE_PTZCTRL            0x81    /* PTZ control  (remote)  */
#define MINOR_REMOTE_FORMAT_HDD         0x82    /* Format hard disk (remote)  */
#define MINOR_REMOTE_STOP               0x83    /* Shut Down  (remote)  */
#define MINOR_REMOTE_LOCKFILE            0x84    /* File lockup  (remote)  */
#define MINOR_REMOTE_UNLOCKFILE         0x85    /* File unlock  (remote */
#define MINOR_REMOTE_CFGFILE_OUTPUT     0x86    /* Export Configuration   (remote)  */
#define MINOR_REMOTE_CFGFILE_INTPUT     0x87    /* Import Configuration  (remote)  */
#define MINOR_REMOTE_RECFILE_OUTPUT     0x88    /* Backup recording files  (remote)  */
#define MINOR_REMOTE_DVR_ALARM          0x89    /* Trigger/clear alarm  (remote) */
#define MINOR_REMOTE_IPC_ADD            0x8a    /* Add IPC  (remote) */
#define MINOR_REMOTE_IPC_DEL            0x8b    /* Delete IPC  (remote) */
#define MINOR_REMOTE_IPC_SET            0x8c    /* Set  IPC  (remote) */
#define MINOR_REBOOT_VCA_LIB            0x8d    /* Reboot vca library*/
#define MINOR_REMOTE_ADD_NAS            0x8e    /* Remote add nas disk*/
#define MINOR_REMOTE_DEL_NAS            0x8f    /* Remote delete nas disk*/
#define MINOR_REMOTE_SET_NAS            0x90    /* Remote set nas disk*/
//2012-11-29 Netra2.3
#define MINOR_LOCAL_OPERATE_LOCK        0x9d    /* local operate Lock*/
#define MINOR_LOCAL_OPERATE_UNLOCK      0x9e    /* local operate UnLock */
#define MINOR_REMOTE_DELETE_HDISK       0x9a    /* Remote delete HDisk */
#define MINOR_REMOTE_LOAD_HDISK         0x9b    /* Remote Load HDisk*/
#define MINOR_REMOTE_UNLOAD_HDISK       0x9c    /* Remote Unload HDisk   */

//2010- 05- 26 Add Inquest DVR Log Type
#define MINOR_LOCAL_START_REC_CDRW      0x91    /* Local start CD/DVD writing */
#define MINOR_LOCAL_STOP_REC_CDRW       0x92    /* Local stop CD/DVD writing */
#define MINOR_REMOTE_START_REC_CDRW     0x93    /* Remote Start CD/DVD writing  */
#define MINOR_REMOTE_STOP_REC_CDRW      0x94    /* Remote stop CD/DVD writing */

#define MINOR_LOCAL_PIC_OUTPUT            0x95    /* local save picture */
#define MINOR_REMOTE_PIC_OUTPUT            0x96    /* remote save picture */

//2011-07-26 Add 81 Inquest DVR Log Type
#define MINOR_LOCAL_INQUEST_RESUME      0x97    /* local resume inquest event*/
#define MINOR_REMOTE_INQUEST_RESUME     0x98    /* remote resume inquest event*/

#define MINOR_LOCAL_ADD_FILE            0x99
#define MINOR_LOCAL_DEL_FILE            0x9f

#define MINOR_DELETE_LOGO               0xdd    /* delete logo */

#define MINOR_REMOTE_INQUEST_ADD_FILE   0x100




//2009- 12- 16 Add Video integrated platform Log Type
#define MINOR_SUBSYSTEMREBOOT           0xa0    /*Video integrated platform: dm6467 normal reboot*/
#define MINOR_MATRIX_STARTTRANSFERVIDEO 0xa1    /*Video integrated platform: Matrix Switch start transmitting images*/
#define MINOR_MATRIX_STOPTRANSFERVIDEO    0xa2    /*Video integrated platform: Matrix Switching to stop transmission of images*/
#define MINOR_REMOTE_SET_ALLSUBSYSTEM   0xa3    /*Video integrated platform: Set all the 6467 sub- systems of information*/
#define MINOR_REMOTE_GET_ALLSUBSYSTEM   0xa4    /*Video integrated platform: Get all the 6467 sub- systems of information*/
#define MINOR_REMOTE_SET_PLANARRAY      0xa5    /*Video integrated platform: Set plan array*/
#define MINOR_REMOTE_GET_PLANARRAY      0xa6    /*Video integrated platform: Get plan array*/
#define MINOR_MATRIX_STARTTRANSFERAUDIO 0xa7    /*Video integrated platform: Start transmission Audio Matrix Switch */
#define MINOR_MATRIX_STOPRANSFERAUDIO   0xa8    /*Video integrated platform: Stop transmission Audio Matrix Switch*/
#define MINOR_LOGON_CODESPITTER         0xa9    /*Video integrated platform: Logon spitter code*/
#define MINOR_LOGOFF_CODESPITTER        0xaa    /*Video integrated platform: Logoff spitter code*/
//2010- 01- 22 Add Video integrated platform Log Type
#define MINOR_START_DYNAMIC_DECODE         0xb0    /*Start dynamic decode*/
#define MINOR_STOP_DYNAMIC_DECODE        0xb1    /*Stop dynamic decode*/
#define MINOR_GET_CYC_CFG                0xb2    /*Get cycle config*/
#define MINOR_SET_CYC_CFG                0xb3    /*Set cycle config*/
#define MINOR_START_CYC_DECODE            0xb4    /*Start cycle decode*/
#define MINOR_STOP_CYC_DECODE            0xb5    /*Stop cycle decode*/
#define MINOR_GET_DECCHAN_STATUS        0xb6    /*Get decode channel status*/
#define MINOR_GET_DECCHAN_INFO            0xb7    /*Get decode channel information*/
#define MINOR_START_PASSIVE_DEC            0xb8    /*Start passive*/
#define MINOR_STOP_PASSIVE_DEC            0xb9    /*Stop passive decode*/
#define MINOR_CTRL_PASSIVE_DEC            0xba    /*Passive decode control*/
#define MINOR_RECON_PASSIVE_DEC            0xbb    /*Passive decode reconnect*/
#define MINOR_GET_DEC_CHAN_SW            0xbc    /*Get decode channel switch*/
#define MINOR_SET_DEC_CHAN_SW            0xbd    /*Set decode channel switch*/
#define MINOR_CTRL_DEC_CHAN_SCALE        0xbe    /*Decode channel scale control*/
#define MINOR_SET_REMOTE_REPLAY            0xbf    /*Set remote replay*/
#define MINOR_GET_REMOTE_REPLAY            0xc0    /*Get remote replay*/
#define MINOR_CTRL_REMOTE_REPLAY        0xc1    /*Remote replay control*/
#define MINOR_SET_DISP_CFG                0xc2    /*Set display config*/
#define MINOR_GET_DISP_CFG                0xc3    /*Get display config*/
#define MINOR_SET_PLANTABLE                0xc4    /*Set plan table*/
#define MINOR_GET_PLANTABLE                0xc5    /*Get plan table*/
#define MINOR_START_PPPPOE                0xc6    /*Start pppoe*/
#define MINOR_STOP_PPPPOE                0xc7    /*Stop pppoe*/
#define MINOR_UPLOAD_LOGO                0xc8    /*Upload logo*/

#define MINOR_LOCAL_PIN                    0xc9    /* local PIN operation*/
#define MINOR_LOCAL_DIAL                0xca    /* local manual disconnect dialing*/
#define MINOR_SMS_CONTROL                0xcb    /* SMS control on line/off line*/
#define MINOR_CALL_ONLINE                0xcc    /* call control on line*/
#define MINOR_REMOTE_PIN                0xcd    /* remote PIN operation*/


#define MINOR_REMOTE_ALARMOUT_OPEN_MAN  0xd6    /* remote mamual open alarmout */
#define MINOR_REMOTE_ALARMOUT_CLOSE_MAN 0xd7    /* remote mamual close alarmout*/
#define MINOR_DELETE_LOGO               0xdd    /* delete logo */
#define MINOR_REMOTE_INQUEST_DEL_FILE   0xde

#define MINOR_LOCAL_CONF_REB_RAID       0x101           /*Rebuild configuration automatically and locally*/
#define MINOR_LOCAL_CONF_SPARE          0x102           /*Hot spare of local configuration*/
#define MINOR_LOCAL_ADD_RAID            0x103           /*Add RAID locally*/
#define MINOR_LOCAL_DEL_RAID            0x104           /*Delete RAID locally*/
#define MINOR_LOCAL_MIG_RAID            0x105           /*Migrate RAID locally*/
#define MINOR_LOCAL_REB_RAID            0x106           /*Rebuild RAID manually and locally*/
#define MINOR_LOCAL_QUICK_CONF_RAID     0x107           /*Quick local configuration by one key*/
#define MINOR_LOCAL_ADD_VD              0x108           /*Add visual disk locally*/
#define MINOR_LOCAL_DEL_VD              0x109           /*Delete visual disk locally*/
#define MINOR_LOCAL_RP_VD               0x10a           /*Repair visual disk locally*/
#define MINOR_LOCAL_FORMAT_EXPANDVD     0X10b           /*Expand volume of visual disk locally*/
#define MINOR_LOCAL_RAID_UPGRADE        0X10c           /*Upgrade RAID locally*/
#define MINOR_LOCAL_STOP_RAID           0x10d           /*Local stop RAID*/

#define MINOR_REMOTE_CONF_REB_RAID      0x111           /*Rebuild configuration automatically and remotely*/
#define MINOR_REMOTE_CONF_SPARE         0x112           /*Hot spare of remote configuration*/
#define MINOR_REMOTE_ADD_RAID           0x113           /*Add RAID remotely*/
#define MINOR_REMOTE_DEL_RAID           0x114           /*Delete RAID remotely*/
#define MINOR_REMOTE_MIG_RAID           0x115           /*Migrate RAID remotely*/
#define MINOR_REMOTE_REB_RAID           0x116           /*Rebuild RAID manually and remotely*/
#define MINOR_REMOTE_QUICK_CONF_RAID    0x117           /*Quick remote configuration by one key*/
#define MINOR_REMOTE_ADD_VD             0x118           /*Add visual disk remotely*/
#define MINOR_REMOTE_DEL_VD             0x119           /*Delete visual disk remotely*/
#define MINOR_REMOTE_RP_VD              0x11a           /*Repair visual disk remotely*/
#define MINOR_REMOTE_FORMAT_EXPANDVD    0X11b           /*Expand volume of visual disk remotely*/
#define MINOR_REMOTE_RAID_UPGRADE       0X11c           /*Upgrade RAID remotely*/
#define MINOR_REMOTE_STOP_RAID          0x11d           /*Remote stop RAID*/

#define MINOR_LOCAL_START_PIC_REC        0x121           /*local start snapshot*/
#define MINOR_LOCAL_STOP_PIC_REC        0x122           /*local stop snapshot*/
#define MINOR_LOCAL_SET_SNMP            0x125           /*local set SNMP*/
#define MINOR_LOCAL_TAG_OPT                0x126           /*local operate label*/
#define MINOR_REMOTE_START_PIC_REC        0x131           /*remote start snapshot*/
#define MINOR_REMOTE_STOP_PIC_REC        0x132           /*remote stop snapshot*/
#define MINOR_REMOTE_SET_SNMP            0x135           /*remote set SNMP*/
#define MINOR_REMOTE_TAG_OPT            0x136           /*remote operate label*/

// 9000 v2.2.0
#define MINOR_LOCAL_VOUT_SWITCH         0x140    /* local video out switch*/
#define MINOR_STREAM_CABAC                 0x141    /* stream cabac configuration*/


//Netra 3.0.0
#define MINOR_LOCAL_SPARE_OPT           0x142   /*Local spare opration*/
#define MINOR_REMOTE_SPARE_OPT            0x143   /*Remote spare opration*/
#define MINOR_LOCAL_IPCCFGFILE_OUTPUT    0x144      /*Local export ipc config file*/
#define MINOR_LOCAL_IPCCFGFILE_INPUT      0x145   /*Local import ipc config file */
#define MINOR_LOCAL_IPC_UPGRADE         0x146   /*Local ipc upgrade */
#define MINOR_REMOTE_IPCCFGFILE_OUTPUT  0x147   /*Remote export ipc config file*/
#define MINOR_REMOTE_IPCCFGFILE_INPUT   0x148   /*Remote import ipc config file*/
#define MINOR_REMOTE_IPC_UPGRADE        0x149   /*Remote ipc upgrade*/

#define MINOR_LOCAL_UNLOAD_HDISK        0x150     /*Local unload hdisk*/
#define MINOR_LOCAL_AUDIO_MIX           0x151     /*Local audio mix*/
#define MINOR_REMOTE_AUDIO_MIX          0x152     /*Remote audio mix*/
#define MINOR_LOCAL_TRIAL_PAUSE         0x153     /*Local inquest pause*/
#define MINOR_LOCAL_TRIAL_RESUME        0x154     /*Local inquest resume*/
#define MINOR_REMOTE_TRIAL_PAUSE        0x155     /*Remote inquest paus*/
#define MINOR_REMOTE_TRIAL_RESUME       0x156     /*Remote inquest resume*/

#define MINOR_SET_MULTI_MASTER          0x201    /*set multi master*/
#define MINOR_SET_MULTI_SLAVE           0x202    /*set multi slave*/
#define MINOR_CANCEL_MULTI_MASTER       0x203    /*cancel multi master*/
#define MINOR_CANCEL_MULTI_SLAVE        0x204    /*cancel multi slave*/

#define MINOR_DISPLAY_LOGO                0x205    /*display LOGO*/
#define MINOR_HIDE_LOGO                 0x206    /*hide LOGO*/
#define MINOR_SET_DEC_DELAY_LEVEL       0x207    /*set delay level of decode*/
#define MINOR_SET_BIGSCREEN_DIPLAY_AREA 0x208    /*set big screen display area*/
#define MINOR_CUT_VIDEO_SOURCE          0x209    /*cut video source*/
#define MINOR_SET_BASEMAP_AREA          0x210    /*set basemap area*/
#define MINOR_DOWNLOAD_BASEMAP          0x211    /*download basemap*/
#define MINOR_CUT_BASEMAP               0x212    /*cut basemap*/
#define MINOR_CONTROL_ELEC_ENLARGE      0x213    /*control electronic amplification*/
#define MINOR_SET_OUTPUT_RESOLUTION     0x214    /*set output resolution*/
#define MINOR_SET_TRANCSPARENCY         0X215    /*set layer transparency*/
#define MINOR_SET_OSD                   0x216    /*set OSD*/
#define MINOR_RESTORE_DEC_STATUS        0x217    /*restore decode status after switching scene*/
#define MINOR_SCREEN_SET_INPUT            0x251    /*set input signal*/
#define MINOR_SCREEN_SET_OUTPUT            0x252    /*set output channel*/
#define MINOR_SCREEN_SET_OSD            0x253    /*set virtual LED*/
#define MINOR_SCREEN_SET_LOGO            0x254    /*set LOGO*/
#define MINOR_SCREEN_SET_LAYOUT            0x255    /*set layout*/
#define    MINOR_SCREEN_PICTUREPREVIEW        0x256     /*picture preview*/

#define MINOR_SCREEN_GET_OSD            0x257   /*get virtual LED*/
#define MINOR_SCREEN_GET_LAYOUT            0x258   /*get layout*/
#define MINOR_SCREEN_LAYOUT_CTRL        0x259   /*layout control*/
#define MINOR_GET_ALL_VALID_WND            0x260    /*get all valid window*/
#define MINOR_GET_SIGNAL_WND            0x261    /*get single window information*/
#define MINOR_WINDOW_CTRL                0x262    /*window control*/
#define MINOR_GET_LAYOUT_LIST            0x263    /*get layout list*/
#define MINOR_LAYOUT_CTRL                0x264    /*layout control*/
#define MINOR_SET_LAYOUT                0x265    /*set single layout*/
#define MINOR_GET_SIGNAL_LIST            0x266    /*get input signal list*/
#define MINOR_GET_PLAN_LIST                0x267    /*get plan list*/
#define MINOR_SET_PLAN                    0x268    /*set plan*/
#define MINOR_CTRL_PLAN                    0x269    /*plan control*/
#define MINOR_CTRL_SCREEN                0x270    /*screen control*/
#define MINOR_ADD_NETSIG                0x271    /*add net signal*/
#define MINOR_SET_NETSIG                0x272    /*mod net signal*/
#define MINOR_SET_DECBDCFG                0x273    /*set decoder parameter*/
#define MINOR_GET_DECBDCFG                0x274    /*get decoder parameter*/
#define MINOR_GET_DEVICE_STATUS            0x275    /*get device status*/
#define MINOR_UPLOAD_PICTURE            0x276    /*upload picture*/
#define MINOR_SET_USERPWD                0x277    /*set user name and password*/
#define MINOR_ADD_LAYOUT                0x278    /*add layout*/
#define MINOR_DEL_LAYOUT                0x279    /*delete layout*/
#define MINOR_DEL_NETSIG                0x280    /*delete net signal*/
#define MINOR_ADD_PLAN                    0x281    /*add plan*/
#define MINOR_DEL_PLAN                    0x282    /*delete plan*/
#define MINOR_GET_EXTERNAL_MATRIX_CFG    0x283    //get external matrix config
#define MINOR_SET_EXTERNAL_MATRIX_CFG    0x284    //set external matrix config
#define    MINOR_GET_USER_CFG                0x285    //get user config
#define    MINOR_SET_USER_CFG                0x286    //set user config
#define    MINOR_GET_DISPLAY_PANEL_LINK_CFG 0x287    //get display panel link config
#define    MINOR_SET_DISPLAY_PANEL_LINK_CFG 0x288    //set display panel link config
#define    MINOR_GET_WALLSCENE_PARAM    0x289        //get scene parameter
#define    MINOR_SET_WALLSCENE_PARAM    0x28a        //set scene parameter
#define    MINOR_GET_CURRENT_WALLSCENE        0x28b        //get current scene
#define    MINOR_SWITCH_WALLSCENE            0x28c        //switch scene
#define    MINOR_SIP_LOGIN                    0x28d        //SIP login
#define MINOR_VOIP_START                0x28e        //VOIP start
#define MINOR_VOIP_STOP                    0x28f        //VOIP stop
#define MINOR_WIN_TOP                   0x290       //move video wall window to top layer
#define MINOR_WIN_BOTTOM                0x291       //move video wall window to bottom layer

//Netra 2.2.2
#define MINOR_LOCAL_LOAD_HDISK          0x300            //Load hard disk
#define MINOR_LOCAL_DELETE_HDISK        0x301            //Delete Hard disk

//KY2013 3.0.0
#define MINOR_LOCAL_MAIN_AUXILIARY_PORT_SWITCH    0X302 //Local main and auxiliary port switch
#define MINOR_LOCAL_HARD_DISK_CHECK                0x303 //Local hard disk check

//Netra3.1.0
#define MINOR_LOCAL_CFG_DEVICE_TYPE        0x310    //local cfg dev type
#define MINOR_REMOTE_CFG_DEVICE_TYPE    0x311    //remote cfg dev type
#define MINOR_LOCAL_CFG_WORK_HOT_SERVER    0x312    //local cfg work hot server
#define MINOR_REMOTE_CFG_WORK_HOT_SERVER    0x313    //remote cfg work hot server
#define MINOR_LOCAL_DELETE_WORK            0x314    //local delete work
#define MINOR_REMOTE_DELETE_WORK        0x315    //remote delete work
#define    MINOR_LOCAL_ADD_WORK            0x316    //local add work
#define MINOR_REMOTE_ADD_WORK            0x317    //remote add work
#define MINOR_LOCAL_IPCHEATMAP_OUTPUT   0x318   //local Ip cheatmap output
#define MINOR_LOCAL_IPCHEATFLOW_OUTPUT  0x319   //local Ip cheatflow output
#define MINOR_REMOTE_SMS_SEND           0x350    /*remote send sms*/
#define MINOR_LOCAL_SMS_SEND            0x351   /*local  send sms*/
#define MINOR_ALARM_SMS_SEND            0x352
#define MINOR_SMS_RECV                  0x353
#define MINOR_LOCAL_SMS_SEARCH          0x354  /*Local Search SMS*/
#define MINOR_REMOTE_SMS_SEARCH         0x355   /*Remote Search SMS*/
#define MINOR_LOCAL_SMS_READ            0x356   /*local read SMS*/
#define MINOR_REMOTE_SMS_READ           0x357   /*Remote read SMS*/
#define MINOR_REMOTE_DIAL_CONNECT       0x358   /*Remote Dial */
#define MINOR_REMOTE_DIAL_DISCONN       0x359   /*Remote Disconnect Dial*/
#define MINOR_LOCAL_WHITELIST_SET       0x35A   /*local white list CFG*/
#define MINOR_REMOTE_WHITELIST_SET      0x35B   /*Remote white list CFG*/
#define MINOR_LOCAL_DIAL_PARA_SET       0x35C   /*local Dial Alarm CFG*/
#define MINOR_REMOTE_DIAL_PARA_SET      0x35D   /*Remote Dial Alarm CFG*/
#define MINOR_LOCAL_DIAL_SCHEDULE_SET   0x35E   /*local dial schedule CFG*/
#define MINOR_REMOTE_DIAL_SCHEDULE_SET  0x35F   /*Remote dial schedule CFG*/
#define MINOR_PLAT_OPER                 0x360   /*plat operation*/

//0x400-0x1000 ACS operator type
#define MINOR_REMOTE_OPEN_DOOR          0x400   //remote open door
#define MINOR_REMOTE_CLOSE_DOOR         0x401   //remote close door
#define MINOR_REMOTE_ALWAYS_OPEN        0x402   //remote always open door
#define MINOR_REMOTE_ALWAYS_CLOSE       0x403   //remote always close door
#define MINOR_REMOTE_CHECK_TIME         0x404   //remote check time
#define MINOR_NTP_CHECK_TIME            0x405   //ntp check time
#define MINOR_REMOTE_CLEAR_CARD         0x406   //remote clear card
#define MINOR_REMOTE_RESTORE_CFG        0x407   //remote restore configure
#define MINOR_ALARMIN_ARM               0x408   //alarm in arm
#define MINOR_ALARMIN_DISARM            0x409   //alarm in disarm
#define MINOR_LOCAL_RESTORE_CFG         0x40a   //local configure restore
#define MINOR_REMOTE_CAPTURE_PIC        0x40b  //remote capture picture
#define MINOR_MOD_NET_REPORT_CFG        0x40c   //modify net report cfg
#define MINOR_MOD_GPRS_REPORT_PARAM     0x40d   //modify GPRS report param
#define MINOR_MOD_REPORT_GROUP_PARAM    0x40e   //modify report group param
#define    MINOR_UNLOCK_PASSWORD_OPEN_DOOR  0x40f  //unlock password open door
#define MINOR_AUTO_RENUMBER              0x410  //auto renumber
#define MINOR_AUTO_COMPLEMENT_NUMBER     0x411  //auto complement number
#define MINOR_NORMAL_CFGFILE_INPUT     	 0x412   //normal cfg file input
#define MINOR_NORMAL_CFGFILE_OUTTPUT     0x413   //normal cfg file output
#define MINOR_CARD_RIGHT_INPUT     	     0x414   //card right input
#define MINOR_CARD_RIGHT_OUTTPUT     	 0x415   //card right output
#define MINOR_LOCAL_USB_UPGRADE			 0x416   //local USB upgrade

//2012-03-05 ITC
#define MINOR_SET_TRIGGERMODE_CFG       0x1001  /*Set trigger configuration*/
#define MINOR_GET_TRIGGERMODE_CFG       0x1002  /*Get trigger configuration*/
#define MINOR_SET_IOOUT_CFG             0x1003  /*Set IO out configuration*/
#define MINOR_GET_IOOUT_CFG             0x1004  /*Get IO out configuration*/
#define MINOR_GET_TRIGGERMODE_DEFAULT   0x1005  /*Get trigger default configuration*/
#define MINOR_GET_ITCSTATUS             0x1006  /*Get status */
#define MINOR_SET_STATUS_DETECT_CFG     0x1007  /*Set status detect configuration*/
#define MINOR_GET_STATUS_DETECT_CFG     0x1008  /*Get status detect configuration*/
#define MINOR_SET_VIDEO_TRIGGERMODE_CFG 0x1009  /*Set video trigger configuration*/
#define MINOR_GET_VIDEO_TRIGGERMODE_CFG 0x100a  /*Get video trigger configuration*/

//2013-04-19 ITS
#define MINOR_LOCAL_ADD_CAR_INFO            0x2001  /*Local add car info*/
#define MINOR_LOCAL_MOD_CAR_INFO            0x2002  /*Local mode car info*/
#define MINOR_LOCAL_DEL_CAR_INFO            0x2003  /*Local delete car info*/
#define MINOR_LOCAL_FIND_CAR_INFO           0x2004  /*Local find car info*/
#define MINOR_LOCAL_ADD_MONITOR_INFO        0x2005  /*Local add monitor info*/
#define MINOR_LOCAL_MOD_MONITOR_INFO        0x2006  /*Local mode monitor info*/
#define MINOR_LOCAL_DEL_MONITOR_INFO        0x2007  /*Local delete monitor info*/
#define MINOR_LOCAL_FIND_MONITOR_INFO       0x2008  /*Local find monitor info*/
#define MINOR_LOCAL_FIND_NORMAL_PASS_INFO   0x2009  /*Local find normal pass info*/
#define MINOR_LOCAL_FIND_ABNORMAL_PASS_INFO   0x200a  /*Local find abnormal pass info*/
#define MINOR_LOCAL_FIND_PEDESTRIAN_PASS_INFO   0x200b  /*Local find pedestrian pass info*/
#define MINOR_LOCAL_PIC_PREVIEW             0x200c  /*Local picture preview*/
#define MINOR_LOCAL_SET_GATE_PARM_CFG           0x200d  /*Local set gate param configuration*/
#define MINOR_LOCAL_GET_GATE_PARM_CFG           0x200e  /*Local get gate param configuration*/
#define MINOR_LOCAL_SET_DATAUPLOAD_PARM_CFG     0x200f  /*Local set dataupload param configuration*/
#define MINOR_LOCAL_GET_DATAUPLOAD_PARM_CFG     0x2010  /*Local get dataupload param configuration*/
//2013-11-19 Log Type
#define MINOR_LOCAL_DEVICE_CONTROL                        0x2011      /*Local Device Control*/
#define MINOR_LOCAL_ADD_EXTERNAL_DEVICE_INFO              0x2012      /*Add External Device Info */
#define MINOR_LOCAL_MOD_EXTERNAL_DEVICE_INFO              0x2013      /*Modify External Device Info */
#define MINOR_LOCAL_DEL_EXTERNAL_DEVICE_INFO              0x2014      /*Delete External Device Info */
#define MINOR_LOCAL_FIND_EXTERNAL_DEVICE_INFO             0x2015      /*Find External Device Info */
#define MINOR_LOCAL_ADD_CHARGE_RULE                       0x2016      /*Add Charge rule */
#define MINOR_LOCAL_MOD_CHARGE_RULE                       0x2017      /*Modify Charge rule */
#define MINOR_LOCAL_DEL_CHARGE_RULE                       0x2018      /*Delete Charge rule */
#define MINOR_LOCAL_FIND_CHARGE_RULE                      0x2019      /*Find Charge rule */
#define MINOR_LOCAL_COUNT_NORMAL_CURRENTINFO              0x2020      /*Normal Current Info */
#define MINOR_LOCAL_EXPORT_NORMAL_CURRENTINFO_REPORT      0x2021      /*Normal Current Info Report */
#define MINOR_LOCAL_COUNT_ABNORMAL_CURRENTINFO            0x2022      /*Abnormal Current Info */
#define MINOR_LOCAL_EXPORT_ABNORMAL_CURRENTINFO_REPORT    0x2023      /*Abnormal Current Info Report */
#define MINOR_LOCAL_COUNT_PEDESTRIAN_CURRENTINFO          0x2024      /*Pedesteian Current Info */
#define MINOR_LOCAL_EXPORT_PEDESTRIAN_CURRENTINFO_REPORT  0x2025      /*Pedesteian Current Info Report*/
#define MINOR_LOCAL_FIND_CAR_CHARGEINFO                   0x2026      /*Find Car Charge Info */
#define MINOR_LOCAL_COUNT_CAR_CHARGEINFO                  0x2027      /*Count Car Charge Info */
#define MINOR_LOCAL_EXPORT_CAR_CHARGEINFO_REPORT          0x2028      /*Export Car Charge Info Report */
#define MINOR_LOCAL_FIND_SHIFTINFO                        0x2029      /*Find Shift Info */
#define MINOR_LOCAL_FIND_CARDINFO                         0x2030      /*Find Card Info */
#define MINOR_LOCAL_ADD_RELIEF_RULE                       0x2031      /*Add Relief Rule*/
#define MINOR_LOCAL_MOD_RELIEF_RULE                       0x2032      /*Modify Relief Rule */
#define MINOR_LOCAL_DEL_RELIEF_RULE                       0x2033      /*Delete Relief Rule  */
#define MINOR_LOCAL_FIND_RELIEF_RULE                      0x2034      /*find Relief Rule */
#define MINOR_LOCAL_GET_ENDETCFG                          0x2035      /*local Get entrance control machine offline detection configuration */
#define MINOR_LOCAL_SET_ENDETCFG                          0x2036      /*local Set entrance control machine offline detection configuration*/
#define MINOR_LOCAL_SET_ENDEV_ISSUEDDATA                  0x2037      /*local setting entrance control machine issued card information */
#define MINOR_LOCAL_DEL_ENDEV_ISSUEDDATA                  0x2038      /*local Delete entrance control machine issued card information*/

#define MINOR_REMOTE_DEVICE_CONTROL                       0x2101      /*Remote device control*/
#define MINOR_REMOTE_SET_GATE_PARM_CFG                    0x2102      /*Remote set gate param configuration*/
#define MINOR_REMOTE_GET_GATE_PARM_CFG                    0x2103      /*Remote get gate param configuration*/
#define MINOR_REMOTE_SET_DATAUPLOAD_PARM_CFG              0x2104      /*Remote set dataupload param configuration*/
#define MINOR_REMOTE_GET_DATAUPLOAD_PARM_CFG              0x2105      /*Remote get dataupload param configuration*/
#define MINOR_REMOTE_GET_BASE_INFO                        0x2106      /*Remote get base info*/
#define MINOR_REMOTE_GET_OVERLAP_CFG                      0x2107      /*Remote get overlap configuration*/
#define MINOR_REMOTE_SET_OVERLAP_CFG                      0x2108      /*Remote set overlap configuration*/
#define MINOR_REMOTE_GET_ROAD_INFO                        0x2109      /*Remote get road info*/
#define MINOR_REMOTE_START_TRANSCHAN                      0x210a      /*Remote start transchan*/
#define MINOR_REMOTE_GET_ECTWORKSTATE                     0x210b      /*Remote get ect work state*/
#define MINOR_REMOTE_GET_ECTCHANINFO                      0x210c      /*Remote get ect channel info*/

//Remote control 2013-11-19
#define MINOR_REMOTE_ADD_EXTERNAL_DEVICE_INFO             0x210d      /*Remote add external equipment information */
#define MINOR_REMOTE_MOD_EXTERNAL_DEVICE_INFO             0x210e      /*Remote modify the external equipment information */
#define MINOR_REMOTE_GET_ENDETCFG                         0x210f      /*Remote obtain entrance control machine offline detection configuration */
#define MINOR_REMOTE_SET_ENDETCFG                         0x2110      /*Remote setup entrance control machine with off-line detection*/
#define MINOR_REMOTE_ENDEV_ISSUEDDATA                     0x2111      /*Remote setup entrance control machine issued card information */
#define MINOR_REMOTE_DEL_ENDEV_ISSUEDDATA                 0x2112      /*Remote wipe out entrance control machine issued card information */

#define MINOR_REMOTE_ON_CTRL_LAMP           0x2115  /*Open remote control parking lights */
#define MINOR_REMOTE_OFF_CTRL_LAMP          0x2116  /*Close remote control parking lights */
//Netra3.1.0
#define MINOR_SET_VOICE_LEVEL_PARAM         0x2117  /*set voice level param*/
#define MINOR_SET_VOICE_INTERCOM_PARAM      0x2118  /*set voice intercom param */
#define MINOR_SET_INTELLIGENT_PARAM         0x2119  /*intelligent param*/
#define MINOR_LOCAL_SET_RAID_SPEED          0x211a  /*set local raid speed*/
#define MINOR_REMOTE_SET_RAID_SPEED         0x211b /*set remote raid speed*/

//Nerta3.1.2
#define MINOR_REMOTE_CREATE_STORAGE_POOL    0x211c   //remote create Storage pool
#define MINOR_REMOTE_DEL_STORAGE_POOL       0x211d    //remote delete Storage pool

#define MINOR_REMOTE_DEL_PIC                0x2120   //remote delete pic
#define MINOR_REMOTE_DEL_RECORD             0x2121   //remote delete record
#define MINOR_REMOTE_CLOUD_ENABLE           0x2123   //remote set cloud System enable
#define MINOR_REMOTE_CLOUD_DISABLE          0x2124   //remote set cloud System disable
#define MINOR_REMOTE_CLOUD_MODIFY_PARAM     0x2125   //remote modify cloud Storage param
#define MINOR_REMOTE_CLOUD_MODIFY_VOLUME    0x2126   //remote modift cloud Storage volume
#define MINOR_REMOTE_GET_GB28181_SERVICE_PARAM    0x2127  //Remote Get GB28181 Cfg
#define MINOR_REMOTE_SET_GB28181_SERVICE_PARAM    0x2128  //Remote Set GB28181 Cfg
#define MINOR_LOCAL_GET_GB28181_SERVICE_PARAM     0x2129  //local Get GB28181 Cfg
#define MINOR_LOCAL_SET_GB28181_SERVICE_PARAM     0x212a  //local Set GB28181 Cfg
#define MINOR_REMOTE_SET_SIP_SERVER               0x212b  //Remote Set SIP SERVER Cfg
#define MINOR_LOCAL_SET_SIP_SERVER                0x212c  //Local Set SIP SERVER Cfg
#define MINOR_LOCAL_BLACKWHITEFILE_OUTPUT         0x212d  //Local output black white file
#define MINOR_LOCAL_BLACKWHITEFILE_INPUT          0x212e  //Local input black white file
#define MINOR_REMOTE_BALCKWHITECFGFILE_OUTPUT     0x212f  //Remote output black white file
#define MINOR_REMOTE_BALCKWHITECFGFILE_INPUT      0x2130  //Remote input black white file


#define MINOR_REMOTE_CREATE_MOD_VIEWLIB_SPACE        0x2200    //Remote create or mod view lib space
#define MINOR_REMOTE_DELETE_VIEWLIB_FILE            0x2201  //Remote delete view lib file
#define MINOR_REMOTE_DOWNLOAD_VIEWLIB_FILE            0x2202    //Remote download view lib file
#define MINOR_REMOTE_UPLOAD_VIEWLIB_FILE            0x2203    //Remote upload view lib file
#define MINOR_LOCAL_CREATE_MOD_VIEWLIB_SPACE        0x2204    //local create or mod view lib space

#define MINOR_LOCAL_SET_DEVICE_ACTIVE   0x3000  //local activate device
#define MINOR_REMOTE_SET_DEVICE_ACTIVE  0x3001  //remote activate device
#define MINOR_LOCAL_PARA_FACTORY_DEFAULT    0x3002  //local parameter factory default
#define MINOR_REMOTE_PARA_FACTORY_DEFAULT   0x3003  //remote parameter factory default

/*info publish server operation log*/
//minor type\A3\BA
#define MINOR_UPLAOD_STATIC_MATERIAL                0x2401  //static material upload
#define MINOR_UPLOAD_DYNAMIC_MATERIAL               0x2402  //dynamic material upload
#define MINOR_DELETE_MATERIAL                       0x2403  //delete material
#define MINOR_DOWNLOAD_STATIC_MATERIAL              0x2404  //static material download
#define MINOR_COVER_STATIC_MATERIAL                 0x2405  //static material cover
#define MINOR_APPROVE_MATERIAL                      0x2406  //material approve
#define MINOR_UPLAOD_PROGRAM                        0x2407  //add program
#define MINOR_DOWNLOAD_PROGRAM                      0x2408  //get program
#define MINOR_DELETE_PROGRAM                        0x2409  //delete program
#define MINOR_MODIFY_PROGRAM                        0x240a  //program attribute modify
#define MINOR_APPROVE_PRAGRAM                       0x240b  //program approve
#define MINOR_UPLAOD_SCHEDULE                       0x240c  //add schedule
#define MINOR_DOWNLOAD_SCHEDULE                     0x240d  //get schedule
#define MINOR_DELETE_SCHEDULE                       0x240e  //delete schedule
#define MINOR_MODIFY_SCHEDULE                       0x240f  //modify schedule attribute
#define MINOR_RELEASE_SCHEDULE                      0x2410  //publish schedule
#define MINOR_ADD_TERMINAL                          0x2411  //add terminal
#define MINOR_DELETE_TERMINAL                       0x2412  //delete terminal
#define MINOR_MODIFY_TERMIANL_PARAM                 0x2413  //set terminal param
#define MINOR_MODIFY_TERMIANL_PLAY_PARAM            0x2414  //set terminal play parma
#define MINOR_ADD_TERMIANL_GROUP                    0x2415  //add terminal group
#define MINOR_MODIFY_TERMINAL_GROUP_PARAM           0x2416  //modify terminal pram
#define MINOR_DELETE_TERMIANL_GROUP                 0x2417  //delete terminal group
#define MINOR_TERMINAL_PLAY_CONTROL                 0x2418  //terminal play control
#define MINOR_TERMINAL_ON_OFF_LINE                  0x2419  //terminal on and off line
#define MINOR_SET_SWITCH_PLAN                       0x241a  //set terminal switch on plan
#define MINOR_SET_VOLUME_PLAN                       0x241b  //set terminal volume plan
#define MINOR_TERMINAL_SCREENSHOT                   0x241c  //terminal screenshot

#define MINOR_REMOTE_CONFERENCE_CONFIG             0x2501  //MCU conference config
#define MINOR_REMOTE_TERMINAL_CONFIG               0x2502  //MCU terminal config
#define MINOR_REMOTE_GROUP_CONFIG                  0x2503  //MCU group config
#define MINOR_REMOTE_CONFERENCE_CTRL               0x2504  //MCU conference config
#define MINOR_REMOTE_TERMINAL_CTRL                 0x2505  //MCU terminal control

//NVR
#define MINOR_LOCAL_RESET_LOGIN_PASSWORD           0x2600    /* local reset login password*/
#define MINOR_REMOTE_RESET_LOGIN_PASSWORD          0x2601    /* remote reset login password*/

/*Additional Log Info*/
//Main Type
#define MAJOR_INFORMATION                0x4     /*Extra Info*/
//Hypo- Type
#define MINOR_HDD_INFO                  0xa1 //HD info*/
#define MINOR_SMART_INFO                0xa2 //SMART info*/
#define MINOR_REC_START                 0xa3 //Start record*/
#define MINOR_REC_STOP                  0xa4 //Stop record */
#define MINOR_REC_OVERDUE                0xa5 //Record overdue*/
#define MINOR_LINK_START                0xa6 //start to link device
#define MINOR_LINK_STOP                    0xa7 //stop to link device
#define MINOR_NET_DISK_INFO                0xa8 //Network hard disk info
#define MINOR_RAID_INFO                 0xa9 //raid Info
#define MINOR_RUN_STATUS_INFO           0xaa //run status info

//Netra3.0.0
#define MINOR_SPARE_START_BACKUP        0xab   /*Spare start backup*/
#define MINOR_SPARE_STOP_BACKUP            0xac   /*Spare stop backup*/
#define MINOR_SPARE_CLIENT_INFO         0xad   /*Spare client infomation*/
#define MINOR_ANR_RECORD_START            0xae   /*ANR record start*/
#define MINOR_ANR_RECORD_END            0xaf   /*ANR record end*/
#define MINOR_ANR_ADD_TIME_QUANTUM        0xb0    /*ANR add time quantum*/
#define MINOR_ANR_DEL_TIME_QUANTUM        0xb1    /*ANR del time quantum*/

#define MINOR_PIC_REC_START             0xb3 //start snapshot
#define MINOR_PIC_REC_STOP              0xb4 //stop snapshot
#define MINOR_PIC_REC_OVERDUE           0xb5 //delete delayed picture

//Netra3.1.0
#define  MINOR_CLIENT_LOGIN             0xb6   /*login serice success*/
#define  MINOR_CLIENT_RELOGIN            0xb7   /*relogin serice*/
#define  MINOR_CLIENT_LOGOUT            0xb8   /*logout serice s*/
#define  MINOR_CLIENT_SYNC_START        0xb9   /*record sync start */
#define  MINOR_CLIENT_SYNC_STOP            0xba   /*record sync stop*/
#define  MINOR_CLIENT_SYNC_SUCC            0xbb   /*record sync success*/
#define  MINOR_CLIENT_SYNC_EXCP            0xbc   /*record sync excption*/
#define  MINOR_GLOBAL_RECORD_ERR_INFO   0xbd   /*global record err info*/
#define  MINOR_BUFFER_STATE             0xbe   /*The state of the buffer logging*/
#define  MINOR_DISK_ERRORINFO_V2        0xbf   /*Disk error details V2*/
#define  MINOR_CS_DATA_EXPIRED          0xc0   //cloud storage data out of date
#define  MINOR_PLAT_INFO                0xc1   //plat operation info
#define  MINOR_DIAL_STAT                0xc2   /*dial statues*/
#define  MINOR_UNLOCK_RECORD            0xc3   //unlock Record
#define  MINOR_VIS_ALARM                0xc4   //VIS Alarm
#define  MINOR_TALK_RECORD              0xc5   //talk Record
#define MINOR_ACCESSORIES_MESSAGE       0xc6 //Accessories plate information
#define MINOR_KMS_EXPAMSION_DISK_INSERT 0xc7// KMS Expansion disc insert
#define MINOR_EZVIZ_OPERATION           0xcc   //Fluorite running state
/*event*/
//major event
#define MAJOR_EVENT                             0x5     /*event*/
//minor type
#define MINOR_LEGAL_CARD_PASS                   0x01    //legal card pass
#define MINOR_CARD_AND_PSW_PASS                 0x02    //swipe and password pass
#define MINOR_CARD_AND_PSW_FAIL                 0x03    //swipe and password fail
#define MINOR_CARD_AND_PSW_TIMEOUT              0x04    //swipe and password timeout
#define MINOR_CARD_AND_PSW_OVER_TIME            0x05    //swipe and password over time
#define MINOR_CARD_NO_RIGHT                     0x06    //card no right
#define MINOR_CARD_INVALID_PERIOD               0x07    //invalid period
#define MINOR_CARD_OUT_OF_DATE                  0x08    //card out of date
#define MINOR_INVALID_CARD                      0x09    //invalid card
#define MINOR_ANTI_SNEAK_FAIL                   0x0a    //anti sneak fail
#define MINOR_INTERLOCK_DOOR_NOT_CLOSE          0x0b    //interlock door doesn't close
#define MINOR_NOT_BELONG_MULTI_GROUP            0x0c    //card no belong multi group
#define MINOR_INVALID_MULTI_VERIFY_PERIOD       0x0d    // invalid multi verify period
#define MINOR_MULTI_VERIFY_SUPER_RIGHT_FAIL     0x0e    //have no super right  in multi verify mode
#define MINOR_MULTI_VERIFY_REMOTE_RIGHT_FAIL    0x0f    //have no remote right in multi verify mode
#define MINOR_MULTI_VERIFY_SUCCESS              0x10    // success in multi verify mode
#define MINOR_LEADER_CARD_OPEN_BEGIN            0x11    // leader card begin to open
#define MINOR_LEADER_CARD_OPEN_END              0x12    // leader card end to open
#define MINOR_ALWAYS_OPEN_BEGIN                 0x13    // always open begin
#define MINOR_ALWAYS_OPEN_END                   0x14    //always open end
#define MINOR_LOCK_OPEN                         0x15    //lock open
#define MINOR_LOCK_CLOSE                        0x16    //lock close
#define MINOR_DOOR_BUTTON_PRESS                 0x17    //press door open button
#define MINOR_DOOR_BUTTON_RELEASE               0x18    //release door open button
#define MINOR_DOOR_OPEN_NORMAL                  0x19    //door open normal
#define MINOR_DOOR_CLOSE_NORMAL                 0x1a    //door close normal
#define MINOR_DOOR_OPEN_ABNORMAL                0x1b    //open door abnormal
#define MINOR_DOOR_OPEN_TIMEOUT                 0x1c    //open door timeout
#define MINOR_ALARMOUT_ON                       0x1d    //alarm out turn on
#define MINOR_ALARMOUT_OFF                      0x1e    //alarm out turn off
#define MINOR_ALWAYS_CLOSE_BEGIN                0x1f    //always close begin
#define MINOR_ALWAYS_CLOSE_END                  0x20    //always close end
#define MINOR_MULTI_VERIFY_NEED_REMOTE_OPEN     0x21    //need remote open in multi verify mode
#define MINOR_MULTI_VERIFY_SUPERPASSWD_VERIFY_SUCCESS  0x22  //superpasswd verify success in multi verify mode
#define MINOR_MULTI_VERIFY_REPEAT_VERIFY        0x23    //repeat verify in multi verify mode
#define MINOR_MULTI_VERIFY_TIMEOUT               0x24    //timeout in multi verify mode
#define MINOR_DOORBELL_RINGING                  0x25    //doorbell ringing
#define MINOR_FINGERPRINT_COMPARE_PASS          0x26    //fingerprint compare pass
#define MINOR_FINGERPRINT_COMPARE_FAIL          0x27    //fingerprint compare fail
#define MINOR_CARD_FINGERPRINT_VERIFY_PASS              0x28    //card and fingerprint verify pass
#define MINOR_CARD_FINGERPRINT_VERIFY_FAIL              0x29    //card and fingerprint verify fail
#define MINOR_CARD_FINGERPRINT_VERIFY_TIMEOUT           0x2a    //card and fingerprint verify timeout
#define MINOR_CARD_FINGERPRINT_PASSWD_VERIFY_PASS       0x2b    //card and fingerprint and passwd verify pass
#define MINOR_CARD_FINGERPRINT_PASSWD_VERIFY_FAIL       0x2c    //card and fingerprint and passwd verify fail
#define MINOR_CARD_FINGERPRINT_PASSWD_VERIFY_TIMEOUT    0x2d    //card and fingerprint and passwd verify timeout
#define MINOR_FINGERPRINT_PASSWD_VERIFY_PASS            0x2e    //fingerprint and passwd verify pass
#define MINOR_FINGERPRINT_PASSWD_VERIFY_FAIL            0x2f    //fingerprint and passwd verify fail
#define MINOR_FINGERPRINT_PASSWD_VERIFY_TIMEOUT         0x30    //fingerprint and passwd verify timeout
#define MINOR_FINGERPRINT_INEXISTENCE                   0x31    //fingerprint inexistence
#define MINOR_CARD_PLATFORM_VERIFY                      0x32    //card platform verify
#define MINOR_CALL_CENTER                               0x33    //call center
#define MINOR_FIRE_RELAY_TURN_ON_DOOR_ALWAYS_OPEN       0x34    //fire relay turn on door always open
#define MINOR_FIRE_RELAY_RECOVER_DOOR_RECOVER_NORMAL    0x35    //fire relay recover door recover normal
#define MINOR_FACE_AND_FP_VERIFY_PASS                   0x36    //face and finger print verify pass
#define MINOR_FACE_AND_FP_VERIFY_FAIL                   0x37    //face and finger print verify fail
#define MINOR_FACE_AND_FP_VERIFY_TIMEOUT                0x38    //face and finger print verify timeout
#define MINOR_FACE_AND_PW_VERIFY_PASS                   0x39    //face and password verify pass
#define MINOR_FACE_AND_PW_VERIFY_FAIL                   0x3a    //face and password verify fail
#define MINOR_FACE_AND_PW_VERIFY_TIMEOUT                0x3b    //face and password verify timeout
#define MINOR_FACE_AND_CARD_VERIFY_PASS                 0x3c    //face and card verify pass
#define MINOR_FACE_AND_CARD_VERIFY_FAIL                 0x3d    //face and card verify fail
#define MINOR_FACE_AND_CARD_VERIFY_TIMEOUT              0x3e    //face and card verify timeout
#define MINOR_FACE_AND_PW_AND_FP_VERIFY_PASS            0x3f    //face and password and finger print verify pass
#define MINOR_FACE_AND_PW_AND_FP_VERIFY_FAIL            0x40    //face and password and finger print verify fail
#define MINOR_FACE_AND_PW_AND_FP_VERIFY_TIMEOUT         0x41    //face and password and finger print verify timeout
#define MINOR_FACE_CARD_AND_FP_VERIFY_PASS              0x42    //face and card and finger print verify pass
#define MINOR_FACE_CARD_AND_FP_VERIFY_FAIL              0x43    //face and card and finger print verify fail
#define MINOR_FACE_CARD_AND_FP_VERIFY_TIMEOUT           0x44    //face and card and finger print verify timeout
#define MINOR_EMPLOYEENO_AND_FP_VERIFY_PASS             0x45    //employee and finger print verify pass
#define MINOR_EMPLOYEENO_AND_FP_VERIFY_FAIL             0x46    //employee and finger print verify fail
#define MINOR_EMPLOYEENO_AND_FP_VERIFY_TIMEOUT          0x47    //employee and finger print verify timeout
#define MINOR_EMPLOYEENO_AND_FP_AND_PW_VERIFY_PASS      0x48    //employee and finger print and password verify pass
#define MINOR_EMPLOYEENO_AND_FP_AND_PW_VERIFY_FAIL      0x49    //employee and finger print and password verify fail
#define MINOR_EMPLOYEENO_AND_FP_AND_PW_VERIFY_TIMEOUT   0x4a    //employee and finger print and password verify timeout
#define MINOR_FACE_VERIFY_PASS                          0x4b    //face verify pass
#define MINOR_FACE_VERIFY_FAIL                          0x4c    //face verify fail
#define MINOR_EMPLOYEENO_AND_FACE_VERIFY_PASS           0x4d    //employee no and face verify pass
#define MINOR_EMPLOYEENO_AND_FACE_VERIFY_FAIL           0x4e    //employee no and face verify fail
#define MINOR_EMPLOYEENO_AND_FACE_VERIFY_TIMEOUT        0x4f    //employee no and face verify time out
#define MINOR_FACE_NO_EXIST                             0x50    //face no exist
#define MINOR_FIRSTCARD_AUTHORIZE_BEGIN					0x51    //first card authorize begin
#define MINOR_FIRSTCARD_AUTHORIZE_END					0x52    //first card authorize end
#define MINOR_DOORLOCK_INPUT_SHORT_CIRCUIT				0x53    //door lock input short circuit
#define MINOR_DOORLOCK_INPUT_BROKEN_CIRCUIT				0x54    //door lock input broken circuit
#define MINOR_DOORLOCK_INPUT_EXCEPTION					0x55    //door lock input exception
#define MINOR_DOORCONTACT_INPUT_SHORT_CIRCUIT			0x56    //door contact input short circuit
#define MINOR_DOORCONTACT_INPUT_BROKEN_CIRCUIT			0x57    //door contact input broken circuit
#define MINOR_DOORCONTACT_INPUT_EXCEPTION				0x58    //door contact input exception
#define MINOR_OPENBUTTON_INPUT_SHORT_CIRCUIT			0x59    //open button input short circuit
#define MINOR_OPENBUTTON_INPUT_BROKEN_CIRCUIT			0x5a    //open button input broken circuit
#define MINOR_OPENBUTTON_INPUT_EXCEPTION				0x5b    //open button input exception
#define MINOR_DOORLOCK_OPEN_EXCEPTION					0x5c    //door lock open exception
#define MINOR_DOORLOCK_OPEN_TIMEOUT						0x5d    //door lock open timeout
#define MINOR_FIRSTCARD_OPEN_WITHOUT_AUTHORIZE			0x5e    //first card open without authorize

typedef enum tagALARMHOST_MAJOR_TYPE
{
    MAJOR_ALARMHOST_ALARM = 1,
    MAJOR_ALARMHOST_EXCEPTION,
    MAJOR_ALARMHOST_OPERATION,
    MAJ0R_ALARMHOST_EVENT
}ALARMHOST_MAJOR_TYPE;

typedef enum tagALARMHOST_MINOR_TYPE
{
    // Alarm
            MINOR_SHORT_CIRCUIT =0x01,      // Short circuit alarm
    MINOR_BROKEN_CIRCUIT,           // Broken circuit alarm
    MINOR_ALARM_RESET,              // Alarm reset
    MINOR_ALARM_NORMAL,                // Alarm resumes to normal
    MINOR_PASSWORD_ERROR,            // Password error(consecutive times for password error)
    MINOR_ID_CARD_ILLEGALLY,        // Illegal proximity card ID
    MINOR_KEYPAD_REMOVE,            // Keypad tamper
    MINOR_KEYPAD_REMOVE_RESTORE,    // Keypad tamper reset
    MINOR_DEV_REMOVE,                // Device tamper
    MINOR_DEV_REMOVE_RESTORE,        // Device tamper reset
    MINOR_BELOW_ALARM_LIMIT1,        // Analog lower than alarm limit 1
    MINOR_BELOW_ALARM_LIMIT2,        // Analog lower than alarm limit 2
    MINOR_BELOW_ALARM_LIMIT3,        // Analog lower than alarm limit 3
    MINOR_BELOW_ALARM_LIMIT4,        // Analog lower than alarm limit 4
    MINOR_ABOVE_ALARM_LIMIT1,        // Analog higher than alarm limit 1
    MINOR_ABOVE_ALARM_LIMIT2,        // Analog higher than alarm limit 2
    MINOR_ABOVE_ALARM_LIMIT3,        // Analog higher than alarm limit 3
    MINOR_ABOVE_ALARM_LIMIT4,        // Analog higher than alarm limit 4
    MINOR_URGENCYBTN_ON,            // Urgency button on
    MINOR_URGENCYBTN_OFF,            // Urgency button off
    MINOR_VIRTUAL_DEFENCE_BANDIT,            //Virtual zone bandit
    MINOR_VIRTUAL_DEFENCE_FIRE,                //virtual zone fire
    MINOR_VIRTUAL_DEFENCE_URGENT,            //virtual zone urgent
    MINOR_ALARMHOST_MOTDET_START,            //start move detection
    MINOR_ALARMHOST_MOTDET_STOP,            //stop move detection
    MINOR_ALARMHOST_HIDE_ALARM_START,        //start hide alarm
    MINOR_ALARMHOST_HIDE_ALARM_STOP,        //stop hide alarm
    MINOR_ALARMHOST_UPS_ALARM,                //UPS alarm
    MINOR_ALARMHOST_ELECTRICITY_METER_ALARM, //electricity meter alarm
    MINOR_ALARMHOST_SWITCH_POWER_ALARM,      //switch power alarm
    MINOR_ALARMHOST_GAS_DETECT_SYS_ALARM,      //gas detect system alarm
    MINOR_ALARMHOST_TRANSFORMER_TEMPRATURE_ALARM, //transformer temprature alarm
    MINOR_ALARMHOST_TEMP_HUMI_ALARM,            //temprature&huminity sensor alarm
    MINOR_ALARMHOST_UPS_ALARM_RESTORE,    //UPS alarm restore
    MINOR_ALARMHOST_ELECTRICITY_METER_ALARM_RESTORE, //electricity meter alarm restore
    MINOR_ALARMHOST_SWITCH_POWER_ALARM_RESTORE,      //switch power alarm restore
    MINOR_ALARMHOST_GAS_DETECT_SYS_ALARM_RESTORE,      //gas detect system alarm restore
    MINOR_ALARMHOST_TRANSFORMER_TEMPRATURE_ALARM_RESTORE, //transformer temprature alarm restore
    MINOR_ALARMHOST_TEMP_HUMI_ALARM_RESTORE,          //temprature&huminity sensor alarm restore
    MINOR_ALARMHOST_WATER_LEVEL_SENSOR_ALARM,            //water level sensor alarm
    MINOR_ALARMHOST_WATER_LEVEL_SENSOR_ALARM_RESTORE,    //water level sensor alarm restore
    MINOR_ALARMHOST_DUST_NOISE_ALARM,                    //dust and noise alarm
    MINOR_ALARMHOST_DUST_NOISE_ALARM_RESTORE,            //dust and noise alarm restore
    MINOR_ALARMHOST_ENVIRONMENTAL_LOGGER_ALARM,            //environmental logger alarm
    MINOR_ALARMHOST_ENVIRONMENTAL_LOGGER_ALARM_RESTORE,    //environmental logger alarm restore

    MINOR_ALARMHOST_TRIGGER_TAMPER,                //trigger tamper
    MINOR_ALARMHOST_TRIGGER_TAMPER_RESTORE,                //trigger tamper restore
    MINOR_ALARMHOST_EMERGENCY_CALL_HELP_ALARM,            //emergency call help alarm
    MINOR_ALARMHOST_EMERGENCY_CALL_HELP_ALARM_RESTORE,    //emergency call help alarm restore

    // Exception
            MINOR_POWER_ON      = 0x01,        // Power on
    MINOR_POWER_OFF,                // Power off
    MINOR_WDT_RESET,                // WDT reset
    MINOR_LOW_BATTERY_VOLTAGE,        // Low battery voltage
    MINOR_AC_LOSS,                    // AC loss
    MINOR_AC_RESTORE,                // AC restore
    MINOR_RTC_EXCEPTION,            // RTC real-time clock exception
    MINOR_NETWORK_CONNECT_FAILURE,    // Network is disconnected
    MINOR_NETWORK_CONNECT_RESTORE,    // Network connection restore
    MINOR_TEL_LINE_CONNECT_FAILURE,    // Telephone line is disconnected
    MINOR_TEL_LINE_CONNECT_RESTORE,    // Telephone line restore
    MINOR_EXPANDER_BUS_LOSS,        // Expansion bus module dropped
    MINOR_EXPANDER_BUS_RESTORE,        // Expansion bus module restore
    MINOR_KEYPAD_BUS_LOSS,            // Keyboard bus module dropped
    MINOR_KEYPAD_BUS_RESTORE,        // Keyboard bus module restore
    MINOR_SENSOR_FAILURE,            // Analog sensor failure
    MINOR_SENSOR_RESTORE,            // Analog sensor restore
    MINOR_RS485_CONNECT_FAILURE,    // RS485 channel is disconnected
    MINOR_RS485_CONNECT_RESTORE,    // RS485 channel disconnection restore
    MINOR_BATTERT_VOLTAGE_RESTORE,  // Battery voltage resume to normal
    MINOR_WIRED_NETWORK_ABNORMAL,    // network abnormal
    MINOR_WIRED_NETWORK_RESTORE,    // network restore
    MINOR_GPRS_ABNORMAL,            // GPRS abnormal
    MINOR_GPRS_RESTORE,                // GPRS restore
    MINOR_3G_ABNORMAL,                // 3G abnormal
    MINOR_3G_RESTORE,                // 3G restore
    MINOR_SIM_CARD_ABNORMAL,        // SIM Card abnormal
    MINOR_SIM_CARD_RESTORE,            // SIM Card restore
    MINOR_ALARMHOST_VI_LOST,        // video lost
    MINOR_ALARMHOST_ILLEGAL_ACCESS,    // illegnal access
    MINOR_ALARMHOST_HD_FULL,        // hard disk full
    MINOR_ALARMHOST_HD_ERROR,        // hard disk error
    MINOR_ALARMHOST_DCD_LOST,        // MODEM lost
    MINOR_ALARMHOST_IP_CONFLICT,    // IP  conflict
    MINOR_ALARMHOST_NET_BROKEN,        // network broken
    MINOR_ALARMHOST_REC_ERROR,      // record error
    MINOR_ALARMHOST_VI_EXCEPTION,   // video exception
    MINOR_ALARMHOST_FORMAT_HDD_ERROR, //format hard disk error
    MINOR_ALARMHOST_USB_ERROR,        //USB connect error
    MINOR_ALARMHOST_USB_RESTORE,    //USB connect restore
    MINOR_ALARMHOST_PRINT_ERROR,    //printer error
    MINOR_ALARMHOST_PRINT_RESTORE,    //printer restore
    MINOR_SUBSYSTEM_COMMUNICATION_ERROR, //subsystem communication error
    MINOR_ALARMHOST_IPC_NO_LINK,        //IPC connection failed
    MINOR_ALARMHOST_IPC_IP_CONFLICT,//IPC IP conflict
    MINOR_ALARMHOST_VI_MISMATCH,    //Video format error.
    MINOR_ALARMHOST_MCU_RESTART,    //MCU restart
    MINOR_ALARMHOST_GPRS_MODULE_FAULT,                     //GPRS Module Fault
    MINOR_ALARMHOST_TELEPHONE_MODULE_FAULT,                 //Telephone Module Fault
    MINOR_ALARMHOST_WIFI_ABNORMAL,
    MINOR_ALARMHOST_WIFI_RESTORE,
    MINOR_ALARMHOST_RF_ABNORMAL,
    MINOR_ALARMHOST_RF_RESTORE,
    MINOR_ALARMHOST_DETECTOR_ONLINE,
    MINOR_ALARMHOST_DETECTOR_OFFLINE,
    MINOR_ALARMHOST_DETECTOR_BATTERY_NORMAL,
    MINOR_ALARMHOST_DETECTOR_BATTERY_LOW,

    // Operation
            MINOR_GUARD         = 0x01,        // Normal arm
    MINOR_UNGUARD,                    // Normal disarm
    MINOR_BYPASS,                    // Bypass
    MINOR_DURESS_ACCESS,            // Duress access
    MINOR_ALARMHOST_LOCAL_REBOOT,    // Local reboot
    MINOR_ALARMHOST_REMOTE_REBOOT,    // Remote reboot
    MINOR_ALARMHOST_LOCAL_UPGRADE,    // Local upgrade
    MINOR_ALARMHOST_REMOTE_UPGRADE,    // Remote upgrade
    MINOR_RECOVERY_DEFAULT_PARAM,    // Recovery default parameter
    MINOR_ALARM_OUTPUT,                // Control alarm output
    MINOR_ACCESS_OPEN,                // Control access open
    MINOR_ACCESS_CLOSE,                // Control access close
    MINOR_SIREN_OPEN,                // Control siren open
    MINOR_SIREN_CLOSE,                // Control siren close
    MINOR_MOD_ZONE_CONFIG,              // Modify defense area configuration
    MINOR_MOD_ALARMOUT_CONIFG,        // Control alarmout configuration
    MINOR_MOD_ANALOG_CONFIG,        // Modify analog configuration
    MINOR_RS485_CONFIG,                // Modify RS-485 configuration
    MINOR_PHONE_CONFIG,                // Modify dialing configuration
    MINOR_ADD_ADMIN,                // Add administrator
    MINOR_MOD_ADMIN_PARAM,            // Modify password of administrator
    MINOR_DEL_ADMIN,                // Delete administrator
    MINOR_ADD_NETUSER,                // Add network user
    MINOR_MOD_NETUSER_PARAM,        // Modify password of network user
    MINOR_DEL_NETUSER,                // Delete network user
    MINOR_ADD_OPERATORUSER,            // Add operator user
    MINOR_MOD_OPERATORUSER_PW,        // Add operator user
    MINOR_DEL_OPERATORUSER,            // Add operator user
    MINOR_ADD_KEYPADUSER,            // Add user of keyboard or card reader
    MINOR_DEL_KEYPADUSER,            // Delete user of keyboard or card reader
    MINOR_REMOTEUSER_LOGIN,            // Remote login
    MINOR_REMOTEUSER_LOGOUT,        // Remote logout
    MINOR_REMOTE_GUARD,                // Remotely fortify
    MINOR_REMOTE_UNGUARD,            // Remotely cancel fortification
    MINOR_MOD_HOST_CONFIG,          // Modify host configuration
    MINOR_RESTORE_BYPASS,            // Bypass restore
    MINOR_ALARMOUT_OPEN,            // Open alarm out
    MINOR_ALARMOUT_CLOSE,            // Close alarm out
    MINOR_MOD_SUBSYSTEM_PARAM,        // Mod subsystem config
    MINOR_GROUP_BYPASS,                // Group bypass
    MINOR_RESTORE_GROUP_BYPASS,        // Restore group bypass
    MINOR_MOD_GRPS_PARAM,            // Mod gprs parameter
    MINOR_MOD_NET_REPORT_PARAM,        // Mod net report config
    MINOR_MOD_REPORT_MOD,            // Mod report config
    MINOR_MOD_GATEWAY_PARAM,        // Mod gateway config
    MINOR_ALARMHOST_REMOTE_START_REC,        // Start remote record
    MINOR_ALARMHOST_REMOTE_STOP_REC,        // Stop remote record
    MINOR_ALARMHOST_START_TRANS_CHAN,        // Start trans channel
    MINOR_ALARMHOST_STOP_TRANS_CHAN,        // Stop trans channel
    MINOR_ALARMHOST_START_VT,                // Start voice intercom
    MINOR_ALARMHOST_STOP_VTM,                // Stop voice intercom
    MINOR_ALARMHOST_REMOTE_PLAYBYFILE,        // Remote playback by file name
    MINOR_ALARMHOST_REMOTE_PLAYBYTIME,      // Remote playback by time
    MINOR_ALARMHOST_REMOTE_PTZCTRL,            // Remote PTZ control
    MINOR_ALARMHOST_REMOTE_FORMAT_HDD,      // Remote Format hard disk
    MINOR_ALARMHOST_REMOTE_LOCKFILE,        // Remote lock file
    MINOR_ALARMHOST_REMOTE_UNLOCKFILE,      // Remote unlock file
    MINOR_ALARMHOST_REMOTE_CFGFILE_OUTPUT,  // Remote Import config file
    MINOR_ALARMHOST_REMOTE_CFGFILE_INTPUT,  // Remote Export config file
    MINOR_ALARMHOST_REMOTE_RECFILE_OUTPUT,  // Remote Export record file

    MINOR_ALARMHOST_STAY_ARM,                        //stay arm
    MINOR_ALARMHOST_QUICK_ARM,                        //quick arm
    MINOR_ALARMHOST_AUTOMATIC_ARM,                    //auto arm
    MINOR_ALARMHOST_AUTOMATIC_DISARM,                //auto disarm
    MINOR_ALARMHOST_KEYSWITCH_ARM,                    //key switch arm
    MINOR_ALARMHOST_KEYSWITCH_DISARM,                //key switch disarm
    MINOR_ALARMHOST_CLEAR_ALARM,                    //clear alarm
    MINOR_ALARMHOST_MOD_FAULT_CFG,                    //mod fault config
    MINOR_ALARMHOST_MOD_EVENT_TRIGGER_ALARMOUT_CFG,    //mod event cause alarm out
    MINOR_ALARMHOST_SEARCH_EXTERNAL_MODULE,            //search external module
    MINOR_ALARMHOST_REGISTER_EXTERNAL_MODULE,        //register external module
    MINOR_ALARMHOST_CLOSE_KEYBOARD_ALARM,            //close keyboard alarm
    MINOR_ALARMHOST_MOD_3G_PARAM,                    //modify 3G parameter
    MINOR_ALARMHOST_MOD_PRINT_PARAM, //modify printer parameter
    MINOR_SD_CARD_FORMAT,        //SD card format
    MINOR_SUBSYSTEM_UPGRADE,        //subsystem upgrade

    MINOR_ALARMHOST_PLAN_ARM_CFG,    //arm plan config
    MINOR_ALARMHOST_PHONE_ARM,        //phone arm
    MINOR_ALARMHOST_PHONE_STAY_ARM,    //phone stay arm
    MINOR_ALARMHOST_PHONE_QUICK_ARM,//phone quick arm
    MINOR_ALARMHOST_PHONE_DISARM,    //phone disarm
    MINOR_ALARMHOST_PHONE_CLEAR_ALARM,    //phone clear alarm
    MINOR_ALARMHOST_WHITELIST_CFG,    //white list config
    MINOR_ALARMHOST_TIME_TRIGGER_CFG,            //turn on/off trigger config
    MINOR_ALARMHOST_CAPTRUE_CFG,                //capture config
    MINOR_ALARMHOST_TAMPER_CFG,                //tamper config
    MINOR_ALARMHOST_TEMPORARY_PASSWORD,
    MINOR_ALARMHOST_ONEKEY_AWAY_ARM,
    MINOR_ALARMHOST_ONEKEY_STAY_ARM,
    MINOR_ALARMHOST_SINGLE_ZONE_ARM,
    MINOR_ALARMHOST_SINGLE_ZONE_DISARM,
    MINOR_ALARMHOST_HIDDNS_CONFIG,
    MINOR_ALARMHOST_REMOTE_KEYBOARD_UPDATA,
    MINOR_ALARMHOST_ZONE_ADD_DETECTOR,
    MINOR_ALARMHOST_ZONE_DELETE_DETECTOR,
    MINOR_ALARMHOST_QUERY_DETECTOR_SIGNAL,
    MINOR_ALARMHOST_QUERY_DETECTOR_BATTERY,
    MINOR_ALARMHOST_SET_DETECTOR_GUARD,
    MINOR_ALARMHOST_SET_DETECTOR_UNGUARD,
    MINOR_ALARMHOST_SET_WIFI_PARAMETER,
    MINOR_ALARMHOST_OPEN_VOICE,
    MINOR_ALARMHOST_CLOSE_VOICE,

    MINOR_ALARMHOST_REMOTE_KEYPAD_UPGRADE,               //Remote Keypad Upgrade
    MINOR_ALARMHOST_ONETOUCH_AWAY_ARMING,                //One-touch Away Arming
    MINOR_ALARMHOST_ONETOUCH_STAY_ARMING,                //One-touch Stay Arming
    MINOR_ALARMHOST_SINGLE_PARTITION_ARMING_OR_DISARMING,    //Single Partition Arming/Disarming
    MINOR_ALARMHOST_CARD_CONFIGURATION,         //Card Configuration
    MINOR_ALARMHOST_CARD_ARMING_OR_DISARMING,         //Card Arming/Disarming
    MINOR_ALARMHOST_EXPENDING_NETCENTER_CONFIGURATION,         //Expending Network Center Configuration
    MINOR_ALARMHOST_NETCARD_CONFIGURATION,         //Network Card Configuration
    MINOR_ALARMHOST_DDNS_CONFIGURATION,         //DDNS Configuration
    MINOR_ALARMHOST_RS485BUS_CONFIGURATION,        // RS-485 Bus Configuration
    MINOR_ALARMHOST_RS485BUS_RE_REGISTRATION,            //RS-486 Bus Re-registration

    MINOR_ALARMHOST_REMOTE_OPEN_ELECTRIC_LOCK,    //remote open electric lock
    MINOR_ALARMHOST_REMOTE_CLOSE_ELECTRIC_LOCK,    //remote close electric lock
    MINOR_ALARMHOST_LOCAL_OPEN_ELECTRIC_LOCK,    //local open electric lock
    MINOR_ALARMHOST_LOCAL_CLOSE_ELECTRIC_LOCK,    //local close electric lock
    MINOR_ALARMHOST_OPEN_ALARM_LAMP,            //open alarm lamp(remote)
    MINOR_ALARMHOST_CLOSE_ALARM_LAMP,            //close alarm lamp(remote)

    MINOR_ALARMHOST_LOCAL_SET_DEVICE_ACTIVE = 0xf0,        //local activate device
    MINOR_ALARMHOST_REMOTE_SET_DEVICE_ACTIVE = 0xf1,        //remote activate device
    MINOR_ALARMHOST_LOCAL_PARA_FACTORY_DEFAULT = 0xf2,    //local parameter factory default
    MINOR_ALARMHOST_REMOTE_PARA_FACTORY_DEFAULT = 0xf3,    //remote parameter factory default

    // Event
            MINOR_SCHOOLTIME_IRGI_B = 0x01,        // B code timing
    MINOR_SCHOOLTIME_SDK,                // SDK timing
    MINOR_SCHOOLTIME_SELFTEST,            // Scheduled self-test timing
    MINOR_SUBSYSTEM_ABNORMALINSERT,        //subSystem abnormal insert
    MINOR_SUBSYSTEM_ABNORMALPULLOUT,        //subSystem abnormal pullout

    MINOR_AUTO_ARM,                //auto arm
    MINOR_AUTO_DISARM,            //auto disarm
    MINOR_TIME_TIGGER_ON,                        //turn on tigger on time
    MINOR_TIME_TIGGER_OFF,                        //turn off tigger on time
    MINOR_AUTO_ARM_FAILD,            //auto arm failed
    MINOR_AUTO_DISARM_FAILD,        //auto disarm failed
    MINOR_TIME_TIGGER_ON_FAILD,                        //turn on tigger on time failed
    MINOR_TIME_TIGGER_OFF_FAILD,                        //turn off tigger on time failed
    MINOR_MANDATORY_ALARM,                //mandatory alarm
    MINOR_KEYPAD_LOCKED,            //keypad locked
    MINOR_USB_INSERT,
    MINOR_USB_PULLOUT,
}ALARMHOST_MINOR_TYPE;
/*
If the main type of the log is MAJOR_OPERATION=03 (Operation) And Sub type is
MINOR_LOCAL_CFG_PARM=0x52 (local configuration)
MINOR_REMOTE_GET_PARM=0x76 (remote get configuration)
MINOR_REMOTE_CFG_PARM=0x77 (remote set configuration)
dwParaType:  is valid,  and the relative definition is listed as below:
*/
#define PARA_VIDEOOUT      0x1
#define PARA_IMAGE          0x2
#define PARA_ENCODE          0x4
#define PARA_NETWORK      0x8
#define PARA_ALARM          0x10
#define PARA_EXCEPTION      0x20
#define PARA_DECODER      0x40    /*Decoder*/
#define PARA_RS232          0x80
#define PARA_PREVIEW      0x100
#define PARA_SECURITY      0x200
#define PARA_DATETIME      0x400
#define PARA_FRAMETYPE      0x800    /*Frame Type*/
#define PARA_DETECTION    0x1000   //Detection config
#define PARA_VCA_RULE     0x1001   //Rules of conduct
#define PARA_VCA_CTRL     0x1002   //Intelligent control information configured
#define PARA_VCA_PLATE      0x1003   //  License Plate Recognition

#define PARA_CODESPLITTER 0x2000 /*spitter code parameter*/
//2010- 01- 22
#define PARA_RS485          0x2001            /* RS485 config info*/
#define PARA_DEVICE          0x2002            /* Device config info*/
#define PARA_HARDDISK      0x2003            /* HD config info */
#define PARA_AUTOBOOT      0x2004            /* Auto-reboot info*/
#define PARA_HOLIDAY      0x2005            /* Holiday info*/
#define PARA_IPC          0x2006            /* IPC channel info */

typedef enum tagCharEncodeType
{
    ENUM_MEM_CHAR_ENCODE_ERR  = -1,         //Error
    ENUM_MEM_CHAR_ENCODE_NO   = 0,          //Don't know.
    ENUM_MEM_CHAR_ENCODE_CN   = 1,          //EUC-CN, GB2312
    ENUM_MEM_CHAR_ENCODE_GBK  = 2,          //GBK
    ENUM_MEM_CHAR_ENCODE_BIG5 = 3,          //BIG5
    ENUM_MEM_CHAR_ENCODE_JP   = 4,          //JISX0208-1, EUC-JP
    ENUM_MEM_CHAR_ENCODE_KR   = 5,          //EUC-KR
    ENUM_MEM_CHAR_ENCODE_UTF8 = 6,          //UTF-8
    ENUM_MEM_CHAR_ENCODE_ISO8859_1  = 7,    //ISO-8859-n: ENUM_MEM_CHAR_ENCODE_ISO8859_1 + n -1
}CHAR_ENCODE_TYPE;

//Time correction structure
typedef struct
{
    DWORD dwYear;             //Year
    DWORD dwMonth;             //Month
    DWORD dwDay;             //Day
    DWORD dwHour;             //Hour
    DWORD dwMinute;         //Minute
    DWORD dwSecond;         //Second
}NET_DVR_TIME,  *LPNET_DVR_TIME;

typedef struct tagNET_DVR_TIME_V30
{
    WORD wYear;
    BYTE byMonth;
    BYTE byDay;
    BYTE byHour;
    BYTE byMinute;
    BYTE bySecond;
    BYTE byRes;
    WORD wMilliSec;
    BYTE byRes1[2];
}NET_DVR_TIME_V30, *LPNET_DVR_TIME_V30;

typedef struct tagNET_DVR_TIME_SEARCH
{
    WORD 	wYear;
    BYTE	byMonth;
    BYTE 	byDay;
    BYTE 	byHour;
    BYTE 	byMinute;
    BYTE 	bySecond;
    char cTimeDifferenceH;        //The time difference between with the international standard time (hours), - 12 ... + 14
    char cTimeDifferenceM;        //The time difference between with the international standard time (minutes)\A3\AC-30, 0, 30, 45
    BYTE	byRes[3];
}NET_DVR_TIME_SEARCH, *LPNET_DVR_TIME_SEARCH;

typedef struct  tagNET_DVR_CALIBRATE_TIME
{
    DWORD  dwSize;
    NET_DVR_TIME struTime;
    WORD wMilliSec;
    BYTE byRes[14];
}NET_DVR_CALIBRATE_TIME,*LPNET_DVR_CALIBRATE_TIME;

/*
IP Address
*/
typedef struct
{
    char    sIpV4[16];                         //IPv4 Address
    BYTE    byIPv6[128];                     //Reserved
}NET_DVR_IPADDR,  *LPNET_DVR_IPADDR;

//Log Info (9000extended)
typedef struct
{
    NET_DVR_TIME strLogTime;
    DWORD    dwMajorType;     //Main type 1- alarm;  2- abnormal;  3- operation;  0xff- all
    DWORD    dwMinorType;     //Hypo- Type 0- all;
    BYTE    sPanelUser[MAX_NAMELEN];  //user ID for local panel operation
    BYTE    sNetUser[MAX_NAMELEN]; //user ID for network operation
    NET_DVR_IPADDR    struRemoteHostAddr; //remote host IP
    DWORD    dwParaType; //parameter type,  for 9000 series MINOR_START_VT/MINOR_STOP_VT,  channel of the voice talking
    DWORD    dwChannel; //channel number
    DWORD    dwDiskNumber; //HD number
    DWORD    dwAlarmInPort; //alarm input port
    DWORD    dwAlarmOutPort; //alarm output port
    DWORD   dwInfoLen;
    char    sInfo[LOG_INFO_LEN];
}NET_DVR_LOG_V30,  *LPNET_DVR_LOG_V30;

//Log Info
typedef struct
{
    NET_DVR_TIME strLogTime;
    DWORD    dwMajorType;     //MMain type 1- alarm;  2- abnormal;  3- operation;  0xff- all
    DWORD    dwMinorType; //Hypo- Type 0- all;
    BYTE    sPanelUser[MAX_NAMELEN];  //user ID for local panel operation
    BYTE    sNetUser[MAX_NAMELEN]; //user ID for network operation
    char    sRemoteHostAddr[16]; //remote host IP
    DWORD    dwParaType; //parameter type
    DWORD    dwChannel; //channel number
    DWORD    dwDiskNumber; //HD number
    DWORD    dwAlarmInPort; //alarm input port
    DWORD    dwAlarmOutPort; //alarm output port
}NET_DVR_LOG,  *LPNET_DVR_LOG;

/************************DVR Log end***************************/

/*************************************************
Parameters configuration structure (_V30 is for 9000)
**************************************************/

/////////////////////////////////////////////////////////////////////////
#define    MAX_TIMESIGN_LEN    32 //Custom Set Time Sign Info Length
typedef  struct tagNET_DVR_TIMESIGN_CFG
{
    DWORD  dwSize;
    BYTE  byCustomSetTimeSign[MAX_TIMESIGN_LEN/*32*/];//Custom Set Time Sign
    BYTE  byRes[96];
}NET_DVR_TIMESIGN_CFG,*LPNET_DVR_TIMESIGN_CFG;

typedef struct tagNET_DVR_TIME_EX
{
    WORD wYear;
    BYTE byMonth;
    BYTE byDay;
    BYTE byHour;
    BYTE byMinute;
    BYTE bySecond;
    BYTE byRes;
}NET_DVR_TIME_EX,*LPNET_DVR_TIME_EX;

//Time Segment (Sub structure)
typedef struct
{
    //Start
    BYTE byStartHour;
    BYTE byStartMin;
    //End
    BYTE byStopHour;
    BYTE byStopMin;
}NET_DVR_SCHEDTIME,  *LPNET_DVR_SCHEDTIME;

/*Handling way of Alarm & Exception*/
#define NOACTION            0x0                /*Don't Respond*/
#define WARNONMONITOR        0x1                /*Warning on Monitor*/
#define WARNONAUDIOOUT        0x2                /*Audio Warning*/
#define UPTOCENTER            0x4                /*Upload to center*/
#define TRIGGERALARMOUT        0x8                /*Trigger Alarm Output*/
#define TRIGGERCATPIC        0x10            /*capture picture and E-mail*/
#define SEND_PIC_FTP        0x200           /*capture picture and upload to ftp*/

typedef struct tagNET_DVR_HANDLEEXCEPTION_V41
{
    DWORD   dwHandleType;        //Way to handle,  result of operation OR
    /*0x00:  No response*/
    /*0x01:  Alarm on monitor*/
    /*0x02:  Audio Alarm*/
    /*0x04:  Upload to center*/
    /*0x08:  Trigger alarm output*/
    /*0x10:  Grab JPEG image and EMail it*/
    /*0x20:  wireless voice and light alarm*/
    /*0x40:  Trigger electric map(only PCNVR supports)*/
    /*0x200: capture jpeg and update to FTP*/
    DWORD   dwMaxRelAlarmOutChanNum ; //the max of dvr support can trigger the alarm output channel number (read-only)
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40];  //Trigger an alarm channel ,  Encountered 0xffffffff follow-up without alarm trigger channel
    BYTE    byRes[64];
}NET_DVR_HANDLEEXCEPTION_V41, *LPNET_DVR_HANDLEEXCEPTION_V41;

//Handle Alarm & Exception
typedef struct  tagNET_DVR_HANDLEEXCEPTION_V40
{
    DWORD   dwHandleType;        //Way to handle,  result of operation OR
    /*0x00:  No response*/
    /*0x01:  Alarm on monitor*/
    /*0x02:  Audio Alarm*/
    /*0x04:  Upload to center*/
    /*0x08:  Trigger alarm output*/
    /*0x10:  Grab JPEG image and EMail it*/
    /*0x20:  wireless voice and light alarm*/
    /*0x40:  Trigger electric map(only PCNVR supports)*/
    /*0x80:  alarm trigger recording (currently only PCNVR support)*/
    /*0x100: alarm trigger PTZ preset point (currently only PCNVR support)*/
    /*0x200: capture jpeg and update to FTP*/
    /*0x400: virtual intersecting detection of linkage focus mode (provides a configuration item, the original equipment automatically) IPC5.1.0*/
    /*0x800: PTZ track linkage*/
    /*0x1000:capture jpeg and update to cloud*/
    DWORD  dwMaxRelAlarmOutChanNum ;        //the max of dvr support can trigger the alarm output channel number (read-only)
    DWORD  dwRelAlarmOutChanNum ;           //The actual number of alarm out channels set
    DWORD   dwRelAlarmOut[MAX_CHANNUM_V30]; //Trigger an alarm channel ,  Encountered 0xffffffff follow-up without alarm trigger channel
    BYTE    byRes[64];
}NET_DVR_HANDLEEXCEPTION_V40, *LPNET_DVR_HANDLEEXCEPTION_V40;

typedef struct
{
    DWORD    dwHandleType;     /*Way to handle,  result of operation OR*/
    /*0x00:  No response*/
    /*0x01:  Alarm on monitor*/
    /*0x02:  Audio Alarm*/
    /*0x04:  Upload to center*/
    /*0x08:  Trigger alarm output*/
    /*0x10:  Grab JPEG image and EMail it*/
    /*0x20:  wireless voice and light alarm*/
    /*0x40:  Trigger electric map(only PCNVR supports)*/
    /*0x200: capture jpeg and update to FTP*/
    BYTE byRelAlarmOut[MAX_ALARMOUT_V30];
    //Alarm out channel,  1 means trigger this channel
}NET_DVR_HANDLEEXCEPTION_V30,  *LPNET_DVR_HANDLEEXCEPTION_V30;

//Handle Alarm & Exception  (sub structure)
typedef struct
{
    DWORD    dwHandleType;             /*Way to handle,  result of operation OR*/
    /*0x00:  No response*/
    /*0x01:  Alarm on monitor*/
    /*0x02:  Audio Alarm*/
    /*0x04:  Upload to center*/
    /*0x08:  Trigger alarm output*/
    /*0x10:  Grab JPEG image and EMail it*/
    BYTE byRelAlarmOut[MAX_ALARMOUT];  //Alarm out channel,  1 means trigger this channel
}NET_DVR_HANDLEEXCEPTION,  *LPNET_DVR_HANDLEEXCEPTION;

//DVR Device Parameters
typedef struct
{
    DWORD dwSize;
    BYTE sDVRName[NAME_LEN];    //DVR Name
    DWORD dwDVRID;                 //DVR ID for IR Control //V1.4 (0- 99) ,  V1.5 (0- 255)
    DWORD dwRecycleRecord;         //cycle Record, 0: No cycle;  1: cycle
    //The variable below is read only
    BYTE sSerialNumber[SERIALNO_LEN];     //SN
    DWORD dwSoftwareVersion;             //software version, high 16 bits is main version,  low 16 bits is hypo- version
    DWORD dwSoftwareBuildDate;             //build date, 0xYYYYMMDD
    DWORD dwDSPSoftwareVersion;         //DSP software version,  high 16 bits is main version,  low 16 bits is hypo- version
    DWORD dwDSPSoftwareBuildDate;         // DSP software build date, 0xYYYYMMDD
    DWORD dwPanelVersion;                 // Front panel version,  high 16 bits is main version,  low 16 bits is hypo- version
    DWORD dwHardwareVersion;     //Hardware version,  high 16 bits is main version,  low 16 bits is hypo- version
    BYTE byAlarmInPortNum;         //Number of alarm input
    BYTE byAlarmOutPortNum;     //Number of alarm output
    BYTE byRS232Num;             //Number of DVR RS232 ports
    BYTE byRS485Num;             //Number of DVR RS485 ports
    BYTE byNetworkPortNum;         //Number of network ports
    BYTE byDiskCtrlNum;         //Number of DVR hardware controllers
    BYTE byDiskNum;             //DVR Hard disk number
    BYTE byDVRType;             //DVR Model,  1: DVR 2: ATM DVR 3: DVS ......
    BYTE byChanNum;             //DVR channel number
    BYTE byStartChan;             //First channel's No. e.g.,  DVS- 1, DVR -  1
    BYTE byDecordChans;         //Number of decoding channels
    BYTE byVGANum;                 //Number of VGA ports
    BYTE byUSBNum;                 //Number of USB ports
    BYTE byAuxoutNum;             //Number of AUX ports
    BYTE byAudioNum;             //Number of audio ports
    BYTE byIPChanNum;             //Maximum number of IP channels
}NET_DVR_DEVICECFG,  *LPNET_DVR_DEVICECFG;

/*
Network structure  (9000)
*/
typedef struct
{
    NET_DVR_IPADDR    struDVRIP;               //DVR IP address
    NET_DVR_IPADDR    struDVRIPMask;             //DVR IP Mask
    DWORD    dwNetInterface;                    //Network port,  1- 10MBase- T, 2- 10MBase- T full duplex,  3- 100MBase- TX, 4- 100M full duplex,  5- 10M/100M adaptive
    WORD    wDVRPort;                         //Port
    WORD    wMTU;                             //MTU,  1500 by default
    BYTE    byMACAddr[MACADDR_LEN];         //MAC address
    BYTE    byRes[2];
}NET_DVR_ETHERNET_V30,  *LPNET_DVR_ETHERNET_V30;

/*
Network data structure (Sub structure)
*/
typedef struct
{
    char sDVRIP[16];              //DVR IP address
    char sDVRIPMask[16];          //DVR IP Mask
    DWORD dwNetInterface;         //Network interface: 1- 10MBase- T, 2- 10MBase- T full duplex, 3- 100MBase- TX, 4- 100M full duplex, 5- 10M/100M adaptive
    WORD wDVRPort;                   //Port
    BYTE byMACAddr[MACADDR_LEN];  //Mac address
}NET_DVR_ETHERNET;

//pppoe structure
typedef struct
{
    DWORD    dwPPPOE;                                         //0- disable, 1- enable
    BYTE    sPPPoEUser[NAME_LEN];                             //PPPoE user name
    char    sPPPoEPassword[PASSWD_LEN];                     //PPPoE password
    NET_DVR_IPADDR    struPPPoEIP;                             //PPPoE IP address
}NET_DVR_PPPOECFG,  *LPNET_DVR_PPPOECFG;

//Network Configure Structure  (9000DVR extended)
typedef struct
{
    DWORD dwSize;
    NET_DVR_ETHERNET_V30    struEtherNet[MAX_ETHERNET];     //Network Port
    NET_DVR_IPADDR    struRes1[2];                             //Reserved
    NET_DVR_IPADDR    struAlarmHostIpAddr;                     //IP address of Alarm Host
    BYTE    byRes2[4];                                         //Reserved
    WORD    wAlarmHostIpPort;                                 //Port of Alarm Host
    BYTE    byUseDhcp;                                      //Enable DHCP or not 0xff- invalid 0- disable 1- enable
    BYTE    byIPv6Mode;                                     //IPv6 allocation, 0 - route bulletin, 1 - manually set, 2 - Enable DHCP-assigned
    NET_DVR_IPADDR    struDnsServer1IpAddr;                     //IP address of DNS 1
    NET_DVR_IPADDR    struDnsServer2IpAddr;                     //IP address of DNS 2
    BYTE    byIpResolver[MAX_DOMAIN_NAME];                     //IP address or domain name of analysis server
    WORD    wIpResolverPort;                                 //Port of IP analysis server
    WORD    wHttpPortNo;                                     //HTTP port
    NET_DVR_IPADDR    struMulticastIpAddr;                     //Multicast group address
    NET_DVR_IPADDR    struGatewayIpAddr;                         //Gateway address
    NET_DVR_PPPOECFG struPPPoE;
    BYTE    byEnablePrivateMulticastDiscovery;              //Private Multicast Discovery\A3\AC0~Default\A3\AC1~Enable\A3\AC2-Disable
    BYTE    byEnableOnvifMulticastDiscovery;                //Onvif Multicast Discovery\A3\AC0~Default\A3\AC1~Enable\A3\AC2-Disable
    BYTE    byEnableDNS; //DNS Atuo enable, 0-Res\A3\AC1-open, 2-close
    BYTE    byRes[61];
} NET_DVR_NETCFG_V30,  *LPNET_DVR_NETCFG_V30;

//Netcard Configure Structure
typedef struct
{
    NET_DVR_IPADDR struDVRIP;                  /*Network card IP address */
    NET_DVR_IPADDR struDVRIPMask;              /*Network card IP address mask*/
    DWORD dwNetInterface;                      /*Network port,  1- 10MBase- T 2- 10MBase- T full duplex  3- 100MBase- TX 4- 100M full duplex  5- 10M/100M adaptive*/
    BYTE byCardType;  //Network card type\A3\AC0-Normal network card\A3\AC1-internal network card \A3\AC2-external network card
    BYTE    byEnableDNS; //DNS Auto Enabled\A3\AC0 - res, 1 - open, 2 - close
    WORD wMTU; 						         /*MTU,  1500 by default*/
    BYTE byMACAddr[MACADDR_LEN]; 		     /*Mac address*/
    BYTE byRes2[2];                          /*Reserved*/
    BYTE byUseDhcp;                          /* Enable DHCP or not 0xff- invalid 0- disable 1- enable*/
    BYTE byRes3[3];                             /*Reserved*/
    NET_DVR_IPADDR struGatewayIpAddr;          /*Gateway address*/
    NET_DVR_IPADDR struDnsServer1IpAddr;      /*IP address of DNS 1*/
    NET_DVR_IPADDR struDnsServer2IpAddr;      /*IP address of DNS 2*/
}NET_DVR_ETHERNET_MULTI,  *LPNET_DVR_ETHERNET_MULTI;

//Multi Netcard Configure Structure
typedef struct
{
    DWORD  dwSize;
    BYTE   byDefaultRoute;           /* Default route, 0:  struEtherNet[0], 1:  struEtherNet[1] */
    BYTE   byNetworkCardNum;         //Network card sum
    BYTE   byWorkMode;   //Work mode,0-normal multi network card mode\A3\AC1-internal and external network isolation mode
    BYTE   byRes;
    NET_DVR_ETHERNET_MULTI struEtherNet[MAX_NETWORK_CARD];  /* Network Port*/
    NET_DVR_IPADDR         struManageHost1IpAddr;        /* Manage host 1 IP */
    NET_DVR_IPADDR         struManageHost2IpAddr;        /* Manage host 2 IP */
    NET_DVR_IPADDR           struAlarmHostIpAddr;          /* Alarm host IP 1 */
    WORD wManageHost1Port;      /* Manage host 1 port */
    WORD wManageHost2Port;      /* Manage host 2 port */
    WORD wAlarmHostIpPort;      /* Alarm host port */
    BYTE  byIpResolver[MAX_DOMAIN_NAME];      /* IP address or domain name of analysis serve */
    WORD wIpResolverPort;                    /* Port of IP analysis server */
    WORD wDvrPort;                            //DVR port ,  default 8000
    WORD wHttpPortNo;                        /* HTTP port */
    WORD wDvrPort2; //DVR port 2
    BYTE byRes2[4];
    NET_DVR_IPADDR   struMulticastIpAddr;          /* Multicast group address */
    NET_DVR_PPPOECFG struPPPoE;
    BYTE byRes3[24];
}NET_DVR_NETCFG_MULTI,  *LPNET_DVR_NETCFG_MULTI;

//Network Configure Structure
typedef struct
{
    DWORD dwSize;
    NET_DVR_ETHERNET struEtherNet[MAX_ETHERNET];         /* Network Port */
    char sManageHostIP[16];         //IP address of remote management host
    WORD wManageHostPort;         //Port of remote management Host
    char sIPServerIP[16];        //Address of IPServer
    char sMultiCastIP[16];      //Multicast group address
    char sGatewayIP[16];            //Gateway address
    char sNFSIP[16];             //IP address of NFS host
    BYTE sNFSDirectory[PATHNAME_LEN]; //NFS directory
    DWORD dwPPPOE;                 //0- disable, 1- enable
    BYTE sPPPoEUser[NAME_LEN];     //PPPoE username
    char sPPPoEPassword[PASSWD_LEN]; // PPPoE password
    char sPPPoEIP[16];             //PPPoE IP address  (read only)
    WORD wHttpPort;                 //HTTP port
}NET_DVR_NETCFG,  *LPNET_DVR_NETCFG;

//Network Configure Structure(V50)
typedef struct tagNET_DVR_NETCFG_V50
{
    DWORD dwSize;
    NET_DVR_ETHERNET_V30	struEtherNet[MAX_ETHERNET];		//Network Port
    NET_DVR_IPADDR	struRes1[2];							/*reserve*/
    NET_DVR_IPADDR	struAlarmHostIpAddr;					/* IP address of remote management host */
    BYTE	byRes2[4];										/* reserve */
    WORD	wAlarmHostIpPort;								/* Port of remote management Host */
    BYTE    byUseDhcp;                                      /* Whether to enable the DHCP 0xff- invalid 0- enabled 1- not enabled */
    BYTE	byIPv6Mode;										//IPv6 allocation, 0- routing announcement, 1- manually, 2- enable DHCP allocation
    NET_DVR_IPADDR	struDnsServer1IpAddr;					/* IP address of the domain name server 1  */
    NET_DVR_IPADDR	struDnsServer2IpAddr;					/* IP address of the domain name server 2  */
    BYTE	byIpResolver[MAX_DOMAIN_NAME];					/* IP parse server domain name or IP address */
    WORD	wIpResolverPort;								/* Parsing IP server port number */
    WORD	wHttpPortNo;									/* HTTP port number  */
    NET_DVR_IPADDR	struMulticastIpAddr;					/* Multicast group address */
    NET_DVR_IPADDR	struGatewayIpAddr;						/* Gateway address  */
    NET_DVR_PPPOECFG struPPPoE;
    BYTE	byEnablePrivateMulticastDiscovery;				//Private multicast search, 0- default, 1- enabled, 2 - disabled
    BYTE	byEnableOnvifMulticastDiscovery;				//Onvif multicast search, 0- default, 1- enabled, 2 - disabled
    WORD	wAlarmHost2IpPort;								/* Alarm host 2 port */
    NET_DVR_IPADDR	struAlarmHost2IpAddr;					/* Alarm host 2 IP addresses */
    BYTE    byEnableDNS; //DNS Enabled, 0-close\A3\AC1-open
    BYTE    byRes[599];
}NET_DVR_NETCFG_V50, *LPNET_DVR_NETCFG_V50;

//sip
typedef struct tagNET_DVR_SIP_CFG
{
    DWORD dwSize;
    BYTE byEnableAutoLogin;    //Enable auto login\A3\AC0-disable\A3\AC1-enable
    BYTE byLoginStatus;  //login status\A3\AC0-not login\A3\AC1-logined
    BYTE byRes1[2];
    NET_DVR_IPADDR stuServerIP;  //SIP server IP
    WORD wServerPort;    //SIP server port
    BYTE byRes2[2];
    BYTE byUserName[NAME_LEN];  //user name
    BYTE byPassWord[PASSWD_LEN]; //user password
    BYTE byLocalNo[MAX_NUMBER_LEN];
    BYTE byDispalyName[MAX_NAME_LEN]; //device name
    WORD wLocalPort;     //local port
    BYTE byLoginCycle;   //login cycle\A3\AC1-99min
    BYTE byRes[129];
}NET_DVR_SIP_CFG, *LPNET_DVR_SIP_CFG;

typedef struct tagNET_DVR_IP_VIEW_DEVCFG
{
    DWORD dwSize;
    BYTE  byDefaultRing; //default ring\A3\AC[1-6]
    BYTE  byRingVolume;  //ring volume\A3\AC[0-9]
    BYTE  byInputVolume; //input ring volume\A3\AC[0-6]
    BYTE  byOutputVolume; //output ring volume[0-9]
    WORD  wRtpPort;  //Rtp port
    BYTE  byRes1[2];
    DWORD dwPreviewDelayTime; //preview delay time\A3\AC0-30s
    BYTE  byRes2[64];
}NET_DVR_IP_VIEW_DEVCFG,*LPNET_DVR_IP_VIEW_DEVCFG;

typedef struct tagNET_DVR_IP_VIEW_AUDIO_CFG
{
    DWORD dwSize;
    BYTE  byAudioEncPri1; //audio encode priority1\A3\AC0-G722\A3\AC1-G711_U\A3\AC2-G711_A\A3\AC 5-MPEG2,6-G726\A3\AC7-AAC
    BYTE  byAudioEncPri2; //audio encode priority2\A3\AC0-G722\A3\AC1-G711_U\A3\AC2-G711_A\A3\AC 5-MPEG2,6-G726\A3\AC7-AAC
    WORD  wAudioPacketLen1; //audio encode packet len1
    WORD  wAudioPacketLen2; //audio encode packet len2
    BYTE  byRes[30];
}NET_DVR_IP_VIEW_AUDIO_CFG,*LPNET_DVR_IP_VIEW_AUDIO_CFG;

typedef struct tagNET_DVR_IP_VIEW_CALL_CFG
{
    DWORD dwSize ;
    BYTE  byEnableAutoResponse; //enable auto-response,0-disable\A3\AC1-enable
    BYTE  byAudoResponseTime; //auto-response time\A3\AC0-30s
    BYTE  byRes1[2];
    BYTE  byEnableAlarmNumber1; //enable alarm number1\A3\AC0-disable\A3\AC1-enable
    BYTE  byRes2[3];
    BYTE  byAlarmNumber1[MAX_NUMBER_LEN]; //alarm number1
    BYTE  byEnableAlarmNumber2; //alarm number2\A3\AC0-diable\A3\AC1-enable
    BYTE  byRes3[3];
    BYTE  byAlarmNumber2[MAX_NUMBER_LEN]; //alarm number2
    BYTE  byRes4[72];
}NET_DVR_IP_VIEW_CALL_CFG,*LPNET_DVR_IP_VIEW_CALL_CFG;
//Channel Image structure

typedef struct
{
    DWORD     dwMaxRecordChanNum;
    DWORD     dwCurRecordChanNum;
    DWORD     dwRelRecordChan[MAX_CHANNUM_V30];
    BYTE       byRes[64];
} NET_DVR_RECORDCHAN, *LPNET_DVR_RECORDCHAN;

//Motion detection structure (sub structure)  (9000 extended)
typedef struct
{
    BYTE byMotionScope[64][96];                                     /*Motion detection area, 0- 96 bits stand for 64 lines and there are 96*64 small areas,  1- - it is motion detection area, 0- - not*/
    BYTE byMotionSensitive;                                         /*sensitive grade of motion detection,  0 -  5 (5 is most sensitive) ,  oxff turn off*/
    BYTE byEnableHandleMotion;                                         /* Process motion alarm  0- No 1- Yes*/
    BYTE byEnableDisplay;    /*Display motion detect,0- No 1- Yes*/
    char reservedData;
    NET_DVR_HANDLEEXCEPTION_V30 struMotionHandleType;                 /* The way to process */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*Guard time*/
    BYTE byRelRecordChan[MAX_CHANNUM_V30];                             /* Channel triggered to record*/
}NET_DVR_MOTION_V30,  *LPNET_DVR_MOTION_V30;

//Motion detection structure (sub structure)
typedef struct
{
    BYTE byMotionScope[18][22];     /*motion detection area,  22*18 blocks in total,  1- - it's motion detection area,  0- - not*/
    BYTE byMotionSensitive;         /*sensitive grade of motion detection,  0 -  5 (5 is most sensitive) ,  oxff turn off*/
    BYTE byEnableHandleMotion;     /* process motion detection or not */
    BYTE byEnableDisplay;    /*Display motion detect,0- No 1- Yes*/
    char reservedData;
    NET_DVR_HANDLEEXCEPTION strMotionHandleType;     /* method to process alarm */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT]; //Guard time
    BYTE byRelRecordChan[MAX_CHANNUM];                 //Channel triggered to record*/
}NET_DVR_MOTION,  *LPNET_DVR_MOTION;


typedef struct
{
    DWORD dwEnableHideAlarm;                 /* Enable tamper alarm or not , 0- disable, 1- low sensitivity 2- Middle 3- High*/
    WORD wHideAlarmAreaTopLeftX;             /* X- coordinate of tamper area */
    WORD wHideAlarmAreaTopLeftY;             /* Y- coordinate of tamper area */
    WORD wHideAlarmAreaWidth;                 /* Width of tampered area */
    WORD wHideAlarmAreaHeight;                 /* Height of tampered area*/

    DWORD   dwHandleType;           /* Way to handle the alarm */
    /*0x00:  No response*/
    /*0x01:  Alarm on monitor*/
    /*0x02:  Audio Alarm*/
    /*0x04:  Upload to center*/
    /*0x08:  Trigger alarm output*/
    /*0x10:  Grab JPEG image and EMail it*/
    /*0x20:  wireless voice and light alarm*/
    /*0x40:  Trigger electric map(only PCNVR supports)*/
    /*0x200: capture jpeg and update to FTP*/
    /*0x1000:capture jpeg and update to cloud*/
    DWORD   dwMaxRelAlarmOutChanNum ;
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40];
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*alarm Time*/
    BYTE  byRes[64];
}NET_DVR_HIDEALARM_V40,*LPNET_DVR_HIDEALARM_V40; //Tamper Alarm

//Tamper Alarm  (sub structure)  (9000 extended)   area size:  704*576
typedef struct
{
    DWORD dwEnableHideAlarm;                 /* Enable tamper alarm or not , 0- disable, 1- low sensitivity 2- Middle 3- High*/
    WORD wHideAlarmAreaTopLeftX;             /* X- coordinate of tamper area */
    WORD wHideAlarmAreaTopLeftY;             /* Y- coordinate of tamper area */
    WORD wHideAlarmAreaWidth;                 /* Width of tampered area */
    WORD wHideAlarmAreaHeight;                 /* Height of tampered area*/
    NET_DVR_HANDLEEXCEPTION_V30 strHideAlarmHandleType;     /* Way to handle alarm */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; //Guard time
}NET_DVR_HIDEALARM_V30,  *LPNET_DVR_HIDEALARM_V30;

//Tamper Alarm  (sub structure)  area size:  704*576
typedef struct
{
    DWORD dwEnableHideAlarm;                 /* Enable tamper alarm or not , 0- disable, 1- low sensitivity 2- Middle 3- High*/
    WORD wHideAlarmAreaTopLeftX;             /* X- coordinate of tamper area */
    WORD wHideAlarmAreaTopLeftY;             /* Y- coordinate of tamper area */
    WORD wHideAlarmAreaWidth;                 /* Width of tampered area */
    WORD wHideAlarmAreaHeight;                 /* Height of tampered area*/
    NET_DVR_HANDLEEXCEPTION strHideAlarmHandleType;     /* Way to handle the alarm */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT]; //Guard time
}NET_DVR_HIDEALARM,  *LPNET_DVR_HIDEALARM;

//Signal Lost Alarm (sub structure)  (9000 extended)
typedef struct
{
    BYTE byEnableHandleVILost;     /* Respond the alarm or not */
    NET_DVR_HANDLEEXCEPTION_V30 strVILostHandleType;     /* Way to respond*/
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; //Guard time
}NET_DVR_VILOST_V30,  *LPNET_DVR_VILOST_V30;

//Signal Lost Alarm (sub structure)
typedef struct
{
    BYTE byEnableHandleVILost;     /* Respond the alarm or not */
    NET_DVR_HANDLEEXCEPTION strVILostHandleType;     /* Way to respond*/
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT]; //Guard time
}NET_DVR_VILOST,  *LPNET_DVR_VILOST;

//Tampered Area (sub structure)
typedef struct
{
    WORD wHideAreaTopLeftX;                 /* X- coordinate of tamper area */
    WORD wHideAreaTopLeftY;                 /* Y- coordinate of tamper area */
    WORD wHideAreaWidth;                 /* Width of tampered area */
    WORD wHideAreaHeight;                 /* Height of tampered area*/
}NET_DVR_SHELTER,  *LPNET_DVR_SHELTER;

typedef struct
{
    BYTE byBrightness;       /*Brightness, 0- 255*/
    BYTE byContrast;         /*contrast, 0- 255*/
    BYTE bySaturation;       /*Saturation, 0- 255*/
    BYTE byHue;                 /*Hue, 0- 255*/
}NET_DVR_COLOR,  *LPNET_DVR_COLOR;

typedef struct
{
    BYTE byRed;
    BYTE byGreen;
    BYTE byBlue;
    BYTE byRes;        //res
}NET_DVR_RGB_COLOR, *LPNET_DVR_RGB_COLOR;

//Point
typedef struct tagNET_VCA_POINT
{
    float fX;                                 //X axis coordinate,  0.001~1
    float fY;                                 //Y axis coordinate,  0.001~1
}NET_VCA_POINT,  *LPNET_VCA_POINT;

//Video Structure (9000 extended)
typedef struct
{
    DWORD dwSize;
    BYTE sChanName[NAME_LEN];
    DWORD dwVideoFormat;     /* Read only,  Video Standard 1- NTSC 2- PAL*/
    BYTE  byReservedData[64]; /*Reserved*/
    //Display Channel Name
    DWORD dwShowChanName;  // Display channel name or not, 0- no, 1- display size = 704*576
    WORD wShowNameTopLeftX;                 /* X- coordinate of display position */
    WORD wShowNameTopLeftY;                 /* Y- coordinate of display position  */
    //Signal lost Alarm
    NET_DVR_VILOST_V30 struVILost;
    NET_DVR_VILOST_V30 struRes;         /*Reserved*/
    //Motion detection
    NET_DVR_MOTION_V30 struMotion;
    //Tamper alarm
    NET_DVR_HIDEALARM_V30 struHideAlarm;
    //Tampered Area 704*576
    DWORD dwEnableHide;         /* Enable Tamper Alarm , 0- disable, 1- enable*/
    NET_DVR_SHELTER struShelter[MAX_SHELTERNUM];
    //OSD
    DWORD dwShowOsd;         // Display OSD or not, 0- No OSD, 1- Display Area for display:  704*576
    WORD wOSDTopLeftX;                 /* X- coordinate of OSD */
    WORD wOSDTopLeftY;                 /* Y- coordinate of OSD*/
    BYTE byOSDType;                     /* OSD Type  (format of Year/Month/Day)  */
    /* 0: XXXX- XX- XX Year Month Day */
    /* 1: XX- XX- XXXX Month Day Year */
    /* 2: XXXXYearXXNonthXXDay */
    /* 3: XXMonthXXDayXXXXYear */
    /* 4: XX- XX- XXXX Day Month Year*/
    /* 5: XXDayXXMonthXXXXYear */
    /* 6: xx/xx/xxxx(Month/Day/Year) */
    /* 7: xxxx/xx/xx(Year/Month/Day) */
    /* 8: xx/xx/xxxx(Day/Month/Year)*/
    BYTE byDispWeek;                 /* display Week */
    BYTE byOSDAttrib;                 /* OSD attribute:  Transparent, Flash */
    /* 1:  Transparent, Flash */
    /* 2:  Transparent, not Flash */
    /* 3:  Flash, not Transparent */
    /* 4:  not Transparent,  not Flash */
    BYTE byHourOSDType;                 /* : 24- Hour system, 12- Hour system */
    BYTE byFontSize;
    BYTE byOSDColorType;    //0-OSD Color type\A3\A8black or white\A3\A9\A3\BB1-custom
    BYTE byAlignment;//0- adaptive, 1- right aligned 2- left aligned
    BYTE byOSDMilliSecondEnable;//OSD MilliSecond Enable
    NET_DVR_RGB_COLOR    struOsdColor;//OSD color
    BYTE byRes[56];
}NET_DVR_PICCFG_V30, *LPNET_DVR_PICCFG_V30;

//Video Structure (SDK_V14 extended)
typedef struct
{
    DWORD dwSize;
    BYTE sChanName[NAME_LEN];
    DWORD dwVideoFormat;     /* Read only,  Video Standard 1- NTSC 2- PAL*/
    BYTE byBrightness;      /*0-255*/
    BYTE byContrast;        /*0-255*/
    BYTE bySaturation;      /*0-255 */
    BYTE byHue;                /*0-255*/
    //Display Channel Name
    DWORD dwShowChanName;  // Display channel name or not, 0- no, 1- display size = 704*576
    WORD wShowNameTopLeftX;                 /* X- coordinate of display position */
    WORD wShowNameTopLeftY;                 /* Y- coordinate of display position  */
    //Signal lost Alarm
    NET_DVR_VILOST struVILost;
    //Motion Detection
    NET_DVR_MOTION struMotion;
    //Tamper Alarm
    NET_DVR_HIDEALARM struHideAlarm;
    //Tamper Area size:  704*576
    DWORD dwEnableHide;         /* Enable Tamper Alarm , 0- disable, 1- enable**/
    NET_DVR_SHELTER struShelter[MAX_SHELTERNUM];
    //OSD
    DWORD dwShowOsd;                 // Display OSD or not, 0- No OSD, 1- Display Area for display:  704*576
    WORD wOSDTopLeftX;                 /* X- coordinate of OSD */
    WORD wOSDTopLeftY;                 /* Y- coordinate of OSD*/
    BYTE byOSDType;                     /* OSD Type  (format of Year/Month/Day)  */
    /* 0:  XXXX- XX- XX Year/Month/Day */
    /* 1:  XX- XX- XXXX Month/Day/Year */
    /* 2:  XXXXYearXXNonthXXDay */
    /* 3:  XXMonthXXDayXXXXYear */
    /* 4:  XX- XX- XXXX Day Month Year*/
    /* 5:  XXDayXXMonthXXXXYear */
    /*6: xx/xx/xxxx(Month/Day/Year) */
    /*7: xxxx/xx/xx(Year/Month/Day) */
    /*8: xx/xx/xxxx(Day/Month/Year)*/
    BYTE byDispWeek;                 /* display Week */
    BYTE byOSDAttrib;                 /* OSD attribute:  Transparent, Flash */
    /* 1:  Transparent, Flash */
    /* 2:  Transparent, not Flash */
    /* 3:  Flash, not Transparent */
    /* 4:  not Transparent,  not Flash */
    BYTE byHourOsdType;     //hour: 0- 24 hours, 1- am/pm
}NET_DVR_PICCFG_EX,  *LPNET_DVR_PICCFG_EX;

//Video Structure (SDK_V14 extended)
typedef struct
{
    DWORD dwSize;
    BYTE sChanName[NAME_LEN];
    DWORD dwVideoFormat;     /* Read only,  Video Standard 1- NTSC 2- PAL*/
    BYTE byBrightness;      /*0-255*/
    BYTE byContrast;        /*0-255*/
    BYTE bySaturation;      /*0-255 */
    BYTE byHue;                /*0-255*/
    //Display Channel Name
    DWORD dwShowChanName;  // Display channel name or not, 0- no, 1- display size = 704*576
    WORD wShowNameTopLeftX;                 /* X- coordinate of display position */
    WORD wShowNameTopLeftY;                 /* Y- coordinate of display position  */
    //Signal lost Alarm
    NET_DVR_VILOST struVILost;
    //Motion Detection
    NET_DVR_MOTION struMotion;
    //Tamper Alarm
    NET_DVR_HIDEALARM struHideAlarm;
    //Tamper Area size:  704*576
    DWORD dwEnableHide;         /* Enable Tamper Alarm , 0- disable, 1- enable*/
    WORD wHideAreaTopLeftX;                 /* X- coordinate of tampered area*/
    WORD wHideAreaTopLeftY;                 /* Y- coordinate of tampered area */
    WORD wHideAreaWidth;                 /* Width of tampered area */
    WORD wHideAreaHeight;                 /* Height of tampered area */
    //OSD
    DWORD dwShowOsd;                 // Display OSD or not, 0- No OSD, 1- Display Area for display:  704*576
    WORD wOSDTopLeftX;                 /* X- coordinate of OSD */
    WORD wOSDTopLeftY;                 /* Y- coordinate of OSD*/
    BYTE byOSDType;                     /* OSD Type  (format of Year/Month/Day)  */
    /* 0:  XXXX- XX- XX Year/Month/Day */
    /* 1:  XX- XX- XXXX Month/Day/Year */
    /* 2:  XXXXYearXXNonthXXDay */
    /* 3:  XXMonthXXDayXXXXYear */
    /* 4:  XX- XX- XXXX Day Month Year*/
    /* 5:  XXDayXXMonthXXXXYear */
    /*6: xx/xx/xxxx(Month/Day/Year) */
    /*7: xxxx/xx/xx(Year/Month/Day) */
    /*8: xx/xx/xxxx(Day/Month/Year)*/
    BYTE byDispWeek;                 /* display Week */
    BYTE byOSDAttrib;                 /* OSD attribute:  Transparent, Flash */
    /* 1:  Transparent, Flash */
    /* 2:  Transparent, not Flash */
    /* 3:  Flash, not Transparent */
    /* 4:  not Transparent,  not Flash */
    char reservedData2;
}NET_DVR_PICCFG,  *LPNET_DVR_PICCFG;

typedef enum _BITRATE_ENCODE_INDEX_
{
    BITRATE_ENCODE_def = 0,
    BITRATE_ENCODE_8kps = 1,
    BITRATE_ENCODE_16kps = 2,
    BITRATE_ENCODE_32kps = 3,
    BITRATE_ENCODE_64kps = 4,
    BITRATE_ENCODE_128kps = 5,
    BITRATE_ENCODE_192kps = 6,
    BITRATE_ENCODE_40kps = 7,
    BITRATE_ENCODE_48kps = 8,
    BITRATE_ENCODE_56kps = 9,
    BITRATE_ENCODE_80kps = 10,
    BITRATE_ENCODE_96kps = 11,
    BITRATE_ENCODE_112kps = 12,
    BITRATE_ENCODE_144kps = 13,
    BITRATE_ENCODE_160kps = 14
}BITRATE_ENCODE_INDEX;

//Encoding Parameters (Sub Strut)  (9000 extended)
typedef struct
{
    BYTE byStreamType;         //Stream type 0- video,  1- video&audio,  when it stands for compression parameters,  the highest bit stands for whether adopt encoding parameters
    /*Resolution 0-DCIF                 1-CIF,                     2-QCIF,                 3-4CIF,
            4-2CIF                                                 6-QVGA(320*240),        7-QQVGA(160*120),
            12-384*288                  13-576*576,
            16-VGA\A3\A8640*480\A3\A9,          17-UXGA\A3\A81600*1200\A3\A9,      18-SVGA(800*600),       19-HD720p(1280*720\A3\A9,
            20-XVGA,                    21-HD900p,                 22-1360*1024,           23-1536*1536,
            24-1920*1920,               27-HD1080i,
            28-2560*1920,               29-1600*304,               30-2048*1536,           31-2448*2048,
            32-2448*1200,               33-2448*800,               34-XGA\A3\A81024*768\A3\A9\A3\AC    35-SXGA\A3\A81280*1024\A3\A9,
            36-WD1(960*576/960*480),    37-1080i,                  38-WSXGA(1440*900),     39-HD_F(1920*1080/1280*720),
            40-HD_H(1920*540/1280*360), 41-HD_Q(960*540/630*360),  42-2336*1744,           43-1920*1456,
            44-2592*2048,               45-3296*2472,              46-1376*768,            47-1366*768,
            48-1360*768,                49-WSXGA+,                 50-720*720,             51-1280*1280,
            52-2048*768,                53-2048*2048,              54-2560*2048,           55-3072*2048,
            56-2304*1296                57-WXGA(1280*800),         58-1600*600,            59-1600*900,
            60-2752*2208,                61-retain,                 62-4000*3000,           63-4096*2160,
            64-3840*2160,                65-4000*2250,              66-3072*1728,           67-2592*1944,
            68-2464*1520,               69-1280*1920,              70-2560*1440,           71-1024*1024,
            72-160*128,                 73-324*240,                74-324*256,             75-336*256,
            76-640*512,                 77-2720*2048,              78-384*256,             79-384*216,
            80-320*256,                 81-320*180,                82-320*192,             83-512*384,
            84-325*256,                 85-256*192,                86-640*360,               87-1776x1340,
            88-1936x1092,                89-2080x784,               90-2144x604,            91-1920*1200,
            92-4064*3040,               93-3040*3040,              94-3072*2304,           95-3072*1152,
            96-2560*2560,               97-2688*1536,              98-2688*1520,           99-3072*3072,
            100-3392*2008,,             101-4000*3080,             102-960*720,            103-1024*1536,
            104-704*1056,               105-352*528,               106-2048*1530,          107-2560*1600,
            108-2800*2100,              109-4088*4088,             110-4000*3072           111-960*1080(1080p Lite)
            112-640*720(half 720p),     113-640*960,               114-320*480,             115-3840*2400,
            116-3840*1680,              117-2560*1120,             118-704*320,             119-1200*1920,
            120-480*768,                121-768*480,               122-320*512,             123-512*320,
            124-4096*1800,              125-1280*560,              126-2400*3840,          127-480*272,
            128-512*272,                129-2592*2592,             130-1792*2880,          131-1600*2560,
            132-2720*1192,              133-3MP(1920*1536/2048*1536)\A3\AC                     134-5MP(2560*1944)\A3\AC
            135-2560*960,               136-2064*1544              137-4096*1200,
            138-3840*1080               139-2720*800               140-512*232             141-704*200,
            142-512*152,                143-2048*896               144-2048*600            145-1280*376,
            146-2592*1520,              147-2592*1536,             148-3072*8192,          149-768*2048,
            150-8208*3072,              151-4096*1536,             152-6912*2800,          153-3456*1400
            154-480*720
			0xff-Auto(use current resolution)
	*/
    BYTE byResolution;
    BYTE byBitrateType; 		//Bitrate Type 0: VBR, 1: CBR
    BYTE byPicQuality; 		//Image Quality 0- best 1- much better 2- better 3- Normal 4- worse 5- worst
    /*video bit rate 0- reserved 1- 16K 2- 32K 3- 48k 4- 64K 5- 80K 6- 96K 7- 128K 8- 160k 9- 192K 10- 224K 11- 256K 12- 320K
    13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K  24-3072K 25-4096K 26-8192K 27-16384K
    if The highest bit (31 bit)  is 1,  it stands for user defined bit rate,  0- 30 is the value of bit rate*/
    DWORD dwVideoBitrate;
    DWORD dwVideoFrameRate; //Frame rate 0- full;  1- 1/16;  2- 1/8;  3- 1/4;  4- 1/2;  5- 1;  6- 2;  7- 4;  8- 6;  9- 8;  10- 10;  11- 12;  12- 16;  13- 20; 14- 15;  15- 18;  16- 22;
    //17-25\A3\BB18-30\A3\BB19-35\A3\BB20-40\A3\BB21-45\A3\BB22-50\A3\BB23-55\A3\BB24-60\A3\AC25-3;26-5;27-7;28-9;29-100; 30-120;31-24;32-48,0xfffffffe-auto
    WORD  wIntervalFrameI;  //interval of I frame
    BYTE  byIntervalBPFrame;//0- BBP frame;  1- BP frame;  2- P frame only(2006-08-11 Add single P frame).
    BYTE  byres1;           //reserve
    BYTE  byVideoEncType;   //Video Code Type:  0-private h264\A3\AC1-standard H264\A3\AC2-standard MPEG4\A3\AC7-M-JPEG\A3\AC8-MPEG2\A3\AC9-SVAC, 10-Standard h265, 0xfe- auto\A3\AC0xff-invalid
    BYTE  byAudioEncType;   //Audio Code Type:  0- G722; 1- G711_U; 2- G711_A;5-MP2L2;6-G726;7-AAC,8-PCM
    BYTE  byVideoEncComplexity; //Video encode complexity, 0-low,1-middle,2-high
    BYTE  byEnableSvc; //0 - do not enable the SVC function; 1 - enable SVC function; 2-Auto SVC
    BYTE  byFormatType; //video format type\A3\AC1-original\A3\AC2-RTP\A3\AC3-PS\A3\AC4-TS\A3\AC5-private\A3\AC6-FLV\A3\AC7-ASF\A3\AC8-3GP,9-RTP+PS(GB28181)\A3\AC0xff-Invalid
    BYTE  byAudioBitRate; // audioBitRate refer to BITRATE_ENCODE_INDEX
    BYTE  byStreamSmooth;    //stream smoothing 1\A1\AB100\A3\A81-(Clear),..., 100-(Smooth)\A3\A9
    BYTE  byAudioSamplingRate;//AudioSamplingRate 0-default\A3\AC1-16kHZ, 2-32kHZ\A3\AC3-48kHZ, 4- 44.1kHZ,5-8kHZ
    BYTE  bySmartCodec;//High performance code: 0-Close\A3\AC1-Open
    BYTE  byres;
    WORD  wAverageVideoBitrate;// Average Video Bitrate
}NET_DVR_COMPRESSION_INFO_V30,  *LPNET_DVR_COMPRESSION_INFO_V30;

//Encoding Parameters  (9000 extended)
typedef struct
{
    DWORD dwSize;
    NET_DVR_COMPRESSION_INFO_V30 struNormHighRecordPara;     //Record,  corresponding to 8000's normal
    NET_DVR_COMPRESSION_INFO_V30 struRes;                     //Reserved char reserveData[28];
    NET_DVR_COMPRESSION_INFO_V30 struEventRecordPara;        //Encoding parameters triggered by Events
    NET_DVR_COMPRESSION_INFO_V30 struNetPara;                //network transfer
}NET_DVR_COMPRESSIONCFG_V30,  *LPNET_DVR_COMPRESSIONCFG_V30;

//Encoding Parameters (Sub Strut)
typedef struct
{
    BYTE byStreamType;         //Stream type 0- video,  1- video&audio,  when it stands for compression parameters,  the hightest bit stands for whether adopt encoding parameters
    BYTE byResolution;       //Resolution 0- DCIF 1- CIF,  2- QCIF,  3- 4CIF,  4- 2CIF,  5- 2QCIF (352X144)  (for Mobile DVR)
    BYTE byBitrateType;         //Bit rate type 0: VBR, 1: CBR
    BYTE  byPicQuality;         //Image Quality 0- best 1- much better 2- better 3- Normal 4- worse 5- worst
    DWORD dwVideoBitrate;      //video bit rate 0- reserved 1- 16K (reserved)  2- 32K 3- 48k 4- 64K 5- 80K 6- 96K 7- 128K 8- 160k 9- 192K 10- 224K 11- 256K 12- 320K
    // 13- 384K 14- 448K 15- 512K 16- 640K 17- 768K 18- 896K 19- 1024K 20- 1280K 21- 1536K 22- 1792K 23- 2048K
    //if The highest bit (31 bit)  is 1,  it stands for user defined bit rate,  0- 30 is the value of bit rate (MIN- 32K)
    DWORD dwVideoFrameRate;     //Frame rate 0- full;  1- 1/16;  2- 1/8;  3- 1/4;  4- 1/2;  5- 1;  6- 2;  7- 4;  8- 6;  9- 8;  10- 10;  11- 12;  12- 16;  13- 20;
}NET_DVR_COMPRESSION_INFO,  *LPNET_DVR_COMPRESSION_INFO;

//Encoding Parameters
typedef struct
{
    DWORD dwSize;
    NET_DVR_COMPRESSION_INFO struRecordPara;  //Record triggered by events
    NET_DVR_COMPRESSION_INFO struNetPara;     //Network transfer (reserved)
}NET_DVR_COMPRESSIONCFG,  *LPNET_DVR_COMPRESSIONCFG;

//Encoding Parameters (Sub Strut)  (extended)  Add I Frame interval
typedef struct
{
    BYTE byStreamType;         //Stream type 0- video,  1- video&audio,
    BYTE byResolution;          //Resolution 0- DCIF 1- CIF,  2- QCIF,  3- 4CIF,  4- 2CIF,  5- 2QCIF (352X144)  (for Mobile DVR)
    BYTE byBitrateType;         //Bit rate type 0: VBR, 1: CBR
    BYTE  byPicQuality;         //Image Quality 0- best 1- much better 2- better 3- Normal 4- worse 5- worst
    DWORD dwVideoBitrate;      //video bit rate 0- reserved 1- 16K (reserved)  2- 32K 3- 48k 4- 64K 5- 80K 6- 96K 7- 128K 8- 160k 9- 192K 10- 224K 11- 256K 12- 320K
    // 13- 384K 14- 448K 15- 512K 16- 640K 17- 768K 18- 896K 19- 1024K 20- 1280K 21- 1536K 22- 1792K 23- 2048K
    //if The highest bit (31 bit)  is 1,  it stands for user defined bit rate,  0- 30 is the value of bit rate (MIN- 32K MAX- 8192K)
    DWORD dwVideoFrameRate;     //Frame rate 0- full;  1- 1/16;  2- 1/8;  3- 1/4;  4- 1/2;  5- 1;  6- 2;  7- 4;  8- 6;  9- 8;  10- 10;  11- 12;  12- 16;  13- 20, 14- 15,  15- 18,  16- 22;
    WORD  wIntervalFrameI;   //I Frame interval
    //2006- 08- 11 Add single P frame
    BYTE  byIntervalBPFrame; //0- BBP frame;  1- BP frame;  2- P frame only.
    BYTE  byRes;
}NET_DVR_COMPRESSION_INFO_EX,  *LPNET_DVR_COMPRESSION_INFO_EX;

//Encoding Parameters  (extended)
typedef struct
{
    DWORD dwSize;
    NET_DVR_COMPRESSION_INFO_EX struRecordPara;  //Record
    NET_DVR_COMPRESSION_INFO_EX struNetPara;     //Network Transfer
}NET_DVR_COMPRESSIONCFG_EX,  *LPNET_DVR_COMPRESSIONCFG_EX;


//Parameters Configure of Recording in Time segment  (Sub Strut)
typedef struct
{
    NET_DVR_SCHEDTIME struRecordTime;
    BYTE byRecordType;     //0: Time Record, 1: Motion detection, 2: Alarm record, 3: Motion|alarm, 4: Motion&Alarm,  5: Triggered by Commands,  6:  Intelligent Record,10-PIR,11-wireless,12-callhelp,13-all,14-Intelligent Transportation\A3\AC15-NULL\A3\AC16-Field dection\A3\AC17-audio Exception
    char reservedData[3];
}NET_DVR_RECORDSCHED,  *LPNET_DVR_RECORDSCHED;

//Record All- day
typedef struct
{
    WORD wAllDayRecord;                 /* Enable record all- day or not; 0- disable, 1- enable*/
    BYTE byRecordType;                 //0: Time Record, 1: Motion detection, 2: Alarm record, 3: Motion|alarm, 4: Motion&Alarm,  5: Triggered by Commands,  6:  Intelligent Record,10-PIR,11-wireless,12-callhelp,13-motion|alarm|PIR|wireless|callhelp,14-Intelligent Transportation\A3\AC 20-face detection
    char reservedData;
}NET_DVR_RECORDDAY,  *LPNET_DVR_RECORDDAY;

//Recording Parameters  (9000 extended)
typedef struct
{
    DWORD    dwSize;
    DWORD    dwRecord;                           /*Record or not 0- not 1- Record*/
    NET_DVR_RECORDDAY    struRecAllDay[MAX_DAYS];
    NET_DVR_RECORDSCHED    struRecordSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    DWORD    dwRecordTime;                     /* post record time  0- 5Seconds,  1- 10Seconds,  2- 30Seconds,  3- 1 Minutes,  4- 2Minutes, ,  5- 5Minutes, ,  6- 10Minutes, */
    DWORD    dwPreRecordTime;                 /* Pre- record time 0- disable 1- 5Seconds 2- 10Seconds 3- 15Seconds 4- 20Seconds 5- 25Seconds 6- 30Seconds 7- 0xffffffff */
    DWORD    dwRecorderDuration;                 /*  */
    BYTE    byRedundancyRec;                  /*Redundancy record to backup important data: 0/1*/
    BYTE    byAudioRec;                         /*Record audio or not*/
    BYTE    byStreamType;                    /* 0-main stream\A3\AC1-sub stream\A3\AC2-main&sub 3-stream3*/
    BYTE    byPassbackRecord;
    WORD    wLockDuration;
    BYTE    byRecordBackup;
    BYTE     bySVCLevel;    //SVC frame type\A3\BA0-no frame\A3\AC1-half frame 2-three fourths frame
    BYTE    byRecordManage;   //record manage 0-enable, 1-disable
    BYTE    byExtraSaveAudio;
    BYTE   byIntelligentRecord; //open smart record 0-no 1-yes
    BYTE    byReserve;
}NET_DVR_RECORD_V30,  *LPNET_DVR_RECORD_V30;


//Parameters Configure of Recording in Time segment  (Sub Strut)
typedef struct
{
    NET_DVR_SCHEDTIME  struRecordTime;
    //0: Time Record, 1: Motion detection, 2: Alarm record, 3: Motion|alarm, 4: Motion&Alarm,  5: Triggered by Commands,
    //6: Intelligent Record,10: PIR, 11: wireless,12: callhelp, 13: Event all,
    //14: Intelligent Transportation, 15: NULL, 16: Field dection, 17: audio Exception
    //18: Sence Exception Detection,
    //19: Smart Detection(Traverse Plane Dection|Field Dection|audio Exception Dection|Sence Exception Detection|Face detection),
    //20: face detection
    BYTE byRecordType;
    BYTE byRes[31];
}NET_DVR_RECORDSCHED_V40, *LPNET_DVR_RECORDSCHED_V40;

//Record All- day
typedef struct
{
    BYTE byAllDayRecord;/* Enable record all- day or not; 0- disable, 1- enable*/
    //0: Time Record, 1: Motion detection, 2: Alarm record, 3: Motion|alarm, 4: Motion&Alarm,  5: Triggered by Commands,
    //6: Intelligent Record,10: PIR, 11: wireless,12: callhelp, 13: Event all,
    //14: Intelligent Transportation, 15: NULL, 16: Field dection, 17: audio Exception
    //18: Sence Exception Detection,
    //19: Smart Detection(Traverse Plane Dection|Field Dection|audio Exception Dection|Sence Exception Detection|Face detection),
    //20: face detection
    BYTE byRecordType;
    BYTE byRes[62];
}NET_DVR_RECORDDAY_V40, *LPNET_DVR_RECORDDAY_V40;

typedef struct
{
    DWORD    dwSize;
    DWORD    dwRecord;                           /*Record or not 0- not 1- Record*/
    NET_DVR_RECORDDAY_V40    struRecAllDay[MAX_DAYS];
    NET_DVR_RECORDSCHED_V40    struRecordSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    DWORD    dwRecordTime;                     /* post record time  0- 5Seconds,  1- 10Seconds,  2- 30Seconds,  3- 1 Minutes,  4- 2Minutes, ,  5- 5Minutes, ,  6- 10Minutes, */
    DWORD    dwPreRecordTime;                 /* Pre- record time 0- disable 1- 5Seconds 2- 10Seconds 3- 15Seconds 4- 20Seconds 5- 25Seconds 6- 30Seconds 7- 0xffffffff */
    DWORD    dwRecorderDuration;                 /*  */
    BYTE    byRedundancyRec;                  /*Redundancy record to backup important data: 0/1*/
    BYTE    byAudioRec;                         /*Record audio or not*/
    BYTE    byStreamType;                    /* 0-main stream\A3\AC1-sub stream\A3\AC2-main&sub\A3\AC3-stream3*/
    BYTE    byPassbackRecord;
    WORD    wLockDuration;
    BYTE    byRecordBackup;
    BYTE     bySVCLevel;    //SVC frame type\A3\BA0-no frame\A3\AC1-half frame 2-three fourths frame
    BYTE    byRecordManage;
    BYTE    byExtraSaveAudio;
    BYTE   byIntelligentRecord; //open smart record 0-no 1-yes
    BYTE    byRes[125];
}NET_DVR_RECORD_V40,  *LPNET_DVR_RECORD_V40;

//Recording Parameters
typedef struct
{
    DWORD dwSize;
    DWORD dwRecord;       /*Record or not 0- not 1- Record*/
    NET_DVR_RECORDDAY struRecAllDay[MAX_DAYS];
    NET_DVR_RECORDSCHED struRecordSched[MAX_DAYS][MAX_TIMESEGMENT];
    DWORD dwRecordTime;         /* Pre- record time*/
    DWORD dwPreRecordTime;     /* Pre- record time 0- disable 1- 5Seconds 2- 10Seconds 3- 15Seconds 4- 20Seconds 5- 25Seconds 6- 30Seconds 7- 0xffffffff  (A.F.A.P) */
}NET_DVR_RECORD,  *LPNET_DVR_RECORD;

//PTZ protocol structure configuration
typedef struct
{
    DWORD dwType;                /*Type value of decoder,  increase from 1 by degrees*/
    BYTE  byDescribe[DESC_LEN];  /*Description of decoder,  same with 8000*/
}NET_DVR_PTZ_PROTOCOL;

typedef struct
{
    DWORD   dwSize;
    NET_DVR_PTZ_PROTOCOL struPtz[PTZ_PROTOCOL_NUM]; /*200 PTZ protocols in total*/
    DWORD   dwPtzNum;            /*Number of valid PTZ protocol, Start from 0*/
    BYTE    byRes[8];
}NET_DVR_PTZCFG,  *LPNET_DVR_PTZCFG;

typedef struct tagNET_DVR_SERIALSTART_V40
{
    DWORD  dwSize;
    DWORD  dwSerialType;
    BYTE   bySerialNum;
    BYTE   byRes[255];
}NET_DVR_SERIALSTART_V40,*LPNET_DVR_SERIALSTART_V40;


typedef struct tagNET_DVR_DECODERCFG_V40
{
    DWORD    dwSize;
    DWORD     dwBaudRate;
    BYTE     byDataBit;
    BYTE     byStopBit;
    BYTE     byParity;
    BYTE     byFlowcontrol;
    WORD     wDecoderType;
    WORD     wDecoderAddress;
    BYTE     bySetPreset [MAX_PRESET_V30];
    BYTE     bySetCruise[MAX_CRUISE_V30];
    BYTE     bySetTrack [MAX_TRACK_V30];
    BYTE     bySerialNO;
    BYTE     byWorkMode;
    BYTE     byRes[254];
}NET_DVR_DECODERCFG_V40,*LPNET_DVR_DECODERCFG_V40;

#define IPC_PROTOCOL_NUM      50   //max number of IP camera protocol

//PTZ protocol structure configuration
typedef struct tagNET_DVR_PROTO_TYPE
{
    DWORD dwType;                /*Type value of IP camera protocol,  increase from 0 by degrees*/
    BYTE  byDescribe[DESC_LEN];  /*Description of IP camera protocol,  same with 8000*/
}NET_DVR_PROTO_TYPE , *LPNET_DVR_PROTO_TYPE;

typedef struct
{
    DWORD   dwSize;
    DWORD   dwProtoNum;            /*Number of valid PTZ protocol, Start from 0*/
    NET_DVR_PROTO_TYPE struProto[IPC_PROTOCOL_NUM]; /*200 PTZ protocols in total*/
    BYTE    byRes[8];
}NET_DVR_IPC_PROTO_LIST,  *LPNET_DVR_IPC_PROTO_LIST;

//PTZ protocol V41
typedef struct tagNET_DVR_IPC_PROTO_LIST_V41
{
    DWORD   dwSize;
    DWORD   dwProtoNum;  /*Number of valid PTZ protocol, Start from 0*/
    BYTE    *pBuffer;    //protocol buffer , there are dwProtoNum INTER_PROTO_TYPE structure
    DWORD   dwBufferLen; //bufffer length
    BYTE    byRes[32];
}NET_DVR_IPC_PROTO_LIST_V41, *LPNET_DVR_IPC_PROTO_LIST_V41;

/***************************PTZ Protocol (end) ******************************/

//PTZ configuration  (9000 extended)
typedef struct
{
    DWORD dwSize;
    DWORD dwBaudRate;   //Baud rate (bps) , 0- 50, 1- 75, 2- 110, 3- 150, 4- 300, 5- 600, 6- 1200, 7- 2400, 8- 4800, 9- 9600, 10- 19200,  11- 38400, 12- 57600, 13- 76800, 14- 115.2k;
    BYTE byDataBit;     //Data bit 0- 5Seconds, 1- 6bit, 2- 7bit, 3- 8bit;
    BYTE byStopBit;     //Stop bit 0- 1bit, 1- 2bit;
    BYTE byParity;      //Parity 0- No parity, 1- odd, 2- even;
    BYTE byFlowcontrol; //Flow control:  0- None, 1- software , 2- Hardware
    WORD wDecoderType;  //Decoder Type,  corresponding to PTZ list
    WORD wDecoderAddress;               //Decoder address: 0 -  255
    BYTE bySetPreset[MAX_PRESET_V30]; //Configure Preset or not, 0- No, 1- Yes
    BYTE bySetCruise[MAX_CRUISE_V30]; //Configure Cruise or not:  0- No, 1- Yes
    BYTE bySetTrack[MAX_TRACK_V30];   //Configure Track or not, 0- No, 1- Yes
}NET_DVR_DECODERCFG_V30,  *LPNET_DVR_DECODERCFG_V30;

//PTZ decoder configuration
typedef struct
{
    DWORD dwSize;
    DWORD dwBaudRate;   //Baud rate (bps) , 0- 50, 1- 75, 2- 110, 3- 150, 4- 300, 5- 600, 6- 1200, 7- 2400, 8- 4800, 9- 9600, 10- 19200,  11- 38400, 12- 57600, 13- 76800, 14- 115.2k;
    BYTE byDataBit;     //Data bit 0- 5bit, 1- 6bit, 2- 7bit, 3- 8bit;
    BYTE byStopBit;     //Stop bit 0- 1bit, 1- 2bit;
    BYTE byParity;      //Parity 0- No parity, 1- odd, 2- even;
    BYTE byFlowcontrol; //Flow control:  0- None, 1- software , 2- Hardware

    WORD wDecoderType;       //Decoder Type,  0- YouLi, 1- LiLin- 1016, 2- LiLin- 820, 3- Pelco- p, 4- DM DynaColor, 5- HD600, 6- JC- 4116, 7- Pelco- d WX, 8- Pelco- d PICO
    WORD wDecoderAddress;      //Decoder Address: 0 -  255
    BYTE bySetPreset[MAX_PRESET];         //Configure Preset or not, 0- No, 1- Yes
    BYTE bySetCruise[MAX_CRUISE];         //Configure Cruise or not:  0- No, 1- Yes
    BYTE bySetTrack[MAX_TRACK];         //Configure Track or not, 0- No, 1- Yes
}NET_DVR_DECODERCFG,  *LPNET_DVR_DECODERCFG;

//ppp parameters configuration (Sub Struct)
typedef struct
{
    NET_DVR_IPADDR struRemoteIP;     //Remote IP
    NET_DVR_IPADDR struLocalIP;     //Local IP
    char sLocalIPMask[16];             //Local Mask
    BYTE sUsername[NAME_LEN];         //Username
    BYTE sPassword[PASSWD_LEN];     //Password
    BYTE byPPPMode;                 //PPP mode,  0- active, 1- passive
    BYTE byRedial;                     //Callback or not : 0- No, 1- Yes
    BYTE byRedialMode;                 //Callback, 0- user specified, 1- preseted number
    BYTE byDataEncrypt;             //Encrypt Data , 0- No, 1- Yes
    DWORD dwMTU;                     //MTU
    char sTelephoneNumber[PHONENUMBER_LEN];    //Telephone number
}NET_DVR_PPPCFG_V30,  *LPNET_DVR_PPPCFG_V30;

//ppp parameters configuration (Sub Struct)
typedef struct
{
    char sRemoteIP[16];             //Remote IP
    char sLocalIP[16];                 //Local IP
    char sLocalIPMask[16];             //Local Mask
    BYTE sUsername[NAME_LEN];         //Username
    BYTE sPassword[PASSWD_LEN];     //Password
    BYTE byPPPMode;                 //PPP mode,  0- active, 1- passive
    BYTE byRedial;                     //Callback or not : 0- No, 1- Yes
    BYTE byRedialMode;                 //Callback, 0- user specified, 1- preset number
    BYTE byDataEncrypt;             //Encrypt Data , 0- No, 1- Yes
    DWORD dwMTU;                     //MTU
    char sTelephoneNumber[PHONENUMBER_LEN];    //Telephone number
}NET_DVR_PPPCFG,  *LPNET_DVR_PPPCFG;

//RS232 Configuration (9000 extended)
typedef struct
{
    DWORD dwBaudRate; //Baud rate (bps) , 0- 50, 1- 75, 2- 110, 3- 150, 4- 300, 5- 600, 6- 1200, 7- 2400, 8- 4800, 9- 9600, 10- 19200,  11- 38400, 12- 57600, 13- 76800, 14- 115.2k;
    BYTE byDataBit;   //Data bit 0- 5bit, 1- 6bit, 2- 7bit, 3- 8bit;
    BYTE byStopBit;   //Stop bit 0- 1bit, 1- 2bit;
    BYTE byParity;    //Parity 0- No parity, 1- odd, 2- even;
    BYTE byFlowcontrol; //Flow control:  0- None, 1- software , 2- Hardware
    DWORD dwWorkMode;   //Word mode, 0- 232 for PPP dial, 1- 232 for parameter control, 2- for transparent channel 3- ptz mode 4-Alarm mode 5-Matrix control,
    //6-Screen control, 7-Direct connect, 8-Keyboard control 9-Monitor control 10-PTZ control

}NET_DVR_SINGLE_RS232;

typedef struct tagNET_DVR_USB_RS232
{
    DWORD dwBaudRate; //Baud rate (bps) , 0- 50, 1- 75, 2- 110, 3- 150, 4- 300, 5- 600, 6- 1200, 7- 2400, 8- 4800, 9- 9600, 10- 19200,  11- 38400, 12- 57600, 13- 76800, 14- 115.2k;
    BYTE byDataBit;   //Data bit 0- 5bit, 1- 6bit, 2- 7bit, 3- 8bit;
    BYTE byStopBit;   //Stop bit 0- 1bit, 1- 2bit;
    BYTE byParity;    //Parity 0- No parity, 1- odd, 2- even;
    BYTE byFlowcontrol; //Flow control:  0- None, 1- software , 2- Hardware
    BYTE byVirtualSerialPort;  // Virtual Serial Port
    BYTE byRes[3];
}NET_DVR_USB_RS232,*LPNET_DVR_USB_RS232;

//RS232 Configuration (9000 extended)
typedef struct
{
    DWORD dwSize;
    NET_DVR_SINGLE_RS232 struRs232[MAX_SERIAL_PORT];/*note: this structure has change*/
    NET_DVR_PPPCFG_V30 struPPPConfig;
}NET_DVR_RS232CFG_V30,  *LPNET_DVR_RS232CFG_V30;

//RS232 Configuration
typedef struct
{
    DWORD dwSize;
    DWORD dwBaudRate; //Baud rate (bps) , 0- 50, 1- 75, 2- 110, 3- 150, 4- 300, 5- 600, 6- 1200, 7- 2400, 8- 4800, 9- 9600, 10- 19200,  11- 38400, 12- 57600, 13- 76800, 14- 115.2k;
    BYTE byDataBit;   //Data bit 0- 5bit, 1- 6bit, 2- 7bit, 3- 8bit;
    BYTE byStopBit;   //Stop bit 0- 1bit, 1- 2bit;
    BYTE byParity;    //Parity 0- No parity, 1- odd, 2- even;
    BYTE byFlowcontrol; //Flow control:  0- None, 1- software , 2- Hardware
    DWORD dwWorkMode;   //Word mode, 0- 232 for PPP dial, 1- 232 for parameter control, 2- for transparent channel
    NET_DVR_PPPCFG struPPPConfig;
}NET_DVR_RS232CFG,  *LPNET_DVR_RS232CFG;


typedef struct
{
    DWORD dwEnablePresetChan;
    DWORD dwPresetPointNo;
}NET_DVR_PRESETCHAN_INFO, LPNET_DVR_PRESETCHAN_INFO;

typedef struct
{
    DWORD dwEnableCruiseChan;
    DWORD dwCruiseNo;
}NET_DVR_CRUISECHAN_INFO, LPNET_DVR_CRUISECHAN_INFO;

typedef struct
{
    DWORD dwEnablePtzTrackChan;
    DWORD dwPtzTrackNo;
}NET_DVR_PTZTRACKCHAN_INFO, LPNET_DVR_PTZTRACKCHAN_INFO;

typedef struct tagNET_DVR_PTZ_NOTIFICATION_COND
{
    DWORD   dwSize;
    /*
    0-facedetection,
    1-vehicleDetection,
    2-scenechangedetection,
    3-LineDetection,
    4-regionEntrance,
    5-regionExiting,
    6-loitering,
    7-group,
    8-rapidMove,
    9-parking,
    10-unattendedBaggage,
    11-attendedBaggage,
    12-audioDetection,
    13-PIR,
    14-defocusDetection
    15-temperature,
    16-fireDetection,
    17-thermometry,
    18-shipsDetection
    */
    WORD    byEventType;
    BYTE    byRes[2];
    DWORD   dwChannel;
    BYTE    byRes1[128];
}NET_DVR_PTZ_NOTIFICATION_COND, *LPNET_DVR_PTZ_NOTIFICATION_COND;

typedef struct tagNET_DVR_PTZ_NOTIFICATION_CFG
{
    DWORD   dwSize;
    DWORD   dwEnablePresetChanNum;  //The number of points currently enabled preset
    NET_DVR_PRESETCHAN_INFO struPresetChanInfo[MAX_CHANNUM_V40]; //Enable the preset point information (PTZ) associated linkage type
    DWORD   dwEnableCruiseChanNum;  //The current enabled channel number of the cruise
    NET_DVR_CRUISECHAN_INFO struCruiseChanInfo[MAX_CHANNUM_V40]; //Enable the cruise function channel information (PTZ) associated linkage type
    DWORD   dwEnablePtzTrackChanNum;  //The current enabled holder channel number of the track
    NET_DVR_PTZTRACKCHAN_INFO struPtzTrackInfo[MAX_CHANNUM_V40]; //Call holder track channel information (PTZ) associated linkage type
    BYTE  	byRes1[1024];
}NET_DVR_PTZ_NOTIFICATION_CFG, *LPNET_DVR_PTZ_NOTIFICATION_CFG;


typedef struct tagNET_DVR_PTZ_NOTIFICATION
{
    DWORD   dwSize;
    /*
    0-facedetection,
    1-vehicleDetection,
    2-scenechangedetection,
    3-LineDetection,
    4-regionEntrance,
    5-regionExiting,
    6-loitering,
    7-group,
    8-rapidMove,
    9-parking,
    10-unattendedBaggage,
    11-attendedBaggage,
    12-audioDetection,
    13-PIR,
    14-defocusDetection\A3\AC
    15-temperature,
    16-fireDetection,
    17-thermometry,
    18-shipsDetection
    */
    WORD    byEventType;
    BYTE    byRes[62];
    DWORD   dwEnablePresetChanNum;  //The number of points currently enabled preset
    NET_DVR_PRESETCHAN_INFO struPresetChanInfo[MAX_CHANNUM_V40]; //Enable the preset point information (PTZ) associated linkage type
    DWORD   dwEnableCruiseChanNum;  //The current enabled channel number of the cruise
    NET_DVR_CRUISECHAN_INFO struCruiseChanInfo[MAX_CHANNUM_V40]; //Enable the cruise function channel information (PTZ) associated linkage type
    DWORD   dwEnablePtzTrackChanNum;  //The current enabled holder channel number of the track
    NET_DVR_PTZTRACKCHAN_INFO struPtzTrackInfo[MAX_CHANNUM_V40]; //Call holder track channel information (PTZ) associated linkage type
    BYTE  	byRes1[1024];
}NET_DVR_PTZ_NOTIFICATION, *LPNET_DVR_PTZ_NOTIFICATION;

//Alarm Input Configuration
typedef struct tagNET_DVR_ALARMINCFG_V40
{
    DWORD dwSize;
    BYTE sAlarmInName[NAME_LEN];    //Name
    BYTE byAlarmType;                 //Alarm Type, 0: normally open, 1: normally close
    BYTE byAlarmInHandle;             //Handle alarm or not 0- No 1- Yes
    BYTE byChannel;                 //Intelligent recognition channel triggered by alarm input
    BYTE byInputType;                //Input type, 0 - semaphore 1 - switch
    DWORD   dwHandleType;        //The way to handle alarm
    /*0x00:  No response*/
    /*0x01:  Alarm on monitor*/
    /*0x02:  Audio Alarm*/
    /*0x04:  Upload to center*/
    /*0x08:  Trigger alarm output*/
    /*0x10:  Grab JPEG image and EMail it*/
    /*0x20:  wireless voice and light alarm*/
    /*0x40:  Trigger electric map(only PCNVR supports)*/
    /*0x200: capture jpeg and update to FTP*/
    /*0x1000:capture jpeg and update to cloud*/
    DWORD   dwMaxRelAlarmOutChanNum ; //Max RelAlarm Out Chan Num (read Only)
    DWORD   dwRelAlarmOutChanNum;
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40]; //Alarm Out Chan No.
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//alarm Time

    DWORD   dwMaxRecordChanNum;
    DWORD   dwCurRecordChanNum;
    DWORD   dwRelRecordChan[MAX_CHANNUM_V40];
    DWORD   dwMaxEnablePtzCtrlNun;
    DWORD   dwEnablePresetChanNum;  //enable preset Num
    NET_DVR_PRESETCHAN_INFO struPresetChanInfo[MAX_CHANNUM_V40]; //Call preset Info
    BYTE    byRes2[516];
    DWORD   dwEnableCruiseChanNum;  //enable Cruise Num
    NET_DVR_CRUISECHAN_INFO struCruiseChanInfo[MAX_CHANNUM_V40]; //Cruise Info
    DWORD   dwEnablePtzTrackChanNum;  //Track Num
    NET_DVR_PTZTRACKCHAN_INFO struPtzTrackInfo[MAX_CHANNUM_V40]; //Track No
    BYTE    byRes[256];
}NET_DVR_ALARMINCFG_V40, *LPNET_DVR_ALARMINCFG_V40;

//Alarm Input Configuration (9000 extended)
typedef struct
{
    DWORD dwSize;
    BYTE sAlarmInName[NAME_LEN];     //Name
    BYTE byAlarmType;                 //Alarm Type, 0: normally open, 1: normally close
    BYTE byAlarmInHandle;             //Handle alarm or not 0- No 1- Yes
    BYTE byChannel;                 //Intelligent recognition channel triggered by alarm input
    BYTE byInputType;                //Input type, 0 - semaphore 1 - switch
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;     //The way to handle alarm
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; //Guard time
    BYTE byRelRecordChan[MAX_CHANNUM_V30];         //Channel triggered to record,  1- - trigger
    BYTE byEnablePreset[MAX_CHANNUM_V30];         //Call preset or not 0- No, 1- Yes
    BYTE byPresetNo[MAX_CHANNUM_V30];             //Preset No. One alarm input can trigger several presets,  0xff- disable
    BYTE byRes2[192];                             //Reserved
    BYTE byEnableCruise[MAX_CHANNUM_V30];         //Call Cruise or not 0- No, 1- Yes
    BYTE byCruiseNo[MAX_CHANNUM_V30];             //Cruise No.
    BYTE byEnablePtzTrack[MAX_CHANNUM_V30];     //Call Track or not 0- No, 1- Yes
    BYTE byPTZTrack[MAX_CHANNUM_V30];             //Track No.
    BYTE byRes3[16];
}NET_DVR_ALARMINCFG_V30,  *LPNET_DVR_ALARMINCFG_V30;

//Alarm Input Configuration
typedef struct
{
    DWORD dwSize;
    BYTE sAlarmInName[NAME_LEN];     //Name
    BYTE byAlarmType;                 //Alarm Type, 0: normally open, 1: normally close
    BYTE byAlarmInHandle;             //Handle alarm or not 0- No 1- Yes
    BYTE byChannel;                 //Intelligent recognition channel triggered by alarm input
    BYTE byRes;
    NET_DVR_HANDLEEXCEPTION struAlarmHandleType; //The way to handle alarm
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT]; //Guard time
    BYTE byRelRecordChan[MAX_CHANNUM];         //Channel triggered to record,  1- - trigger
    BYTE byEnablePreset[MAX_CHANNUM];         //Call preset or not 0- No, 1- Yes
    BYTE byPresetNo[MAX_CHANNUM];             //Preset No. One alarm input can trigger several presets,  set 0xff to disable
    BYTE byEnableCruise[MAX_CHANNUM];         //Call Cruise or not 0- No, 1- Yes
    BYTE byCruiseNo[MAX_CHANNUM];             //Cruise No.
    BYTE byEnablePtzTrack[MAX_CHANNUM];     //Call Track or not 0- No, 1- Yes
    BYTE byPTZTrack[MAX_CHANNUM];             //Track No.
}NET_DVR_ALARMINCFG,  *LPNET_DVR_ALARMINCFG;

typedef struct tagNET_DVR_MB_AUTOWORKPARA
{

    BYTE    byCurPowerCtrlType;   /*parent start control type 0:  reserved,  1:  delay shutdown,  2:  auto start and shutdown*/
    BYTE    byRes[3];
    NET_DVR_SCHEDTIME    struWorkTime[MAX_DAYS][2];
}NET_DVR_MB_AUTOWORKPARA, *LPNET_DVR_MB_AUTOWORKPARA;

//analogy input Configuration
typedef struct tagNet_DVR_ANALOG_ALARMINCFG
{
    DWORD     dwSize;
    BYTE        byEnableAlarmHandle; //Handle alarm or not 0- No 1- Yes
    BYTE        byRes1[3];
    BYTE        byAlarmInName[NAME_LEN]; //Name
    WORD        wAlarmInUpper; //The analog input voltage under limit\A3\ACThe actual value*10\A3\AC[0~360]
    WORD        wAlarmInLower; //The analog input voltage upper limit\A3\ACThe actual value*10\A3\AC[0~360]
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;    //The way to handle alarm
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//Guard time
    BYTE        byRelRecordChan[MAX_CHANNUM_V30]; //Channel triggered to record
    BYTE        byRes2[100];
}NET_DVR_ANALOG_ALARMINCFG, *LPNET_DVR_ANALOG_ALARMINCFG;


typedef struct tagNET_DVR_ALARMINFO_FIXED_HEADER
{
    DWORD dwAlarmType;              /*0- sensor alarm; 1- hard disk full; 2- video lost; 3- motion detection; 4- hard disk unformatted; 5- hard disk error; 6- tampering detection; 7- unmatched video output standard; 8- illegal operation; 9- video exception; 0xa- record exception
                        11- Vca scene change 12-Array exception 13 resolution dismatch,14-alloc decode resource fail,15-VCA detect, 20-record on,21-record off,22-vehicle detection exception, 23-switch alarm*/
    NET_DVR_TIME_EX struAlarmTime;    //alarm Time
    union
    {
        BYTE    byUnionLen[128];
        struct
        {
            DWORD    dwAlarmInputNo;
            DWORD    dwTrigerAlarmOutNum;
            DWORD    dwTrigerRecordChanNum;
        }struIOAlarm;    // sensor alarm
        struct
        {
            DWORD    dwAlarmChanNum;
        }struAlarmChannel;    // dwAlarmType is 2,3,6,9,10 or13 Effective
        struct
        {
            DWORD    dwAlarmHardDiskNum;    /*it stands for Hard Disk,  dwDiskNumber*/
        }struAlarmHardDisk;/*When dwAlarmType is 1, 4 or 5,  it stands for Hard Disk,  dwDiskNumber[0] is the first disk*/
        struct
        {
            BYTE       bySubAlarmType;  //alarm type\A3\AC1-delay record\A3\BB
            BYTE       byRes1[3]; //res
            NET_DVR_TIME_EX  struRecordEndTime; //record end
            BYTE    byRes[116]; //res
        }struRecordingHost;  //record host alarm
    }uStruAlarm;
}NET_DVR_ALRAM_FIXED_HEADER, *LPNET_DVR_ALARM_FIXED_HEADER;

//Upload Alarm Information(256 NVR extended)
typedef struct NET_DVR_ALARMINFO_V40
{
    NET_DVR_ALRAM_FIXED_HEADER     struAlarmFixedHeader;
    DWORD*                        pAlarmData;
}NET_DVR_ALARMINFO_V40, *LPNET_DVR_ALARMINFO_V40;

//Upload Alarm Information  (9000 extended)
typedef struct
{
    DWORD dwAlarmType; /*0- sensor alarm; 1- hard disk full; 2- video lost; 3- motion detection; 4- hard disk unformatted; 5- hard disk error; 6- tampering detection; 7- unmatched video output standard; 8- illegal operation; 9- video exception; 0xa- record exception
                       11- Vca scene change 12-Array exception 13 resolution dismatch,14-alloc decode resource fail,15-VCA detect\A3\AC 16-POE power supply abnormal alarm,17-Flash anomaly ,18-Disk full load anomaly,19-audio input lost, 20-record on, 21-record off,22-vehicle detection exception, 23-switch alarm*/
    DWORD dwAlarmInputNumber; /*Alarm input Port*/
    BYTE byAlarmOutputNumber[MAX_ALARMOUT_V30]; /*State of Alarm output channel, 1- - Triggered*/
    BYTE byAlarmRelateChannel[MAX_CHANNUM_V30]; /*channels triggered to record, 1- recording,  dwAlarmRelateChannel[0] is the first channel*/
    BYTE byChannel[MAX_CHANNUM_V30]; /*If the dwAlarmType is 2, 3 , 6,14 or 19 it stands for channel, dwChannel[0] is the first channel*/
    BYTE byDiskNumber[MAX_DISKNUM_V30]; /*When dwAlarmType is 1, 4 or 5,  it stands for Hard Disk,  dwDiskNumber[0] is the first disk*/
}NET_DVR_ALARMINFO_V30,  *LPNET_DVR_ALARMINFO_V30;

typedef struct tagNET_DVR_ALARM_HOT_SPARE
{
    DWORD  dwSize;
    DWORD  dwExceptionCase;   //alarm reason   0-net exception
    NET_DVR_IPADDR  struDeviceIP;    //Device IP
    BYTE    byRes[256];
}NET_DVR_ALARM_HOT_SPARE, *LPNET_DVR_ALARM_HOT_SPARE;

typedef struct
{
    DWORD dwAlarmType; /*0- sensor alarm; 1- hard disk full; 2- video lost; 3- motion detection; 4- hard disk unformatted; 5- hard disk error; 6- tampering detection; 7- unmatched video output standard; 8- illegal operation; 9- video exception; 0xa- record exception*/
    DWORD dwAlarmInputNumber; /*/*Alarm input Port*/
    DWORD dwAlarmOutputNumber[MAX_ALARMOUT]; /*State of Alarm output channel, 1- - Triggered*/
    DWORD dwAlarmRelateChannel[MAX_CHANNUM]; /*channels triggered to record, 1- recording,  dwAlarmRelateChannel[0] is the first channel*/
    DWORD dwChannel[MAX_CHANNUM]; /*If the dwAlarmType is 2, 3 or 6, it stands for channel, dwChannel[0] is the first channel*/
    DWORD dwDiskNumber[MAX_DISKNUM]; /*When dwAlarmType is 1, 4 or 5,  it stands for Hard Disk,  dwDiskNumber[0] is the first disk*/
}NET_DVR_ALARMINFO,  *LPNET_DVR_ALARMINFO;

//////////////////////////////////////////////////////////////////////////////////////
//IP Camera Parameter
/* IP Device */
//extended ipc connection functions,  support add IPC domain name

#define  DEV_ID_LEN           32
typedef struct tagNET_DVR_IPDEVINFO_V31
{
    BYTE byEnable;                     //Valid status for IP device
    BYTE byProType;                 //Protocol type,  0- private (default) ,  1-  Panasonic,  2-  SONY
    BYTE byEnableQuickAdd;          //0-  does not support quick adding of IP device;  1-   enable quick adding of IP device
    //Quick add of device IP and protocol,  fill in the other parameters as system default
    BYTE byRes1;                     //reserved as 0
    BYTE sUserName[NAME_LEN];         //user name
    BYTE sPassword[PASSWD_LEN];     //Password
    BYTE byDomain[MAX_DOMAIN_NAME]; //Domain name of the device
    NET_DVR_IPADDR struIP;             //IP
    WORD wDVRPort;                      //Port number
    BYTE  szDeviceID[DEV_ID_LEN];  //Device ID
    BYTE byRes2[2];                 //Reserved as 0
}NET_DVR_IPDEVINFO_V31,  *LPNET_DVR_IPDEVINFO_V31;

typedef struct
{
    DWORD dwEnable;                 /* Enable this device */
    BYTE sUserName[NAME_LEN];         /* Username */
    BYTE sPassword[PASSWD_LEN];     /* Password */
    NET_DVR_IPADDR struIP;             /* IP address */
    WORD wDVRPort;                      /* Port */
    BYTE byRes[34];                 /* Reserved */
}NET_DVR_IPDEVINFO,  *LPNET_DVR_IPDEVINFO;

/* IP Channel parameters */
typedef struct
{
    BYTE byEnable;                     //0- Failed to connect IP device; 1- Successfully;
    BYTE byIPID;                     //ID of IP device,  low 8 bit
    BYTE byChannel;                 //Channel No.
    BYTE byIPIDHigh;                //ID of IP device,  high 8 bit
    BYTE byTransProtocol;            //Trans Protocol Type 0-TCP/auto (Determined by the device)\A3\AC1-UDP 2-Multicast 3-only TCP 4-auto
    BYTE byres[31];                    /* Reserved */
} NET_DVR_IPCHANINFO,  *LPNET_DVR_IPCHANINFO;

/* Struct of connecting IP device*/
typedef struct
{
    DWORD dwSize;                                          /* Structure Size */
    NET_DVR_IPDEVINFO  struIPDevInfo[MAX_IP_DEVICE];     /* IP Device */
    BYTE byAnalogChanEnable[MAX_ANALOG_CHANNUM];         /* Enable analog channel or not, channel 1 (low bit)  to channel 32 (high bit) , 0- invalid;  1- valid */
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_IP_CHANNEL];   /* IP Channel */
}NET_DVR_IPPARACFG,  *LPNET_DVR_IPPARACFG;

typedef struct tagNET_DVR_IPPARACFG_V31
{
    DWORD dwSize;                                          /* Structure size */
    NET_DVR_IPDEVINFO_V31  struIPDevInfo[MAX_IP_DEVICE]; /* IP device */
    BYTE byAnalogChanEnable[MAX_ANALOG_CHANNUM];         /* Enable/disable analog channels,  stands for channel 1- 32 ,  0- disable;  1- enable */
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_IP_CHANNEL];      /* IP channel*/
}NET_DVR_IPPARACFG_V31,  *LPNET_DVR_IPPARACFG_V31;

typedef  struct tagNET_DVR_IPSERVER_STREAM
{
    BYTE    byEnable;   //Is enable
    BYTE    byRes[3];
    NET_DVR_IPADDR struIPServer;   //IPServer Address
    WORD  wPort;                   //IPServer port
    WORD  wDvrNameLen;             //DVR Name Length
    BYTE   byDVRName[NAME_LEN];    //DVR Name
    WORD  wDVRSerialLen;           //Serial Length
    WORD  byRes1[2];               //reserved
    BYTE   byDVRSerialNumber[SERIALNO_LEN];    //DVR Serial
    BYTE   byUserName[NAME_LEN];               //DVR User name
    BYTE   byPassWord[PASSWD_LEN];             //DVR User password
    BYTE    byChannel;                         //DVR channel
    BYTE   byRes2[11];              //Reserved
}NET_DVR_IPSERVER_STREAM, *LPNET_DVR_IPSERVER_STREAM;

/*the configuration of stream server*/
typedef struct tagNET_DVR_STREAM_MEDIA_SERVER_CFG
{
    BYTE    byValid;            //Is enable
    BYTE    byRes1[3];
    NET_DVR_IPADDR  struDevIP;  //stream server IP
    WORD    wDevPort;            //stream server Port
    BYTE    byTransmitType;        //Protocol: 0-TCP, 1-UDP
    BYTE    byRes2[69];
}NET_DVR_STREAM_MEDIA_SERVER_CFG,*LPNET_DVR_STREAM_MEDIA_SERVER_CFG;

//device information
typedef struct tagNET_DVR_DEV_CHAN_INFO
{
    NET_DVR_IPADDR     struIP;            //DVR IP address
    WORD     wDVRPort;                 //DVR PORT
    BYTE     byChannel;                //Channel
    BYTE    byTransProtocol;        //Transmit protocol:0-TCP\A3\AC1-UDP
    BYTE    byTransMode;            //Stream mode: 0\A3\ADmian stream 1\A3\ADsub stream
    BYTE    byFactoryType;            /*IPC factory type*/
    BYTE    byDeviceType; //Device type(Used by videoplatfom VCA card)\A3\AC1-decoder\A3\A8use decode channel No. or display channel depends on byVcaSupportChanMode in videoplatform ability struct\A3\A9\A3\AC2-coder
    BYTE    byDispChan;//Display channel No. used by VCA configuration
    BYTE    bySubDispChan;//Display sub channel No. used by VCA configuration
    BYTE    byResolution;    //Resolution: 1-CIF 2-4CIF 3-720P 4-1080P 5-500w used by big screen controler
    BYTE    byRes[2];
    BYTE    byDomain[MAX_DOMAIN_NAME];    //Device domain name
    BYTE    sUserName[NAME_LEN];    //Remote device user name
    BYTE    sPassword[PASSWD_LEN];    //Remote device password
}NET_DVR_DEV_CHAN_INFO,*LPNET_DVR_DEV_CHAN_INFO;

typedef struct tagNET_DVR_PU_STREAM_CFG
{
    DWORD                                dwSize;
    NET_DVR_STREAM_MEDIA_SERVER_CFG    struStreamMediaSvrCfg;
    NET_DVR_DEV_CHAN_INFO                struDevChanInfo;
}NET_DVR_PU_STREAM_CFG,*LPNET_DVR_PU_STREAM_CFG;

typedef struct tagNET_DVR_DDNS_STREAM_CFG
{
    BYTE   byEnable;   //Is Enable.
    BYTE   byRes1[3];
    NET_DVR_IPADDR  struStreamServer;   //Stream server IP
    WORD   wStreamServerPort;           //Stream server Port
    BYTE   byStreamServerTransmitType;  //Stream protocol
    BYTE   byRes2;
    NET_DVR_IPADDR   struIPServer;      //IPserver IP
    WORD   wIPServerPort;               //IPserver Port
    BYTE   byRes3[2];
    BYTE   sDVRName[NAME_LEN];     //DVR Name
    WORD   wDVRNameLen;            //DVR Name Len
    WORD   wDVRSerialLen;          //Serial Len
    BYTE   sDVRSerialNumber[SERIALNO_LEN];    //Serial number
    BYTE   sUserName[NAME_LEN];   //the user name which is used to login DVR.
    BYTE   sPassWord[PASSWD_LEN]; //the password which is used to login DVR.
    WORD   wDVRPort;        //DVR port
    BYTE   byRes4[2];
    BYTE   byChannel;       //channel
    BYTE   byTransProtocol; //protocol
    BYTE   byTransMode;     //transform mode
    BYTE   byFactoryType;   //The type of factory who product the device.
}NET_DVR_DDNS_STREAM_CFG, *LPNET_DVR_DDNS_STREAM_CFG;

#define MAX_LICENSE_LEN_EX                    32        //Max. length of the license number
typedef	struct
{
    DWORD	dwSize;
    NET_DVR_TIME_EX    strStartTime;  //start time
    NET_DVR_TIME_EX    strStopTime;  //end time
    char     sLicense[MAX_LICENSE_LEN_EX/*32*/];    //vechial number
    // area index 0-res\A3\AC1-(Europe Region)\A3\AC2-(Russian Region)\A3\AC3-(EU&CIS) ,0xff-all
    DWORD	  dwChannel;
    BYTE      byRegion;
    BYTE	  byRes[127];
}NET_DVR_VEHICLE_INFO_COND, *LPNET_DVR_VEHICLE_INFO_COND;

typedef  struct
{
    DWORD 	dwSize;
    DWORD 	dwIndex;//index
    BYTE    byDeviceID[DEVICE_ID_LEN/*48*/];	//device num
    BYTE    byBelieve;//\A3\AC0-100
    BYTE    byDir;//derection\A3\AC0-none\A3\AC1-reverse\A3\AC2-positive\A3\AC3-unknown
    BYTE	byLineID;//
    BYTE   byRes1;
    NET_DVR_TIME_EX  struSnapTime;//snap time
    char sLicense[MAX_LICENSE_LEN_EX/*32*/];		//vehicle num
    BYTE  byMonitoringSiteID[MONITORSITE_ID_LEN /*48*/];	//
    BYTE  byCountry; // conutry index\A3\ACCOUNTRY_INDEX\A3\A8no support\A1\B1COUNTRY_ALL = 0xff, //ALL \A1\B1\A3\A9
    BYTE   byRes[511];
}NET_DVR_VEHICLE_INFO_CFG, *LPNET_DVR_VEHICLE_INFO_CFG;

#define URL_LEN     240   //URL length
typedef struct tagNET_DVR_PU_STREAM_URL
{
    BYTE    byEnable;
    BYTE    strURL[URL_LEN];
    BYTE    byTransPortocol ; // transport protocol type  0-tcp  1-UDP
    WORD    wIPID;  //Device ID\A3\ACwIPID = iDevInfoIndex + iGroupNO*64 +1
    BYTE    byChannel;  //channel NO.
    BYTE    byRes[7];
}NET_DVR_PU_STREAM_URL, *LPNET_DVR_PU_STREAM_URL;

typedef  struct tagNET_DVR_HKDDNS_STREAM
{
    BYTE    byEnable;   //Is enable
    BYTE    byRes[3];
    BYTE    byDDNSDomain[64];    // hiDDNS domain
    WORD    wPort;                   //IPServer port
    WORD    wAliasLen;               //Alias Length
    BYTE    byAlias[NAME_LEN];         //Alias
    WORD    wDVRSerialLen;           //Serial Length
    BYTE    byRes1[2];               //reserved
    BYTE    byDVRSerialNumber[SERIALNO_LEN];    //DVR Serial
    BYTE    byUserName[NAME_LEN];               //DVR User name
    BYTE    byPassWord[PASSWD_LEN];             //DVR User passward
    BYTE    byChannel;                          //DVR channel
    BYTE    byRes2[11];              //Reserved
}NET_DVR_HKDDNS_STREAM, *LPNET_DVR_HKDDNS_STREAM;

typedef struct tagNET_DVR_IPCHANINFO_V40
{
    BYTE    byEnable;                /* Enable */
    BYTE    byRes1;
    WORD    wIPID;                  //IP ID
    DWORD     dwChannel;                //channel
    BYTE    byTransProtocol;        //Trans protocol,0-TCP,1-UDP
    BYTE    byTransMode;            //Trans mode 0\A3\ADmain, 1\A3\ADsub
    BYTE    byFactoryType;            /*Factory type*/
    BYTE    byRes[241];
}NET_DVR_IPCHANINFO_V40,*LPNET_DVR_IPCHANINFO_V40;

// Brainare CVR
#define MAX_ID_COUNT    256
#define MAX_STREAM_ID_COUNT    1024
#define STREAM_ID_LEN   32
#define PLAN_ID_LEN  32

#define LEN_32                    32
#define LEN_31                    31
#define DEVICE_NO_LEN  24
#define MAX_VOLUMENAME_LEN 32   //volume name lenth
#define MAX_VAG_CHANNO_LEN  32

#define MAX_STREAM_ID_NUM    30

typedef struct tagNET_DVR_RTSP_PROTOCAL_CFG
{
    BYTE    byEnable;
    BYTE    byLocalBackUp; //enable local backup 0-disable ,1-enable
    BYTE    byRes[2];
    BYTE    strURL[URL_LEN_V40];
    DWORD   dwProtocalType;
    BYTE    sUserName[NAME_LEN];
    BYTE    sPassWord[PASSWD_LEN];
    BYTE    byAddress[MAX_DOMAIN_NAME];  //Encoder IP or domain name, the device needs to resolve Analytical methods exist for the letters and there '.' Is considered to be the domain name, IP address otherwise
    WORD    wPort;
    BYTE    byRes1[122];
}NET_DVR_RTSP_PROTOCAL_CFG, *LPNET_DVR_RTSP_PROTOCAL_CFG;


// Stream info
typedef struct tagNET_DVR_STREAM_INFO
{
    DWORD dwSize;
    BYTE  byID[STREAM_ID_LEN];      //ID
    DWORD dwChannel;                //Relation channel, 0xffffffff: not related
    BYTE  byRes[32];
}NET_DVR_STREAM_INFO, *LPNET_DVR_STREAM_INFO;


typedef union tagNET_DVR_GET_STREAM_UNION
{
    NET_DVR_IPCHANINFO      struChanInfo;         //Get stream from Device.
    NET_DVR_IPSERVER_STREAM struIPServerStream;  //Get stream from Device which register the IPServer
    NET_DVR_PU_STREAM_CFG   struPUStream;         //Get stream from stream server.
    NET_DVR_DDNS_STREAM_CFG struDDNSStream;      //Get stream by IPserver and stream server.
    NET_DVR_PU_STREAM_URL   struStreamUrl;        //get stream through stream server by url.
    NET_DVR_HKDDNS_STREAM struHkDDNSStream;   //get stream through hiDDNS
    NET_DVR_IPCHANINFO_V40 struIPChan; //Get stream from device(Extend)
}NET_DVR_GET_STREAM_UNION, *LPNET_DVR_GET_STREAM_UNION;

typedef enum
{
    NET_SDK_IP_DEVICE = 0,
    NET_SDK_STREAM_MEDIA,
    NET_SDK_IPSERVER,
    NET_SDK_DDNS_STREAM_CFG,
    NET_SDK_STREAM_MEDIA_URL,
    NET_SDK_HKDDNS,
    NET_SDK_IP_DEVICE_ADV,
    NET_SDK_IP_DEVICE_V40,
    NET_SDK_RTSP
}GET_STREAM_TYPE;

typedef struct tagNET_DVR_STREAM_MODE
{
    BYTE    byGetStreamType; //the type of gettin stream:0-Get stream from Device, 1-Get stream fram stream server,
    //2-Get stream from Device which register the IPServer, 3.Get stream by IPserver and stream server
    //4-get stream by url,5-hkDDNS\A3\AC6-Get stream from Device,NET_DVR_IPCHANINFO_V40,7- Get Stream by Rtsp Protocal
    BYTE    byRes[3];        //reserved
    NET_DVR_GET_STREAM_UNION uGetStream;    //the union of different getting stream type.
}NET_DVR_STREAM_MODE, *LPNET_DVR_STREAM_MODE;


typedef struct tagNET_DVR_IPPARACFG_V40
{
    DWORD      dwSize;                        //Size
    DWORD        dwGroupNum;                    //The number of group
    DWORD      dwAChanNum;                    //The number of simulate channel
    DWORD      dwDChanNum;                  //the number of IP channel
    DWORD      dwStartDChan;                //the begin NO. of IP channel
    BYTE       byAnalogChanEnable[MAX_CHANNUM_V30];    //Is simulate channel enable? represent by bit
    NET_DVR_IPDEVINFO_V31   struIPDevInfo[MAX_IP_DEVICE_V40];      //IP device
    NET_DVR_STREAM_MODE  struStreamMode [MAX_CHANNUM_V30];
    BYTE            byRes2[20];                 //reserved
}NET_DVR_IPPARACFG_V40, *LPNET_DVR_IPPARACFG_V40;


typedef struct tagNET_DVR_ALARMINFO_DEV
{
    DWORD     dwAlarmType;    //type
    NET_DVR_TIME   struTime;  //time
    BYTE       byRes[32];     //reserved
    DWORD      dwNumber;      //number
    WORD       *pNO;
}NET_DVR_ALARMINFO_DEV, *LPNET_DVR_ALARMINFO_DEV;

/* Alarm output channel */
typedef struct
{
    BYTE byIPID;                     /* ID of IP device,  the range:  1 to MAX_IP_DEVICE */
    BYTE byAlarmOut;                 /* Alarm output NO. */
    BYTE byRes[18];                 /* Reserved */
}NET_DVR_IPALARMOUTINFO,  *LPNET_DVR_IPALARMOUTINFO;

/* IP Alarm output configuration */
typedef struct
{
    DWORD dwSize;                                                 /*struct size */
    NET_DVR_IPALARMOUTINFO struIPAlarmOutInfo[MAX_IP_ALARMOUT]; /* IP alarm output */
}NET_DVR_IPALARMOUTCFG,  *LPNET_DVR_IPALARMOUTCFG;


/* Alarm output parameters */
typedef struct tagNET_DVR_IPALARMOUTINFO_V40
{
    DWORD dwIPID;                    /* ID of IP device,  the range:  1 to MAX_IP_DEVICE*/
    DWORD dwAlarmOut;                /* Alarm Out NO. */
    BYTE  byRes[32];                /* Reserved */
}NET_DVR_IPALARMOUTINFO_V40, *LPNET_DVR_IPALARMOUTINFO_V40;

typedef struct tagNET_DVR_IPALARMOUTCFG_V40
{
    DWORD   dwSize;
    DWORD   dwCurIPAlarmOutNum;
    NET_DVR_IPALARMOUTINFO_V40 struIPAlarmOutInfo[MAX_IP_ALARMOUT_V40];
    BYTE     byRes[256];
}NET_DVR_IPALARMOUTCFG_V40, *LPNET_DVR_IPALARMOUTCFG_V40;

/* Alarm input parameters */
typedef struct
{
    BYTE byIPID;                     /* ID of IP device,  the range:  1 to MAX_IP_DEVICE */
    BYTE byAlarmIn;                 /* Alarm input NO. */
    BYTE byRes[18];                 /* Reserved */
}NET_DVR_IPALARMININFO,  *LPNET_DVR_IPALARMININFO;

/* IP Alarm input configuration */
typedef struct
{
    DWORD dwSize;                                              /*struct size */
    NET_DVR_IPALARMININFO struIPAlarmInInfo[MAX_IP_ALARMIN];  /* IP alarm input */
}NET_DVR_IPALARMINCFG,  *LPNET_DVR_IPALARMINCFG;

/* IP Alarm input configuration */
typedef struct tagNET_DVR_IPALARMININFO_V40
{
    DWORD dwIPID;                    /* ID of IP device,  the range:  1 to MAX_IP_DEVICE */
    DWORD dwAlarmIn;                /* Alarm input NO. */
    BYTE  byRes[32];
}NET_DVR_IPALARMININFO_V40, *LPNET_DVR_IPALARMININFO_V40;

typedef struct tagNET_DVR_IPALARMINCFG_V40
{
    DWORD   dwSize;
    DWORD   dwCurIPAlarmInNum;
    NET_DVR_IPALARMININFO_V40 struIPAlarmInInfo[MAX_IP_ALARMIN_V40];
    BYTE     byRes[256];
}NET_DVR_IPALARMINCFG_V40, *LPNET_DVR_IPALARMINCFG_V40;


//IP Camera alarm info
typedef struct
{
    NET_DVR_IPDEVINFO  struIPDevInfo[MAX_IP_DEVICE];             /* IP Device */
    BYTE byAnalogChanEnable[MAX_ANALOG_CHANNUM];                 /* Enable analog channel or not, 0- Enable;  1- Disable */
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_IP_CHANNEL];              /* IP Channel */
    NET_DVR_IPALARMININFO struIPAlarmInInfo[MAX_IP_ALARMIN];     /* IP Alarm input */
    NET_DVR_IPALARMOUTINFO struIPAlarmOutInfo[MAX_IP_ALARMOUT];  /* IP Alarm output */
}NET_DVR_IPALARMINFO,  *LPNET_DVR_IPALARMINFO;

//IPC configuration change alarm  (Extended for 9000_1.1)
typedef struct tagNET_DVR_IPALARMINFO_V31
{
    NET_DVR_IPDEVINFO_V31  struIPDevInfo[MAX_IP_DEVICE];         /* IP device*/
    BYTE byAnalogChanEnable[MAX_ANALOG_CHANNUM];                 /* Enable/ disable analog channel,  0-  disable;  1- enable */
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_IP_CHANNEL];              /* IP channel */
    NET_DVR_IPALARMININFO struIPAlarmInInfo[MAX_IP_ALARMIN];     /* IP alarm input */
    NET_DVR_IPALARMOUTINFO struIPAlarmOutInfo[MAX_IP_ALARMOUT];  /* IP alarm output */
}NET_DVR_IPALARMINFO_V31,  *LPNET_DVR_IPALARMINFO_V31;

typedef struct tagNET_DVR_IPALARMINFO_V40
{
    NET_DVR_IPDEVINFO_V31 struIPDevInfo[MAX_IP_DEVICE_V40];     //IP device
    BYTE     byAnalogChanEnable[MAX_CHANNUM_V30];               //Enable analog channel or not: 0- disable, 1- enable
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_CHANNUM_V30];            //IP channel
    NET_DVR_IPALARMININFO struIPAlarmInInfo[MAX_IP_ALARMIN];    //IP alarm input
    NET_DVR_IPALARMOUTINFO struIPAlarmOutInfo[MAX_IP_ALARMOUT]; //IP alarm output
    BYTE                    byRes[20];                          //Reserved
}NET_DVR_IPALARMINFO_V40, *LPNET_DVR_IPALARMINFO_V40;

typedef enum _HD_STAT_
{
    HD_STAT_OK                    =    0,   /* Normal */
    HD_STAT_UNFORMATTED            =    1,   /* Raw */
    HD_STAT_ERROR               =    2,   /* Error */
    HD_STAT_SMART_FAILED        =    3,   /* SMART State */
    HD_STAT_MISMATCH            =    4,   /* Unmatched */
    HD_STAT_IDLE                =    5,   /* Sleep*/
    NET_HD_STAT_OFFLINE         =    6,   /* Net Disk is off line */
    HD_RIADVD_EXPAND            =   7,   /* riad virtual disk expand */
    HD_STAT_REPARING            =   10,  /* disk is repairing */
    HD_STAT_FORMATING           =   11,  /* disk is formating */
}HD_STAT;

//Configuration of local Hard Disk
typedef struct
{
    DWORD dwHDNo;          /*Hard Disk No.  (0~MAX_DISKNUM_V30- 1)  */
    DWORD dwCapacity;      /*Capacity (Read only) */
    DWORD dwFreeSpace;     /*Free space (Read only) */
    DWORD dwHdStatus;      /*Disk status (Read only)  0- Normal,  1- Raw,  2- Error,  3- SMART State,  4- Unmatched,  5- Sleep*/
    /* 6 - network hard disk is not online 7 - the virtual disk scalable 10 - hard drive being repaired*/
    /* 11 - hard disk is formatted 12 - hard drive is waiting for formatting 13 - hard uninstalled */
    /*14 - the local hard disk does not exist 15 - (network hard drive being deleted),16-locked*/
    BYTE  byHDAttr;        /*0- Default,  1- Redundancy;  2- Read only, , 3- backup, use for CVR,4-NotRW*/
    BYTE  byHDType;           /*0- Local HD,1-ESATA HD,2-NAS HD,3-iSCSI HD 4-Array Virtual Disk,5-SD card,,6-minSAS*/
    BYTE  byDiskDriver;    //The value means its ANSC character, added for IVMS device
    BYTE  byRes1;
    DWORD dwHdGroup;       //Disk Group  (1- MAX_HD_GROUP)
    BYTE  byRecycling;       //  0\A3\BAno reuse\A3\AC1\A3\BAreuse
    BYTE  byRes2[3];
    DWORD  dwStorageType;    //by bit 0-not support      none 0-support
    // dwStorageType & 0x1 for common record
    // dwStorageType & 0x2  for drawframe record
    // dwStorageType & 0x4  for picture

    DWORD dwPictureCapacity;  //Hard picture capacity (not set) Unit: MB
    DWORD dwFreePictureSpace; //Remaining the pictures space (not set), unit: MB
    BYTE  byRes3[104];
}NET_DVR_SINGLE_HD,  *LPNET_DVR_SINGLE_HD;

typedef struct
{
    DWORD dwSize;
    DWORD dwHDCount;                               //Number of Disk (Read only)
    NET_DVR_SINGLE_HD struHDInfo[MAX_DISKNUM_V30]; //Reboot Device to take effect
}NET_DVR_HDCFG,  *LPNET_DVR_HDCFG;

//Local Disk Group Configuration
typedef struct tagNET_DVR_SINGLE_HDGROUP_V40
{
    DWORD     dwHDGroupNo;       /*Group NO. (Read only)  1- MAX_HD_GROUP*/
    DWORD      dwRelRecordChan[MAX_CHANNUM_V40];  /*Corresponding Channel of HD Group,*/
    BYTE       byRes[64];
}NET_DVR_SINGLE_HDGROUP_V40, *LPNET_DVR_SINGLE_HDGROUP_V40;

typedef struct tagNET_DVR_HDGROUP_CFG_V40
{
    DWORD      dwSize;
    DWORD     dwMaxHDGroupNum;           /*Total groups (Read only) */
    DWORD     dwCurHDGroupNum;       /*Cur groups (Read only) */
    NET_DVR_SINGLE_HDGROUP_V40 struHDGroupAttr[MAX_HD_GROUP]; //Reboot Device to take effect
    BYTE       byRes[128];
}NET_DVR_HDGROUP_CFG_V40, *LPNET_DVR_HDGROUP_CFG_V40;


//Local Disk Group Configuration
typedef struct
{
    DWORD dwHDGroupNo;        /*Group NO. (Read only)  1- MAX_HD_GROUP*/
    BYTE byHDGroupChans[MAX_CHANNUM_V30];  /*Corresponding Channel of HD Group,  0- Not record in this group, 1- Record in this group*/
    BYTE byRes[8];
}NET_DVR_SINGLE_HDGROUP,  *LPNET_DVR_SINGLE_HDGROUP;

typedef struct
{
    DWORD dwSize;
    DWORD dwHDGroupCount;         /*Total groups (Read only) */
    NET_DVR_SINGLE_HDGROUP struHDGroupAttr[MAX_HD_GROUP]; //Reboot Device to take effect
}NET_DVR_HDGROUP_CFG,  *LPNET_DVR_HDGROUP_CFG;


//Display Scale Configuration
typedef struct
{
    DWORD dwSize;
    DWORD dwMajorScale;     /* Main Screen  0- No Scale, 1- Scale*/
    DWORD dwMinorScale;     /* AUX Screen   0- No Scale, 1- Scale*/
    DWORD dwRes[2];
}NET_DVR_SCALECFG,  *LPNET_DVR_SCALECFG;



//DVR Alarm output (9000 extended)
typedef struct
{
    DWORD dwSize;
    BYTE sAlarmOutName[NAME_LEN];     /* Name */
    DWORD dwAlarmOutDelay;             /* Alarm Duration (- 1- - Stop manually)  */
    //0- 5 Sec, 1- 10Sec, 2- 30Sec, 3- 1Min, 4- 2Min, 5- 5Min, 6- 10Min, 7- Stop Manually
    NET_DVR_SCHEDTIME struAlarmOutTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /* Time Segment for Alarm output */
    BYTE byRes[16];
}NET_DVR_ALARMOUTCFG_V30,  *LPNET_DVR_ALARMOUTCFG_V30;

//DVR Alarm output
typedef struct
{
    DWORD dwSize;
    BYTE sAlarmOutName[NAME_LEN];     /* Name */
    DWORD dwAlarmOutDelay;     /* Alarm Duration (- 1- - Stop manually)  */
    //0- 5Sec, 1- 10Sec, 2- 30Sec, 3- 1Min, 4- 2Min, 5- 5Min, 6- 10Min, 7- Stop Manually
    NET_DVR_SCHEDTIME struAlarmOutTime[MAX_DAYS][MAX_TIMESEGMENT];  /* Time Segment for Alarm output */
}NET_DVR_ALARMOUTCFG,  *LPNET_DVR_ALARMOUTCFG;

//DVR Local Preview (9000 extended)
typedef struct
{
    DWORD dwSize;
    BYTE byPreviewNumber; //Mode of preview channels, 0- 1 window, 1- 4 windows, 2- 9 windows, 3- 16 windows, 0xff:  largest
    BYTE byEnableAudio; //Preview audio, 0- No, 1- Yes
    WORD wSwitchTime; //duration to switch, 0- disable, 1- 5s, 2- 10s, 3- 20s, 4- 30s, 5- 60s, 6- 120s, 7- 300s
    BYTE bySwitchSeq[MAX_PREVIEW_MODE][MAX_WINDOW_V30]; //Order to switch,  lSwitchSeq[i]==0xff- not used
    BYTE byRes[24];
}NET_DVR_PREVIEWCFG_V30,  *LPNET_DVR_PREVIEWCFG_V30;
//DVR Local Preview
typedef struct
{
    DWORD dwSize;
    BYTE byPreviewNumber; //Number of preview channels, 0- 1 window, 1- 4 windows, 2- 9 windows, 3- 16 windows, 0xff:  largest
    BYTE byEnableAudio; //Preview audio, 0- No, 1- Yes
    WORD wSwitchTime; //duration to switch, 0- disable, 1- 5s, 2- 10s, 3- 20s, 4- 30s, 5- 60s, 6- 120s, 7- 300s
    BYTE bySwitchSeq[MAX_WINDOW]; //Order to switch,  lSwitchSeq[i] 0xff- not used
}NET_DVR_PREVIEWCFG,  *LPNET_DVR_PREVIEWCFG;

//DVR video output
typedef struct
{
    WORD wResolution;                                 /* Resolution */
    WORD wFreq;                                     /* Refresh rate */
    DWORD dwBrightness;                             /* Brightness */
}NET_DVR_VGAPARA;

/*
* MATRIX Output Configuration
*/
typedef struct
{
    WORD    wOrder[MAX_ANALOG_CHANNUM];         /* Preview order,  0xff means this channel is disabled */
    WORD    wSwitchTime;                         /* Time to witch */
    BYTE    res[14];
}NET_DVR_MATRIXPARA_V30,  *LPNET_DVR_MATRIXPARA_V30;

typedef struct
{
    WORD wDisplayLogo;                         /* Display Channel No. */
    WORD wDisplayOsd;                         /* Display Time */
}NET_DVR_MATRIXPARA;

typedef struct
{
    BYTE byVideoFormat;                     /* Video Standard, 0- PAL, 1- NTSC */
    BYTE byMenuAlphaValue;                     /* the contrast between Menu and background image */
    WORD wScreenSaveTime;                     /* Screen Saver 0- Never, 1- 1Min, 2- 2Min, 3- 5Min, 4- 10Min, 5- 20Min, 6- 30Min */
    WORD wVOffset;                             /* Offset of video output */
    WORD wBrightness;                         /* Brightness*/
    BYTE byStartMode;                         /* Video output mode (0: Menu, 1: Preview) */
    BYTE byEnableScaler;                    /* Enable Scale  (0- Disable,  1- Enable) */
}NET_DVR_VOOUT;

//DVR Video output  (9000 extended)
typedef struct
{
    DWORD dwSize;
    NET_DVR_VOOUT struVOOut[MAX_VIDEOOUT_V30];
    NET_DVR_VGAPARA struVGAPara[MAX_VGA_V30];                     /* VGA Parameter */
    NET_DVR_MATRIXPARA_V30 struMatrixPara[MAX_MATRIXOUT];         /* MATRIX Parameter */
    BYTE byRes[16];
}NET_DVR_VIDEOOUT_V30,  *LPNET_DVR_VIDEOOUT_V30;

//DVR Video Output
typedef struct
{
    DWORD dwSize;
    NET_DVR_VOOUT struVOOut[MAX_VIDEOOUT];
    NET_DVR_VGAPARA struVGAPara[MAX_VGA];     /* VGA Parameter */
    NET_DVR_MATRIXPARA struMatrixPara;         /* MATRIX Parameter */
}NET_DVR_VIDEOOUT,  *LPNET_DVR_VIDEOOUT;



//Single User Parameters (Sub Struct)  (256NVR  extended)
typedef struct tagNET_DVR_USER_INFO_V40
{
    BYTE sUserName[NAME_LEN];         /* Username */
    BYTE sPassword[PASSWD_LEN];     /* Password */
    BYTE byLocalRight[MAX_RIGHT];     /* Local privilege */
    /*
                                    array 0:  local PTZ control
                                    array 1:  local manual record
                                    array 2:  local playback
                                    array 3:  local configuration
                                    array 4:  local log & status query
                                    array 5:  local advanced settings  (upgrade,  format,  reboot,  shut down)
                                    array 6:  local parameter check
                                    array 7:  local analog & IP camera management
                                    array 8:  local backup
                                    array 9:  local shut down/reboot
                                    */

    BYTE byRemoteRight[MAX_RIGHT]; /* remote privilege settings */
    /*
                                  array 0:  remote PTZ control
                                  array 1:  remote manual record
                                  array 2:  remote playback
                                  array 3:  remote configuration
                                  array 4:  remote log & status query
                                  array 5:  remote advanced settings  (upgrade,  format,  reboot,  shut down)
                                  array 6:  remote start voice talk
                                  array 7:  remote preview
                                  array 8: remote alarm upload to center,  alarm output
                                  array 9: remote control local output
                                  array 10: remote serial port control
                                  array 11:  remote parameter query
                                  array 12:  remote analog & IP camera management
                                  array 13:  remote shut down/reboot
                                  */
    DWORD    dwNetPreviewRight[MAX_CHANNUM_V40];            /* remote preview channel No., Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwLocalRecordRight[MAX_CHANNUM_V40];            /* local record channel , Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwNetRecordRight[MAX_CHANNUM_V40];            /* remote record channel ,  Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwLocalPlaybackRight[MAX_CHANNUM_V40];            /* local playback channel ,Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwNetPlaybackRight[MAX_CHANNUM_V40];            /* remote record channel , Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwLocalPTZRight[MAX_CHANNUM_V40];                /* local PTZ channel ,  Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwNetPTZRight[MAX_CHANNUM_V40];                /* remote PTZ channel , Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwLocalBackupRight[MAX_CHANNUM_V40];            /* local backup channel, Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    NET_DVR_IPADDR struUserIP;         /* User IP  (0 stands for no IP restriction)  */
    BYTE byMACAddr[MACADDR_LEN];     /* MAC */
    BYTE byPriority;                 /* Priority settings ,  0xff-  disable ,  0- low,  1- Mid,  2- High */
    /*
                                    Low\A1\AD\A1\ADDefault privileges including local/remote playback,  log & status query,  reboot/shut down.
                                    Mid\A1\AD\A1\ADInclude local/remote PTZ control,  manual record,  voice talk,  playback,  log & status query,  reboot/shut down,  log backup and remote preview.
                                    High\A1\AD\A1\ADAdministrator
                                    */
    BYTE    byAlarmOnRight;         // Alarm In guard privileges
    BYTE    byAlarmOffRight;        // Alarm In unguard privileges
    BYTE    byBypassRight;          // Alarm In bypass privileges
    BYTE    byRes1[2];
    BYTE    byPublishRight[MAX_RIGHT];  //Information release proprietary rights
    /*An array of 0: material audit jurisdiction*/
    /*An array of 1: program audit authority*/
    /*An array of 2: schedule audit jurisdiction*/
    /*Array 3: upload material privileges*/
    /*An array of 4: new program permissions*/
    /*An array of 5: new schedule*/
    /*An array of 6: information broadcast rights*/
    /*An array of 7: terminal management authority*/
    /*An array of 8: business intelligence*/
    BYTE    byRes[84];
}NET_DVR_USER_INFO_V40, *LPNET_DVR_USER_INFO_V40;

//Single User Parameters (Sub Struct)  (9000 extended)
typedef struct
{
    BYTE sUserName[NAME_LEN];         /* Username */
    BYTE sPassword[PASSWD_LEN];     /* Password */
    BYTE byLocalRight[MAX_RIGHT];     /* Local privilege */
    /*
                                    array 0:  local PTZ control
                                    array 1:  local manual record
                                    array 2:  local playback
                                    array 3:  local configuration
                                    array 4:  local log & status query
                                    array 5:  local advanced settings  (upgrade,  format,  reboot,  shut down)
                                    array 6:  local parameter check
                                    array 7:  local analog & IP camera management
                                    array 8:  local backup
                                    array 9:  local shut down/reboot
                                    */

    BYTE byRemoteRight[MAX_RIGHT]; /* remote privilege settings */
    /*
                                  array 0:  remote PTZ control
                                  array 1:  remote manual record
                                  array 2:  remote playback
                                  array 3:  remote configuration
                                  array 4:  remote log & status query
                                  array 5:  remote advanced settings  (upgrade,  format,  reboot,  shut down)
                                  array 6:  remote start voice talk
                                  array 7:  remote preview
                                  array 8: remote alarm upload to center,  alarm output
                                  array 9: remote control local output
                                  array 10: remote serial port control
                                  array 11:  remote parameter query
                                  array 12:  remote analog & IP camera management
                                  array 13:  remote shut down/reboot
                                  */
    BYTE byNetPreviewRight[MAX_CHANNUM_V30];         /* remote preview channel ,  0- enable,  1- disable*/
    BYTE byLocalPlaybackRight[MAX_CHANNUM_V30];         /* local playback channel ,  0- enable,  1- disable*/
    BYTE byNetPlaybackRight[MAX_CHANNUM_V30];         /* remote playback channel ,  0- enable,  1- disable*/
    BYTE byLocalRecordRight[MAX_CHANNUM_V30];         /* local record channel ,  0- enable,  1- disable*/
    BYTE byNetRecordRight[MAX_CHANNUM_V30];         /* remote record channel ,  0- enable,  1- disable*/
    BYTE byLocalPTZRight[MAX_CHANNUM_V30];         /* local PTZ channel ,  0- enable,  1- disable*/
    BYTE byNetPTZRight[MAX_CHANNUM_V30];             /* remote PTZ channel ,  0- enable,  1- disable*/
    BYTE byLocalBackupRight[MAX_CHANNUM_V30];         /* local backup channel ,  0- enable,  1- disable*/
    NET_DVR_IPADDR struUserIP;         /* User IP  (0 stands for no IP restriction)  */
    BYTE byMACAddr[MACADDR_LEN];     /* MAC */
    BYTE byPriority;                 /* Priority settings ,  0xff-  disable ,  0- low,  1- Mid,  2- High */
    /*
                                    Low\A1\AD\A1\ADDefault privileges including local/remote playback,  log & status query,  reboot/shut down.
                                    Mid\A1\AD\A1\ADInclude local/remote PTZ control,  manual record,  voice talk,  playback,  log & status query,  reboot/shut down,  log backup and remote preview.
                                    High\A1\AD\A1\ADAdministrator
                                    */
    BYTE    byAlarmOnRight;         // Alarm In guard privileges
    BYTE    byAlarmOffRight;        // Alarm In unguard privileges
    BYTE    byBypassRight;          // Alarm In bypass privileges
    BYTE    byRes[14];
}NET_DVR_USER_INFO_V30,  *LPNET_DVR_USER_INFO_V30;

//Single User Parameters (SDK_V15extended)  (Sub Structure)
typedef struct
{
    BYTE sUserName[NAME_LEN];         /* Username */
    BYTE sPassword[PASSWD_LEN];     /* Password */
    DWORD dwLocalRight[MAX_RIGHT];     /* privilege */
    /*
                                    array 0- local PTZ control
                                    array 1- local manual record
                                    array 2- local playback
                                    array 3- local configuration
                                    array 4- local log & status query
                                    array 5- local advanced settings  (upgrade,  format,  reboot,  shut down)
                                    */
    DWORD dwLocalPlaybackRight;         /*  local playback channel. 1 bit0 - -  channel 1*/
    DWORD dwRemoteRight[MAX_RIGHT];     /* privilege */
    /*
                                    array 0- remote  PTZ control
                                    array 1- remote manual record
                                    array 2- remote playback
                                    array 3- remote configuration
                                    array 4- remote log & status query
                                    array 5- remote advanced settings  (upgrade,  format,  reboot,  shut down)
                                    array 6- remote start voice talk
                                    array 7- remote preview
                                    array 8- remote alarm upload to center,  alarm output
                                    array 9- remote control local output
                                    array 10- remote serial port control
                                    */
    DWORD dwNetPreviewRight;         /* remote preview channel number,  bit0 - -  channel 1*/
    DWORD dwNetPlaybackRight;         /* remote playback channel number,  bit0 - -  channel 1*/
    char sUserIP[16];                 /* User IP  (0 stands for no IP restriction)  */
    BYTE byMACAddr[MACADDR_LEN];     /* MAC */
}NET_DVR_USER_INFO_EX,  *LPNET_DVR_USER_INFO_EX;

//Single User Parameters (Sub Structure)
typedef struct
{
    BYTE sUserName[NAME_LEN];         /* Username */
    BYTE sPassword[PASSWD_LEN];     /* Password */
    DWORD dwLocalRight[MAX_RIGHT];     /* privilege */
    /*
                                    array 0- local PTZ control
                                    array 1- local manual record
                                    array 2- local playback
                                    array 3- local configuration
                                    array 4- local log & status query
                                    array 5- local advanced settings  (upgrade,  format,  reboot,  shut down)
    */
    DWORD dwRemoteRight[MAX_RIGHT]; /* privilege */
    /*
                                    array 0- remote  PTZ control
                                    array 1- remote manual record
                                    array 2- remote playback
                                    array 3- remote configuration
                                    array 4- remote log & status query
                                    array 5- remote advanced settings  (upgrade,  format,  reboot,  shut down)
                                    array 6- remote start voice talk
                                    array 7- remote preview
                                    array 8- remote alarm upload to center,  alarm output
                                    array 9- remote control local output
                                    array 10- remote serial port control
    */
    char sUserIP[16];                 /* User IP  (0 stands for no IP restriction)  */
    BYTE byMACAddr[MACADDR_LEN];     /* MAC */
}NET_DVR_USER_INFO,  *LPNET_DVR_USER_INFO;


//DVR User Parameters (256 NVR extended)
typedef struct  tagNET_DVR_USER_V40
{
    DWORD dwSize;
    DWORD dwMaxUserNum;
    NET_DVR_USER_INFO_V40 struUser[MAX_USERNUM_V30];
}NET_DVR_USER_V40,*LPNET_DVR_USER_V40;
typedef struct  tagNET_DVR_USER_V50
{
    DWORD dwSize;
    DWORD dwMaxUserNum;
    NET_DVR_USER_INFO_V40 struUser[MAX_USERNUM_V30];
    char	sloginPassword[PASSWD_LEN/*16*/];
    BYTE 	byRes[240];
}NET_DVR_USER_V50, *LPNET_DVR_USER_V50;
//DVR User Parameters (9000extended)
typedef struct
{
    DWORD dwSize;
    NET_DVR_USER_INFO_V30 struUser[MAX_USERNUM_V30];
}NET_DVR_USER_V30,  *LPNET_DVR_USER_V30;

//DVR User Parameters (SDK_V15extended)
typedef struct
{
    DWORD dwSize;
    NET_DVR_USER_INFO_EX struUser[MAX_USERNUM];
}NET_DVR_USER_EX,  *LPNET_DVR_USER_EX;

//DVR User Parameters
typedef struct
{
    DWORD dwSize;
    NET_DVR_USER_INFO struUser[MAX_USERNUM];
}NET_DVR_USER,  *LPNET_DVR_USER;

//DVR Exception Parameters (256NVR extended)
typedef struct tagNET_DVR_EXCEPTION_V40
{
    DWORD             dwSize ;
    DWORD             dwMaxGroupNum ;
    NET_DVR_HANDLEEXCEPTION_V41 struExceptionHandle[MAX_EXCEPTIONNUM_V30];
    BYTE                byRes[128];
}NET_DVR_EXCEPTION_V40,*LPNET_DVR_EXCEPTION_V40;

//DVR Exception Parameters (9000extended)
typedef struct
{
    DWORD dwSize;
    NET_DVR_HANDLEEXCEPTION_V30 struExceptionHandleType[MAX_EXCEPTIONNUM_V30];
    /*array 0-  hard disk is full,  1-  hard disk error,  2-  signal lost,  3-  network link is broken,  4- illegal access,  5-  input/output video standard not match,  6- overspeed Car (for mobile DVR) ,  7- record exception 8-raid exception 9-resolusion mismatch 10-speed exceed 11-spare exception\
    12-temperature abnormal, 13-subsystem abnormal, 14-fan abnormal, , 15-POE Power Exception*/
}NET_DVR_EXCEPTION_V30,  *LPNET_DVR_EXCEPTION_V30;

//DVR Exception Parameters
typedef struct
{
    DWORD dwSize;
    NET_DVR_HANDLEEXCEPTION struExceptionHandleType[MAX_EXCEPTIONNUM];
    /*array 0-  hard disk is full,  1-  hard disk error,  2-  signal lost,  3-  network link is broken,  4- illegal access,  5-  input/output video standard not match,  6- overspeed Car (for mobile DVR) */
}NET_DVR_EXCEPTION,  *LPNET_DVR_EXCEPTION;

//Channel State (9000 extended)
typedef struct
{
    BYTE byRecordStatic;  //whether the channel is in recording,  0-  no,  1-  yes
    BYTE bySignalStatic;  //video signal status,  0-  normal,  1-  lost
    BYTE byHardwareStatic; //the channel hardware status,  0-  normal,  1-  abnormal,  e.g. DSP is not work
    BYTE byRes1;         //Reserved
    DWORD dwBitRate;     //actual bit rate
    DWORD dwLinkNum;     //connected client number
    NET_DVR_IPADDR struClientIP[MAX_LINK]; //client IP referred to NET_DVR_IPADDR
    DWORD dwIPLinkNum; //if the current channel is set as IPC channel,  then this parameter represents the current connected IP channel number.
    BYTE byExceedMaxLink;   // 0-less than 6 link, 1 more than 6 link
    BYTE byRes[3];
    DWORD dwAllBitRate;      //All Bit Rate
    DWORD dwChannelNo;    //cur chanNo, 0xffffffff  is  invalid
}NET_DVR_CHANNELSTATE_V30,  *LPNET_DVR_CHANNELSTATE_V30;

//Channel State
typedef struct
{
    BYTE byRecordStatic;        //Whether the channel is in recording,  0-  no,  1-  yes
    BYTE bySignalStatic;        //Video signal status,  0-  normal,  1-  lost
    BYTE byHardwareStatic;      //The channel hardware status,  0-  normal,  1-  abnormal,  e.g. DSP is not work
    char reservedData;             //Reserved
    DWORD dwBitRate;             //Actual bit rate
    DWORD dwLinkNum;             //Connected client number
    DWORD dwClientIP[MAX_LINK]; //Client IP
}NET_DVR_CHANNELSTATE,  *LPNET_DVR_CHANNELSTATE;

//Hard Disk Status
typedef struct
{
    DWORD dwVolume; //Capacity
    DWORD dwFreeSpace; //Free Space
    DWORD dwHardDiskStatic;  //HD status: 0- active; 1- sleep mode; 2- abnormal;  3-  sleep mode error, 4-not format, 5- can't connect(net disk) 6- being formating.
}NET_DVR_DISKSTATE,  *LPNET_DVR_DISKSTATE;

//DVR Work State (256 NVR extended)
typedef struct tagNET_DVR_WORKSTATE_V40
{
    DWORD   dwSize ;
    DWORD   dwDeviceStatic;      //the device's status,  0-  normal,  1-  the occupancy of CPU is too high,  more than 85%,  2- hardware error,  e.g. the serial ports do not work
    NET_DVR_DISKSTATE  struHardDiskStatic[MAX_DISKNUM_V30];
    NET_DVR_CHANNELSTATE_V30 struChanStatic[MAX_CHANNUM_V40/*512*/];//chan Status
    DWORD   dwHasAlarmInStatic[MAX_ALARMIN_V40/*512*/];
    DWORD   dwHasAlarmOutStatic[MAX_ALARMOUT_V40/*512*/];
    DWORD   dwLocalDisplay;         //Local display status,  0-  normal,  1- abnormal
    BYTE    byAudioInChanStatus[MAX_AUDIO_V30/*2*/];//Audio channel status,  0- unused;  1- on using; 0xff- invalid
    BYTE    byRes1[2];
    float    fHumidity;    //0.0 ~ 100.0
    float    fTemperature;    //-20.0 ~ 90.0
    BYTE    byRes[116];
}NET_DVR_WORKSTATE_V40, *LPNET_DVR_WORKSTATE_V40;


typedef struct tagNET_DVR_GETWORKSTATE_COND
{
    DWORD   dwSize ;
    BYTE    byFindHardByCond; /*0-find all Hard */
    BYTE    byFindChanByCond ;  /*0-find All Chan,and The dwFindChanNum is invalid, else The dwFindChanNum is valid*/
    BYTE    byRes1[2] ;
    DWORD   dwFindHardStatus[MAX_DISKNUM_V30/*33*/] ; /*To find the hard disk No. , according to the values, the values of the order, met 0xFFFFFFFF that subsequent invalid */
    DWORD   dwFindChanNo[MAX_CHANNUM_V40/*512*/] ; /*To find the Chan No. ,according to the values,\A3\ACaccording to the values, the values of the order, met 0xFFFFFFFF that subsequent invalid */
    BYTE     byRes[64] ;
}NET_DVR_GETWORKSTATE_COND, *LPNET_DVR_GETWORKSTATE_COND;

//DVR Work State (9000 extended)
typedef struct
{
    DWORD dwDeviceStatic;      //the device's status,  0-  normal,  1-  the occupancy of CPU is too high,  more than 85%,  2- hardware error,  e.g. the serial ports do not work
    NET_DVR_DISKSTATE  struHardDiskStatic[MAX_DISKNUM_V30];
    NET_DVR_CHANNELSTATE_V30 struChanStatic[MAX_CHANNUM_V30]; //channel status  as NET_DVR_CHANNELSTATE
    BYTE  byAlarmInStatic[MAX_ALARMIN_V30];  //alarm input status,  0-  no alarm,  1- alarm
    BYTE  byAlarmOutStatic[MAX_ALARMOUT_V30];  //alarm output status,  0- no output,  1- alarm output
    DWORD  dwLocalDisplay; //Local display status,  0-  normal,  1- abnormal
    BYTE  byAudioChanStatus[MAX_AUDIO_V30]; //Audio channel status,  0- unused;  1- on using; 0xff- invalid
    BYTE  byRes[10];
}NET_DVR_WORKSTATE_V30,  *LPNET_DVR_WORKSTATE_V30;

//DVR Status Structure
typedef struct
{
    DWORD dwDeviceStatic;      //the device's status,  0-  normal,  1-  the occupancy of CPU is too high,  more than 85%,  2- hardware error,  e.g. the serial ports do not work
    NET_DVR_DISKSTATE  struHardDiskStatic[MAX_DISKNUM];
    NET_DVR_CHANNELSTATE struChanStatic[MAX_CHANNUM]; //channel status  as NET_DVR_CHANNELSTATE
    BYTE  byAlarmInStatic[MAX_ALARMIN];             //alarm input status,  0-  no alarm,  1- alarm
    BYTE  byAlarmOutStatic[MAX_ALARMOUT];         //alarm output status,  0- no output,  1- alarm output
    DWORD  dwLocalDisplay;                         //Local display status,  0-  normal,  1- abnormal
}NET_DVR_WORKSTATE,  *LPNET_DVR_WORKSTATE;



/************************ Alarm-host log searching begin************************************************/
typedef struct tagNET_DVR_ALARMHOST_SEARCH_LOG_PARAM
{
    WORD            wMajorType;        // Major type
    WORD            wMinorType;        // Minor type
    NET_DVR_TIME    struStartTime;    // Start time
    NET_DVR_TIME    struEndTime;    // End time
    BYTE            byRes[8];        // Reserved
}NET_DVR_ALARMHOST_SEARCH_LOG_PARAM, LPNET_DVR_ALARMHOST_SEARCH_LOG_PARAM;

typedef struct tagNET_DVR_ALARMHOST_LOG_RET
{
    NET_DVR_TIME    struLogTime;                // Log time
    BYTE            sUserName[NAME_LEN];        // Operator user
    NET_DVR_IPADDR    struIPAddr;                 // Operator IP address
    WORD            wMajorType;                 // Major type
    WORD            wMinorType;                 // Minor type
    WORD            wParam;                        // Operation parameter
    BYTE            byRes[10];
    DWORD            dwInfoLen;                    // Length of description information
    char            sInfo[LOG_INFO_LEN];        // Description information
}NET_DVR_ALARMHOST_LOG_RET, *LPNET_DVR_ALARMHOST_LOG_RET;

/************************* Alarm-host log searching end***********************************************/

//Alarm output state (9000 extended)
typedef struct
{
    BYTE Output[MAX_ALARMOUT_V30];
}NET_DVR_ALARMOUTSTATUS_V30,  *LPNET_DVR_ALARMOUTSTATUS_V30;

//Alarm output state
typedef struct
{
    BYTE Output[MAX_ALARMOUT];
}NET_DVR_ALARMOUTSTATUS,  *LPNET_DVR_ALARMOUTSTATUS;

//Transaction Info
typedef struct
{
    USHORT m_Year;
    USHORT m_Month;
    USHORT m_Day;
    USHORT m_Hour;
    USHORT m_Minute;
    USHORT m_Second;
    BYTE DeviceName[24];     //Device name
    DWORD dwChannelNumer;     //Channel name
    BYTE CardNumber[32];     //Credit Card No.
    char cTradeType[12];     //Transaction type
    DWORD dwCash;             //Transaction money
}NET_DVR_TRADEINFO,  *LPNET_DVR_TRADEINFO;


//Special for ATM
/****************************ATM (begin) ***************************/
#define NCR                0
#define DIEBOLD            1
#define WINCOR_NIXDORF    2
#define SIEMENS            3
#define OLIVETTI        4
#define FUJITSU            5
#define HITACHI            6
#define SMI                7
#define IBM                8
#define BULL            9
#define YiHua            10
#define LiDe            11
#define GDYT            12
#define Mini_Banl        13
#define GuangLi            14
#define DongXin            15
#define ChenTong        16
#define NanTian            17
#define XiaoXing        18
#define GZYY            19
#define QHTLT            20
#define DRS918            21
#define KALATEL            22
#define NCR_2            23
#define NXS                24


/*Frame Type*/
typedef struct
{
    BYTE code[12];         /* code */
}NET_DVR_FRAMETYPECODE;

//ATM Parameters
typedef struct
{
    DWORD dwSize;
    char sATMIP[16];                             /* ATM IP */
    DWORD dwATMType;                             /* ATM Type*/
    DWORD    dwInputMode;                         /* 0-  network listening 1- network receive; 2-directly input via serial port; 3-input ATM command via serial port*/
    DWORD    dwFrameSignBeginPos;                 /* the start position of Message flag*/
    DWORD    dwFrameSignLength;                     /* the length of Message flag */
    BYTE    byFrameSignContent[12];             /* the content of Message flag */
    DWORD    dwCardLengthInfoBeginPos;             /* offset of credit card No. length information */
    DWORD    dwCardLengthInfoLength;             /* the length of the card length information */
    DWORD    dwCardNumberInfoBeginPos;             /* Start position of the card number information */
    DWORD    dwCardNumberInfoLength;             /* Length of the card number information */
    DWORD    dwBusinessTypeBeginPos;             /* the offset of operation type information */
    DWORD    dwBusinessTypeLength;                 /* the length of the operation type */
    NET_DVR_FRAMETYPECODE    frameTypeCode[10];     /* type */
}NET_DVR_FRAMEFORMAT,  *LPNET_DVR_FRAMEFORMAT;

//SDK_V31 ATM
/*1.1.1.18    Structure of package filter*/
typedef struct    tagNET_DVR_FILTER
{
    BYTE                    byEnable;             //0,  disable;  1,  enable
    BYTE                    byMode;             //0, ASCII; 1, HEX
    BYTE                    byFrameBeginPos;    //begin position of target text
    BYTE                    byRes;           //Reserved
    BYTE                     byFilterText[16];     //filter text
    BYTE                    byRes2[12];         //Reserved
}NET_DVR_FILTER,  *LPNET_DVR_FILTER;

//Package structure of starting flag
typedef struct    tagNET_DVR_IDENTIFICAT
{
    BYTE                    byStartMode;         //start mode: 0, ASCII; 1, HEX
    BYTE                    byEndMode;             //end mode:  0, ASCII; 1, HEX
    BYTE                    byRes[2];           //Reserved
    NET_DVR_FRAMETYPECODE    struStartCode;         //start code
    NET_DVR_FRAMETYPECODE    struEndCode;         //end code
    BYTE                    byRes1[12];         //Reserved
}NET_DVR_IDENTIFICAT,  *LPNET_DVR_IDENTIFICAT;

typedef struct    tagNET_DVR_PACKAGE_LOCATION/* package information position*/
{
    BYTE                     byOffsetMode;             /* 0, token (character flag mode) ; 1, fix (fix mode) */
    BYTE                    byRes1[3];                 // Reserved
    DWORD                      dwOffsetPos;             /*Used when mode is 1,  offset size*/
    NET_DVR_FRAMETYPECODE    struTokenCode;             /*Flag bit*/
    BYTE                    byMultiplierValue;         /*number of Flags*/
    BYTE                    byEternOffset;             /*extern offset*/
    BYTE                    byCodeMode;             /*0, ASCII; 1, HEX*/
    BYTE                     byRes2[9];                 //Reserved
}NET_DVR_PACKAGE_LOCATION,  *LPNET_DVR_PACKAGE_LOCATION;


typedef struct    tagNET_DVR_PACKAGE_LENGTH//package length
{
    BYTE                    byLengthMode;             //length mode:  0,  variable;  1,  fixed ; 2, gotten from package (Used when setting the card number length )
    BYTE                    byRes1[3];              // Reserved
    DWORD                      dwFixLength;             //Used when mode is 1,  fixed length
    DWORD                    dwMaxLength;            //Maximum length  byLengthMode is 0
    DWORD                    dwMinLength;            //Minimum length  byLengthMode is 0
    BYTE                    byEndMode;                 //Terminator:  0, ASCII; 1, HEX
    BYTE                    byRes2[3];              //Reserved
    NET_DVR_FRAMETYPECODE    struEndCode;             //Terminator with variable length
    DWORD                    dwLengthPos;             //Used when length mode is 2,  card length position in the package
    DWORD                    dwLengthLen;             //Used when length mode is 2,  length of the card number length
    BYTE                    byRes3[8];              // Reserved
}NET_DVR_PACKAGE_LENGTH, * LPNET_DVR_PACKAGE_LENGTH;

typedef struct    tagNET_DVR_OSD_POSITION//OSD overlay position
{
    BYTE                    byPositionMode;         //Mode,  0:  not display,  1: Custom
    BYTE                    byRes1[3];              // Reserved
    DWORD                     dwPosX;                 //X- coordinator,  used when position mode is custom
    DWORD                    dwPosY;                 //Y- coordinator,  used when position mode is custom
    BYTE                    byRes2[8];              //Reserved
}NET_DVR_OSD_POSITION,  *LPNET_DVR_OSD_POSITION;

typedef struct    tagNET_DVR_DATE_FORMAT//date display format
{
    BYTE                    byMonth;                 //Month, 0-mm; 1-mmm; 2-mmmm
    BYTE                     byDay;                     //Day, 0-dd;
    BYTE                     byYear;                 //Year, 0-yy; 1-yyyy
    BYTE                    byDateForm;             //0-5,  permutations and combinations of year, month, day
    BYTE                    byRes[20];              // Reserved
    char                    chSeprator[4];             //separator
    char                    chDisplaySeprator[4];     //display separator
    BYTE                    byDisplayForm;             //0-5, permutations and combinations of 3 items
    BYTE                    res[27];                // Reserved
}NET_DVR_DATE_FORMAT,  *LPNET_DVR_DATE_FORMAT;
typedef struct    tagNET_DVRT_TIME_FORMAT//time display format
{
    BYTE                    byTimeForm;             //1. HH MM SS; 0. HH MM
    BYTE                     byRes1[23];             // Reserved
    BYTE                    byHourMode;             //0, 12; 1, 24
    BYTE                    byRes2[3];              // Reserved
    char                    chSeprator[4];          //package separator,  reserved
    char                    chDisplaySeprator[4];     //display separator
    BYTE                    byDisplayForm;             //0~5,  permutations and combinations  of 3 items
    BYTE                    byRes3[3];              // Reserved
    BYTE                    byDisplayHourMode;         //0-12;  1- 24
    BYTE                    byRes4[19];             // Reserved
}NET_DVR_TIME_FORMAT,  *LPNET_DVR_TIME_FORMAT;

typedef struct tagNET_DVR_OVERLAY_CHANNEL
{
    BYTE                    byChannel[64]; //overlay channel,  Set 1 to display,  set 0 to hide
    DWORD                    dwDelayTime;             //overlay delay time
    BYTE                    byEnableDelayTime;         //enable or disable. Overlay delay is enabled,  in the absence of withdrawal card command
    BYTE                    byRes[11];           // Reserved
}NET_DVR_OVERLAY_CHANNEL,  *LPNET_DVR_OVERLAY_CHANNEL;

// Structure of Trading action
typedef struct tagNET_DVR_ATM_PACKAGE_ACTION
{
    NET_DVR_PACKAGE_LOCATION    struPackageLocation; // location of package
    NET_DVR_OSD_POSITION        struOsdPosition;     // OSD overlay position
    NET_DVR_FRAMETYPECODE        struActionCode;         //codes of trading type
    NET_DVR_FRAMETYPECODE        struPreCode;         //character before overlaying
    BYTE                    byActionCodeMode;         //codes of trading type. 0, ASCII; 1, HEX
    BYTE                    byRes[7];                // Reserved
}NET_DVR_ATM_PACKAGE_ACTION,  *LPNET_DVR_ATM_PACKAGE_ACTION;

//  Date info of ATM package
typedef struct tagNET_DVR_ATM_PACKAGE_DATE
{
    NET_DVR_PACKAGE_LOCATION    struPackageLocation; // Position of date
    NET_DVR_DATE_FORMAT            struDateForm;         //date display mode
    NET_DVR_OSD_POSITION        struOsdPosition;     // OSD overly position
    BYTE                        res[8];              // Reserved
}NET_DVR_ATM_PACKAGE_DATE,  *LPNET_DVR_ATM_PACKAGE_DATE;


//Time info of ATM package
typedef struct tagNET_DVR_ATM_PACKAGE_TIME
{
    NET_DVR_PACKAGE_LOCATION    location;         // Position of time
    NET_DVR_TIME_FORMAT            struTimeForm;     //display mode
    NET_DVR_OSD_POSITION        struOsdPosition; // OSD overly position
    BYTE                        byRes[8];         // Reserved
}NET_DVR_ATM_PACKAGE_TIME,  *LPNET_DVR_ATM_PACKAGE_TIME;


//other info of  ATM package (Card SN.,  Transaction amount,  Transaction SN.)
typedef struct tagNET_DVR_ATM_PACKAGE_OTHERS
{
    NET_DVR_PACKAGE_LOCATION    struPackageLocation;  //Position info
    NET_DVR_PACKAGE_LENGTH    struPackageLength;         //length Info
    NET_DVR_OSD_POSITION        struOsdPosition;     //overlay position
    NET_DVR_FRAMETYPECODE        struPreCode;         //character before overlaying
    BYTE                    res[8];                     //Reserved
}NET_DVR_ATM_PACKAGE_OTHERS,  *LPNET_DVR_ATM_PACKAGE_OTHERS;


//User- defined Protocol
typedef struct tagNET_DVR_ATM_USER_DEFINE_PROTOCOL
{
    NET_DVR_IDENTIFICAT        struIdentification;   //Package Flag
    NET_DVR_FILTER             struFilter;  //Filter settings
    NET_DVR_ATM_PACKAGE_OTHERS struCardNoPara;  // Settings of overlay card number
    NET_DVR_ATM_PACKAGE_ACTION struTradeActionPara[MAX_ACTION_TYPE];  //Settings of overlay trade action, 0- 9: InCard,  OutCard,  OverLay,  SetTime,  GetStatus,  Query,  WithDraw,  Deposit,  ChanPass,  Transfer
    NET_DVR_ATM_PACKAGE_OTHERS struAmountPara;  //Settings of overlay Transaction amount
    NET_DVR_ATM_PACKAGE_OTHERS struSerialNoPara;  //Settings of overlay trade SN
    NET_DVR_OVERLAY_CHANNEL    struOverlayChan;  //Settings of overlay channel
    NET_DVR_ATM_PACKAGE_DATE   struRes1;  //Settings of overlay data,  reserved
    NET_DVR_ATM_PACKAGE_TIME   struRes2;  //Settings of overlay time,  reserved
    BYTE                       byRes3[124];         //Reserved
}NET_DVR_ATM_USER_DEFINE_PROTOCOL,  *LPNET_DVR_ATM_USER_DEFINE_PROTOCOL;

typedef struct tagNET_DVR_ATM_FRAMEFORMAT_V30
{
    DWORD                        dwSize;                 //structure size
    BYTE                        byEnable;                 /*0:  Enable,  1:  Disable*/
    BYTE                        byInputMode;             /*Input mode:  0- Network Listen,  1- Network Protocol,  2- Serial Listen,  3- Serial Protocol*/
    BYTE                        byRes1[34];              //Reserved
    NET_DVR_IPADDR                struAtmIp;                 /*ATM IP,  used in network listen mode */
    WORD                        wAtmPort;                 /* Get port by card number,  Network Protocol mode or Serial server port mode*/
    BYTE                        byRes2[2];               // Reserved
    DWORD                        dwAtmType;                 /*ATM protocol type,  get from NET_DVR_ATM_PROTOCOL,  using user- defined protocol when the type is user_defined*/
    NET_DVR_ATM_USER_DEFINE_PROTOCOL   struAtmUserDefineProtocol;  //User- defined protocol,  using this definition when the ATM protocol is user- defined.
    BYTE                        byRes3[8];
}NET_DVR_ATM_FRAMEFORMAT_V30,  *LPNET_DVR_ATM_FRAMEFORMAT_V30;


typedef struct  tagNET_DVR_ATM_PROTO_TYPE
{
    DWORD dwAtmType;  //ATM protocol type,  index SN,  and 1025 is for user- defined.
    char chDesc[ATM_DESC_LEN];  //Simple description of ATM protocol
}NET_DVR_ATM_PROTO_TYPE,  *LPNET_DVR_ATM_PROTO_TYPE;  //Data structure of protocol information

typedef struct tagNET_DVR_ATM_PROTO_LIST    //ATM Protocol List
{
    DWORD                  dwAtmProtoNum;    // Number of protocol
    NET_DVR_ATM_PROTO_TYPE struAtmProtoType[MAX_ATM_PROTOCOL_NUM];  //protocol list info
}NET_DVR_ATM_PROTO_LIST,  *LPNET_DVR_ATM_PROTO_LIST;

typedef struct tagNET_DVR_ATM_PROTOCOL
{
    DWORD dwSize;
    NET_DVR_ATM_PROTO_LIST struNetListenList;  // Description of Network Listen protocol
    NET_DVR_ATM_PROTO_LIST struSerialListenList;  //Description of Serial Listen protocol
    NET_DVR_ATM_PROTO_LIST struNetProtoList;      //Description of Network protocol
    NET_DVR_ATM_PROTO_LIST struSerialProtoList;    //Description of Serial Protocol
    NET_DVR_ATM_PROTO_TYPE struCustomProto;         //User- defined protocol
}NET_DVR_ATM_PROTOCOL,  *LPNET_DVR_ATM_PROTOCOL;
//SDK_V31

/*****************************DS- 6001D/F (begin) ***************************/
//DS- 6001D Decoder
typedef struct
{
    BYTE byEncoderIP[16];         //Server IP that decoder connected
    BYTE byEncoderUser[16];         //Server Username that decoder connected
    BYTE byEncoderPasswd[16];     //Server Password that decoder connected
    BYTE bySendMode;             //Server Connection Mode that decoder connected
    BYTE byEncoderChannel;         //Server Channel No. that decoder connected
    WORD wEncoderPort;             //Server Port that decoder connected
    BYTE reservedData[4];         //Reserved
}NET_DVR_DECODERINFO,  *LPNET_DVR_DECODERINFO;

typedef struct
{
    BYTE byEncoderIP[16];         //Server IP that decoder connected
    BYTE byEncoderUser[16];         //Server Username that decoder connected
    BYTE byEncoderPasswd[16];     //Server Password that decoder connected
    BYTE byEncoderChannel;         //Server Channel No. that decoder connected
    BYTE bySendMode;             //Server Connection Mode that decoder connected
    WORD wEncoderPort;             //Server Port that decoder connected
    DWORD dwConnectState;         //Server State that decoder connected
    BYTE reservedData[4];         //Reserved
}NET_DVR_DECODERSTATE,  *LPNET_DVR_DECODERSTATE;

/*Definition of Decoder Control Code */
#define NET_DEC_STARTDEC        1
#define NET_DEC_STOPDEC            2
#define NET_DEC_STOPCYCLE        3
#define NET_DEC_CONTINUECYCLE    4

/*Channel Connected Configuration*/
typedef struct
{
    char sDVRIP[16];                 /* DVR IP Address */
    WORD wDVRPort;                      /* Ports */
    BYTE sUserName[NAME_LEN];         /* Username */
    BYTE sPassword[PASSWD_LEN];         /* Password */
    BYTE byChannel;                     /* Channel No. */
    BYTE byLinkMode;                 /* Connection Mode */
    BYTE byLinkType;                 /* Stream for Connection  0- Main Stream 1- Sub Stream */
}NET_DVR_DECCHANINFO,  *LPNET_DVR_DECCHANINFO;

/*Configuration of Each Decoding Channel*/
typedef struct
{
    BYTE    byPoolChans;             /*Switch channel number on each decoder channel,  range from 0- 4*/
    NET_DVR_DECCHANINFO struchanConInfo[MAX_DECPOOLNUM];
    BYTE    byEnablePoll;             /*enable switching or not:  0-  disable 1-  enable*/
    BYTE    byPoolTime;                 /*switching interval:  1- 10 sec;  2-  15 sec;  3-  20 sec;  4-  30 sec;   5-  45 sec;  6-  1min;  7-  2min;  8-  5min */
}NET_DVR_DECINFO,  *LPNET_DVR_DECINFO;

/*Decoder Configuration*/
typedef struct
{
    DWORD    dwSize;
    DWORD    dwDecChanNum;          /*Number of decoding channels*/
    NET_DVR_DECINFO struDecInfo[MAX_DECNUM];
}NET_DVR_DECCFG,  *LPNET_DVR_DECCFG;

//2005- 08- 01
/* Transparent Channel of Decoder */
typedef struct
{
    DWORD dwEnableTransPort;     /* Enable transparent channel or not:  0-  disable;  1-  enable*/
    char sDecoderIP[16];         /* DVR IP */
    WORD wDecoderPort;             /* Port number */
    WORD wDVRTransPort;             /* Configuration DVR output serial port:  1-  232;  2-  485 */
    char cReserve[4];
}NET_DVR_PORTINFO,  *LPNET_DVR_PORTINFO;

typedef struct
{
    DWORD dwSize;
    NET_DVR_PORTINFO struTransPortInfo[MAX_TRANSPARENTNUM];  /* Array 0- - 232;  Array 1- - 485 */
}NET_DVR_PORTCFG,  *LPNET_DVR_PORTCFG;

/* Remote Playback */
typedef struct
{
    DWORD dwSize;
    char sDecoderIP[16];         /* DVR IP*/
    WORD wDecoderPort;             /* Port */
    WORD wLoadMode;                 /* Playback Mode 1- by name 2- by time */
    union
    {
        BYTE byFile[100];         /* File Name */
        struct
        {
            DWORD dwChannel;
            BYTE sUserName[NAME_LEN];     /* Username for playback*/
            BYTE sPassword[PASSWD_LEN];     /* Password */
            NET_DVR_TIME struStartTime;     /* Start time of playback by time mode*/
            NET_DVR_TIME struStopTime;     /* End time */
        }bytime;
    }mode_size;
}NET_DVR_PLAYREMOTEFILE,  *LPNET_DVR_PLAYREMOTEFILE;

/*Decoder Channel Status Structure */
typedef struct
{
    DWORD dwWorkType;         /*Work mode:  1-  switching;  2-  dynamic connect to decoder;  3-  playback by file;  4-  playback by time*/
    char sDVRIP[16];         /*Connected device IP*/
    WORD wDVRPort;             /*Connected port number*/
    BYTE byChannel;             /*Channel number */
    BYTE byLinkMode;         /*Connection mode */
    DWORD    dwLinkType;         /*Connection stream type:  0-  main stream;  1-  sub stream*/
    union
    {
        struct
        {
            BYTE sUserName[NAME_LEN];     /*Username*/
            BYTE sPassword[PASSWD_LEN];     /* Password */
            char cReserve[52];
        }userInfo;
        struct
        {
            BYTE   fileName[100];
        }fileInfo;
        struct
        {
            DWORD    dwChannel;
            BYTE    sUserName[NAME_LEN];     /*Username*/
            BYTE    sPassword[PASSWD_LEN];     /* Password */
            NET_DVR_TIME struStartTime;         /* Start position for playback by time */
            NET_DVR_TIME struStopTime;         /* End position for playback by time */
        }timeInfo;
    }objectInfo;
}NET_DVR_DECCHANSTATUS,  *LPNET_DVR_DECCHANSTATUS;

typedef struct
{
    DWORD   dwSize;
    NET_DVR_DECCHANSTATUS struDecState[MAX_DECNUM];
}NET_DVR_DECSTATUS,  *LPNET_DVR_DECSTATUS;
/*****************************DS- 6001D/F (end) ***************************/

//Single Character Struct  (Sub Struct)
typedef struct
{
    WORD wShowString;                 //enable text overlay on preview image:  0- disable;  1- enable. The display area ranges totally 704*576 ,  with single character size as 32*32
    WORD wStringSize;                 /* text length,  no more than 44 text character */
    WORD wShowStringTopLeftX;         /* top left X axis position for text overlay*/
    WORD wShowStringTopLeftY;         /* top left Y axis position for text overlay */
    char sString[44];                 /* overlay text content*/
}NET_DVR_SHOWSTRINGINFO,  *LPNET_DVR_SHOWSTRINGINFO;

//Text Overlay  (9000extended)
typedef struct
{
    DWORD dwSize;
    NET_DVR_SHOWSTRINGINFO struStringInfo[MAX_STRINGNUM_V30];                 /* Content for display */
}NET_DVR_SHOWSTRING_V30,  *LPNET_DVR_SHOWSTRING_V30;

//Text Overlay extended (8 lines)
typedef struct
{
    DWORD dwSize;
    NET_DVR_SHOWSTRINGINFO struStringInfo[MAX_STRINGNUM_EX];                 /* Content for display  */
}NET_DVR_SHOWSTRING_EX,  *LPNET_DVR_SHOWSTRING_EX;

//Text Overlay
typedef struct
{
    DWORD dwSize;
    NET_DVR_SHOWSTRINGINFO struStringInfo[MAX_STRINGNUM];                 /* Content for display  */
}NET_DVR_SHOWSTRING,  *LPNET_DVR_SHOWSTRING;

/****************************DS9000 added Structure (begin) ******************************/

/*
EMAIL Parameters Struct
*/
typedef struct
{
    DWORD        dwSize;
    BYTE        sAccount[NAME_LEN];                 /* Email Account*/
    BYTE        sPassword[MAX_EMAIL_PWD_LEN];             /*Password */
    struct
    {
        BYTE    sName[NAME_LEN];                 /* sender name */
        BYTE    sAddress[MAX_EMAIL_ADDR_LEN];         /* sender address */
    }struSender;
    BYTE        sSmtpServer[MAX_EMAIL_ADDR_LEN];     /* SMTP server */
    BYTE        sPop3Server[MAX_EMAIL_ADDR_LEN];     /* POP3 server */
    struct
    {
        BYTE    sName[NAME_LEN];                 /* receiver Name */
        BYTE    sAddress[MAX_EMAIL_ADDR_LEN];         /* receiver address */
    }struReceiver[3];                             /* support up to 3 receivers */
    BYTE        byAttachment;                     /* with attached snapshot or not */
    BYTE        bySmtpServerVerify;                 /* Enable Email server authentication:  1- enable;  0- disable */
    BYTE        byMailInterval;                  /* mail interval 0- 2s,  1- 3s,  2- 4s. 3- 5s*/
    BYTE        byEnableSSL;                     //enable ssl
    WORD        wSmtpPort;                         //gmail default 465,  else default 25
    BYTE        byEnableTLS;                    /*enable TLS*/
    BYTE        byStartTLS;                     /*Start TLS*/
    BYTE        byRes[72];                        /*res*/
} NET_DVR_EMAILCFG_V30,  *LPNET_DVR_EMAILCFG_V30;

/*
DVR Cruise Structure
*/
typedef struct
{
    DWORD     dwSize;
    BYTE    byPresetNo[CRUISE_MAX_PRESET_NUMS];         /* Preset No. */
    BYTE     byCruiseSpeed[CRUISE_MAX_PRESET_NUMS];     /* Cruise Speed */
    WORD    wDwellTime[CRUISE_MAX_PRESET_NUMS];         /* Dwell time */
    BYTE    byEnableThisCruise;                         /* Enable this cruise */
    BYTE    res[15];
}NET_DVR_CRUISE_PARA,  *LPNET_DVR_CRUISE_PARA;
/****************************DS9000 Added (end) ******************************/


//Time
typedef struct
{
    DWORD dwMonth;         //Month 0- 11 for 1- 12 month
    DWORD dwWeekNo;         //Week 0-  First Week 1- Second Week 2- Third Week 3- Fourth Week 4- last Week
    DWORD dwWeekDate;     //Day 0- Sun 1- Mon 2- Tue 3- Wed 4- Thu 5- Fri 6- Sat
    DWORD dwHour;         //begin/end hour,  begin hour ranges from 0- 23,  and end hour ranges from 1- 23
    DWORD dwMin;         //begin/stop minutes ranges from 0- 59
}NET_DVR_TIMEPOINT;

//Time Zone & DST
typedef struct
{
    DWORD dwSize;
    DWORD dwZoneIndex; //Use cTimeDifferenceH or cTimeDifferenceM in NET_DVR_NTPPARA
    BYTE byRes1[12];             //Reserved
    DWORD dwEnableDST;         //enable DST,  0- disable;  1- enable
    BYTE byDSTBias;             //DST bias;  30min,  60min,  90min,  120min,  count with minute
    BYTE byRes2[3];
    NET_DVR_TIMEPOINT struBeginPoint;     //DST start time
    NET_DVR_TIMEPOINT struEndPoint;         //DST stop time
}NET_DVR_ZONEANDDST,  *LPNET_DVR_ZONEANDDST;



//Image Quality
typedef struct
{
    /*Note:  If encoding resolution is VGA, it supports grabbing 0=CIF,  1=QCIF,  2=D1 image.
    But if encoding resolution is 3=UXGA (1600x1200) ,  4=SVGA (800x600) ,  5=HD720p (1280x720) ,  6=VGA,  7=XVGA,  and 8=HD900p it only support grabbing image with current resolution*/
    /*
       0-CIF\A3\AC           1-QCIF\A3\AC           2-D1\A3\AC         3-UXGA(1600x1200), 4-SVGA(800x600),5-HD720p(1280x720)\A3\AC
       6-VGA\A3\AC           7-XVGA\A3\AC           8-HD900p\A3\AC     9-HD1080\A3\AC     10-2560*1920\A3\AC
       11-1600*304\A3\AC     12-2048*1536\A3\AC     13-2448*2048,  14-2448*1200\A3\AC 15-2448*800\A3\AC
       16-XGA(1024*768), 17-SXGA(1280*1024),18-WD1(960*576/960*480),      19-1080i,      20-576*576\A3\AC
       21-1536*1536,     22-1920*1920,      23-320*240,    24-720*720,    25-1024*768,
       26-1280*1280,     27-1600*600,       28-2048*768,   29-160*120,    75-336*256,
       78-384*256,         79-384*216,        80-320*256,    82-320*192,    83-512*384,
       127-480*272,      128-512*272,       500-384*288,
       0xff-Auto(Use resolution of current stream)
    */
    WORD    wPicSize;
    WORD    wPicQuality; /* 0 -  the best,  1 -  better,  2 -  average;  */
}NET_DVR_JPEGPARA,  *LPNET_DVR_JPEGPARA;

typedef  struct
{
    NET_DVR_JPEGPARA  struParam;
    BYTE   byPicFormat;			// The equipment at 0 - Jpeg image format
    BYTE   byCapturePicType;		// Equipment, scratching figure type 0 - equipment general figure, 1 - eagle eye calibration images
    BYTE   byRes[254];
}NET_DVR_PICPARAM_V50, *LPNET_DVR_PICPARAM_V50;

/* aux video out parameter */
//AUX Output Parameter
typedef struct
{
    DWORD dwSize;
    DWORD dwAlarmOutChan;                        /* 0\A8Cmain video output;  1\A8Caux1 video output;  2\A8Caux2 video output;  3\A8Caux3 video output;  4\A8Caux4 video output*/
    DWORD dwAlarmChanSwitchTime;                 /* : 1Sec -  10: 10Sec */
    DWORD dwAuxSwitchTime[MAX_AUXOUT];             /* aux output switch time:  0-  no switch;  1- 5sec; 2- 10sec; 3- 20sec; 4- 30sec; 5- 60sec; 6- 120sec; 7- 300sec*/
    BYTE  byAuxOrder[MAX_AUXOUT][MAX_WINDOW];     /* aux output preview sequence,  0xff means not preview the camera */
}NET_DVR_AUXOUTCFG,  *LPNET_DVR_AUXOUTCFG;


//ntp
typedef struct
{
    BYTE sNTPServer[64];    /* Domain Name or IP address of NTP server */
    WORD wInterval;          /* adjust time interval (hours)  */
    BYTE byEnableNTP;     /* enable NPT client 0- no, 1- yes*/
    signed char cTimeDifferenceH;  /* Difference with Standard Time  (Hour) :  ranges from - 12... +13 */
    signed char cTimeDifferenceM; /* Difference with Standard Time  (Minute) */
    BYTE res1;
    WORD wNtpPort;          /* ntp server port (9000 added) ,  123 is default*/
    BYTE res2[8];
}NET_DVR_NTPPARA,  *LPNET_DVR_NTPPARA;

//DDNS
typedef struct
{
    BYTE sUsername[NAME_LEN];   /* DDNS Username*/
    BYTE sPassword[PASSWD_LEN]; /*Password */
    BYTE sDomainName[64];        /* Domain name */
    BYTE byEnableDDNS;             /*Enable DDNS 0- disable, 1- enable*/
    BYTE res[15];
}NET_DVR_DDNSPARA,  *LPNET_DVR_DDNSPARA;


typedef struct
{
    BYTE byHostIndex;                     /* 0- private DNS (Reserved)  1- Dyndns 2- PeanutHull 3- xw3322  */
    BYTE byEnableDDNS;                     /*enable DDNS:  0- disable;  1- enable*/
    WORD wDDNSPort;                         /* DDNS port */
    BYTE sUsername[NAME_LEN];             /* DDNS Username*/
    BYTE sPassword[PASSWD_LEN];             /* DDNS Password */
    BYTE sDomainName[MAX_DOMAIN_NAME];     /* DVR domain name*/
    BYTE sServerName[MAX_DOMAIN_NAME];     /* DDNS server domain name or IP */
    BYTE byRes[16];
}NET_DVR_DDNSPARA_EX,  *LPNET_DVR_DDNSPARA_EX;

//9000extended
typedef struct
{
    BYTE byEnableDDNS;
    BYTE byHostIndex; /*0-IPServer 1\A3\ADDyndns 2\A3\ADPeanutHull\A3\AC3- NO-IP, 4- hiDDNS*/
    BYTE byRes1[2];
    struct
    {
        BYTE sUsername[NAME_LEN];             /* DDNS Username*/
        BYTE sPassword[PASSWD_LEN];         /* Password */
        BYTE sDomainName[MAX_DOMAIN_NAME];     /* DVR domain name */
        BYTE sServerName[MAX_DOMAIN_NAME];     /* DDNS server domain name or IP*/
        WORD wDDNSPort;                     /* Port */
        WORD    wCountryID;                    //Country ID,Only byHostIndex is 4 effective, 0 represents the default
        BYTE byStatus;                         /*DDNS status(ro),0-Meaningless\A3\AC1-connAddrSrvfail\
        2-solveAddrMesFail,3-connHeartSrvfail,4-solveHeartMesFail, 5-connHostSrvfail,6-solveHostMesFail,7-registHostSuccess\
        8-registHostFail,9-sendHeartSuccess, 10-noDNSSrv,  11-DomainConflict,12-serviceException,13-needAuthentication\
        14-invalidAlias, 15-disable*/
        BYTE byRes[7];
    } struDDNS[MAX_DDNS_NUMS];
    BYTE byRes2[16];
}NET_DVR_DDNSPARA_V30,  *LPNET_DVR_DDNSPARA_V30;

//email
typedef struct
{
    BYTE sUsername[64];   /* Email Account */
    BYTE sPassword[64];
    BYTE sSmtpServer[64];
    BYTE sPop3Server[64];
    BYTE sMailAddr[64];    /* email */
    BYTE sEventMailAddr1[64];   /* email for upload Alarm/Exception */
    BYTE sEventMailAddr2[64];
    BYTE res[16];
}NET_DVR_EMAILPARA,  *LPNET_DVR_EMAILPARA;

//Network Parameter
typedef struct
{
    DWORD  dwSize;
    char  sDNSIp[16];                 /* DNS Server IP */
    NET_DVR_NTPPARA  struNtpClientParam;       /* NTP Parameters */
    NET_DVR_DDNSPARA struDDNSClientParam;      /* DDNS Parameters */
    BYTE res[464];             /* Reserved */
}NET_DVR_NETAPPCFG,  *LPNET_DVR_NETAPPCFG;

//nfs Structure Configuration
typedef struct
{
    char sNfsHostIPAddr[16];
    BYTE sNfsDirectory[PATHNAME_LEN];         // PATHNAME_LEN = 128
}NET_DVR_SINGLE_NFS,  *LPNET_DVR_SINGLE_NFS;

typedef struct
{
    DWORD  dwSize;
    NET_DVR_SINGLE_NFS struNfsDiskParam[MAX_NFS_DISK];
}NET_DVR_NFSCFG,  *LPNET_DVR_NFSCFG;

typedef struct tagNET_DVR_ISCSI_CFG
{
    DWORD dwSize;                   // Structure size
    WORD wVrmPort;                  // VRM listening port
    BYTE byEnable;                  // Enable ISCSI storage or not
    BYTE byRes[69];                 // Reserved
    NET_DVR_IPADDR struVrmAddr;     // VRM IP address, 16-bit
    char chNvtIndexCode[64];        //nvt index Code
}NET_DVR_ISCSI_CFG, *LPNET_DVR_ISCSI_CFG;

//Cruise Point Configuration (for private IP Speed Dome)
typedef struct
{
    BYTE    PresetNum;     //Preset
    BYTE    Dwell;         //Dwell time
    BYTE    Speed;         //Speed
    BYTE    Reserve;     //Reserved
}NET_DVR_CRUISE_POINT,  *LPNET_DVR_CRUISE_POINT;

typedef struct
{
    NET_DVR_CRUISE_POINT struCruisePoint[32];             //32 points in total
}NET_DVR_CRUISE_RET,  *LPNET_DVR_CRUISE_RET;

/************************************Multi- Channel Decoder (begin) ***************************************/
typedef struct
{
    DWORD    dwSize;
    char    sFirstDNSIP[16];
    char    sSecondDNSIP[16];
    char    sRes[32];
}NET_DVR_NETCFG_OTHER,  *LPNET_DVR_NETCFG_OTHER;

typedef struct
{
    char     sDVRIP[16];                 /* DVR IP */
    WORD     wDVRPort;                  /* Port */
    BYTE     byChannel;                 /* Channel No. */
    BYTE    byTransProtocol;             /* Network Protocol 0- TCP,  1- UDP */
    BYTE    byTransMode;                 /* Stream Type 0 -  Main Stream 1 -  Sub Stream*/
    BYTE    byRes[3];
    BYTE    sUserName[NAME_LEN];             /* DVR login user name */
    BYTE    sPassword[PASSWD_LEN];             /* DVR login Password */
}NET_DVR_MATRIX_DECINFO,  *LPNET_DVR_MATRIX_DECINFO;

//Dynamic Decoding
typedef struct
{
    DWORD    dwSize;
    NET_DVR_MATRIX_DECINFO struDecChanInfo;         /*Info of Dynamic Decoding Channel*/
}NET_DVR_MATRIX_DYNAMIC_DEC,  *LPNET_DVR_MATRIX_DYNAMIC_DEC;

typedef struct
{
    DWORD     dwSize;
    DWORD   dwIsLinked;          /* Network link status tag,  0:  Sleep,  1:  linking,  2:  linked,  3:  decoding */
    DWORD   dwStreamCpRate;      /* Stream copy rate,  X kbits/second */
    char    cRes[64];         /* Reserved */
}NET_DVR_MATRIX_DEC_CHAN_STATUS,  *LPNET_DVR_MATRIX_DEC_CHAN_STATUS;

typedef struct
{
    DWORD    dwSize;
    NET_DVR_MATRIX_DECINFO struDecChanInfo;         /* Decode channel information  */
    DWORD    dwDecState;     /* 0- dynamic decode 1-  switch decode 2- playback by time 3- playback by file */
    NET_DVR_TIME StartTime;         /* start time for playback by time mode,  */
    NET_DVR_TIME StopTime;         /* stop time for playback by time mode */
    char    sFileName[128];         /* file name for playback by file mode */
}NET_DVR_MATRIX_DEC_CHAN_INFO,  *LPNET_DVR_MATRIX_DEC_CHAN_INFO;

//Channel Connected Configuration 2007- 11- 05
typedef struct
{
    DWORD dwEnable;                     /*0- Disable 1- Enable*/
    NET_DVR_MATRIX_DECINFO struDecChanInfo;         /* Info of switching decoding channel */
}NET_DVR_MATRIX_DECCHANINFO,  *LPNET_DVR_MATRIX_DECCHANINFO;

//2007- 11- 05 Configuration for each channel
typedef struct
{
    DWORD    dwSize;
    DWORD    dwPoolTime;             /*Switch interval */
    NET_DVR_MATRIX_DECCHANINFO struchanConInfo[MAX_CYCLE_CHAN];
}NET_DVR_MATRIX_LOOP_DECINFO,  *LPNET_DVR_MATRIX_LOOP_DECINFO;

//2007- 12- 22
typedef struct
{
    BYTE    baudrate;          /* baud rate */
    BYTE    databits;         /* Data bit */
    BYTE    stopbits;         /* Stop bit*/
    BYTE    parity;             /* Parity digit */
    BYTE    flowcontrol;     /* Flow control */
    BYTE    res[3];
}TTY_CONFIG,  *LPTTY_CONFIG;

typedef struct
{
    BYTE byTranChanEnable;     /* Open current transparent channel or not 0:  close 1:  open */
    /*
                            There is a 232 interface and a 485 interface on the decoder,  which can all be set as transparent channel,  device number can be distributed as below:
                            0 -  RS485; 1 -  RS232 Console
                            */
    BYTE    byLocalSerialDevice;             /* Local serial device */
    /*
                                            *    Remote output serial device
                                            *    1- RS232
                                            *    2- RS485
                                            */
    BYTE    byRemoteSerialDevice;             /* Remote output serial device */
    BYTE    res1;                             /* Reserved */
    char    sRemoteDevIP[16];                 /* Remote Device IP */
    WORD    wRemoteDevPort;                     /* Remote Net Communication Port */
    BYTE    res2[2];                         /* Reserved */
    TTY_CONFIG RemoteSerialDevCfg;
}NET_DVR_MATRIX_TRAN_CHAN_INFO,  *LPNET_DVR_MATRIX_TRAN_CHAN_INFO;

typedef struct
{
    DWORD dwSize;
    BYTE     by232IsDualChan;  /* Set full- duplex 232 transparent channel,  set value ranges from 1 to MAX_SERIAL_NUM */
    BYTE    by485IsDualChan;  /* Set full- duplex 485 transparent channel,  set value ranges from 1 to MAX_SERIAL_NUM */
    BYTE    res[2];     /* Reserved */
    NET_DVR_MATRIX_TRAN_CHAN_INFO struTranInfo[MAX_SERIAL_NUM]; /*Support to create transparent channel number up to MAX_SERIAL_NUM*/
}NET_DVR_MATRIX_TRAN_CHAN_CONFIG,  *LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG;

//2007- 12- 24 Merry Christmas Eve...
typedef struct
{
    DWORD    dwSize;
    char    sDVRIP[16];             /* DVR IP */
    WORD    wDVRPort;             /* Port */
    BYTE    byChannel;             /* Channel Port */
    BYTE     byReserve;
    BYTE    sUserName[NAME_LEN];         /* Username */
    BYTE    sPassword[PASSWD_LEN];         /* Password */
    DWORD    dwPlayMode;        /* 0- by file 1-  by time*/
    NET_DVR_TIME StartTime;
    NET_DVR_TIME StopTime;
    char    sFileName[128];
}NET_DVR_MATRIX_DEC_REMOTE_PLAY,  *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY;

/* Commands for playing file*/
#define NET_DVR_PLAYSTART        1//Start play
#define NET_DVR_PLAYSTOP        2//Stop play
#define NET_DVR_PLAYPAUSE        3//Pause
#define NET_DVR_PLAYRESTART        4//Restore
#define NET_DVR_PLAYFAST        5//Play Faster
#define NET_DVR_PLAYSLOW        6//Play Slower
#define NET_DVR_PLAYNORMAL        7//Normal Speed
#define NET_DVR_PLAYSTARTAUDIO    9//Open Audio
#define NET_DVR_PLAYSTOPAUDIO    10//Close Audio
#define NET_DVR_PLAYSETPOS        12//Change playing progress

typedef struct
{
    DWORD    dwSize;
    DWORD    dwPlayCmd;         /* Command of Play*/
    DWORD    dwCmdParam;         /* Parameter of Command*/
}NET_DVR_MATRIX_DEC_REMOTE_PLAY_CONTROL,  *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_CONTROL;

typedef struct
{
    DWORD dwSize;
    DWORD dwCurMediaFileLen;         /* Current file length  */
    DWORD dwCurMediaFilePosition;     /* Current file position */
    DWORD dwCurMediaFileDuration;     /* Current file duration */
    DWORD dwCurPlayTime;             /* Current playback time  */
    DWORD dwCurMediaFIleFrames;         /* Current playback frame number  */
    DWORD dwCurDataType;             /* Current stream type,  19- file header,  20-  stream data,  21- end */
    BYTE res[72];
}NET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS,  *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS;

typedef struct tagNet_DVR_IP_ADDRESS
{
    BYTE    byDevAddress[MAX_DOMAIN_NAME];    /*Dev ip*/
    WORD    wDevPort;       //dev Port
    BYTE     byres[134];
}NET_DVR_IP_ADDRESS, *LPNET_DVR_IP_ADDRESS;

typedef struct tagNet_DVR_DDNS_ADDRESS
{
    BYTE byDevAddress[MAX_DOMAIN_NAME];    /*DDNS Domain*/
    BYTE byDevDdns[MAX_DOMAIN_NAME];    /*Dev Address*/
    BYTE byDdnsType; //Domain Server type\A3\AC0-IPServer 1\A3\ADDyndns 2\A3\ADPeanutHull\A3\AC//3- NO-IP, 4- hiDDNS
    BYTE byRes1[3];
    WORD wDevPort;       //Dev Port
    WORD wDdnsPort; //Dev Server Port
    BYTE byres[64];
}NET_DVR_DDNS_ADDRESS, *LPNET_DVR_DDNS_ADDRESS;

typedef struct tagNet_DVR_PLAY_BACK_BY_TIME
{
    NET_DVR_TIME StartTime;
    NET_DVR_TIME StopTime;
}NET_DVR_PLAY_BACK_BY_TIME, *LPNET_DVR_PLAY_BACK_BY_TIME;



typedef struct tagNet_DVR_MATRIX_DEC_REMOTE_PLAY_EX
{
    DWORD    dwSize;
    DWORD    dwDecChannel;  //Decode Channal NUM
    BYTE    byAddressType;  //Device Address Type\A3\AC0-IP\A3\AC1-DDNS
    BYTE    byChannelType;  //Channal Type\A3\AC0-Normal Channal\A3\AC1-Zero Channal\A3\AC2-Stream ID
    BYTE    byres[2];
    BYTE    sUserName[NAME_LEN];        /* user */
    BYTE    sPassword[PASSWD_LEN];        /* password */
    DWORD    dwChannel;            /* Device Channal */
    BYTE    byStreamId[STREAM_ID_LEN];  //Stream ID
    DWORD    dwPlayMode;       /* 0\A3\ADPlay by name 1\A3\ADplay by time*/
    union
    {
        BYTE byRes[200];
        NET_DVR_IP_ADDRESS struIpAddr;
        NET_DVR_DDNS_ADDRESS struDdnsAddr;
    }unionAddr;

    union
    {
        BYTE byRes[128];
        NET_DVR_PLAY_BACK_BY_TIME struPlayBackByTime;
        char sFileName[128];
    }unionPlayBackInfo;
}NET_DVR_MATRIX_DEC_REMOTE_PLAY_EX, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_EX;
//Multi- channels Decoder new
typedef struct tagNET_MATRIX_PASSIVEMODE
{
    WORD    wTransProtol;         //Transfer Protocol, 0- TCP,  1- UDP,  2- MCAST
    WORD    wPassivePort;         //UDP port. When TCP,  use default value
    NET_DVR_IPADDR  struMcastIP; //Multicast address,  invalid when using TCP or UDP,
    BYTE    byStreamType; /* play mode: REAL_TIME_STREAM (1) real-time, RECORD_STREAM (2) record */
    BYTE    byRes[7];
}NET_DVR_MATRIX_PASSIVEMODE,  *LPNET_DVR_MATRIX_PASSIVEMODE;

typedef struct tagNET_DVR_MATRIX_TRAN_CHAN_INFO_V30
{
    BYTE byTranChanEnable;     /*Transparent Channel State:  0- Close,  1- Open */
    /*
                            *    Multi- channel Decoder has 1 RS485 port and 1 RS232 Port,  both of them can be transparent channel. Device Number is :
                            *    0 -  RS485
                            *    1 -  RS232 Console
                            */
    BYTE    byLocalSerialDevice;             /* Local serial device */
    /*
                                            *    Remote Serial Output Port:  one RS232 and one RS485
                                            *    1 -  RS232
                                            *    2 -  RS485
                                            */
    BYTE    byRemoteSerialDevice;             /* Remote output serial device */
    BYTE    res1;                             /* Reserved */
    // char    sRemoteDevIP[16];                 /* Remote Device IP */
    NET_DVR_IPADDR  struRemoteDevIP;
    WORD    wRemoteDevPort;                 /* Remote Net Communication Port */
    BYTE  byIsEstablished;     /* Establish Transparent channel: 0- Failure,  1- Success*/
    BYTE    res2;                     /* Reserved */
    TTY_CONFIG RemoteSerialDevCfg;
    BYTE      byUsername[NAME_LEN];          /* 32BYTES */
    BYTE       byPassword[PASSWD_LEN];      /* 16BYTES */
    DWORD   dwLocalSerialNo;
    DWORD   dwRemoteSerialNo;
    BYTE    byRes3[8];
}NET_DVR_MATRIX_TRAN_CHAN_INFO_V30, *LPNET_DVR_MATRIX_TRAN_CHAN_INFO_V30;

typedef struct tagMATRIX_TRAN_CHAN_CONFIG
{
    DWORD   dwSize;
    BYTE     by232IsDualChan;  /* Set this RS232 transparent channel as Duplex: 1 ~ MAX_SERIAL_NUM*/
    BYTE    by485IsDualChan;  /* Set this RS485 transparent channel as Duplex: 1 ~ MAX_SERIAL_NUM */
    BYTE    vyRes[2];     /* Reserved */
    NET_DVR_MATRIX_TRAN_CHAN_INFO_V30 struTranInfo[MAX_SERIAL_NUM]; /*Support MAX_SERIAL_NUM Transparent channels simultaneously*/
}NET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30, *LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30;


typedef struct
{
    DWORD                                dwEnable;     /*0- Disable,  1- Enable*/
    NET_DVR_STREAM_MEDIA_SERVER_CFG    streamMediaServerCfg;
    NET_DVR_DEV_CHAN_INFO         struDevChanInfo;         /* Loop Decoding channel info */
}NET_DVR_MATRIX_CHAN_INFO_V30, *LPNET_DVR_CYC_SUR_CHAN_ELE_V30;

typedef struct  tagMATRIX_LOOP_DECINFO_V30
{
    DWORD                            dwSize;
    DWORD                            dwPoolTime;         /*Loop Interval*/
    NET_DVR_MATRIX_CHAN_INFO_V30    struchanConInfo[MAX_CYCLE_CHAN_V30];
    BYTE                               byRes[16];
} NET_DVR_MATRIX_LOOP_DECINFO_V30, *LPNET_DVR_MATRIX_LOOP_DECINFO_V30;


typedef struct tagDEC_MATRIX_CHAN_INFO
{
    DWORD    dwSize;
    NET_DVR_STREAM_MEDIA_SERVER_CFG streamMediaServerCfg;     /*Streaming Media Server Config*/
    NET_DVR_DEV_CHAN_INFO               struDevChanInfo;         /*Decoding Channel Info  */
    DWORD    dwDecState;         /*  0- Dynamic Decoding,  1- Loop Decoding 2- Playback by time,  3- Playback by file */
    NET_DVR_TIME StartTime;         /* Start time of playback by time */
    NET_DVR_TIME StopTime;             /* End time of playback by time */
    char    sFileName[128];         /* File name for playback by file */
    DWORD   dwGetStreamMode;     /*Fetch Stream Mode: 1- Positive, 2- Passive*/
    NET_DVR_MATRIX_PASSIVEMODE      struPassiveMode;
    BYTE    byRes[32];
}NET_DVR_MATRIX_DEC_CHAN_INFO_V30, *LPNET_DVR_MATRIX_DEC_CHAN_INFO_V30;

#define MAX_RESOLUTIONNUM    64 //Max resolution number
typedef struct tagNET_DVR_MATRIX_ABILITY
{
    DWORD dwSize;
    BYTE  byDecNums;
    BYTE  byStartChan;
    BYTE  byVGANums;
    BYTE  byBNCNums;
    BYTE  byVGAWindowMode[8][12];      /*Window Mode of VGA*/
    BYTE  byBNCWindowMode[4];            /*Window Mode of BNC*/
    BYTE  byDspNums;
    BYTE  byHDMINums; //HDMI display channel number  ( start from 25)
    BYTE  byDVINums; //DVI display channel number  (start from 29)
    BYTE  byRes1[13];
    BYTE  bySupportResolution[MAX_RESOLUTIONNUM]; //resolution enable, 1: enable, 0: unenable
    BYTE  byHDMIWindowMode[4][8]; //Window-split mode supported by HDMI
    BYTE  byDVIWindowMode[4][8]; //Window-split mode supported by DVI
    BYTE  byRes2[24];
}NET_DVR_MATRIX_ABILITY,  *LPNET_DVR_MATRIX_ABILITY;
//Upload Logo
typedef struct tagNET_DVR_DISP_LOGOCFG
{
    DWORD        dwCorordinateX;     //X- coordinate for logo display
    DWORD        dwCorordinateY;     //Y- coordinate for logo display
    WORD        wPicWidth; //Picture width
    WORD        wPicHeight; //Picture height
    BYTE        byRes1[4];
    BYTE        byFlash;   //Flash or not:  1- Flash,  0- Not flash
    BYTE        byTranslucent;  //Translucence or not:  1- Yes,  0- NO
    BYTE        byRes2[6];                 //Reserved
    DWORD        dwLogoSize; //LOGO size including BMP file head
}NET_DVR_DISP_LOGOCFG, *LPNET_DVR_DISP_LOGOCFG;

/*Encoding Format*/
#define NET_DVR_ENCODER_UNKOWN         0 /*Unknown Format*/
#define NET_DVR_ENCODER_H264         1 /*private H264*/
#define NET_DVR_ENCODER_S264         2 /*Standard H264*/
#define NET_DVR_ENCODER_MPEG4         3 /*MPEG4*/
#define NET_DVR_ORIGINALSTREAM         4 /*Original Stream*/
#define NET_DVR_PICTURE                 5 /*Picture*/
#define NET_DVR_ENCODER_MJPEG         6
#define NET_DVR_ENCODER_MPEG2         7
#define NET_DVR_ENCODER_H265         8

#define NET_DVR_ENCODER_SVAC    9
#define NET_DVR_ENCODER_SMART264                   10/*Smart 264*/
#define NET_DVR_ENCODER_SMART265                   11/*Smart 265*/

/* Encapsulation Format */
#define NET_DVR_STREAM_TYPE_UNKOWN   0   /*Unknown Format*/
#define NET_DVR_STREAM_TYPE_PRIVT    1   /*private Format*/
#define NET_DVR_STREAM_TYPE_TS         7   /* TS */
#define NET_DVR_STREAM_TYPE_PS         8   /* PS */
#define NET_DVR_STREAM_TYPE_RTP         9   /* RTP */
#define NET_DVR_STREAM_TYPE_ORIGIN   10  //ORIGIN

/*State of decoding channel*/
typedef struct
{
    BYTE  byDecodeStatus;     /*Status:  0- Disabled,  1- Enabled*/
    BYTE  byStreamType;     /*Stream Type*/
    BYTE  byPacketType;     /*Encapsulation Type*/
    BYTE  byRecvBufUsage;     /*Usage of receiving buffer*/
    BYTE  byDecBufUsage;     /*Usage of decoding buffer*/
    BYTE  byFpsDecV;         /*video decoding frame*/
    BYTE  byFpsDecA;         /*audio decoding frame*/
    BYTE  byCpuLoad;         /*DSP CPU usage*/
    BYTE  byRes1[4];         //Reserved
    DWORD dwDecodedV;         /*Decoded Video Frame*/
    DWORD dwDecodedA;         /*Decoded Audio Frame*/
    WORD  wImgW;             /*Current Image size*/
    WORD  wImgH;
    BYTE  byVideoFormat;    /*inputted Video standard:  1- PAL,  2- NTSC*/
    BYTE  byRes2[3];
    DWORD  dwDecChan;       /*only valid for gettting all*/
    BYTE  byRes3[20];
}NET_DVR_MATRIX_CHAN_STATUS,  *LPNET_DVR_MATRIX_CHAN_STATUS;

/*Status of Display Channel*/
#define NET_DVR_MAX_DISPREGION  16        /*Maximum display regions of each display channel*/


//resolution
typedef enum
{
    /*VGA*/
            VGA_NOT_AVALIABLE,
    VGA_THS8200_MODE_SVGA_60HZ,     // (800*600)
    VGA_THS8200_MODE_SVGA_75HZ,     // (800*600)
    VGA_THS8200_MODE_XGA_60HZ,      // (1024*768)
    VGA_THS8200_MODE_XGA_75HZ,      // (1024*768)
    VGA_THS8200_MODE_SXGA_60HZ,     // (1280*1024)
    VGA_THS8200_MODE_720P_60HZ,     // (1280*720)
    VGA_THS8200_MODE_1080I_60HZ,    // (1920*1080)
    VGA_THS8200_MODE_1080P_30HZ,    // (1920*1080)
    VGA_THS8200_MODE_UXGA_30HZ ,    // (1600*1200)
    /*HDMI*/
            HDMI_SII9134_MODE_XGA_60HZ,     // (1024*768)
    HDMI_SII9134_MODE_SXGA_60HZ,    // (1280*1024)
    HDMI_SII9134_MODE_SXGA2_60HZ,   // (1280*960)
    HDMI_SII9134_MODE_720P_60HZ,    // (1280*720)
    HDMI_SII9134_MODE_720P_50HZ,    // (1280*720)
    HDMI_SII9134_MODE_1080I_60HZ,   // (1920*1080)
    HDMI_SII9134_MODE_1080I_50HZ,   // (1920*1080)
    HDMI_SII9134_MODE_1080P_25HZ,   // (1920*1080)
    HDMI_SII9134_MODE_1080P_30HZ,   // (1920*1080)
    HDMI_SII9134_MODE_1080P_50HZ,   // (1920*1080)
    HDMI_SII9134_MODE_1080P_60HZ,   // (1920*1080)
    HDMI_SII9134_MODE_UXGA_60HZ,    // (1600*1200)
    /*DVI*/
            DVI_SII9134_MODE_XGA_60HZ,         // (1024*768)
    DVI_SII9134_MODE_SXGA_60HZ,     // (1280*1024)
    DVI_SII9134_MODE_SXGA2_60HZ,    // (1280*960)
    DVI_SII9134_MODE_720P_60HZ,     // (1280*720)
    DVI_SII9134_MODE_720P_50HZ,     // (1280*720)
    DVI_SII9134_MODE_1080I_60HZ,    // (1920*1080)
    DVI_SII9134_MODE_1080I_50HZ,    // (1920*1080)
    DVI_SII9134_MODE_1080P_25HZ,    // (1920*1080)
    DVI_SII9134_MODE_1080P_30HZ,    // (1920*1080)
    DVI_SII9134_MODE_1080P_50HZ,    // (1920*1080)
    DVI_SII9134_MODE_1080P_60HZ,    // (1920*1080)
    DVI_SII9134_MODE_UXGA_60HZ      // (1600*1200)
}VGA_MODE;

//low frame per second
#define           LOW_DEC_FPS_1_2                51
#define           LOW_DEC_FPS_1_4                52
#define           LOW_DEC_FPS_1_8                53
#define           LOW_DEC_FPS_1_16               54

/*Video Standard*/
typedef enum
{
    VS_NON  = 0,
    VS_NTSC = 1,
    VS_PAL  = 2
}VIDEO_STANDARD;

typedef struct tagNET_DVR_VGA_DISP_CHAN_CFG
{
    DWORD    dwSize;
    BYTE    byAudio;             /*Enable Audio, 0- No, 1- Yes*/
    BYTE    byAudioWindowIdx;       /*child window of enabled audio*/
    BYTE     byVgaResolution;       /*VGA resolution*/
    BYTE    byVedioFormat;          /*Video Standard,  1: NTSC, 2: PAL, 0- NON*/
    DWORD    dwWindowMode;         /*Windows layout mode gotten from Capability Set:  1, 2, 4, 9, 16 windows*/
    BYTE    byJoinDecChan[MAX_WINDOWS]; /*Decoding channel associated by each display window*/
    BYTE    byEnlargeStatus;           /*0: Enlarge, 1: not enlarge*/
    BYTE    byEnlargeSubWindowIndex; //Sub Window Index
    union
    {
        BYTE byRes[16];
        struct
        {
            /*Decoding sub system's slot number of the display window's corresponding decoding channel number*/
            BYTE     byJoinDecoderId[MAX_WINDOWS];
        }struVideoPlatform;
        struct
        {
            BYTE     byRes[16];
        }struNotVideoPlatform;
    }struDiff;
    /*diff union, 0- video platform integrated decoder, 1-others*/
    BYTE        byUnionType;
    BYTE        byScale; /*show mode,0-real,1-zoom(BNC)*/
}NET_DVR_VGA_DISP_CHAN_CFG, *LPNET_DVR_VGA_DISP_CHAN_CFG;

/*Status of Display Channel*/
#define NET_DVR_MAX_DISPREGION 16 /*Maximum display regions of each display channel*/
typedef struct
{
    BYTE  byDispStatus;           /*Display Status: 0- No Display, 1- Enabled*/
    BYTE  byBVGA;                 /*0- BNC, 1- VGA,  2- HDMI, 3- DVI*/
    BYTE  byVideoFormat;         /*Video Standard: 1- PAL,  2- NTSC*/
    BYTE  byWindowMode;         /*Current window Layout*/
    BYTE  byJoinDecChan[MAX_WINDOWS];         /*Decoding channel of each region*/
    BYTE  byFpsDisp[NET_DVR_MAX_DISPREGION];  /*Display frame rate of each region*/
    BYTE  byRes2[32];
}NET_DVR_DISP_CHAN_STATUS,  *LPNET_DVR_DISP_CHAN_STATUS;

#define MAX_DECODECHANNUM   32//Maximum number of decoding channel
#define MAX_DISPCHANNUM   24//Maximum number of display channel
/*Decoder Status*/
typedef struct tagNET_DVR_DECODER_WORK_STATUS
{
    DWORD dwSize;
    NET_DVR_MATRIX_CHAN_STATUS struDecChanStatus[MAX_DECODECHANNUM];  /*Status of decoding channel*/
    NET_DVR_DISP_CHAN_STATUS   struDispChanStatus[MAX_DISPCHANNUM];   /*Status of display channel*/
    BYTE byAlarmInStatus[MAX_ANALOG_ALARMIN];          /*Status of Alarm input*/
    BYTE byAlarmOutStatus[MAX_ANALOG_ALARMOUT];        /*Status of Alarm output*/
    BYTE byAudioInChanStatus;           /*Status of intercom*/
    BYTE byRes[127];
}NET_DVR_DECODER_WORK_STATUS, *LPNET_DVR_DECODER_WORK_STATUS;

//2009- 12- 1 Add passive decode play control
typedef struct tagNET_DVR_PASSIVEDECODE_CONTROL
{
    DWORD    dwSize;
    DWORD    dwPlayCmd;         /* play command*/
    DWORD    dwCmdParam;         /* command parameter */
    BYTE    byRes[16]; //Reverse
}NET_DVR_PASSIVEDECODE_CONTROL, *LPNET_DVR_PASSIVEDECODE_CONTROL;

#define        PASSIVE_DEC_PAUSE                1    /*passive decode pause (only file stream valid) */
#define        PASSIVE_DEC_RESUME                2    /*passive decode resume (only file stream valid) */
#define     PASSIVE_DEC_FAST                  3   /*passive decode fast (only file stream valid) */
#define     PASSIVE_DEC_SLOW                4   /*passive decode slow (only file stream valid) */
#define     PASSIVE_DEC_NORMAL              5   /*passive decode normal*/
#define     PASSIVE_DEC_ONEBYONE              6   /*passive decode one by one (reserved) */
#define     PASSIVE_DEC_AUDIO_ON             7   /*passive decode open audio*/
#define     PASSIVE_DEC_AUDIO_OFF            8      /*passive decode close audio*/
#define        PASSIVE_DEC_RESETBUFFER            9   /*reset buffer */

//2009- 12- 16 scale control
typedef struct tagNET_DVR_MATRIX_DECCHAN_CONTROL
{
    DWORD    dwSize;
    BYTE    byDecChanScaleStatus; /*decode channel scale control, 1: scale display, 0: real display*/
    BYTE    byDecodeDelay;//Decoding delay: 0- default, 1- most real-time, 2- more real-time, 3- real-time and fluency, 4- more fluency, 5- most fluency, 0xff- automatically adjust
    BYTE    byEnableSpartan;//motion fluency\A3\AC0-off\A3\AC1-on
    BYTE    byLowLight;      //low light, 0-close, 1-8 means low light level, the level is larger ,the power is bigger
    BYTE    byNoiseReduction; //3D reduce noise, 0-close, 1-open, 2-auto
    BYTE    byDefog;         //consumption, 0-close 1-7 means level, the larger, the more power
    BYTE    byEnableVcaDec;    //decode show vca information\A3\AC0-close\A3\AC1-open
    BYTE    byRes1;
    DWORD   dwAllCtrlType;    //all window control type,valid for setting,each bit reference to one operation
    //dwAllCtrlType & 0x01, switch for vca decoding
    BYTE    byRes[56];
}NET_DVR_MATRIX_DECCHAN_CONTROL, *LPNET_DVR_MATRIX_DECCHAN_CONTROL;

/************************************Decoder (end) ***************************************/

typedef struct
{    /* 12 bytes */
    DWORD    dwSize;
    char    sUserName[32];
    char     sPassWord[32];
    char     sFromName[32];             /* Sender */
    char     sFromAddr[48];             /* Sender address */
    char     sToName1[32];             /* Receiver1 */
    char     sToName2[32];             /* Receiver2 */
    char     sToAddr1[48];             /* Receiver address1 */
    char     sToAddr2[48];             /* Receiver address2 */
    char    sEmailServer[32];         /* Email server address */
    BYTE    byServerType;             /* Email server type:  0- SMTP,  1- POP,  2- IMTP...*/
    BYTE    byUseAuthen;             /* Email server authentication method:  1- enable,  0- disable */
    BYTE    byAttachment;             /* enable attachment */
    BYTE    byMailinterval;         /* mail interval 0- 2s,  1- 3s,  2- 4s. 3- 5s*/
} NET_DVR_EMAILCFG,  *LPNET_DVR_EMAILCFG;

typedef struct
{
    DWORD dwSize;
    NET_DVR_COMPRESSION_INFO_EX  struLowCompression;     // Time Record
    NET_DVR_COMPRESSION_INFO_EX  struEventCompression;     //  Triggered by events
}NET_DVR_COMPRESSIONCFG_NEW,  *LPNET_DVR_COMPRESSIONCFG_NEW;

//Position info of Speed Dome
typedef struct
{
    WORD wAction; //invalid
    WORD wPanPos; //pan position
    WORD wTiltPos; //tilt position
    WORD wZoomPos; //zoom position
}NET_DVR_PTZPOS,  *LPNET_DVR_PTZPOS;

//PTZ Scope Structure
typedef struct
{
    WORD wPanPosMin; //min pan position
    WORD wPanPosMax; //max pan position
    WORD wTiltPosMin; //min tilt position
    WORD wTiltPosMax; //max tilt position
    WORD wZoomPosMin; //min zoom factor
    WORD wZoomPosMax; //max zoom factor
}NET_DVR_PTZSCOPE,  *LPNET_DVR_PTZSCOPE;

//rtsp Configuration (Special for IP camera)
typedef struct
{
    DWORD dwSize;          //Length
    WORD  wPort;           //rtsp Port
    BYTE  byReserve[54];   //Reserved
}NET_DVR_RTSPCFG,  *LPNET_DVR_RTSPCFG;


/********************************Interface Parameters Structure (begin) *********************************/

//NET_DVR_Login ()
typedef struct
{
    BYTE sSerialNumber[SERIALNO_LEN];   //SN
    BYTE byAlarmInPortNum;                 //DVR Alarm input
    BYTE byAlarmOutPortNum;             //DVR Alarm Output
    BYTE byDiskNum;                     //DVR Number of Hard Disk
    BYTE byDVRType;                     //DVR Type,  1: DVR 2: ATM DVR 3: DVS ......
    BYTE byChanNum;                     //DVR Number of Channel
    BYTE byStartChan;                     //The first Channel No. E.g. DVS- 1, DVR- 1
}NET_DVR_DEVICEINFO,  *LPNET_DVR_DEVICEINFO;

//NET_DVR_Login_V30 ()
typedef struct
{
    BYTE sSerialNumber[SERIALNO_LEN];    //SN
    BYTE byAlarmInPortNum;                 //Number of Alarm input
    BYTE byAlarmOutPortNum;                 //Number of Alarm Output
    BYTE byDiskNum;                         //Number of Hard Disk
    BYTE byDVRType;                         //DVR Type,  1: DVR 2: ATM DVR 3: DVS ......
    BYTE byChanNum;                         //Number of Analog Channel
    BYTE byStartChan;                     //The first Channel No. E.g. DVS- 1, DVR- 1
    BYTE byAudioChanNum;                 //Number of Audio Channel
    BYTE byIPChanNum;                     //Maximum number of IP Channel  low
    BYTE byZeroChanNum;             //Zero channel encoding number//2010- 01- 16
    BYTE byMainProto;             //Main stream transmission protocol 0- private,  1- rtsp,2-both private and rtsp
    BYTE bySubProto;                 //Sub stream transmission protocol 0- private,  1- rtsp,2-both private and rtsp
    BYTE bySupport;         //Ability, the 'AND' result by bit: 0- not support;  1- support
    //bySupport & 0x1,  smart search
    //bySupport & 0x2,  backup
    //bySupport & 0x4,  get compression configuration ability
    //bySupport & 0x8,  multi network adapter
    //bySupport & 0x10, support remote SADP
    //bySupport & 0x20  support Raid card
    // bySupport & 0x40 support IPSAN directory search
    BYTE bySupport1;        // Ability expand, the 'AND' result by bit: 0- not support;  1- support
    // bySupport1 & 0x1, support snmp v30
    // bySupport1& 0x2\A3\ACsupport distinguish download and playback
    //bySupport1 & 0x4, support deployment level
    //bySupport1 & 0x8, support vca alarm time extension
    //bySupport1 & 0x10, support muti disks(more than 33)
    //bySupport1 & 0x20, support rtsp over http
    //bySupport1 & 0x40, support delay preview
    //bySuppory1 & 0x80 support NET_DVR_IPPARACFG_V40, in addition  support  License plate of the new alarm information
    BYTE bySupport2;        // Ability expand, the 'AND' result by bit: 0- not support;  1- support
    //bySupport & 0x1, decoder support get stream by URL
    //bySupport2 & 0x2,  support FTPV40
    //bySupport2 & 0x4,  support ANR
    //bySupport2 & 0x20, support get single item of device status
    //bySupport2 & 0x40,  support stream encryt
    WORD wDevType;              //device type
    BYTE bySupport3;        //Support  epresent by bit, 0 - not support 1 - support
    //bySupport3 & 0x1-muti stream support
    //bySupport3 & 0x8  support use delay preview parameter when delay preview
    //bySupport3 & 0x10 support the interface of getting alarmhost main status V40
    BYTE byMultiStreamProto;//support multi stream, represent by bit, 0-not support ;1- support; bit1-stream 3 ;bit2-stream 4, bit7-main stream, bit8-sub stream
    BYTE byStartDChan;        //Start digital channel
    BYTE byStartDTalkChan;    //Start digital talk channel
    BYTE byHighDChanNum;        //Digital channel number high
    BYTE bySupport4;        //Support  epresent by bit, 0 - not support 1 - support
    //bySupport4 & 0x4 whether support video wall unified interface
    // bySupport4 & 0x80 Support device upload center alarm enable
    BYTE byLanguageType;    // support language type by bit,0-support,1-not support
    //  byLanguageType 0 -old device
    //  byLanguageType & 0x1 support chinese
    //  byLanguageType & 0x2 support english
    BYTE byVoiceInChanNum;   //voice in chan num
    BYTE byStartVoiceInChanNo; //start voice in chan num
    BYTE  bySupport5;  //0-no support,1-support,bit0-muti stream
    //bySupport5 &0x01support wEventTypeEx
    //bySupport5 &0x04support sence expend
    BYTE  bySupport6;
    BYTE  byMirrorChanNum;    //mirror channel num\A3\AC<it represents direct channel in the recording host>
    WORD  wStartMirrorChanNo;  //start mirror chan
    BYTE bySupport7;        //Support  epresent by bit, 0 - not support 1 - support
    //bySupport7 & 0x1- supports INTER_VCA_RULECFG_V42 extension
    // bySupport7 & 0x2  Supports HVT IPC mode expansion
    // bySupport7 & 0x04  Back lock time
    // bySupport7 & 0x08  Set the pan PTZ position, whether to support the band channel
    // bySupport7 & 0x10  Support for dual system upgrade backup
    // bySupport7 & 0x20  Support OSD character overlay V50
    // bySupport7 & 0x40  Support master slave tracking (slave camera)
    // bySupport7 & 0x80  Support message encryption
    BYTE  byRes2;
}NET_DVR_DEVICEINFO_V30,  *LPNET_DVR_DEVICEINFO_V30;

typedef struct tagNET_DVR_DEVICEINFO_V40
{
    NET_DVR_DEVICEINFO_V30 struDeviceV30;
    BYTE  bySupportLock;        //the device support lock function\A3\ACthis byte assigned by SDK\A1\A3when bySupportLock is 1\A3\ACdwSurplusLockTime and byRetryLoginTime is valid
    BYTE  byRetryLoginTime;        //retry login times
    BYTE  byPasswordLevel;      //PasswordLevel,0-invalid,1-default password,2-valid password,3-risk password
    BYTE  byProxyType;  //Proxy Type\A3\AC0-not use proxy, 1-use socks5 proxy, 2-use EHome proxy
    DWORD dwSurplusLockTime;    //surplus locked time
    BYTE  byCharEncodeType;     //character encode type
    BYTE  bySupportDev5;//Support v50 version of the device parameters, device name and device type name length is extended to 64 bytes
    BYTE  byRes2[254];
}NET_DVR_DEVICEINFO_V40, *LPNET_DVR_DEVICEINFO_V40;

//sdk Network environment,  for update
typedef enum _SDK_NET_ENV
{
    LOCAL_AREA_NETWORK = 0,
    WIDE_AREA_NETWORK
}SDK_NETWORK_ENVIRONMENT;

//Display Mode
typedef enum
{
    NORMALMODE = 0,
    OVERLAYMODE
}DISPLAY_MODE;

//Send Mode
typedef enum
{
    PTOPTCPMODE = 0,
    PTOPUDPMODE,
    MULTIMODE,
    RTPMODE,
    RESERVEDMODE
}SEND_MODE;

//Grub Mode
typedef enum
{
    BMP_MODE  = 0,         //BMP Mode
    JPEG_MODE = 1        //JPEG Mode
}CAPTURE_MODE;

//Real time Audio mode
typedef enum
{
    MONOPOLIZE_MODE = 1, //exclusive mode
    SHARE_MODE      = 2     //shared mode
}REALSOUND_MODE;

//Preview via software decoding
typedef struct
{
    LONG  lChannel; //channel no.
    LONG  lLinkMode; //If 31st bit is 0,  it means connect main stream,  is 1 means sub stream. Bit 0~bit 30 are used for link mode:  0:  TCP mode,  1:  UDP mode,  2:  Multi- play mode,  3:  RTP mode,4-RTP/RTSP,5-RSTP/HTTP
    HWND  hPlayWnd; // the play window's handle;  set NULL to disable preview
    char* sMultiCastIP;  //Multicast group
    BYTE byProtoType; //0-private protocol\A3\AC1-RTSP protocol
    BYTE byRes[3];
}NET_DVR_CLIENTINFO,  *LPNET_DVR_CLIENTINFO;

typedef struct tagNET_DVR_PREVIEWINFO{
    LONG    lChannel;         // Channel no.
    DWORD    dwStreamType;    // Stream type 0-main stream\A3\AC1-sub stream\A3\AC2-third stream\A3\AC3-forth stream, and so on
    DWORD    dwLinkMode;        // Protocol type: 0-TCP, 1-UDP, 2-Muticast, 3-RTP\A3\AC4-RTP/RTSP, 5-RSTP/HTTP
    HWND    hPlayWnd;        // Play window's handle;  set NULL to disable preview
    DWORD bBlocked;          //If data stream requesting process is blocked or not: 0-no, 1-yes
    //if true, the SDK Connect failure return until 5s timeout  , not suitable for polling to preview.
    DWORD bPassbackRecord; //0- not enable  ,1 enable
    BYTE byPreviewMode;    // Preview mode 0-normal preview\A3\AC2-delay preview
    BYTE byStreamID[STREAM_ID_LEN/*32*/];//Stream ID
    BYTE byProtoType; //0-private,1-RTSP
    BYTE byRes1;
    BYTE byVideoCodingType;
    DWORD dwDisplayBufNum; //soft player display buffer size(number of frames), range:1-50, default:1
    BYTE byRes[216];
}NET_DVR_PREVIEWINFO, *LPNET_DVR_PREVIEWINFO;

//SDK information (9000 added)
typedef struct
{
    DWORD dwTotalLoginNum;         //current login user operation number
    DWORD dwTotalRealPlayNum;     //current real play operation number
    DWORD dwTotalPlayBackNum;     //current playback or download operation number
    DWORD dwTotalAlarmChanNum;     //current alarm channel operation number
    DWORD dwTotalFormatNum;         //current HDD format operation number
    DWORD dwTotalFileSearchNum;     //current files search operation number
    DWORD dwTotalLogSearchNum;     //current logs search operation number
    DWORD dwTotalSerialNum;         //current transparent series port operation number
    DWORD dwTotalUpgradeNum;     //current upgrading operation number
    DWORD dwTotalVoiceComNum;     //current network voice communication operation number
    DWORD dwTotalBroadCastNum;     //current network broadcast voice communication operation number
    DWORD dwTotalListenNum;         //current net listen operation number
    DWORD dwEmailTestNum;        //current E- mail test operation number
    DWORD dwBackupNum;           //current backup  operation number
    DWORD dwTotalInquestUploadNum;  //current inquest upload operation number
    DWORD dwRes[6];
}NET_DVR_SDKSTATE,  *LPNET_DVR_SDKSTATE;

//SDK Ability Information  (9000 added)
typedef struct
{
    DWORD dwMaxLoginNum;         //maximum login user operation number MAX_LOGIN_USERS
    DWORD dwMaxRealPlayNum;         //maximum realplay operation number WATCH_NUM
    DWORD dwMaxPlayBackNum;         //maximum playback or download operation number WATCH_NUM
    DWORD dwMaxAlarmChanNum;     //maximum alarm channel operation number ALARM_NUM
    DWORD dwMaxFormatNum;         //maximum HDD format operation number SERVER_NUM
    DWORD dwMaxFileSearchNum;     //maximum files search operation number SERVER_NUM
    DWORD dwMaxLogSearchNum;     //maximum logs search operation number SERVER_NUM
    DWORD dwMaxSerialNum;         //maximum transparent series port operation number SERVER_NUM
    DWORD dwMaxUpgradeNum;         //maximum current upgrading operation number SERVER_NUM
    DWORD dwMaxVoiceComNum;         //maximum network voice communication operation number SERVER_NUM
    DWORD dwMaxBroadCastNum;     //maximum network broadcast voice communication operation number MAX_CASTNUM
    DWORD dwRes[10];
}NET_DVR_SDKABL,  *LPNET_DVR_SDKABL;

//Alarm Device Infor
typedef struct
{
    BYTE byUserIDValid;                  /* Whether userID is valid,  0- invalid 1- valid. */
    BYTE bySerialValid;                  /* Whether serial number is valid,  0- invalid 1- valid.  */
    BYTE byVersionValid;                 /* Whether version number is valid,  0- invalid 1- valid. */
    BYTE byDeviceNameValid;              /* Whether device name is valid,  0- invalid 1- valid. */
    BYTE byMacAddrValid;                 /* Whether MAC address is valid,  0- invalid 1- valid. */
    BYTE byLinkPortValid;                /* Whether login port number is valid,  0- invalid 1- valid. */
    BYTE byDeviceIPValid;                /* Whether device IP is valid,  0- invalid 1- valid.*/
    BYTE bySocketIPValid;                /* Whether socket IP is valid,  0- invalid 1- valid. */
    LONG lUserID;                        /* NET_DVR_Login () effective when establishing alarm upload channel*/
    BYTE sSerialNumber[SERIALNO_LEN];     /* Serial number. */
    DWORD dwDeviceVersion;                 /* Version number,  2 high byte means the major version,  2 low byte means the minor version*/
    char sDeviceName[NAME_LEN];             /* Device name. */
    BYTE byMacAddr[MACADDR_LEN];         /* MAC address */
    WORD wLinkPort;                      /* link port */
    char sDeviceIP[128];                 /* IP address */
    char sSocketIP[128];                 /* alarm push- mode socket IP address. */
    BYTE byIpProtocol;                   /* IP protocol:  0- IPV4;  1- IPV6. */
    BYTE byRes2[11];
}NET_DVR_ALARMER,  *LPNET_DVR_ALARMER;

//Display Area Parameter of Hardware Decoding (Sub Structure)
typedef struct
{
    long bToScreen;
    long bToVideoOut;
    long nLeft;
    long nTop;
    long nWidth;
    long nHeight;
    long nReserved;
}NET_DVR_DISPLAY_PARA,  *LPNET_DVR_DISPLAY_PARA;

//Preview Parameter of Hardware Decoding
typedef struct
{
    LONG lChannel; // Channel No.
    LONG lLinkMode;  //0-  TCP;  1-  UDP;  2-  Multicast;  3-  RTP;  4-  PPPoE;  5-  128k;  6-  256k;  7-  384k;  8-  512k
    char* sMultiCastIP;
    NET_DVR_DISPLAY_PARA struDisplayPara;
}NET_DVR_CARDINFO,  *LPNET_DVR_CARDINFO;

//Record Parameters
typedef struct
{
    char sFileName[100]; // File Name
    NET_DVR_TIME struStartTime; //Start time of the file
    NET_DVR_TIME struStopTime; //End time of the file
    DWORD dwFileSize; //File size
}NET_DVR_FIND_DATA,  *LPNET_DVR_FIND_DATA;

//Record Parameters (9000)
typedef struct
{
    char sFileName[100]; //File Name
    NET_DVR_TIME struStartTime; //Start time of the file
    NET_DVR_TIME struStopTime; //End time of the file
    DWORD dwFileSize; //File size
    char sCardNum[32];
    BYTE byLocked; //9000 DVR supports this, 1- file is locked, 0- file is Normal
    BYTE byFileType;   //File Type:  0:  scheduled record,  1:  Motion detection,  2:  alarm record,  3:  motion detection| alarm,  4:  motion detection & alarm 5:  command trigger,  6:  manually record
    //9-VCA alarm,10-PIR alarm,11-wireless alarm,12-callhelp alarm,14-Intelligent Transportation
    BYTE byRes[2];
}NET_DVR_FINDDATA_V30,  *LPNET_DVR_FINDDATA_V30;

typedef struct
{
    char sFileName[100];
    NET_DVR_TIME struStartTime;
    NET_DVR_TIME struStopTime;
    DWORD dwFileSize;
    char sCardNum[32];
    BYTE byLocked;
    BYTE byFileType;
    BYTE byQuickSearch;
    BYTE byRes;
    DWORD dwFileIndex;
    BYTE byStreamType;
    BYTE byRes1[127];
}NET_DVR_FINDDATA_V40, *LPNET_DVR_FINDDATA_V40;

//Record Parameters (with Card No.)
typedef struct
{
    char sFileName[100]; //File Name
    NET_DVR_TIME struStartTime; //Start time of the file
    NET_DVR_TIME struStopTime; //End time of the file
    DWORD dwFileSize; //File size
    char sCardNum[32];
}NET_DVR_FINDDATA_CARD,  *LPNET_DVR_FINDDATA_CARD;


//Record Query Condition
typedef struct
{
    LONG lChannel; //channel number
    DWORD dwFileType; /*file record mode: 0xff - all,  0 - scheduled record,  1 - Motion detection,  2 - alarm record,  3:  motion detection| alarm,
                                      4 - motion detection & alarm, 5 - command trigger,  6 - manually record,7-VCA record,10-PIR alarm,11-wireless alarm,12-callhelp alarm,13-all Event alarm,14-Intelligent Transportation*/
    DWORD dwIsLocked; //whether file is locked,  0- normal;  1- locked;  0xff- all
    DWORD dwUseCardNo; //whether card no. is used
    BYTE sCardNumber[32]; //card no.
    NET_DVR_TIME struStartTime; //start time
    NET_DVR_TIME struStopTime; //end time
}NET_DVR_FILECOND,  *LPNET_DVR_FILECOND;


// PTZ Image Zooming  (Special for private Speed dome)
typedef struct
{
    int xTop;      //x coordinate of the origination point of the pane
    int yTop;      //y coordinate of the origination point of the pane
    int xBottom;   //x coordinate of the end point of the pane
    int yBottom;   //y coordinate of the end point of the pane
    int bCounter;  //reserve
}NET_DVR_POINT_FRAME,  *LPNET_DVR_POINT_FRAME;

//audio encode type
typedef struct tagNET_DVR_COMPRESSION_AUDIO
{
    BYTE  byAudioEncType;    //AudioTalk Code Type 0-G722; 1-G711_U; 2-G711_A;5-MP2L2;6-G726;7-AAC,8-PCM
    BYTE  byAudioSamplingRate;//audio sample rate 0-default,1-16kHZ,2-32kHZ,3-48kHZ,4- 44.1kHZ,5-8kHZ
    BYTE  byAudioBitRate;// audio bitrate see BITRATE_ENCODE_INDEX
    BYTE  byres[4];//
    BYTE  bySupport;//bySupport Bit0- mp2l2 data is random length
}NET_DVR_COMPRESSION_AUDIO,  *LPNET_DVR_COMPRESSION_AUDIO;

//2009- 7- 22
#define IW_ESSID_MAX_SIZE                         32
#define WIFI_WEP_MAX_KEY_COUNT                     4
#define WIFI_WEP_MAX_KEY_LENGTH                     33
#define WIFI_WPA_PSK_MAX_KEY_LENGTH                 63
#define WIFI_WPA_PSK_MIN_KEY_LENGTH                 8
#define WIFI_MAX_AP_COUNT                         20
#define WIFI_WPA_PSK_MAX_HEXKEY_LENGTH           68   //WPA Hex Key Len

typedef struct tagNET_DVR_AP_INFO
{
    char  sSsid[IW_ESSID_MAX_SIZE];
    DWORD  dwMode;                         /* 0- mange mode; 1 ad- hoc mode, plz refer to NICMODE */
    DWORD  dwSecurity;            /*0 - not encrypted;  1 wep encrypted;  2 wpa- psk; 3 wpa- Enterprise; 4-WPA2_PSK;refer to WIFISECURITY*/
    DWORD  dwChannel;             /*1-11,  stands for 11 channels*/
    DWORD  dwSignalStrength;     /* Signal strength, 0 (lowest)- 100 (highest)*/
    DWORD  dwSpeed;                /* Signal speed, unit: 0.01mbps*/
}NET_DVR_AP_INFO, *LPNET_DVR_AP_INFO;

typedef struct tagNET_DVR_AP_INFO_LIST
{
    DWORD dwSize;
    DWORD dwCount;         /*Wireless AP number, should be less than 20*/
    NET_DVR_AP_INFO struApInfo[WIFI_MAX_AP_COUNT];
}NET_DVR_AP_INFO_LIST, *LPNET_DVR_AP_INFO_LIST;

typedef struct tagNET_DVR_WIFIETHERNET
{
    char    sIpAddress[16];                 /*IP*/
    char    sIpMask[16];                     /*Sub net mask*/
    BYTE    byMACAddr[MACADDR_LEN];         /*Physical address, read-only*/
    BYTE    byCloseWifi;        //whether close wifi\A3\AC0-not close\A3\AC1-close
    BYTE    bRes;
    DWORD    dwEnableDhcp;                 /*DHCP: 0-disable;  1- enable*/
    DWORD    dwAutoDns;                     /*Get DNS automatically after enable DHCP: 0-disable;  1-enable;  for cable network, DHCP will be set as 'get DNS automatically' mode*/
    char    sFirstDns[16];                          /*Preferred DNS*/
    char    sSecondDns[16];                      /*Alternate DNS*/
    char    sGatewayIpAddr[16];                  /*Network Gateway*/
    BYTE    bRes2[8];
}NET_DVR_WIFIETHERNET, *LPNET_DVR_WIFIETHERNET;

typedef struct tagNET_DVR_WIFI_CFG_EX
{
    NET_DVR_WIFIETHERNET struEtherNet;         /*WIFI port*/
    char sEssid[IW_ESSID_MAX_SIZE];      /*SSID*/
    DWORD dwMode;       /* 0- mange  mode; 1 ad- hoc mode*/
    DWORD dwSecurity;  /*0- no encryption; 1- wep encryption; 2 wpa- psk;3-WPA_ENTPRISE;4-WPA2_PSK,5-WPA2_ENTPRISE  */
    union
    {
        struct
        {
            DWORD dwAuthentication; /*0 - open mode;  1- share mode*/
            DWORD dwKeyLength; /* 0 - 64 bit;  1-  128bit;  2- 152 bit*/
            DWORD dwKeyType; /*0-HEX;  1-ASCI */
            DWORD dwActive; /*0- index: 0- - - 3 stands for the KEY mode*/
            char sKeyInfo[WIFI_WEP_MAX_KEY_COUNT][WIFI_WEP_MAX_KEY_LENGTH];
        }wep;
        struct
        {
            DWORD dwKeyLength; /*8~ 63 ASCII characters*/
            char sKeyInfo[WIFI_WPA_PSK_MAX_KEY_LENGTH];
            BYTE byEncryptType;  /*WPA/WPA2:0-AES, 1-TKIP*/
            char sNewKeyInfo[WIFI_WPA_PSK_MAX_HEXKEY_LENGTH/*68*/];//64bit WPA Hex Key
            BYTE byKeyType;//Key Type
            BYTE byRes[7];
        }wpa_psk;
        struct
        {
            BYTE byEncryptType;  /*encry type,0-AES, 1-TKIP*/
            BYTE byAuthType; //auth type 0-EAP_TTLS,1-EAP_PEAP,2-EAP_TLS
            BYTE byRes[2];
            union
            {
                struct
                {
                    BYTE byEapolVersion; //EAPOL version,0-version1,1-version2
                    BYTE byAuthType; //inter auth type\A3\AC0-PAP\A3\AC1-MSCHAPV2
                    BYTE byRes1[2];
                    BYTE byAnonyIdentity [NAME_LEN]; //anony identity
                    BYTE byUserName[NAME_LEN];
                    BYTE byPassword[NAME_LEN];
                    BYTE byRes[44];
                }EAP_TTLS; //WPA-enterprise/WPA2-enterpris mode
                struct
                {
                    BYTE byEapolVersion; //EAPOL version,0-version1,1-version2
                    BYTE byAuthType; //inter auth type\A3\AC0-PAP\A3\AC1-MSCHAPV2
                    BYTE byPeapVersion; //PEAP version,0-version0,1-version1
                    BYTE byPeapLabel; //PEAP label\A3\AC0-old label,1-new label
                    BYTE byAnonyIdentity[NAME_LEN]; //anony identity
                    BYTE byUserName[NAME_LEN];
                    BYTE byPassword[NAME_LEN];
                    BYTE byRes[44];
                }EAP_PEAP; //WPA-enterprise/WPA2-enterpris mode
                struct
                {
                    BYTE byEapolVersion; //EAPOL version,0-version1,1-version2
                    BYTE byRes1[3];
                    BYTE byIdentity[NAME_LEN]; //idetity
                    BYTE byPrivateKeyPswd[NAME_LEN];
                    BYTE byRes[76];
                }EAP_TLS;
            }auth_param;
        }wpa_wpa2; //WPA-enterprise/WPA2-enterpris mode
    }key;
}NET_DVR_WIFI_CFG_EX, *LPNET_DVR_WIFI_CFG_EX;

//WIFI configuration structure
typedef struct tagNET_DVR_WIFI_CFG
{
    DWORD dwSize;
    NET_DVR_WIFI_CFG_EX struWifiCfg;
}NET_DVR_WIFI_CFG, *LPNET_DVR_WIFI_CFG;

//wifi connection status
typedef     struct  tagNET_DVR_WIFI_CONNECT_STATUS
{
    DWORD        dwSize;
    BYTE        byCurStatus;    //1-connected,2-unconnected,3-connecting
    BYTE        byRes1[3];
    DWORD        dwErrorCode;    // valid when byCurStatus=2,1-username or password error,2-the router is nonexistent,3-unknown error
    BYTE        byRes[244];
}NET_DVR_WIFI_CONNECT_STATUS,*LPNET_DVR_WIFI_CONNECT_STATUS;

//WIFI working mode
typedef struct tagNET_DVR_WIFI_WORKMODE
{
    DWORD dwSize;
    DWORD dwNetworkInterfaceMode;  /*0- auto switch mode;  1- cable network*/
}NET_DVR_WIFI_WORKMODE, *LPNET_DVR_WIFI_WORKMODE;


//Structure parameters
#define VCA_MAX_POLYGON_POINT_NUM        10        //Support polygon with up to 10 coordinates
#define MAX_RULE_NUM                    8        //Max. rule number
#define MAX_RULE_NUM_V42                16       //Max. rule number Expansion
#define MAX_TARGET_NUM                    30        //Max. target number
#define MAX_CALIB_PT                     6        //Max. calibration number
#define MIN_CALIB_PT                     4        //Min. calibration number
#define MAX_TIMESEGMENT_2                2        //Max. time periods number
#define DATA_INDEX_LEN                  64      //Data Index
#define MAX_TRAFFIC_PICTURE_NUM         8      //Traffic Picture Num
#define MAX_LICENSE_LEN                    16        //Max. length of the license number
#define MAX_CARDNO_LEN                  48      //Max. Card No. 2013-11-04
#define MAX_DEBUGCMD_LEN                1024    //Debug CMD Len
#define MAX_DEBUGINFO_LEN               1400    //Debug Info Len
#define MAX_OPERATE_INDEX_LEN           32      //Max. Operate Index 2014-03-03
#define MAX_PLATE_NUM                    3        //license plate number
#define MAX_MASK_REGION_NUM                4       //Max. 4 mask area
#define MAX_SEGMENT_NUM                    6       //Max. segment number for camera calibration
#define MIN_SEGMENT_NUM                    3       //Min. segment number for camera calibration
#define MAX_REL_SNAPCHAN_NUM            3       //Max. relate snap channel number
#define MAX_PIC_SWITCH_STORAGE_SERVER   64      //Max. Storage Server Picture Type
#define MAX_INFO_SWITCH_STORAGE_SERVER  64      //Max. Storage Server Add Info Type
#define RTMP_URL_LEN                    128     //RTMP URL Len
#define MAX_ID_LEN_128                  128     //ID Len 128
#define MAX_VEHICLE_ID_LEN              32      //Max length of  vehicle ID
#define LEN_PROPERTY                    128
//Intelligent config info
#define MAX_VCA_CHAN  16//Max. intelligent channel number
typedef struct tagNET_VCA_CTRLINFO
{
    BYTE   byVCAEnable;     //enable or disable intelligent function
    BYTE   byVCAType;       //intelligent analysis mode, VCA_CHAN_ABILITY_TYPE
    BYTE   byStreamWithVCA; //include intelligent info in video stream
    BYTE   byMode;          //VCA_CHAN_MODE_TYPE for ATM intelligent analysis,TFS_CHAN_MODE_TYPE for TFS intelligent analysis
    BYTE   byControlType;   //control type,0-no,1-yes
    // byControlType &1 enable snap
    BYTE   byPicWithVCA ;   //Alarm drawings superimposed target information (the target frame)
    BYTE   byRes[2];        //Reserved as 0
}NET_VCA_CTRLINFO,  *LPNET_VCA_CTRLINFO;

//Intelligent config info structure
typedef struct tagNET_VCA_CTRLCFG
{
    DWORD dwSize;
    NET_VCA_CTRLINFO  struCtrlInfo[MAX_VCA_CHAN];      //Config info, array 0 is corresponding to the 1st channel of the system
    BYTE byRes[16];
}NET_VCA_CTRLCFG,  * LPNET_VCA_CTRLCFG;

//Intelligent device ability set
typedef struct tagNET_VCA_DEV_ABILITY
{
    DWORD dwSize;                //structure length
    BYTE byVCAChanNum;            //intelligent channel number
    BYTE byPlateChanNum;         //LPR channel number
    BYTE byBBaseChanNum;        //Basic VCA number
    BYTE byBAdvanceChanNum;    //Advanced VCA number
    BYTE byBFullChanNum;       //Complete VCA number
    BYTE byATMChanNum;            //Intelligent ATM number
    BYTE byPDCChanNum;         //PDC channel number
    BYTE byITSChanNum;         //Traffic event analysis channel number
    BYTE byBPrisonChanNum;        //VCA (prison surveillance version) channel number
    BYTE byFSnapChanNum;       //Face snap channel number
    BYTE byFSnapRecogChanNum;  //Face snap and recognize channel number
    BYTE byFRetrievalChanNum;  //Face retrieval channel number
    BYTE bySupport;            //ability, bit, 0-not support,1-support
    //bySupport & 0x1,support track 2012-3-22
    //bySupport & 0x2,support 128 channel 2012-12-27
    BYTE byFRecogChanNum;      //Face recognize channel number
    BYTE byBPPerimeterChanNum; //prison perimeter channel number
    BYTE byTPSChanNum;         //Traffic TPS channel number
    BYTE byTFSChanNum;         //Traffic TFS channel number
    BYTE byFSnapBFullChanNum;  //Face capture & behavioural analysis channel number
    BYTE byHeatMapChanNum;     //Heat Map Chan Num
    BYTE bySmartVehicleNum;  //SMART+Vehicle detection Chan Num
    BYTE bySmartHVTNum;     //SMART+HVT Chan Num
    BYTE bySmartNum;          //SMART  Num
    BYTE byVehicleNum;        //Vehicle detection Chan Num
    BYTE bySmartRoadDetectionNum ; // SMART+Road Detection Chan Num
    BYTE bySmartFaceDetectionNum ; // SMART+Face Detection Chan Num
    BYTE bySmartHeatMapNum ; // SMART+Heat Map Chan Num
    BYTE byRes[14];
}NET_VCA_DEV_ABILITY,  *LPNET_VCA_DEV_ABILITY;


//VCA Abilities Set
typedef enum _VCA_ABILITY_TYPE_
{
    TRAVERSE_PLANE_ABILITY       = 0x01,        //traverse plane
    ENTER_AREA_ABILITY           = 0x02,        //Enter area
    EXIT_AREA_ABILITY            = 0x04,        //Leave area
    INTRUSION_ABILITY            = 0x08,        //Intrusion
    LOITER_ABILITY               = 0x10,        //Loitering
    LEFT_TAKE_ABILITY            = 0x20,        //Object left/take
    PARKING_ABILITY              = 0x40,        //Illegal parking
    RUN_ABILITY                  = 0x80,        //Running
    HIGH_DENSITY_ABILITY         = 0x100,       //People density
    LF_TRACK_ABILITY             = 0x200,       //Auto-tracking of the speed dome
    VIOLENT_MOTION_ABILITY         = 0x400,         //Violent motion
    REACH_HIGHT_ABILITY             = 0x800,         //Reach High
    GET_UP_ABILITY                 = 0x1000,         //Get up
    LEFT_ABILITY                 = 0x2000,      //Item left
    TAKE_ABILITY                 = 0x4000,      //Item take
    LEAVE_POSITION               = 0x8000,      //Leave position
    TRAIL_ABILITY                = 0x10000,     //Trial
    KEY_PERSON_GET_UP_ABILITY    = 0x20000,     //Key person get up
    STANDUP_ABILITY              = 0x40000,     //Stand Up
    FALL_DOWN_ABILITY            = 0x80000,     //Fall down
    AUDIO_ABNORMAL_ABILITY       = 0x100000,    //Audio abnormal
    ADV_REACH_HEIGHT_ABILITY     = 0x200000,    //Advance reach height
    TOILET_TARRY_ABILITY         = 0x400000,    //Toilet tarry
    YARD_TARRY_ABILITY           = 0x800000,    //Yard tarry
    ADV_TRAVERSE_PLANE_ABILITY   = 0x1000000,   //Advance traverse plane
    LECTURE_ABILITY                 = 0x2000000,   //Teaching
    ANSWER_ABILITY                 = 0x4000000,   //Answer
    HUMAN_ENTER_ABILITY          = 0x10000000,  //Human enter ATM, supported only in ATM_PANEL mode
    OVER_TIME_ABILITY            = 0x20000000,  //Overtime, supported only in ATM_PANEL mode
    STICK_UP_ABILITY             = 0x40000000,  //ATM stick-up
    INSTALL_SCANNER_ABILITY      = 0x80000000   //Install scanner on ATM
}VCA_ABILITY_TYPE;

typedef enum _VCA_ABILITY_TYPE_EX_
{
    PEOPLENUM_CHANGE_ABILITY = 0x00000002, //PeopleNum Change
    SPACING_CHANGE_ABILITY = 0x00000004,   //Spacing Change
    EVENT_COMBINED_ABILITY = 0x00000008,   //Combined Event
    EVENT_SIT_QUIETLY =        0x00000010,     //Sit Quietly
    EVENT_HIGH_DENSITY_STATUS_ABILITY = 0x00000020    //high density status
}VCA_ABILITY_TYPE_EX;

//Intelligent channel type
typedef enum _VCA_CHAN_ABILITY_TYPE_
{
    VCA_BEHAVIOR_BASE              =  1,     //Basic VCA
    VCA_BEHAVIOR_ADVANCE           =  2,     //Advanced VCA
    VCA_BEHAVIOR_FULL              =  3,     //FULL VCA
    VCA_PLATE                        =  4,     //LPR
    VCA_ATM                        =  5,     //ATM
    VCA_PDC                        =  6,     //PDC
    VCA_ITS                        =  7,     //Intelligent traffic surveillance
    VCA_BEHAVIOR_PRISON            =  8,     //VCA (prison surveillance version)
    VCA_FACE_SNAP                  =  9,     //Face snap
    VCA_FACE_SNAPRECOG             =  10,    //Face snap and recognize
    VCA_FACE_RETRIEVAL             =  11,    //Face retrieval
    VCA_FACE_RECOG                 =  12,    //Face recognize
    VCA_BEHAVIOR_PRISON_PERIMETER  =  13,    //VCA (prison perimeter version)
    VCA_TPS                        =  14,    //TPS
    VCA_TFS                        =  15,    //TFS
    VCA_BEHAVIOR_FACESNAP          =  16,    //FACESNAP and BEHAVIOR
    VCA_HEATMAP                    =  17,    //Heat Map
    VCA_SMART_VEHICLE_DETECTION    =  18,    // SMART+ Vehicle detection
    VCA_SMART_HVT_DETECTION        =  19,    // SMART+ HVT detection
    VCA_SMART_EVENT                =  20,    // SMART Event
    VCA_VEHICLE_DETECTION          =  21,    // Vehicle detection
    VCA_SMART_ROAD_DETECTION       =  22,    // SMART + Road Detection
    VCA_SMART_FACE_DETECTION       =  23,    // SMART + Face Detection
    VCA_SMART_HEATMAP              =  24     // SMART + Heat Map
}VCA_CHAN_ABILITY_TYPE;

//Intelligent ATM Mode
typedef enum _VCA_CHAN_MODE_TYPE_
{
    VCA_ATM_PANEL     =  0,  //ATM front panel
    VCA_ATM_SURROUND  =  1,  //ATM scenario
    VCA_ATM_FACE      =  2,     //ATM face recognition & private ATM face detect
    VCA_ATM_SAFETYCABIN = 3  //ATM safetycabin
}VCA_CHAN_MODE_TYPE;


//Intelligent TFS Mode
typedef enum _TFS_CHAN_MODE_TYPE_
{
    TFS_CITYROAD    =  0,  //TFS city road
    TFS_FREEWAY     =  1   //TFS free way
}TFS_CHAN_MODE_TYPE;

//Behavior scene mode
typedef enum _BEHAVIOR_SCENE_MODE_TYPE_
{
    BEHAVIOR_SCENE_DEFAULT = 0, //System default
    BEHAVIOR_SCENE_WALL = 1,    //Wall
    BEHAVIOR_SCENE_INDOOR = 2   //Indoor
}BEHAVIOR_SCENE_MODE_TYPE;

//Prison Mode
typedef enum _BEHAVIOR_PRISON_MODE_TYPE_
{
    BEHAVIOR_PRISON                 = 0, //Prison
    BEHAVIOR_HEARING                  = 1, //Hearing
    BEHAVIOR_RECFIELD                 = 2  //Recfield
}BEHAVIOR_PRISON_MODE_TYPE,LPBEHAVIOR_PRISON_MODE_TYPE;

//Channel ability input
typedef struct tagNET_VCA_CHAN_IN_PARAM
{
    BYTE byVCAType;     //VCA_CHAN_ABILITY_TYPE enum
    BYTE byMode;         //VCA_CHAN_MODE_TYPE for ATM analysis; TFS_CHAN_MODE_TYPE for TFS analysis; when VCA_TYPE is traffic event, please refer to TRAFFIC_SCENE_MODE
    BYTE byRes[2];      //Reserved
}NET_VCA_CHAN_IN_PARAM,  *LPNET_VCA_CHAN_IN_PARAM;


//Behavior ability set
typedef struct tagNET_VCA_BEHAVIOR_ABILITY
{
    DWORD dwSize;          //Structure length
    DWORD dwAbilityType;  //Support ability type by digit, please refer to VCA_ABILITY_TYPE
    BYTE byMaxRuleNum;      //Max. rule number
    BYTE byMaxTargetNum;  //Max. target number
    BYTE    bySupport;         //Function type supported (represented by digit)
    // bySupport & 0x01 -Calibration
    BYTE byRes[5];         //Reserved as 0
    DWORD dwAbilityTypeEx;  //Support ability type by digit, please refer to VCA_ABILITY_TYPE_EX
}NET_VCA_BEHAVIOR_ABILITY,  *LPNET_VCA_BEHAVIOR_ABILITY;

typedef struct tagNET_DVR_SCENE_CHANGE_UPDATE_PARAM
{
    DWORD    dwSize;
    BYTE    byIDCount;
    BYTE    byRes1[3];
    BYTE    byStreamID[MAX_STREAM_ID_NUM][STREAM_ID_LEN];
    BYTE    byRes[256];
}NET_DVR_SCENE_CHANGE_UPDATE_PARAM, *LPNET_DVR_SCENE_CHANGE_UPDATE_PARAM;

// Traffic ability structure
typedef struct tagNET_DVR_ITS_ABILITY
{
    DWORD     dwSize;             //Structure size
    DWORD     dwAbilityType;      //Supported ability list, see to ITS_ABILITY_TYPE
    BYTE     byMaxRuleNum;         //Max number of rules
    BYTE     byMaxTargetNum;     //Max number of targets
    BYTE    byRes[10];            //Reserved
}NET_DVR_ITS_ABILITY, *LPNET_DVR_ITS_ABILITY;

/***********************************end*******************************************/

/************************************Intelligent Parameter Structure*********************************/
//Public structure for intelligent functions
//Coordinates normalized, and the  floating-point value is the percentage of the current screen size
//Take accuracy of three decimal places

//Region
typedef struct tagNET_VCA_RECT
{
    float fX;                //X axis coordinate of the upper-left,  0.001~1
    float fY;                //Y axis coordinate of the upper-left,  0.001~1
    float fWidth;            //Region width,  0.001~1
    float fHeight;           //Region height,  0.001~1
}NET_VCA_RECT,  *LPNET_VCA_RECT;

//Behavior event type
typedef enum _VCA_EVENT_TYPE_
{
    VCA_TRAVERSE_PLANE     = 0x1,        //Traverse plane
    VCA_ENTER_AREA           = 0x2,         //Enter area (region rule)
    VCA_EXIT_AREA           = 0x4,         //Leave area (region rule)
    VCA_INTRUSION           = 0x8,         //Intrusion (region rule)
    VCA_LOITER               = 0x10,         //Loitering (region rule)
    VCA_LEFT_TAKE           = 0x20,         //Object left or take (region rule)
    VCA_PARKING               = 0x40,         //Illegal parking (region rule)
    VCA_RUN                   = 0x80,         //Running (region rule)
    VCA_HIGH_DENSITY       = 0x100,         //People density (region rule)
    VCA_VIOLENT_MOTION     = 0x200,      //Violent motion
    VCA_REACH_HIGHT           = 0x400,      //Reach high
    VCA_GET_UP               = 0x800,      //Get up
    VCA_LEFT               = 0x1000,     //Item left
    VCA_TAKE               = 0x2000,     //Item take
    VCA_LEAVE_POSITION     = 0x4000,     //Leave position
    VCA_TRAIL              = 0x8000,     //Trail
    VCA_KEY_PERSON_GET_UP  = 0x10000,    //Key person get up
    VCA_STANDUP            = 0x20000,    //Stand Up
    VCA_FALL_DOWN          = 0x80000,    //Fall down
    VCA_AUDIO_ABNORMAL     = 0x100000,   //Audio abnormal
    VCA_ADV_REACH_HEIGHT   = 0x200000,   //Advance reach height
    VCA_TOILET_TARRY       = 0x400000,   //Toilet tarry
    VCA_YARD_TARRY         = 0x800000,   //Yard tarry
    VCA_ADV_TRAVERSE_PLANE = 0x1000000,  //Advance traverse plane
    VCA_LECTURE            = 0x2000000,  //Lecture
    VCA_ANSWER             = 0x4000000,  //Answer
    VCA_HUMAN_ENTER        = 0x10000000, //Human enter ATM, supported only in ATM_PANEL mode
    VCA_OVER_TIME          = 0x20000000, //Operation overtime, supported only in ATM_PANEL mode
    VCA_STICK_UP           = 0x40000000, //ATM stick up (region rule)
    VCA_INSTALL_SCANNER    = 0x80000000  //Install scanner on ATM (region rule)
}VCA_EVENT_TYPE;

//Behavior event type(extended)
typedef enum _VCA_RULE_EVENT_TYPE_EX_
{
    ENUM_VCA_EVENT_TRAVERSE_PLANE     = 1,   //Traverse plane
    ENUM_VCA_EVENT_ENTER_AREA         = 2,   //Enter area
    ENUM_VCA_EVENT_EXIT_AREA          = 3,   //Leave area
    ENUM_VCA_EVENT_INTRUSION          = 4,   //Intrusion
    ENUM_VCA_EVENT_LOITER             = 5,   //Loitering
    ENUM_VCA_EVENT_LEFT_TAKE          = 6,   //Object left or take
    ENUM_VCA_EVENT_PARKING            = 7,   //Illegal parking
    ENUM_VCA_EVENT_RUN                = 8,   //Running
    ENUM_VCA_EVENT_HIGH_DENSITY       = 9,   //People density
    ENUM_VCA_EVENT_VIOLENT_MOTION     = 10,  //Violent motion
    ENUM_VCA_EVENT_REACH_HIGHT        = 11,  //Reach high
    ENUM_VCA_EVENT_GET_UP             = 12,  //Get up
    ENUM_VCA_EVENT_LEFT               = 13,  //Item left
    ENUM_VCA_EVENT_TAKE               = 14,  //Item take
    ENUM_VCA_EVENT_LEAVE_POSITION     = 15,  //Leave position
    ENUM_VCA_EVENT_TRAIL              = 16,  //Trail
    ENUM_VCA_EVENT_KEY_PERSON_GET_UP  = 17,  //Key person get up
    ENUM_VCA_EVENT_STANDUP            = 18,  //Stand Up
    ENUM_VCA_EVENT_FALL_DOWN          = 20,  //Fall down
    ENUM_VCA_EVENT_AUDIO_ABNORMAL     = 21,  //Audio abnormal
    ENUM_VCA_EVENT_ADV_REACH_HEIGHT   = 22,  //Advance reach height
    ENUM_VCA_EVENT_TOILET_TARRY       = 23,  //Toilet tarry
    ENUM_VCA_EVENT_YARD_TARRY         = 24,  //Yard tarry
    ENUM_VCA_EVENT_ADV_TRAVERSE_PLANE = 25,  //Advance traverse plane
    ENUM_VCA_EVENT_LECTURE            = 26,  //Lecture
    ENUM_VCA_EVENT_ANSWER             = 27,  //Answer
    ENUM_VCA_EVENT_HUMAN_ENTER        = 29,  //Human enter ATM, supported only in ATM_PANEL mode
    ENUM_VCA_EVENT_OVER_TIME          = 30,  //Operation overtime, supported only in ATM_PANEL mode
    ENUM_VCA_EVENT_STICK_UP           = 31,  //ATM stick up (region rule)
    ENUM_VCA_EVENT_INSTALL_SCANNER    = 32,  //Install scanner on ATM (region rule)
    ENUM_VCA_EVENT_PEOPLENUM_CHANGE   = 35,  //People Num Change
    ENUM_VCA_EVENT_SPACING_CHANGE     = 36,  //Spacing Change
    ENUM_VCA_EVENT_COMBINED_RULE      = 37,  //Combination Events
    ENUM_VCA_EVENT_SIT_QUIETLY        = 38,   //Sit Quietly
    ENUM_VCA_EVENT_HIGH_DENSITY_STATUS= 39   //People density status
} VCA_RULE_EVENT_TYPE_EX;

//Traverse plane direction
typedef enum _VCA_CROSS_DIRECTION_
{
    VCA_BOTH_DIRECTION,   // Bi-direction
    VCA_LEFT_GO_RIGHT,    // Left to right
    VCA_RIGHT_GO_LEFT     // Right to left
}VCA_CROSS_DIRECTION;

//Line
typedef struct tagNET_VCA_LINE
{
    NET_VCA_POINT struStart;     // start point
    NET_VCA_POINT struEnd;       // end point
}NET_VCA_LINE,  *LPNET_VCA_LINE;

//Polygon
typedef struct tagNET_VCA_POLYGON
{
    DWORD dwPointNum;                                   //Valid point number , should be no less than 3
    NET_VCA_POINT  struPos[VCA_MAX_POLYGON_POINT_NUM];  //Boundary point, up to 10 points for each polygon
}NET_VCA_POLYGON,  *LPNET_VCA_POLYGON;

//Traverse plane
typedef struct tagNET_VCA_TRAVERSE_PLANE
{
    NET_VCA_LINE struPlaneBottom;          //Bottom line of the alarm plane
    VCA_CROSS_DIRECTION dwCrossDirection;  //Traverse direction:  0- bi-directional, 1- left to right, 2- right to left
    BYTE bySensitivity;                    //[1,5]
    BYTE byPlaneHeight;                    //Height of the alarm plane
    BYTE byDetectionTarget;                //DetectionTarget: 0-all\A3\AC1-Human\A3\AC2-Vehicle
    BYTE byRes2[37];
}NET_VCA_TRAVERSE_PLANE,  *LPNET_VCA_TRAVERSE_PLANE;

typedef struct tagNET_VCA_SIT_QUIETLY
{
    NET_VCA_POLYGON struRegion;//Region
    DWORD   dwDuration;         // trigger after:  1- 3600 second
    BYTE    byRes[4];
} NET_VCA_SIT_QUIETLY, *LPNET_VCA_SIT_QUIETLY;

//Enter or Leave area
typedef struct tagNET_VCA_AREA
{
    NET_VCA_POLYGON struRegion; //Region
    BYTE bySensitivity;        //Sensitiviity\A3\AC[1,5]
    BYTE byDetectionTarget;    //DetectionTarget:0-all\A3\AC1-Human\A3\AC2-Vehicle
    BYTE byRes[6];
}NET_VCA_AREA,  *LPNET_VCA_AREA;

//Mark the alarm snapshot according to the alarm delay time (alarm interval is consistent with IO alarm), send 1 snapshot every second
//Intrusion
typedef struct tagNET_VCA_INTRUSION
{
    NET_VCA_POLYGON struRegion; //region
    WORD wDuration;     // trigger after:  1- 120 second, suggested 5
    BYTE bySensitivity;  //[1-100]
    BYTE byRate;
    BYTE byDetectionTarget;    //DetectionTarget: 0-all\A3\AC1-Human\A3\AC2-Vehicle
    BYTE byRes[3];
}NET_VCA_INTRUSION,  *LPNET_VCA_INTRUSION;

//Loitering
typedef struct tagNET_VCA_LOITER
{
    NET_VCA_POLYGON struRegion; //Region
    WORD wDuration;  //Trigger after: 1- 120 second, suggested 10
    BYTE bySensitivity;            //Sensitivity, [1,5]
    BYTE byRes[5];
}NET_VCA_LOITER,  *LPNET_VCA_LOITER;

//Object left or taken
typedef struct tagNET_VCA_TAKE_LEFT
{
    NET_VCA_POLYGON struRegion; //Region
    WORD wDuration;  //Trigger after: 1- 120 second, suggested 10
    BYTE bySensitivity;            //Sensitivity, value range: [1,5]
    BYTE byRes[5];
}NET_VCA_TAKE_LEFT,  *LPNET_VCA_TAKE_LEFT;

//Illegal
typedef struct tagNET_VCA_PARKING
{
    NET_VCA_POLYGON struRegion;     //Region
    WORD wDuration;                 //Trigger after: 1- 100 second, suggested 10
    BYTE bySensitivity;            //Sensitivity, value range: [1,5]
    BYTE byRes[5];
}NET_VCA_PARKING,  *LPNET_VCA_PARKING;

//Running
typedef struct tagNET_VCA_RUN
{
    NET_VCA_POLYGON struRegion; //Region
    float   fRunDistance;         //Target running distance: [0.1,  1.00]
    BYTE    bySensitivity;    //Sensitivity, value range: [1,5]
    BYTE    byMode;             // 0- pixel mode, 1- actual mode
    BYTE    byDetectionTarget;    //DetectionTarget: 0-All\A3\AC1-human\A3\AC2-Vehicle
    BYTE    byRes;
}NET_VCA_RUN,  *LPNET_VCA_RUN;

//People gathering
typedef struct tagNET_VCA_HIGH_DENSITY
{
    NET_VCA_POLYGON struRegion;     //Region
    float fDensity;                 //Density range:  [0.1,  1.0]
    BYTE            bySensitivity;    //Sensitivity, value range: [1,5]
    BYTE            byRes;          //Reserved
    WORD            wDuration;      //Threshold of triggering people aggregation alarm,value: 20-360s
}NET_VCA_HIGH_DENSITY,  *LPNET_VCA_HIGH_DENSITY;

//Violent motion
typedef struct tagNET_VCA_VIOLENT_MOTION
{
    NET_VCA_POLYGON struRegion; //Region
    WORD  wDuration;            //Trigger after: 1- 120 second
    BYTE  bySensitivity;        //Sensitivity range: [1, 5]
    BYTE  byMode;               //0-Video only\A3\AC1-Video and audio\A3\AC2-Audio only
    BYTE  byRes[4];             //Reserved
}NET_VCA_VIOLENT_MOTION,  *LPNET_VCA_VIOLENT_MOTION;

// Reach high
typedef struct tagNET_VCA_REACH_HIGHT
{
    NET_VCA_LINE struVcaLine;    //Alarm plane
    WORD wDuration;  //Trigger after: 1- 120 second
    BYTE    byRes[6];            // Reserved
}NET_VCA_REACH_HIGHT,  *LPNET_VCA_REACH_HIGHT;

// Get up
typedef struct tagNET_VCA_GET_UP
{
    NET_VCA_POLYGON struRegion;  //Region
    WORD    wDuration;           //Trigger after: 1- 100 second
    BYTE    byMode;              //mode,0-big bed,1-wide bed,2-sitting
    BYTE    bySensitivity;       //Sensitivity range:[1,10]
    BYTE    byRes[4];            //Reserved
}NET_VCA_GET_UP,  * LPNET_VCA_GET_UP;

// Items left
typedef struct tagNET_VCA_LEFT
{
    NET_VCA_POLYGON struRegion;        // Region
    WORD            wDuration;         // Threshold of triggering itmes left alarm, value: 4-60s
    BYTE            bySensitivity;     //[1,5]
    BYTE            byRes[5];          // Reserved
}NET_VCA_LEFT, *LPNET_VCA_LEFT;

//Items take
typedef struct tagNET_VCA_TAKE
{
    NET_VCA_POLYGON struRegion;     // Region
    WORD            wDuration;      // Threshold of triggering itmes take alarm, value: 4-60s
    BYTE            bySensitivity;  //[1,5]
    BYTE            byRes[5];       // Reserved
}NET_VCA_TAKE, *LPNET_VCA_TAKE;

typedef struct tagNET_VCA_OVER_TIME
{
    NET_VCA_POLYGON     struRegion; // Region
    WORD               wDuration;   // Time threshold of operation alarm, value: 4s-60000s
    BYTE   byRes[6];                // Reserved
}NET_VCA_OVER_TIME, *LPNET_VCA_OVER_TIME;

typedef struct tagNET_VCA_HUMAN_ENTER
{
    DWORD                dwRes[23];            //Reserved
}NET_VCA_HUMAN_ENTER, *LPNET_VCA_HUMAN_ENTER;

//ATM stick up
typedef struct tagNET_VCA_STICK_UP
{
    NET_VCA_POLYGON struRegion; //Region
    WORD wDuration;  //Trigger after: 4- 60 second, suggested 10 second
    BYTE  bySensitivity;        // Sensitivity range: [1, 5]
    BYTE byRes[5];
}NET_VCA_STICK_UP,  *LPNET_VCA_STICK_UP;

//Install scanner on ATM
typedef struct tagNET_VCA_SCANNER
{
    NET_VCA_POLYGON struRegion; //Region
    WORD wDuration;  // Scanner reading time: 4- 60 seconds
    BYTE  bySensitivity;        // Sensitivity range: [1, 5]
    BYTE byRes[5];
}NET_VCA_SCANNER,  *LPNET_VCA_SCANNER;

//Leave position
typedef struct tagNET_VCA_LEAVE_POSITION
{
    NET_VCA_POLYGON   struRegion; //Region
    WORD wLeaveDelay;  //Alarm time of no people, unit: s, value:1-1800
    WORD wStaticDelay; //Alarm time of sleeping, unit: s, value:1-1800
    BYTE byMode;       //mode,0-leave,1-sleep,2-leave and sleep
    BYTE byPersonType; //Person on guard\A3\AC0-single\A3\AC1-couple
    BYTE byRes[2];     //Reserved
}NET_VCA_LEAVE_POSITION, *LPNET_VCA_LEAVE_POSITION;

//Trail
typedef struct tagNET_VCA_TRAIL
{
    NET_VCA_POLYGON struRegion;//Region
    WORD  wRes;
    BYTE  bySensitivity;       /* Sensitivity range: [1, 5] */
    BYTE  byRes[5];
}NET_VCA_TRAIL, *LPNET_VCA_TRAIL;

//Fall down
typedef struct tagNET_VCA_FALL_DOWN
{
    NET_VCA_POLYGON struRegion;//Region
    WORD  wDuration;         /* Threshold of triggering itmes take alarm, value: 1-60s*/
    BYTE  bySensitivity;     /* Sensitivity range: [1, 5] */
    BYTE  byHeightThreshold; //Height Threshold\A3\ACRange[0,250]
    BYTE  byRes[4];
}NET_VCA_FALL_DOWN, *LPNET_VCA_FALL_DOWN;

//Stand Up
typedef struct tagNET_VCA_STANDUP
{
    NET_VCA_POLYGON  struRegion; //Region
    BYTE  bySensitivity;     //Sensitivity range: [1, 100]
    BYTE  byHeightThreshold; //Height Threshold\A3\ACRange[0,250]
    WORD  wDuration;         //Threshold of triggering itmes take alarm, value: 1-60s
    BYTE  byRes[4];
}NET_VCA_STANDUP, *LPNET_VCA_STANDUP;


//People Num Change
typedef struct tagNET_VCA_PEOPLENUM_CHANGE
{
    NET_VCA_POLYGON  struRegion; //Region
    BYTE  bySensitivity;        //Sensitivity range: [1, 100]
    BYTE  byPeopleNumThreshold; //People Num Threshold\A3\ACrange: [0,5]
    BYTE  byDetectMode;         //Detect Mode\A3\ACComparison People Num Threshold\A1\A31-Greater than\A3\AC2- less than \A3\AC3-equal to \A3\AC4-Not equal to
    BYTE  byNoneStateEffective; //None State Effective\A3\AC0-Invalid\A3\AC1-Effective
    WORD  wDuration;  //Threshold of triggering itmes take alarm, value:[1,3600]
    BYTE  byRes[2];
}NET_VCA_PEOPLENUM_CHANGE, *LPNET_VCA_PEOPLENUM_CHANGE;

//Spacing Change
typedef struct tagNET_VCA_SPACING_CHANGE
{
    NET_VCA_POLYGON  struRegion; //Region
    float fSpacingThreshold; //Spacing Threshold\A3\ACrange: [0,10.0]\A3\ACUnit: M
    BYTE  bySensitivity;     //Sensitivity range: [1, 100]
    BYTE  byDetectMode;      //Detect Mode\A3\ACComparison Spacing Threshold\A1\A31-Greater than\A3\AC2- less than
    WORD  wDuration;  //Threshold of triggering itmes take alarm, value:[1,3600]
}NET_VCA_SPACING_CHANGE, *LPNET_VCA_SPACING_CHANGE;

//Audio abnormal
typedef struct tagNET_VCA_AUDIO_ABNORMAL
{
    WORD wDecibel;       //Audio decibel
    BYTE bySensitivity;  //Sensitivity range: [1, 100]
    BYTE byAudioMode;    //Audio mode,0-enable sensitivity detect,1-enable decibel threshold,2-enable sensitivity and decibel threshold detect
    BYTE byEnable;       //0-disabled,1-enabled
    BYTE byThreshold;    //Sound threshold:[1,100]
    BYTE byRes[54];      //Reserved
}NET_VCA_AUDIO_ABNORMAL, *LPNET_VCA_AUDIO_ABNORMAL;

//Sound intensity dropped 2014-03-21
typedef struct tagNET_DVR_AUDIO_STEEP_DROP
{
    BYTE  bySensitivity;   /* Sensitivity [1,100] */
    BYTE  byEnable;        //Enable
    BYTE  byRes[6];
}NET_DVR_AUDIO_STEEP_DROP, *LPNET_DVR_AUDIO_STEEP_DROP;

typedef struct tagNET_DVR_AUDIO_EXCEPTION
{
    DWORD                       dwSize;
    BYTE                        byEnableAudioInException;
    BYTE                        byRes1[3];
    NET_VCA_AUDIO_ABNORMAL      struAudioAbnormal;
    NET_DVR_SCHEDTIME           struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;
    DWORD                       dwMaxRelRecordChanNum ;
    DWORD                       dwRelRecordChanNum ;
    DWORD                       byRelRecordChan[MAX_CHANNUM_V30];
    NET_DVR_AUDIO_STEEP_DROP    struAudioSteepDrop;      //Sound intensity dropped
    BYTE                        byRes2[24];
}NET_DVR_AUDIO_EXCEPTION, *LPNET_DVR_AUDIO_EXCEPTION;

typedef struct tagNET_VCA_TOILET_TARRY
{
    NET_VCA_POLYGON struRegion;//region
    WORD wDelay;        //delay[1,3600],uint:s
    BYTE byRes[6];
}NET_VCA_TOILET_TARRY, *LPNET_VCA_TOILET_TARRY;

typedef struct tagNET_VCA_YARD_TARRY
{
    NET_VCA_POLYGON struRegion;//region
    WORD wDelay;        //delay[1,120],uint:s
    BYTE byRes[6];
}NET_VCA_YARD_TARRY, *LPNET_VCA_YARD_TARRY;

typedef struct tagNET_VCA_ADV_REACH_HEIGHT
{
    NET_VCA_POLYGON struRegion; //region
    DWORD dwCrossDirection;  //Cross direction(VCA_CROSS_DIRECTION)
    BYTE    byRes[4];        //
}NET_VCA_ADV_REACH_HEIGHT, * LPNET_VCA_ADV_REACH_HEIGHT;

typedef struct tagNET_VCA_ADV_TRAVERSE_PLANE
{
    NET_VCA_POLYGON struRegion; //Region
    DWORD   dwCrossDirection;   //Cross direction(VCA_CROSS_DIRECTION)
    BYTE    bySensitivity;      //[1,5]
    BYTE    byRes[3];            //Reserved
} NET_VCA_ADV_TRAVERSE_PLANE,*LPNET_VCA_ADV_TRAVERSE_PLANE;


typedef struct tagNET_VCA_SITDOWN
{
    NET_VCA_POLYGON struRegion;//Region
    BYTE bySensitivity;//Sensitivity Param[1-100]
    BYTE byRes[7];
}NET_VCA_SITDOWN, *LPNET_VCA_SITDOWN;

typedef struct tagNET_VCA_LECTURE
{
    NET_VCA_POLYGON struRegion;//Region
    WORD wDuration; //Duration: [1-10]
    BYTE bySensitivity; //Sensitivity\A3\AC[1-100]
    BYTE byAlarmState;//Alarm State\A3\BB0-Retain,1-Alarm Begin,2-Alarm end
    BYTE byTrackingMode;//Tracking Mode\A3\AC0-Auto(Def),1-Horizontal,2-Vertical
    BYTE byZoomMode;//Zoom Mode, 0-Fixed(Def), 1-Auto
    BYTE byZoomOver;//0-Retain,1-Zoom Over
    BYTE byRes;
}NET_VCA_LECTURE, *LPNET_VCA_LECTURE;

typedef struct tagNET_VCA_ANSWER
{
    NET_VCA_POLYGON struRegion;//Region
    BYTE bySensitivity;//Sensitivity\A3\AC[1-100]
    BYTE byAlarmState;//Alarm State\A3\BB0-Retain,1-Alarm Begin,2-Alarm end
    BYTE byZoomOver;//0-Retain,1-Zoom Over
    BYTE byRes[5];
}NET_VCA_ANSWER, *LPNET_VCA_ANSWER;

//Rule Struct
typedef struct tagNET_VCA_RELATE_RULE_PARAM
{
    BYTE  byRuleID;  //Rule ID
    BYTE  byRes;
    WORD  wEventType;        //Event Type  See VCA_RULE_EVENT_TYPE_EX
}NET_VCA_RELATE_RULE_PARAM,*LPNET_VCA_RELATE_RULE_PARAM;

//Combined Rule
typedef struct tagNET_VCA_COMBINED_RULE_
{
    //Rule Sequence
    BYTE    byRuleSequence;
    BYTE    byRes[7];
    DWORD  dwMinInterval;    //Min Interval
    DWORD  dwMaxInterval;   //Max Interval
    NET_VCA_RELATE_RULE_PARAM  struRule1Raram;//Rule1
    NET_VCA_RELATE_RULE_PARAM  struRule2Raram;//Rule2
    BYTE    byRes1[36];
} NET_VCA_COMBINED_RULE, *LPNET_VCA_COMBINED_RULE;


//People gathering status
typedef struct tagNET_VCA_HIGH_DENSITY_STATUS
{
    NET_VCA_POLYGON struRegion;        //Region
    float           fDensity;       //Density range:  [0.1,  1.0]
    BYTE            bySensitivity;    //Sensitivity, value range: [1,5]
    BYTE            byRes[3];
}NET_VCA_HIGH_DENSITY_STATUS, *LPNET_VCA_HIGH_DENSITY_STATUS;


//Alarm event parameters
typedef union tagNET_VCA_EVENT_UNION
{
    DWORD                      uLen[23];             //Parameters
    NET_VCA_TRAVERSE_PLANE     struTraversePlane;     //Traverse plane parameters
    NET_VCA_AREA               struArea;             //Enter or Leave area
    NET_VCA_INTRUSION          struIntrusion;         //Intrusion
    NET_VCA_LOITER             struLoiter;             //Loitering
    NET_VCA_TAKE_LEFT          struTakeTeft;         //Object left or taken
    NET_VCA_PARKING            struParking;         //Illegal parking
    NET_VCA_RUN                struRun;             //Running
    NET_VCA_HIGH_DENSITY       struHighDensity;     //People gathering
    NET_VCA_VIOLENT_MOTION     struViolentMotion;   //Violent motion
    NET_VCA_REACH_HIGHT        struReachHight;         //Reach High
    NET_VCA_GET_UP               struGetUp;             //Get up
    NET_VCA_LEFT               struLeft;            //Items left
    NET_VCA_TAKE               struTake;            //Items take
    NET_VCA_HUMAN_ENTER        struHumanEnter;      //Human entrance
    NET_VCA_OVER_TIME          struOvertime;        //Operation overtime
    NET_VCA_STICK_UP            struStickUp;         //ATM stick up
    NET_VCA_SCANNER            struScanner;         //Install scanner on ATM
    NET_VCA_LEAVE_POSITION     struLeavePos;        //Parameter that leave the position
    NET_VCA_TRAIL              struTrail;           //Trail
    NET_VCA_FALL_DOWN          struFallDown;        //Fall down
    NET_VCA_AUDIO_ABNORMAL     struAudioAbnormal;   //Audio abnormal
    NET_VCA_ADV_REACH_HEIGHT   struReachHeight;     //Advance reach height
    NET_VCA_TOILET_TARRY       struToiletTarry;     //Toilet tarry
    NET_VCA_YARD_TARRY         struYardTarry;       //Yard tarry
    NET_VCA_ADV_TRAVERSE_PLANE struAdvTraversePlane;//Advance traverse plane
    NET_VCA_LECTURE            struLecture;            //Lecture
    NET_VCA_ANSWER             struAnswer;            //Answer
    NET_VCA_STANDUP               struStandUp;         //Stand Up
    NET_VCA_PEOPLENUM_CHANGE   struPeopleNumChange; //People Num Change
    NET_VCA_SPACING_CHANGE     struSpacingChange;   //Spacing Change
    NET_VCA_COMBINED_RULE      struCombinedRule;    //Combined Rule
    NET_VCA_SIT_QUIETLY        struSitQuietly;      //Sit Quietly
    NET_VCA_HIGH_DENSITY_STATUS struHighDensityStatus;        //People gathering status
}NET_VCA_EVENT_UNION,  *LPNET_VCA_EVENT_UNION;

// Target size filter
typedef enum _VCA_SIZE_FILTER_MODE_
{
    IMAGE_PIX_MODE,   // Set by pixels
    REAL_WORLD_MODE,  // Set by actual size
    DEFAULT_MODE       // Default
}SIZE_FILTER_MODE;
//Size filter
typedef struct tagNET_VCA_SIZE_FILTER
{
    BYTE    byActive;             // Enable filter: 0- disable;  1- enable
    BYTE    byMode;             //SIZE_FILTER_MODE
    BYTE    byRes[2];           //Reserved as 0
    NET_VCA_RECT struMiniRect;  //Min. target region, 0 stands for no region settings
    NET_VCA_RECT struMaxRect;     //Max. target region, 0 stands for no region settings
}NET_VCA_SIZE_FILTER,  *LPNET_VCA_SIZE_FILTER;

//Alarm rule configuration
typedef struct tagNET_VCA_ONE_RULE
{
    BYTE   byActive;                       //Activate rule settings: 0- disable;  1- enable
    BYTE   byRes[7];                       //Reserved as 0
    BYTE   byRuleName[NAME_LEN];           //Rule name
    VCA_EVENT_TYPE dwEventType;          //VCA event type
    NET_VCA_EVENT_UNION uEventParam;      //VCA event parameters
    NET_VCA_SIZE_FILTER  struSizeFilter; //Size filter
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_2]; // Arm time
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;     //Handle method
    BYTE byRelRecordChan[MAX_CHANNUM_V30];             //Alarm trigger recording channel, 1- trigger recording on this channel
}NET_VCA_ONE_RULE,  *LPNET_VCA_ONE_RULE;

typedef struct tagNET_VCA_DEV_INFO
{
    NET_DVR_IPADDR  struDevIP;  //PU address
    WORD wPort;              //PU port number
    BYTE byChannel;           //PU channel number
    BYTE byIvmsChannel;     // Ivms channel
} NET_VCA_DEV_INFO,  *LPNET_VCA_DEV_INFO;

//VCA configuration structure
typedef struct tagNET_VCA_RULECFG
{
    DWORD  dwSize;             //Structure length
    BYTE    byPicProType;     //0- do not upload snapshot;  1 - Upload  snapshot on VCA alarm
    BYTE    byUpLastAlarm;  //2011-04-06 Whether upload last alarm firstly
    BYTE   byPicRecordEnable;  /*2012-3-1 Whether record picture, 0-no,1-yes*/
    BYTE    byRes;
    NET_DVR_JPEGPARA struPictureParam;          //snapshot structure
    NET_VCA_ONE_RULE  struRule[MAX_RULE_NUM];   //Rule array
}NET_VCA_RULECFG,  *LPNET_VCA_RULECFG;

typedef struct tagNET_DVR_TARGET_LEFT_REGION_ALARM
{
    DWORD     dwSize;
    DWORD     dwRelativeTime;
    DWORD        dwAbsTime;
    NET_VCA_DEV_INFO  struDevInfo;
    BYTE     byTargetType;
    BYTE     byLeftDirection;
    BYTE     byRes[126];
}NET_DVR_TARGET_LEFT_REGION_ALARM,*LPNET_DVR_TARGET_LEFT_REGION_ALARM;

//Size filter strategy
typedef struct tagNET_VCA_FILTER_STRATEGY
{
    BYTE    byStrategy;      //0 - Disabled, 1-Width and height filter,2-Area filter
    BYTE    byRes[11];       //Reserved
}NET_VCA_FILTER_STRATEGY,*LPNET_VCA_FILTER_STRATEGY;

//Rule trigger param
typedef struct tagNET_VCA_RULE_TRIGGER_PARAM
{
    BYTE   byTriggerMode;   //Trigger mode\A3\AC0- Disabled\A3\AC1- Track point, 2- Target area
    BYTE   byTriggerPoint;  //Trigger point\A3\ACeffective when track point is enabled, 0- Center,1-Up,2-Down
    BYTE   byRes1[2];       //Reserved
    float  fTriggerArea;    //Trigger area percent [0,100]\A3\ACeffective when target area is enabled
    BYTE   byRes2[4];       //Reserved
}NET_VCA_RULE_TRIGGER_PARAM,*LPNET_VCA_RULE_TRIGGER_PARAM;


//Alarm rule configuration
typedef struct tagNET_VCA_ONE_RULE_V41
{
    BYTE   byActive; //Activate rule settings: 0- disable;  1- enable
    BYTE   byRes1[4];
    BYTE   byEventTypeFlag;  //Event Type Flag\A3\AC0-dwEventType Effective\A3\AC1-wEventTypeEx Effective
    WORD   wEventTypeEx; //Event type,substitute for dwEventType,refer to VCA_RULE_EVENT_TYPE_EX
    BYTE   byRuleName[NAME_LEN]; //Rule name
    VCA_EVENT_TYPE dwEventType;    //Event type,It is kept only for compatibility,in your new code,use wEventTypeEx instead
    NET_VCA_EVENT_UNION uEventParam; //VCA event parameters
    NET_VCA_SIZE_FILTER  struSizeFilter; //Size filter
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];// Arm time
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;     //Handle method
    BYTE   byRelRecordChan[MAX_CHANNUM_V30];       //Alarm trigger recording channel, 1- trigger recording on this channel
    WORD   wAlarmDelay; //Alarm delay,0-5s,1-10,2-30s,3-60s,4-120s,5-300s,6-600s
    BYTE   byRes2[2];                              //Reserved
    NET_VCA_FILTER_STRATEGY     struFilterStrategy; //Size filter strategy
    NET_VCA_RULE_TRIGGER_PARAM  struTriggerParam;   //Rule trigger param
    BYTE    byRes[32];                              //Reserved
}NET_VCA_ONE_RULE_V41, *LPNET_VCA_ONE_RULE_V41;

//VCA configuration structure
typedef struct tagNET_VCA_RULECFG_V41
{
    DWORD  dwSize;
    BYTE   byPicProType;    //0- do not upload snapshot;  1 - Upload  snapshot on VCA alarm
    BYTE   byUpLastAlarm; //2011-04-06 Whether upload last alarm firstly
    BYTE   byPicRecordEnable;  /*2012-3-1 Whether to enable the image storage, 0-Not enabled, 1-enabled*/
    BYTE   byRes1;
    NET_DVR_JPEGPARA struPictureParam;         //snapshot structure
    NET_VCA_ONE_RULE_V41  struRule[MAX_RULE_NUM];  //Rule array
    WORD   wRelSnapChan[MAX_REL_SNAPCHAN_NUM]; /*Relate snap channel,when the main channel alarms,together upload the relate channel picture
                                               0-unused,other- channel number*/
    BYTE   byRes[26]; //Reserved
}NET_VCA_RULECFG_V41, *LPNET_VCA_RULECFG_V41;

typedef struct NET_VCA_ONE_RULE_V42_
{
    BYTE           byActive;       //Activate rule settings: 0- disable;  1- enable
    BYTE        byEventPriority;//Event Priority 0-low\A3\AC1-mid\A3\AC2-high
    BYTE           byRes1[4];
    WORD          wEventType;        //Event type,substitute for dwEventType,refer to VCA_RULE_EVENT_TYPE_EX
    BYTE        byRuleName[NAME_LEN/*32*/];        //Rule Name
    NET_VCA_EVENT_UNION  uEventParam;            //VCA event parameters
    NET_VCA_SIZE_FILTER  struSizeFilter;          //Size filter
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//Alarm Time
    NET_DVR_HANDLEEXCEPTION_V40  struAlarmHandleType; //Alarm Handle Type
    DWORD       dwRelRecordChan[MAX_CHANNUM_V30];    //Alarm trigger recording channel, 1- trigger recording on this channel
    WORD          wAlarmDelay; //Alarm delay,0-5s,1-10,2-30s,3-60s,4-120s,5-300s,6-600s
    BYTE           byRes2[2];
    NET_VCA_FILTER_STRATEGY     struFilterStrategy;  //Size filter strategy
    NET_VCA_RULE_TRIGGER_PARAM     struTriggerParam;    //Rule trigger param
    BYTE byRes[32];
}NET_VCA_ONE_RULE_V42, *LPNET_VCA_ONE_RULE_V42;

typedef struct    tagNET_DVR_PTZ_POSITION
{
    // Enable/disable the video scene functions (for speed dome local video scene position configuration) , invalid for video scene rule configuration mode,
    BYTE byEnable;
    BYTE byRes1[3];   //Reserved
    BYTE byPtzPositionName[NAME_LEN];  //Video scene position name
    NET_DVR_PTZPOS struPtzPos;  //PTZ  coordinates
    BYTE byRes2[40];
}NET_DVR_PTZ_POSITION,  *LPNET_DVR_PTZ_POSITION;

//VCA configuration structure V42
typedef struct tagNET_VCA_RULECFG_V42
{
    DWORD        dwSize;
    BYTE           byPicProType;        //0- do not upload snapshot;  1 - Upload  snapshot on VCA alarm
    BYTE        byUpLastAlarm;         //Whether upload last alarm firstly
    BYTE        byPicRecordEnable;  //Whether to enable the image storage, 0-Not enabled, 1-enabled
    BYTE        byRes1;
    NET_DVR_JPEGPARA       struPicParam;         //snapshot structure
    NET_VCA_ONE_RULE_V42  struRule[MAX_RULE_NUM_V42/*16*/];       //Rule array
    WORD        wRelSnapChan[MAX_REL_SNAPCHAN_NUM]; /*Relate snap channel,when the main channel alarms,together upload the relate channel picture
                                               0-unused,other- channel number*/
    BYTE        byTrackEnable; //Track Enable
    BYTE        byRes2;
    NET_DVR_PTZ_POSITION  struPTZPosition;  //PTZ Position
    WORD        wTrackDuration; //Track Duration
    BYTE        byRes[62];
}NET_VCA_RULECFG_V42, *LPNET_VCA_RULECFG_V42;

//Simplified target info structure
typedef struct tagNET_VCA_TARGET_INFO
{
    DWORD    dwID;                 //Target ID, the target ID will be 0 on high density alarm
    NET_VCA_RECT struRect;       //target brim rectangle
    BYTE      byRes[4];             //Reserved
}NET_VCA_TARGET_INFO,  *LPNET_VCA_TARGET_INFO;

//Simplified rule info
typedef struct tagNET_VCA_RULE_INFO
{
    BYTE   byRuleID;              //Rule ID, 0- 7
    BYTE   byRes;              //Reserved
    WORD   wEventTypeEx;         //Event type,substitute for dwEventType,refer to VCA_RULE_EVENT_TYPE_EX
    BYTE   byRuleName[NAME_LEN]; //Rule name
    VCA_EVENT_TYPE  dwEventType; //Event type,It is kept only for compatibility,in your new code,use wEventTypeEx instead
    NET_VCA_EVENT_UNION uEventParam; //Event parameters
}NET_VCA_RULE_INFO,  *LPNET_VCA_RULE_INFO;

//PU address info, (address of connected IP device for iVMS, or local address for the other intelligent devices)
// typedef struct tagNET_VCA_DEV_INFO
// {
//     NET_DVR_IPADDR  struDevIP;  //PU address
//     WORD wPort;              //PU port number
//     BYTE byChannel;           //PU channel number
//     BYTE byIvmsChannel;     // Ivms channel
// } NET_VCA_DEV_INFO,  *LPNET_VCA_DEV_INFO;

//VCA upload info
typedef struct  tagNET_VCA_RULE_ALARM
{
    DWORD    dwSize;                         //Structure length
    DWORD    dwRelativeTime;                 //relative time stamp
    DWORD    dwAbsTime;                     //Absolute time stamp
    NET_VCA_RULE_INFO     struRuleInfo;     //Event rule info
    NET_VCA_TARGET_INFO  struTargetInfo;     //Alarm target info
    NET_VCA_DEV_INFO       struDevInfo;         //PU device info
    DWORD    dwPicDataLen;     //Return snapshot length, 0- no snapshot;  others- snapshot data size followed*/
    BYTE     byPicType;    //0- normal picture, 1- contrast picture
    BYTE     byRelAlarmPicNum; //Related alarm picture number
    BYTE     bySmart;   //IDS DEV Return 0(default)\A3\ACSmart Functiom Return 1
    BYTE     byRes;        //Reserved
    DWORD    dwAlarmID; //Alarm ID,marking the same group of alarmls\A3\AC0-unused
    WORD     wDevInfoIvmsChannelEx;     //NET_VCA_DEV_INFO->byIvmsChannel
    BYTE     byRes2[6];  //Reserved
    BYTE     *pImage;    //Pointer to the snapshot picture
}NET_VCA_RULE_ALARM,  *LPNET_VCA_RULE_ALARM;

//VCA info overlay via DSP
typedef struct tagNET_VCA_DRAW_MODE
{
    DWORD  dwSize;
    BYTE    byDspAddTarget;         //Overlay target info during encoding
    BYTE    byDspAddRule;             //Overlay rule info during encoding
    BYTE    byDspPicAddTarget;         //Overlay target info for snapshot
    BYTE    byDspPicAddRule;         //Overlay rule info for snapshot
    BYTE    byRes[4];
}NET_VCA_DRAW_MODE,  *LPNET_VCA_DRAW_MODE;

//Object type
typedef enum tagOBJECT_TYPE_ENUM
{
    ENUM_OBJECT_TYPE_COAT  = 1  //coat
}OBJECT_TYPE_ENUM;

//Object color condition
typedef struct tagNET_DVR_OBJECT_COLOR_COND
{
    DWORD  dwChannel;   //Channel number
    DWORD  dwObjType;   //Object type\A3\ACrefer to OBJECT_TYPE_ENUM
    BYTE   byRes[64];   //Reserved
}NET_DVR_OBJECT_COLOR_COND,*LPNET_DVR_OBJECT_COLOR_COND;

//Picture parameters
typedef struct tagNET_DVR_PIC
{
    BYTE   byPicType;        //Picture type\A3\AC1-jpg
    BYTE   byRes1[3];        //Reserved
    DWORD  dwPicWidth;       //Picture width
    DWORD  dwPicHeight;      //Picture height
    DWORD  dwPicDataLen;     //Picture data length
    DWORD  dwPicDataBuffLen; //Picture buffer size
    BYTE*  byPicDataBuff;    //Picture buffer pointer
    BYTE   byRes2[40];       //Reserved
}NET_DVR_PIC,*LPNET_DVR_PIC;

//Object color union
typedef union tagNET_DVR_OBJECT_COLOR_UNION
{
    NET_DVR_COLOR  struColor;   //Color value
    NET_DVR_PIC    struPicture; //Picture
    BYTE           byRes[64];   //Reserved
}NET_DVR_OBJECT_COLOR_UNION,*LPNET_DVR_OBJECT_COLOR_UNION;

//Object color paraemters
typedef struct tagNET_DVR_OBJECT_COLOR
{
    DWORD  dwSize;       //Structure size
    BYTE   byEnable;     //0-disabled\A3\AC1-enabled
    BYTE   byColorMode;  //Color mode\A3\AC1-from color value\A3\AC2-from picture
    BYTE   byRes1[2];    //Reserved
    NET_DVR_OBJECT_COLOR_UNION uObjColor; //Object color union\A3\ACdepends on the value of byColorMode
    BYTE   byRes2[64];   //Reserved
}NET_DVR_OBJECT_COLOR, *LPNET_DVR_OBJECT_COLOR;

//Area type
typedef enum tagAREA_TYPE_ENUM
{
    ENUM_OVERLAP_REGION  = 1,//Overlap region
    ENUM_BED_LOCATION  = 2   //Bed location
}AREA_TYPE_ENUM;

//Auxiliary area
typedef struct tagNET_DVR_AUXAREA
{
    DWORD  dwAreaType;   //Area type\A3\ACrefer to AREA_TYPE_ENUM
    BYTE   byEnable;     //0-disabled\A3\AC1-enabled
    BYTE   byRes1[3];    //Reserved
    NET_VCA_POLYGON struPolygon; //Area polygon
    BYTE   byRes2[16];   //Reserved
}NET_DVR_AUXAREA,*LPNET_DVR_AUXAREA;

//Auxiliary area list
typedef struct tagNET_DVR_AUXAREA_LIST
{
    DWORD     dwSize;    //Structure size
    NET_DVR_AUXAREA struArea[MAX_AUXAREA_NUM]; //Auxiliary area list
    BYTE    byRes2[64];    //Reserved
}NET_DVR_AUXAREA_LIST,*LPNET_DVR_AUXAREA_LIST;

//Channel workmode
typedef enum tagCHAN_WORKMODE_ENUM
{
    ENUM_CHAN_WORKMODE_INDEPENDENT = 1,  //Independent
    ENUM_CHAN_WORKMODE_MASTER  = 2,      //Master
    ENUM_CHAN_WORKMODE_SLAVE  = 3        //Slave
}CHAN_WORKMODE_ENUM;

//Channel workmode parameters
typedef struct tagNET_DVR_CHANNEL_WORKMODE
{
    DWORD dwSize;        //Structure size
    BYTE  byWorkMode;    //Workmode\A3\ACrefer to CHAN_WORKMODE_ENUM
    BYTE  byRes[63];     //Reserved
}NET_DVR_CHANNEL_WORKMODE,*LPNET_DVR_CHANNEL_WORKMODE;

//Device channel
typedef struct tagNET_DVR_CHANNEL
{
    BYTE   byAddress[MAX_DOMAIN_NAME];    //Device ip or domain name
    WORD   wDVRPort;                     //Port
    BYTE   byRes1[2];                   //Reserved
    BYTE   sUserName[NAME_LEN];            //Username
    BYTE   sPassword[PASSWD_LEN];       //Password
    DWORD  dwChannel;                   //Channel number
    BYTE   byRes2[32];                  //Reserved
}NET_DVR_CHANNEL,*LPNET_DVR_CHANNEL;

//Slave channel union
typedef union tagNET_DVR_SLAVE_CHANNEL_UNION
{
    BYTE            byRes[152];        //Reserved
    DWORD           dwLocalChannel;    //Local channel
    NET_DVR_CHANNEL struRemoteChannel; //Remote channel
}NET_DVR_SLAVE_CHANNEL_UNION,*LPNET_DVR_SLAVE_CHANNEL_UNION;

//Slave channel parameters
typedef struct tagNET_DVR_SLAVE_CHANNEL_PARAM
{
    BYTE   byChanType;   //Slave channel type\A3\AC1-local\A3\AC2-remote
    BYTE   byRes1[3];    //Reserved
    NET_DVR_SLAVE_CHANNEL_UNION uSlaveChannel; //Slave channel union\A3\ACdepends on the value of byChanType
    BYTE   byRes2[64];   //Reserved
}NET_DVR_SLAVE_CHANNEL_PARAM,*LPNET_DVR_SLAVE_CHANNEL_PARAM;


//Slave channel config parameters
typedef struct tagNET_DVR_SLAVE_CHANNEL_CFG
{
    DWORD dwSize;   //Structure size
    NET_DVR_SLAVE_CHANNEL_PARAM struChanParam[MAX_SLAVE_CHANNEL_NUM];//Slave channel list
    BYTE  byRes[64];  //Reserved
}NET_DVR_SLAVE_CHANNEL_CFG,*LPNET_DVR_SLAVE_CHANNEL_CFG;

//Video quality diagnostic detect event
typedef enum tagVQD_EVENT_ENUM
{
    ENUM_VQD_EVENT_BLUR           = 1,  //Image blurring
    ENUM_VQD_EVENT_LUMA           = 2,  //Brightness abnormal
    ENUM_VQD_EVENT_CHROMA         = 3,  //Color cast
    ENUM_VQD_EVENT_SNOW           = 4,  //Snow
    ENUM_VQD_EVENT_STREAK         = 5,  //Streak
    ENUM_VQD_EVENT_FREEZE         = 6,  //Freeze
    ENUM_VQD_EVENT_SIGNAL_LOSS    = 7,  //Signal loss
    ENUM_VQD_EVENT_PTZ            = 8,  //Ptz out of control
    ENUM_VQD_EVENT_SCNENE_CHANGE  = 9,  //Scene change
    ENUM_VQD_EVENT_VIDEO_ABNORMAL = 10, //Video abnormal
    ENUM_VQD_EVENT_VIDEO_BLOCK    = 11, //Video block
}VQD_EVENT_ENUM;

//Video quality diagnostic event condition
typedef struct tagNET_DVR_VQD_EVENT_COND
{
    DWORD dwChannel;   //Channel number
    DWORD dwEventType; //Event type\A3\ACrefer to VQD_EVENT_ENUM
    BYTE  byRes[64];   //Reserved
}NET_DVR_VQD_EVENT_COND,*LPNET_DVR_VQD_EVENT_COND;

//Video quality diagnostic event parameters
typedef struct tagNET_DVR_VQD_EVENT_PARAM
{
    BYTE   byThreshold;    //Alarm threshold [0,100]
    BYTE   byTriggerMode;  //Trigger mode,1-continuous\A3\AC2-single
    BYTE   byUploadPic;    //0-Upload alarm picture\A3\AC1-Not upload alarm pic\A3\ACWhether or not,you can always get the lastest alarm picture of certain VQD event, refer to NET_DVR_StartDownload
    BYTE   byRes1;         //Reserved
    DWORD  dwTimeInterval; //Continuous alarm time interval(seconds)
    BYTE   byRes2[64];     //Reserved
}NET_DVR_VQD_EVENT_PARAM,*LPNET_DVR_VQD_EVENT_PARAM;

//Video quality diagnostic event rule
typedef struct tagNET_DVR_VQD_EVENT_RULE
{
    DWORD  dwSize;       //Structure size
    BYTE   byEnable;     //0-disabled\A3\AC1-enabled
    BYTE   byRes1[3];    //Reserved
    NET_DVR_VQD_EVENT_PARAM struEventParam; //VQD event parameters
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//Detect time
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;  //Handle method
    BYTE   byRelRecordChan[MAX_IVMS_IP_CHANNEL]; //Recording channel triggered by alarm, 1-trigger recording on this channel
    BYTE   byRes2[128];   //Reserved
}NET_DVR_VQD_EVENT_RULE,*LPNET_DVR_VQD_EVENT_RULE;

//Baseline scene parameters
typedef struct tagNET_DVR_BASELINE_SCENE
{
    DWORD dwSize;     //Structure size
    BYTE  byEnable;   //0-disabled\A3\AC1-enabled
    BYTE  byRes[63];  //Reserved
}NET_DVR_BASELINE_SCENE,*LPNET_DVR_BASELINE_SCENE;

//Operation of baseline scene
typedef struct tagNET_DVR_CONTROL_BASELINE_SCENE_PARAM
{
    DWORD dwSize;     //Structure size
    DWORD dwChannel;  //Channel number
    BYTE  byCommand;  //Operation type\A3\AC1-Just reserved for future use\A3\AC2-Update baselien scene
    BYTE  byRes[127];  //Reserved
}NET_DVR_CONTROL_BASELINE_SCENE_PARAM,*LPNET_DVR_CONTROL_BASELINE_SCENE_PARAM;

//Video quality diagnostic alarm
typedef struct tagNET_DVR_VQD_ALARM
{
    DWORD  dwSize;                //Structure size
    DWORD  dwRelativeTime;        //Relative time
    DWORD  dwAbsTime;              //Absolute time
    NET_VCA_DEV_INFO struDevInfo; //device info
    DWORD  dwEventType;           //VQD event type\A3\ACrefer to VQD_EVENT_ENUM
    float  fThreshold;            //Alarm threshold [0.000,1.000]
    DWORD  dwPicDataLen;          //Alarm picture data,if 0, there is no picture uploaded
    BYTE   *pImage;               //Pointer to picture data
    BYTE   byRes[128];            //Reserved
}NET_DVR_VQD_ALARM,*LPNET_DVR_VQD_ALARM;

//Sub structure for calibration point
typedef struct tagNET_DVR_CB_POINT
{
    NET_VCA_POINT struPoint;      //calibration point, main camera (fixed camera)
    NET_DVR_PTZPOS struPtzPos;    //Input PTZ position of the speed dome
    BYTE    byRes[8];
}NET_DVR_CB_POINT,  LPNET_DVR_CB_POINT;

//Calibration parameters
typedef struct tagNET_DVR_TRACK_CALIBRATION_PARAM
{
    BYTE byPointNum;             //Valid calibration
    BYTE byRes[3];
    NET_DVR_CB_POINT  struCBPoint[MAX_CALIB_PT];  //Valid calibration group
}NET_DVR_TRACK_CALIBRATION_PARAM,  *LPNET_DVR_TRACK_CALIBRATION_PARAM;

//Speed Dome configuration
typedef struct tagNET_DVR_TRACK_CFG
{
    DWORD dwSize;                       //Structure size
    BYTE byEnable;                     //Enable/disable calibration
    BYTE byFollowChan;              //Corresponding channel calibrated
    BYTE byDomeCalibrate;             //Set calibration for auto-tracking speed dome, 1-enable, 0-disable
    BYTE byRes;                     //Reserved
    NET_DVR_TRACK_CALIBRATION_PARAM  struCalParam;  //Calibration group
}NET_DVR_TRACK_CFG,  *LPNET_DVR_TRACK_CFG ;

//Tracking mode
typedef enum _TRACK_MODE_
{
    MANUAL_CTRL = 0,   //Manual tracking
    ALARM_TRACK,       //Alarm triggering tracking
    TARGET_TRACK       //Target tracking
}TRACK_MODE;

//Manual control mode
typedef struct tagNET_DVR_MANUAL_CTRL_INFO
{
    NET_VCA_POINT struCtrlPoint;
    BYTE  byRes[8];
}NET_DVR_MANUAL_CTRL_INFO,  *LPNET_DVR_MANUAL_CTRL_INFO ;

//Tracking mode
typedef struct tagNET_DVR_TRACK_MODE
{
    DWORD dwSize;            //Structure size
    BYTE byTrackMode;      //Tracking mode
    BYTE byRuleConfMode;   //Configuration of tracking mode: 0- local tracking mode config, 1- remote tracking mode config
    BYTE byRes[2];         //Reserved
    union
    {
        DWORD dwULen[4];
        NET_DVR_MANUAL_CTRL_INFO  struManualCtrl; //Manual tracking structure
    }uModeParam;
}NET_DVR_TRACK_MODE, *LPNET_DVR_TRACK_MODE;

typedef struct tagNET_DVR_ALARM_JPEG
{
    BYTE    byPicProType;             //Upload snapshot on alarm 0- disable;  1- upload
    BYTE    byRes[3];               //Reserved
    NET_DVR_JPEGPARA struPicParam;  //Snapshot structure
}NET_DVR_ALARM_JPEG,  *LPNET_DVR_ALARM_JPEG;

/**********************ipc/d5.3.0********************************/
typedef struct tagNET_DVR_PHY_RATIO
{
    DWORD  dwSize;
    DWORD  dwPhysicsRatio;
    BYTE   byRes[60];
}NET_DVR_PHY_RATIO, *LPNET_DVR_PHY_RATIO;

typedef struct tagNET_DVR_SLAVECAMERA_COND
{
    DWORD            dwSize;
    DWORD            dwChannel;
    BYTE             byID;//SlaveCamera ID number [1,4]
    BYTE             byRes1[3];
    DWORD           dwSceneID;// scene Id
    BYTE             byRes[56];
}NET_DVR_SLAVECAMERA_COND, *LPNET_DVR_SLAVECAMERA_COND;

typedef struct tagNET_DVR_SLAVECAMERA_CFG
{
    DWORD            dwSize;
    BYTE                 byAddressType;   //0-ipv4 ipv6 1-domain
    WORD                wPort;
    BYTE               byLoginStatus; /*Slave Camera Login Status 0-logout,1-login*/
    union
    {
        struct
        {
            BYTE            szDomain[MAX_DOMAIN_NAME/*64*/];
            BYTE            byRes1[80];
        }struDomain;
        struct
        {
            NET_DVR_IPADDR     struIp;
        } struAddrIP;
    }unionServer;
    BYTE                szUserName[NAME_LEN/*32*/];
    BYTE                szPassWord[PASSWD_LEN/*16*/];
    BYTE        byRes1[128];
}NET_DVR_SLAVECAMERA_CFG, *LPNET_DVR_SLAVECAMERA_CFG;

typedef struct tagNET_DVR_SLAVECAMERA_PARAM
{
    BYTE             byLinkStatus ;// 0- offline\A3\AC1-online
    BYTE             byRes[15];
}NET_DVR_SLAVECAMERA_PARAM, *LPNET_DVR_SLAVECAMERA_PARAM;

typedef struct tagNET_DVR_SLAVECAMERA_STATUS
{
    DWORD            dwSize;
    NET_DVR_SLAVECAMERA_PARAM  struSlaveCamera[MAX_SLAVECAMERA_NUM/*8*/];
    BYTE             byRes[64];
}NET_DVR_SLAVECAMERA_STATUS, *LPNET_DVR_SLAVECAMERA_STATUS;

typedef struct tagNET_PTZ_INFO
{
    float fPan;
    float fTilt;
    float fZoom;
    DWORD dwFocus;//0-100000
    BYTE  byRes[4];
}NET_PTZ_INFO, *LPNET_PTZ_INFO;

typedef struct tagNET_DVR_CALIB_PARAM
{
    NET_PTZ_INFO   struPtzInfo;
    NET_VCA_POINT  struCalibCoordinates;
    BYTE      byRes[16];
}NET_DVR_CALIB_PARAM, *LPNET_DVR_CALIB_PARAM;

typedef struct tagNET_DVR_SLAVECAMERA_CALIB_CFG
{
    DWORD            dwSize;
    BYTE              byCalibMode;//0-res,1-auto, 2-manual
    BYTE             byRes[3];
    NET_DVR_CALIB_PARAM  struCalibParam[MAX_CALIB_NUM/*6*/];
    BYTE             byRes1[64];
}NET_DVR_SLAVECAMERA_CALIB_CFG, *LPNET_DVR_SLAVECAMERA_CALIB_CFG;

typedef struct tagNET_DVR_TRACKING
{
    DWORD dwSize;
    BYTE byEnable;      // 0-false,1-true
    BYTE byMode;        // 0-close\A3\AC1-manual\A3\AC2-auto
    WORD  wTrackingTime;// tracking Time\A3\BA[0,60]s
    NET_VCA_POLYGON struRegion;
    BYTE byRes[64];
}NET_DVR_TRACKING,*LPNET_DVR_TRACKING;

typedef struct tagNET_DVR_SLAVECAMERA_CALIB_V50
{
    DWORD            dwSize;
    BYTE               byCalibMode;//0-Res,1-auto, 2-manual
    BYTE             byRes[3];
    NET_DVR_CALIB_PARAM  struCalibParam[MAX_CALIB_NUM_EX/*20*/];
    BYTE             byRes1[64];
}NET_DVR_SLAVECAMERA_CALIB_V50, *LPNET_DVR_SLAVECAMERA_CALIB_V50;

typedef struct tagNET_DVR_SLAVECAMERA_CALIB_V51
{
    DWORD            dwSize;
    BYTE                byCalibMode;//0-Res,1-auto, 2-manual
    BYTE             byRes[3];
    NET_DVR_CALIB_PARAM  struCalibParam[MAX_CALIB_NUM_EX/*20*/];
    BYTE            byRes1[512];
}NET_DVR_SLAVECAMERA_CALIB_V51, *LPNET_DVR_SLAVECAMERA_CALIB_V51;

//The special features at the structure (eagle eye)
typedef	struct tagNET_DVR_CAPTURE_PICTURE_RESULT
{
    DWORD		dwSize;//The structure size
    DWORD    dwReturnPicSize;//Returns the size of the image
    BYTE        byRes[256];
}NET_DVR_CAPTURE_PICTURE_RESULT, *LPNET_DVR_CAPTURE_PICTURE_RESULT;

typedef struct tagNET_DVR_GOTOSCENE_COND
{
    DWORD            dwSize;
    DWORD            dwChannel;
    DWORD            dwSceneID;//scene id
    BYTE              byRes[512];
}NET_DVR_GOTOSCENE_COND, *LPNET_DVR_GOTOSCENE_COND;

typedef struct tagNET_DVR_TRACK_INITPOSTION
{
    DWORD            dwSize;
    DWORD            dwChannel;
    BYTE             byID;
    BYTE             byRes[127];
}NET_DVR_TRACK_INITPOSTION, *LPNET_DVR_TRACK_INITPOSTION;

typedef struct tagNET_DVR_MANUAL_TRACKRATIO
{
    DWORD            dwSize;
    BYTE             byCoefficient;//Track Ratio Coefficient [1,60]
    BYTE             byRes[127];
}NET_DVR_MANUAL_TRACKRATIO, *LPNET_DVR_MANUAL_TRACKRATIO;

/**********************ipc/d5.3.0********************************/

//iVMS rule structure
//Alarm rule structure
typedef struct tagNET_IVMS_ONE_RULE_
{
    BYTE    byActive;            /* active the rule, 0- disable,  else- yes */
    BYTE    byRes1[7];     //Reserved as 0
    BYTE   byRuleName[NAME_LEN];  //Rule name
    VCA_EVENT_TYPE dwEventType;    //VCA event type
    NET_VCA_EVENT_UNION uEventParam; //VCA parameters
    NET_VCA_SIZE_FILTER  struSizeFilter;   //Size filter
    BYTE byRes2[68];  /*Reserved as 0*/
}NET_IVMS_ONE_RULE,  *LPNET_IVMS_ONE_RULE;

// iVMS rule structure
typedef struct tagNET_IVMS_RULECFG
{
    NET_IVMS_ONE_RULE  struRule[MAX_RULE_NUM];    //rule array
}NET_IVMS_RULECFG,  *LPNET_IVMS_RULECFG;

// IVMS VCA configuration structure
typedef struct tagNET_IVMS_BEHAVIORCFG
{
    DWORD dwSize;
    BYTE    byPicProType;         //Upload snapshot on alarm: 0-disable;  else- upload
    BYTE    byRes[3];
    NET_DVR_JPEGPARA struPicParam;                  //snapshot structure
    NET_IVMS_RULECFG struRuleCfg[MAX_DAYS][MAX_TIMESEGMENT]; //corresponding rule on each time period
} NET_IVMS_BEHAVIORCFG,  *LPNET_IVMS_BEHAVIORCFG;

//Sub structure of the iVMS sub stream query
typedef struct tagNET_IVMS_DEVSCHED
{
    NET_DVR_SCHEDTIME     struTime;        //time structure
    NET_DVR_PU_STREAM_CFG struPUStream;  //PU streaming parameters
}NET_IVMS_DEVSCHED,  *LPNET_IVMS_DEVSCHED;

//iVMS configuration structure
typedef struct tagNET_IVMS_STREAMCFG
{
    DWORD dwSize;
    NET_IVMS_DEVSCHED    struDevSched[MAX_DAYS][MAX_TIMESEGMENT]; // Set PU streaming and rule by time period
} NET_IVMS_STREAMCFG,  *LPNET_IVMS_STREAMCFG;

//Mask Area
typedef struct tagNET_VCA_MASK_REGION
{
    BYTE byEnable;             //Activate privacy mask,  0- disable, else- enable
    BYTE byRes[3];          //Reserved as 0
    NET_VCA_POLYGON  struPolygon;  //Mask Polygon
}NET_VCA_MASK_REGION,  * LPNET_VCA_MASK_REGION;

//Mask region list structure
typedef struct tagNET_VCA_MASK_REGION_LIST
{
    DWORD dwSize;      //Structure length
    BYTE byRes[4];      //Reserved as 0
    NET_VCA_MASK_REGION  struMask[MAX_MASK_REGION_NUM];  //Mask region list structure
}NET_VCA_MASK_REGION_LIST,  *LPNET_VCA_MASK_REGION_LIST;


//ATM Enter Region
typedef struct tagNET_VCA_ENTER_REGION//Mask the target entering the region to avoid interference on ATM detection
{
    DWORD dwSize;
    BYTE byEnable;             //Activate the function, 0- disable, else- enable
    BYTE byRes1[3];
    NET_VCA_POLYGON  struPolygon;  //Enter area
    BYTE byRes2[16];
}NET_VCA_ENTER_REGION,  * LPNET_VCA_ENTER_REGION;

//IVMS mask region list
typedef struct tagNET_IVMS_MASK_REGION_LIST
{
    DWORD dwSize;     //Structure length
    NET_VCA_MASK_REGION_LIST struList[MAX_DAYS][ MAX_TIMESEGMENT];
}NET_IVMS_MASK_REGION_LIST,  *LPNET_IVMS_MASK_REGION_LIST;

//ATM enter area parameters of iVMS
typedef struct tagNET_IVMS_ENTER_REGION
{
    DWORD dwSize;
    NET_VCA_ENTER_REGION  struEnter[MAX_DAYS][ MAX_TIMESEGMENT];  //Enter area
}NET_IVMS_ENTER_REGION,  *LPNET_IVMS_ENTER_REGION;

// iVMS alarm upload structure
typedef struct tagNET_IVMS_ALARM_JPEG
{
    BYTE                byPicProType;
    BYTE                byRes[3];
    NET_DVR_JPEGPARA      struPicParam;
}NET_IVMS_ALARM_JPEG,  *LPNET_IVMS_ALARM_JPEG;

// IVMS  Playback Search Config
typedef struct tagNET_IVMS_SEARCHCFG
{
    DWORD                        dwSize;
    NET_DVR_MATRIX_DEC_REMOTE_PLAY struRemotePlay; // Remote playback
    NET_IVMS_ALARM_JPEG         struAlarmJpeg;  // alarm snapshot upload config
    NET_IVMS_RULECFG           struRuleCfg;    //IVMS VCA rule config
}NET_IVMS_SEARCHCFG,  *LPNET_IVMS_SEARCHCFG;

//Calibration parameters
typedef struct tagNET_DVR_TRACK_CALIBRATION_PARAM_V41
{
    BYTE byPointNum;    //Calibration point number
    BYTE byRes[3];        //Reserved
    NET_DVR_CB_POINT  struCBPoint[MAX_CALIB_PT]; //Calibration point group
    NET_DVR_PTZPOS struHorizonPtzPos;  //Horizontal positon of the track device
    BYTE byRes2[256];    //Reserved
}NET_DVR_TRACK_CALIBRATION_PARAM_V41, *LPNET_DVR_TRACK_CALIBRATION_PARAM_V41;

//Tracking device configuration parameters
typedef struct tagNET_DVR_TRACK_DEV_PARAM_
{
    DWORD  dwSize;         //Structure size
    BYTE   byEnable;       //Track device enabled, 0-disable, 1 -enable
    BYTE   byTransMode;    //Communication mode\A3\AC0-NET SDK\A3\AC1-Serial port 485
    BYTE   byRes1[2];       //Reserved
    NET_DVR_CHANNEL  struTrackDevChan; //Tracking device parameters
    NET_DVR_TRACK_CALIBRATION_PARAM_V41 struCalParam; //Tracking device calibration parameters
    BYTE    byRes2[256];    //Reserved
}NET_DVR_TRACK_DEV_PARAM, *LPNET_DVR_TRACK_DEV_PARAM;

/************************************end******************************************/
//NAS identification cfg
typedef struct tagNET_DVR_IDENTIFICATION_PARAM
{
    BYTE    sUserName[NAME_LEN];        /* username len 32*/
    BYTE    sPassword[PASSWD_LEN];        /* passwd len 16*/
    BYTE    byRes1[4];    //res
}NET_DVR_IDENTIFICATION_PARAM, *LPNET_DVR_IDENTIFICATION_PARAM;

typedef union tagNET_DVR_MOUNT_PARAM_UNION
{
    BYTE  uLen[52];                    //union len
    NET_DVR_IDENTIFICATION_PARAM struIdentificationParam;//(SMB/CIFS work)
} NET_DVR_MOUNT_PARAM_UNION, *LPNET_DVR_MOUNT_PARAM_UNION;

typedef struct tagNET_DVR_NAS_MOUNT_PARAM
{
    BYTE  byMountType; //0\A1\ABres,1~NFS, 2~ SMB/CIFS
    BYTE  byRes[3];
    NET_DVR_MOUNT_PARAM_UNION uMountParam;
}NET_DVR_NAS_MOUNT_PARAM, *LPNET_DVR_NAS_MOUNT_PARAM;

typedef union tagNET_DVR_MOUNTMETHOD_PARAM_UNION
{
    BYTE  uLen[56]; //union len
    NET_DVR_NAS_MOUNT_PARAM struNasMountParam;//NAS mount type (byNetDiskType == NFS(NAS))
}NET_DVR_MOUNTMETHOD_PARAM_UNION, *LPNET_DVR_MOUNTMETHOD_PARAM_UNION;


//Network Disk configuration
typedef struct tagNET_DVR_SINGLE_NET_DISK_INFO
{
    BYTE byNetDiskType;                         //0- NFS, 1- iSCSI
    BYTE byRes1[3];                             //Reserved
    NET_DVR_IPADDR struNetDiskAddr;             //IP address
    BYTE sDirectory[PATHNAME_LEN];             // PATHNAME_LEN = 128
    WORD wPort;                                 //iSCSI port
    BYTE  byRes2[2];
    NET_DVR_MOUNTMETHOD_PARAM_UNION  uMountMethodParam;
    BYTE  byRes3[8];                //res
}NET_DVR_SINGLE_NET_DISK_INFO,  *LPNET_DVR_SINGLE_NET_DISK_INFO;

#define MAX_NET_DISK    16//Max. HDD number

typedef struct tagNET_DVR_NET_DISKCFG
{
    DWORD  dwSize;
    NET_DVR_SINGLE_NET_DISK_INFO struNetDiskParam[MAX_NET_DISK];
}NET_DVR_NET_DISKCFG,  *LPNET_DVR_NET_DISKCFG;

typedef struct tagNET_DVR_SINGLE_NET_DISK_INFO_V40
{
    BYTE byNetDiskType;                         //0- NFS, 1- iSCSI
    BYTE byRes1[3];                             //Reserved
    BYTE sDirectory[PATHNAME_LEN];             // PATHNAME_LEN = 128
    BYTE byDevAddr[MAX_DOMAIN_NAME];    /*domain*/
    WORD wPort;                                 //iSCSI port
    BYTE  byRes2[2];
    NET_DVR_MOUNTMETHOD_PARAM_UNION  uMountMethodParam;
    BYTE    byRes4[80];
}NET_DVR_SINGLE_NET_DISK_INFO_V40,  *LPNET_DVR_SINGLE_NET_DISK_INFO_V40;

typedef struct tagNET_DVR_NET_DISKCFG_V40
{
    DWORD  dwSize;
    NET_DVR_SINGLE_NET_DISK_INFO_V40 struNetDiskParam[MAX_NET_DISK];
}NET_DVR_NET_DISKCFG_V40, *LPNET_DVR_NET_DISKCFG_V40;
//Event Type
//Main type
typedef enum _MAIN_EVENT_TYPE_
{
    EVENT_MOT_DET = 0,             //Motion Detect
    EVENT_ALARM_IN = 1,         //Alarm input
    EVENT_VCA_BEHAVIOR = 2,     //VCA
    EVENT_INQUEST = 3,            //Inquest Event
    EVENT_VCA_DETECTION = 4,    //intelligent detect
    EVENT_POS = 5,
    EVENT_TRIAL_CASE = 6,//case info
    EVENT_STREAM_INFO = 100     //Stream ID information
}MAIN_EVENT_TYPE;

typedef enum _VCA_DETECTION_MINOR_TYPE_
{
    EVENT_VCA_TRAVERSE_PLANE     = 1,        //traverse plane
    EVENT_FIELD_DETECTION,             //field detection
    EVENT_AUDIO_INPUT_ALARM,      //audio input alarm
    EVENT_SOUND_INTENSITY_ALARM,   //sound intensity
    EVENT_FACE_DETECTION,             //face detection
    EVENT_VIRTUAL_FOCUS_ALARM, /*virtul focus*/
    EVENT_SCENE_CHANGE_ALARM, /*scene change*/
    EVENT_PIR_ALARM,
    EVENT_ENTER_REGION,                           //enter region
    EVENT_EXIT_REGION,                            //exit region
    EVENT_LOITERING,                               //loitering
    EVENT_GROUPDETECTION,                       //group detection
    EVENT_RAPIDMOVE,                            //rapidmove
    EVENT_PARK,                              //park
    EVENT_UNATTENDED_BAGGAGE,                   //unattended baggage
    EVENT_ATTENDEDBAGGAGE,                      //attended baggage
    EVENT_VEHICLE_DETECTION,                     //vehicle detection
    EVENT_ALL = 0xffffffff                //all
}VCA_DETECTION_MINOR_TYPE;

#define INQUEST_START_INFO        0x1001
#define INQUEST_STOP_INFO         0x1002
#define INQUEST_TAG_INFO          0x1003
#define INQUEST_SEGMENT_INFO      0x1004
#define INQUEST_CASE_INFO          0x1005

//VCA event type corresponding to the main event type, 0xffff stands for all
typedef enum _BEHAVIOR_MINOR_TYPE_
{
    EVENT_TRAVERSE_PLANE     = 0,   //Traverse plane
    EVENT_ENTER_AREA,                 //target enter area (region rule)
    EVENT_EXIT_AREA,                 //target leave area  (region rule)
    EVENT_INTRUSION,                 //Intrusion  (region rule)
    EVENT_LOITER,                     //Loitering  (region rule)
    EVENT_LEFT_TAKE,                 //Object left or taken  (region rule)
    EVENT_PARKING,                     //Illegal parking  (region rule)
    EVENT_RUN,                         //Running (region rule)
    EVENT_HIGH_DENSITY,
    EVENT_STICK_UP,                    //Stick up, support area rule
    EVENT_INSTALL_SCANNER,            //Install scanner, support area rule
    EVENT_OPERATE_OVER_TIME,        //Operation overtime
    EVENT_FACE_DETECT,              //Exception face
    EVENT_LEFT,                     //Items left
    EVENT_TAKE,                      //Items take
    EVENT_LEAVE_POSITION,         //Leave position
    EVENT_TRAIL_INFO = 16,            //Trial
    EVENT_FALL_DOWN_INFO = 19,                 //Fall down
    EVENT_OBJECT_PASTE        =20,        //object paste
    EVENT_FACE_CAPTURE_INFO = 21,                //Face capture
    EVENT_MULTI_FACES_INFO = 22,                  //Multi faces
    EVENT_AUDIO_ABNORMAL_INFO = 23,             //Audio abnormal
    EVENT_DETECT    = 24                    //smart detection
}BEHAVIOR_MINOR_TYPE;

//Major type 6, minor type
typedef enum _TRIAL_CASE_MINOR_TYPE_
{
    TRIAL_START_INFO  = 0x1001,    // trial start info
    TRIAL_STOP_INFO   = 0x1002,        //trial stio info
    TRIAL_TAG_INFO    = 0x1003,        //trial tag info
    TRIAL_SEGMENT_INFO = 0x1004,    // trial segment info
    TRIAL_JUDGE_CASE_INFO=0x1005 //judge case info
}TRIAL_CASE_MINOR_TYPE;

// Major type 100, minor type
typedef enum _STREAM_INFO_MINOR_TYPE_
{
    EVENT_STREAM_ID  = 0,                // all stream id record
    EVENT_TIMING = 1,                    // time record
    EVENT_MOTION_DETECT = 2,            // motion detect record
    EVENT_ALARM = 3,                    // alarm record
    EVENT_ALARM_OR_MOTION_DETECT = 4,    // alarm or motion detect record
    EVENT_ALARM_AND_MOTION_DETECT = 5,    // alarm and motion detect record
    EVENT_COMMAND_TRIGGER = 6,            // command trigger
    EVENT_MANNUAL = 7,                    // mannual record
    EVENT_BACKUP_VOLUME = 8,            // Backup volume
    STREAM_EVENT_SEMAPHORE,
    STREAM_EVENT_HIDE,
    STREAM_EVENT_INVERSE,
    STREAM_EVENT_VIDEO_LOST,
    STREAM_EVENT_WIRELESS_ALARM,
    STREAM_EVENT_PIR_ALARM,
    STREAM_EVENT_CALLHELP_ALARM,

    STREAM_EVENT_FACESNAP,
    STREAM_EVENT_FACE_DETECTION,
    STREAM_EVENT_ITS_PLATE,
    STREAM_EVENT_PDC,
    STREAM_EVENT_SCENECHANGE_DETECTION,
    STREAM_EVENT_DEFOCUS_DETECTION,
    STREAM_EVENT_AUDIOEXCEPTION,

    VCA_EVENT_TRAVERSE_PLANE,
    VCA_EVENT_INTRUSION,
    VCA_EVENT_ENTER_AREA,
    VCA_EVENT_EXIT_AREA,
    VCA_EVENT_LOITER,
    VCA_EVENT_HIGH_DENSITY,
    VCA_EVENT_RUN,
    VCA_EVENT_PARKING,
    VCA_EVENT_LEFT,
    VCA_EVENT_TAKE
}STREAM_INFO_MINOR_TYPE;



#define SEARCH_EVENT_INFO_LEN 300    //Event info length
#define CASE_NO_LEN                64
#define CASE_NAME_LEN            128
#define LITIGANT_LEN            32
#define CHIEF_JUDGE_LEN         32
#define     SEARCH_CASE_NO_LEN        56
#define  SEARCH_CASE_NAME_LEN    100
#define  SEARCH_LITIGANT_LEN    32
#define  SEARCH_CHIEF_JUDGE_LEN 32
#define     CASE_NO_RET_LEN        52
#define  CASE_NAME_RET_LEN        64
#define     LITIGANT_RET_LEN        24
#define     CHIEF_JUDGE_RET_LEN    24

//Event search condition
typedef struct tagNET_DVR_SEARCH_EVENT_PARAM
{
    WORD wMajorType;             //0- Motion detect, 1- Alarm input,  2-  intelligent event
    WORD wMinorType;             //Sub type- diverse according to the main type, 0xffff- all
    NET_DVR_TIME struStartTime; //Search start and end time, (0,  0) stands for searching from the earliest time and get maximum 4000 events
    NET_DVR_TIME struEndTime;
    BYTE            byLockType;        // 0xff-all\A3\AC0-unlock\A3\AC1-lock
    BYTE             byValue;            //0-by bit\A3\AC1-by value
    BYTE             byRes[130];
    union
    {
        BYTE byLen[SEARCH_EVENT_INFO_LEN];
        struct//Alarm input
        {
            BYTE byAlarmInNo[MAX_ALARMIN_V30];     //Alarm input, if the byAlarmInNo[0] is set as 1, then it stands for event triggered by alarm input 1
            BYTE byRes[SEARCH_EVENT_INFO_LEN -  MAX_ALARMIN_V30];
        }struAlarmParam;

        struct//Alarm input -- By Value
        {
            WORD wAlarmInNo[128];     /*Alarm input No. ,according to the values*/
            BYTE byRes[44];
        }struAlarmParamByValue;

        struct//motion detect
        {
            BYTE byMotDetChanNo[MAX_CHANNUM_V30]; //Motion detect channel, if byMotDetChanNo[0] is set as 1, then it stands for event triggered by channel 1 motion detect
            BYTE byRes[SEARCH_EVENT_INFO_LEN -  MAX_CHANNUM_V30];
        }struMotionParam;

        struct//motion detect -- By Value
        {
            WORD wMotDetChanNo[64];        /* Motion detect channel No.,according to the values */
            BYTE byRes[172];
        }struMotionParamByValue;

        struct//VCA
        {
            BYTE byChanNo[MAX_CHANNUM_V30]; //Channel than triggered the event
            BYTE byRuleID;                     //Rule ID, 0xff- all
            BYTE byRes1[43];                 //Reserved
        }struVcaParam;

        struct //VCA-- By Value
        {
            WORD wChanNo[64];     //Channel than triggered the event
            BYTE byRuleID;      //Rule ID, 0xff- all
            BYTE byRes[171];
        }struVcaParamByValue;

        struct//Inquest
        {
            BYTE byRoomIndex;    //Inquest room number
            BYTE byRes1[3];
            BYTE sInquestInfo[INQUEST_CASE_LEN];
            BYTE byRes2[232];     //Reserved
        } struInquestParam;
        struct// VCA Detect Condition
        {
            BYTE byChan [256];//VCA Detect Trigger channel number, If byChan[0] is 1, is to say Find VCA Detect chan 1
        }struVCADetectByBit;

        struct   // VCA Detect Condition, Chan  indicated by value
        {
            DWORD dwChanNo[MAX_CHANNUM_V30-1];// VCA Detect Trigger channel number, by value,  0xffffffff invalid and subsequent data also indicates an invalid value
            BYTE byAll;//0-not all\A3\AC1-all
            BYTE byres[3];
        }struVCADetectByValue;
        struct
        {
            NET_DVR_STREAM_INFO struIDInfo; // Stream id
            DWORD                dwCmdType;  // Command type
            BYTE                byBackupVolumeNum;
            BYTE                byRes[223];
        }struStreamIDParam;
        struct
        {
            BYTE    byCaseNo[SEARCH_CASE_NO_LEN];
            BYTE    byCaseName[SEARCH_CASE_NAME_LEN];
            BYTE    byLitigant1[SEARCH_LITIGANT_LEN];
            BYTE    byLitigant2[SEARCH_LITIGANT_LEN];
            BYTE    byChiefJudge[SEARCH_CHIEF_JUDGE_LEN];
            BYTE    byCaseType;
            BYTE    byRes[47];
        }struTrialParam;
    }uSeniorParam;
}NET_DVR_SEARCH_EVENT_PARAM,  *LPNET_DVR_SEARCH_EVENT_PARAM;

#define  MAX_POS_KEYWORDS_NUM               3
#define  MAX_POS_KEYWORD_LEN                128
#define  MAX_POS_FILTER_DATA_LEN_MAX         128
#define  SEARCH_EVENT_INFO_LEN_V40             800


typedef struct tagNET_DVR_SEARCH_EVENT_PARAM_V40
{
    WORD wMajorType;             //0- Motion detect, 1- Alarm input,  2-  intelligent event
    WORD wMinorType;             //Sub type- diverse according to the main type, 0xffff- all
    NET_DVR_TIME struStartTime; //Search start and end time, (0,  0) stands for searching from the earliest time and get maximum 4000 events
    NET_DVR_TIME struEndTime;
    BYTE            byLockType;        // 0xff-all\A3\AC0-unlock\A3\AC1-lock
    BYTE             byRes[131];
    union
    {
        BYTE byLen[SEARCH_EVENT_INFO_LEN_V40/*800*/];
        struct//Alarm input -- By Value
        {
            WORD wAlarmInNo[128];     /*Alarm input No. ,according to the values*/
            BYTE byRes[544];
        }struAlarmParam;

        struct
        {

            WORD wMotDetChanNo[MAX_CHANNUM_V30];
            BYTE byRes[672];
        }struMotionParam;

        struct
        {
            WORD wChanNo[MAX_CHANNUM_V30];
            BYTE byRuleID;
            BYTE byRes[671];
        }struVcaParam;

        struct
        {
            BYTE byRoomIndex;
            BYTE byRes[799];
        } struInquestParam;

        struct
        {
            BYTE byAll;
            BYTE byRes1[3];
            WORD wChanNo[MAX_CHANNUM_V30];
            BYTE byRes[668];
        }struVCADetect;

        struct
        {
            NET_DVR_STREAM_INFO struIDInfo; // Stream id
            DWORD                dwCmdType;  // Command type
            BYTE                byBackupVolumeNum;
            BYTE                byRes[723];
        }struStreamIDParam;

        struct
        {
            WORD    wChannel[MAX_CHANNUM_V30];
            BYTE    byAllChan;
            BYTE    byCaseSensitive;
            BYTE    byCombinateMode;
            BYTE    byRes1;
            char    sKeyWord[MAX_POS_KEYWORDS_NUM][MAX_POS_KEYWORD_LEN];
            BYTE    byRes[284];
        }struPosAlarm;

        struct
        {
            BYTE    byCaseNo[SEARCH_CASE_NO_LEN];
            BYTE    byCaseName[SEARCH_CASE_NAME_LEN];
            BYTE    byLitigant1[SEARCH_LITIGANT_LEN];
            BYTE    byLitigant2[SEARCH_LITIGANT_LEN];
            BYTE    byChiefJudge[SEARCH_CHIEF_JUDGE_LEN];
            BYTE    byCaseType;
            BYTE    byRes[47];
        }struTrialParam;
    }uSeniorParam;
}NET_DVR_SEARCH_EVENT_PARAM_V40, *LPNET_DVR_SEARCH_EVENT_PARAM_V40;


//Search result returned
typedef struct tagNET_DVR_SEARCH_EVENT_RET
{
    WORD wMajorType;             //Main type
    WORD wMinorType;             //Sub type
    NET_DVR_TIME struStartTime; //Event starts time
    NET_DVR_TIME struEndTime;   //Event ends time, it will be equal to the start time for pulse event
    BYTE byChan[MAX_CHANNUM_V30];
    BYTE byChanEx[32];         //Expand bychan ,you can use this byChanEx replace byChan
    BYTE byRes[4];
    union
    {
        struct//alarm input result
        {
            DWORD dwAlarmInNo;      //alarm input number
            BYTE byRes[SEARCH_EVENT_INFO_LEN];
        }struAlarmRet;
        struct//Motion detect result
        {
            DWORD dwMotDetNo;     //Motion detect channel
            BYTE byRes[SEARCH_EVENT_INFO_LEN];
        }struMotionRet;
        struct//VCA
        {
            DWORD dwChanNo;                     //Channel than VCA event is triggered
            BYTE byRuleID;                     //Rule ID
            BYTE byRes1[3];                     //Reserved
            BYTE byRuleName[NAME_LEN];         //Rule ID
            NET_VCA_EVENT_UNION uEvent;      //VCA event parameters, wMinorType = VCA_EVENT_TYPE
        }struVcaRet;
        struct//Inquest
        {
            BYTE  byRoomIndex;     //Inquest room number
            BYTE  byDriveIndex;    //Driver number
            BYTE  byRes1[6];       //Reserved
            DWORD dwSegmentNo;     //Segment number
            WORD  wSegmetSize;     //Segment size,M
            WORD  wSegmentState;   //Segment state: 0- Normal, 1- Exception, 2- CD not write when inquest
            BYTE  byRes2[288];     //Reserved
        }struInquestRet;
        struct // Stream id
        {
            DWORD dwRecordType;        //record type
            DWORD dwRecordLength;    //record length
            BYTE  byLockFlag;    // lock flag 0\A3\BAlocked 1\A3\BAnot locked
            BYTE  byDrawFrameType;    // 0\A3\BAcommon record 1\A3\BAdraw frame record
            BYTE  byRes1[2];
            BYTE  byFileName[NAME_LEN];     //File name
            DWORD dwFileIndex;
            BYTE  byRes[256];
        }struStreamIDRet;
        struct
        {
            BYTE    byRoomIndex;
            BYTE    byDriveIndex;
            WORD    wSegmetSize;
            DWORD    dwSegmentNo;
            BYTE    bySegmentState;
            BYTE    byCaseType;
            BYTE    byRes[2];
            BYTE    byCaseNo[CASE_NO_RET_LEN];
            BYTE    byCaseName[CASE_NAME_RET_LEN];
            BYTE    byLitigant1[LITIGANT_RET_LEN];
            BYTE    byLitigant2[LITIGANT_RET_LEN];
            BYTE    byChiefJudge[CHIEF_JUDGE_RET_LEN];
            BYTE    byRes1[104];
        }struTrialRet;
    }uSeniorRet;
}NET_DVR_SEARCH_EVENT_RET,  *LPNET_DVR_SEARCH_EVENT_RET;


typedef struct tagNET_DVR_SEARCH_EVENT_RET_V40
{
    WORD wMajorType;             //Main type
    WORD wMinorType;             //Sub type
    NET_DVR_TIME struStartTime; //Event starts time
    NET_DVR_TIME struEndTime;   //Event ends time, it will be equal to the start time for pulse event

    WORD  wChan[MAX_CHANNUM_V40/*512*/];
    BYTE byRes[36];
    union
    {
        BYTE  byLen[800];
        struct//alarm input result
        {
            DWORD dwAlarmInNo;      //alarm input number
            BYTE byRes[796];
        }struAlarmRet;
        struct//Motion detect result
        {
            DWORD dwMotDetNo;     //Motion detect channel
            BYTE byRes[796];
        }struMotionRet;
        struct//VCA
        {
            DWORD dwChanNo;                     //Channel than VCA event is triggered
            BYTE byRuleID;                     //Rule ID
            BYTE byRes1[3];                     //Reserved
            BYTE byRuleName[NAME_LEN];         //Rule ID
            NET_VCA_EVENT_UNION uEvent;      //VCA event parameters, wMinorType = VCA_EVENT_TYPE
            BYTE byRes[668];                    //Reserved
        }struVcaRet;

        struct//Inquest
        {
            BYTE  byRoomIndex;     //Inquest room number
            BYTE  byDriveIndex;    //Driver number
            BYTE  byRes1[6];       //Reserved
            DWORD dwSegmentNo;     //Segment number
            WORD  wSegmetSize;     //Segment size,M
            WORD  wSegmentState;   //Segment state: 0- Normal, 1- Exception, 2- CD not write when inquest
            BYTE  byRes2[784];     //Reserved
        }struInquestRet;

        struct
        {
            DWORD dwRecordType;        //record type
            DWORD dwRecordLength;    //record length
            BYTE  byLockFlag;    // lock flag 0\A3\BAlocked 1\A3\BAnot locked
            BYTE  byDrawFrameType;    // 0\A3\BAcommon record 1\A3\BAdraw frame record
            BYTE  byRes1[2];
            BYTE  byFileName[NAME_LEN];     //File name
            DWORD dwFileIndex;
            BYTE  byRes[752];
        }struStreamIDRet;
        struct
        {
            DWORD dwChanNo;
            BYTE byRes[796];
        }struPosRet;
    }uSeniorRet;
}NET_DVR_SEARCH_EVENT_RET_V40, *LPNET_DVR_SEARCH_EVENT_RET_V40;

//SDK_V35  2009- 10- 26


// Set face recognition parameter key word
typedef enum _FACE_PARAM_KEY_
{
    MAX_FACE_SIZE  = 20,    //Max. face size
    MINI_FACE_SIZE = 21        //Min. Face size
}FACE_PARAM_KEY;            //Face recognition parameter


// Calibration type
typedef enum tagCALIBRATE_TYPE
{
    PDC_CALIBRATE           = 0x01,  //PDC calibration
    BEHAVIOR_OUT_CALIBRATE  = 0x02,  //VCA outdoor calibration
    BEHAVIOR_IN_CALIBRATE   = 0x03,  //VCA indoor calibration
    ITS_CALBIRETE           = 0x04,  //Traffic event calibration
    BV_DIRECT_CALIBRATE     = 0x05,  //Binocular camera calibration
    PDC_LINE_CALIBRATE      = 0x06   //PDC Line
}CALIBRATE_TYPE;

#define MAX_RECT_NUM  6
typedef struct tagNET_DVR_RECT_LIST
{
    BYTE    byRectNum;     // Rectangle number
    BYTE    byRes1[11];   //Reserved
    NET_VCA_RECT struVcaRect[MAX_RECT_NUM];  // Maximum 6 rectangles
}NET_DVR_RECT_LIST,  *LPNET_DVR_RECT_LIST;

// PDC  Calibration
typedef struct tagNET_DVR_PDC_CALIBRATION
{
    NET_DVR_RECT_LIST struRectList;   //Calibrated rectangle list
    BYTE           byRes[120];        //Reserved
}NET_DVR_PDC_CALIBRATION,  *LPNET_DVR_PDC_CALIBRATION;


//Calibration line mode
typedef enum tagLINE_MODE
{
    HEIGHT_LINE,           //Height calibration
    LENGTH_LINE        //Length calibration
}LINE_MODE;
/*
For calibration setting, if the user also set 'enable' status, then they can set corresponding parameters,
otherwise the users can get relative parameters after calibration setting
*/
typedef struct tagNET_DVR_CAMERA_PARAM
{
    BYTE    byEnableHeight;    //Enable camera height line setting
    BYTE    byEnableAngle;     //Enable camera view angle setting
    BYTE    byEnableHorizon;   //Enable camera horizon setting
    BYTE    byRes[5];          //Reserved
    float   fCameraHeight;     //Enable Camera height setting
    float   fCameraAngle;      //Enable Camera install angle setting
    float   fHorizon;          //enable setting of  video scene's horizon
}NET_DVR_CAMERA_PARAM,  *LPNET_DVR_CAMERA_PARAM;
/*
 If the fValue stands for the target height, then struStartPoint and struEndPoint stands for the target upped point and bottom point
If the fValue stands for the length of the line, then struStartPoint and struEndPoint stands for the start point and end point of the line
mode stands for the line type (height or length)
*/
typedef struct tagNET_DVR_LINE_SEGMENT
{
    BYTE            byLineMode;      //plz refer to LINE_MODE
    BYTE            byRes[3];        //Reserved
    NET_VCA_POINT   struStartPoint;
    NET_VCA_POINT   struEndPoint;
    float           fValue;
}NET_DVR_LINE_SEGMENT,  *LPNET_DVR_LINE_SEGMENT;

#define  MAX_LINE_SEG_NUM 8

/*
Needs 4-8 calibration lines to get camera parameters
*/
typedef struct tagNET_DVR_BEHAVIOR_OUT_CALIBRATION
{
    DWORD                   dwLineSegNum;                          // Calibration line number
    NET_DVR_LINE_SEGMENT    struLineSegment[MAX_LINE_SEG_NUM];     // Max. calibration line number
    NET_DVR_CAMERA_PARAM    struCameraParam;                       // Camera parameters
    BYTE byRes[20];
}NET_DVR_BEHAVIOR_OUT_CALIBRATION,  *LPNET_DVR_BEHAVIOR_OUT_CALIBRATION;

/*
Calibration sample
--including 1 target brim rectangle (standing target) and 1 corresponding height calibration line (from head to bottom)
*/
typedef struct tagNET_DVR_IN_CAL_SAMPLE
{
    NET_VCA_RECT struVcaRect;    // target brim rectangle
    NET_DVR_LINE_SEGMENT struLineSegment;     // Height calibration line
}NET_DVR_IN_CAL_SAMPLE,  *LPNET_DVR_IN_CAL_SAMPLE;

#define  MAX_SAMPLE_NUM 5
typedef struct tagNET_DVR_BEHAVIOR_IN_CALIBRATION
{
    DWORD    dwCalSampleNum;       //  Calibration sample number
    NET_DVR_IN_CAL_SAMPLE  struCalSample[MAX_SAMPLE_NUM];  // Max. calibration sample number
    NET_DVR_CAMERA_PARAM    struCameraParam;     // Camera parameters
    BYTE byRes[20];
}NET_DVR_BEHAVIOR_IN_CALIBRATION,  *LPNET_DVR_BEHAVIOR_IN_CALIBRATION;

#define  CALIB_PT_NUM 4
typedef struct tagNET_DVR_ITS_CALIBRATION
{
    DWORD dwPointNum;  //Calibration number
    NET_VCA_POINT struPoint[CALIB_PT_NUM];  //Image coordinates
    float       fWidth;
    float       fHeight;
    BYTE        byRes1[100];         // Reserved
}NET_DVR_ITS_CALIBRATION,  *LPNET_DVR_ITS_CALIBRATION;

typedef struct tagNET_DVR_BV_DIRECT_CALIBRATION
{
    DWORD  dwCameraHeight;   //Camera Height\A3\ACunit:cm
    float  fPitchAngle;      //Camera Pitch Angle[0\A1\E3, 60\A1\E3],
    float  fInclineAngle;    //Camera Incline Angle[-20\A1\E3,20\A1\E3]
    BYTE   byRes1[228];
}NET_DVR_BV_DIRECT_CALIBRATION,*LPNET_DVR_BV_DIRECT_CALIBRATION;

// PDC Line
typedef struct  tagNET_DVR_PDC_LINE_CALIBRATION
{
    NET_VCA_LINE  struCalibrationLine;
    BYTE       byRes[232];
} NET_DVR_PDC_LINE_CALIBRATION, *LPNET_DVR_PDC_LINE_CALIBRATION;


// Calibration union
typedef union tagNET_DVR_CALIBRATION_PRARM_UNION
{
    BYTE byRes[240];                     //Union size
    NET_DVR_PDC_CALIBRATION struPDCCalibration;   //PDC calibration parameters
    NET_DVR_BEHAVIOR_OUT_CALIBRATION  struBehaviorOutCalibration;   //  Outdoor calibration for VCA (mainly for IVS)
    NET_DVR_BEHAVIOR_IN_CALIBRATION  struBehaviorInCalibration;      // Indoor calibration for VCA (mainly for IAS)
    NET_DVR_ITS_CALIBRATION struITSCalibration;
    NET_DVR_BV_DIRECT_CALIBRATION struBvDirectCalibration; // calibration
    NET_DVR_PDC_LINE_CALIBRATION struPDCLineCalibration; //PDC Line
}NET_DVR_CALIBRATION_PRARM_UNION,  *LPNET_DVR_CALIBRATION_PRARM_UNION;


// Calibration configuration
typedef struct tagNET_DVR_CALIBRATION_CFG
{
    DWORD   dwSize;                // Calibration structure size
    BYTE    byEnable;              // Enable/disable calibration
    BYTE    byCalibrationType;     // Calibration type, please refer to CALIBRATE_TYPE
    BYTE    byRes1[2];
    NET_DVR_CALIBRATION_PRARM_UNION uCalibrateParam;   // Calibration type union
    BYTE    byRes2[12];
}NET_DVR_CALIBRATION_CFG,  *LPNET_DVR_CALIBRATION_CFG;

//PDC direction structure
typedef struct  tagNET_DVR_PDC_ENTER_DIRECTION
{
    NET_VCA_POINT struStartPoint;   // Start point of the direction
    NET_VCA_POINT struEndPoint;     // End point of the direction
}NET_DVR_PDC_ENTER_DIRECTION,  *LPNET_DVR_PDC_ENTER_DIRECTION;

typedef struct tagNET_DVR_PDC_RULE_CFG
{
    DWORD           dwSize;               //Structure size
    BYTE            byEnable;             //Enable/disable the function;
    BYTE            byRes1[23];           //Reserved
    NET_VCA_POLYGON          struPolygon;              //Polygon
    NET_DVR_PDC_ENTER_DIRECTION  struEnterDirection;   //Enter direction
} NET_DVR_PDC_RULE_CFG,  *LPNET_DVR_PDC_RULE_CFG;

typedef struct tagNET_DVR_PDC_RULE_CFG_V41
{
    DWORD           dwSize;
    BYTE            byEnable;             // enable;
    BYTE            byRes1[23];       //
    NET_VCA_POLYGON struPolygon;            //polygon
    NET_DVR_PDC_ENTER_DIRECTION  struEnterDirection;    // enter direction
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//alarm time
    NET_DVR_TIME_EX struDayStartTime; //day start time
    NET_DVR_TIME_EX struNightStartTime; //night start time
    BYTE            byRes[100];       //
}NET_DVR_PDC_RULE_CFG_V41, *LPNET_DVR_PDC_RULE_CFG_V41;

/********* IPC5.1.7 Traffic statistical rules Begin 2014-03-21***********/
typedef struct tagNET_DVR_PDC_RULE_COND
{
    DWORD  dwSize;
    DWORD  dwChannel; //Channel No.
    DWORD dwID; //Scene ID, compatible with the ball machine scene concept, more compatible with the old version of the SDK configuration of new equipment, keep byte 0, so the byte 0, also for scenario 1 by default
    BYTE  byRes[60];
}NET_DVR_PDC_RULE_COND, *LPNET_DVR_PDC_RULE_COND;

typedef struct tagNET_DVR_PDC_RULE_CFG_V42
{
    DWORD  dwSize;
    BYTE   byEnable; //byEnable;
    BYTE   byOSDEnable;//Traffic statistics OSD display is enabled, 0 - no (0 - no), 1 - (0 to enter and leave), 2 -, 3 - to leave for the old equipment is not enabled OSD superposition corresponding (no), enable the corresponding (enter/leave).
    BYTE   byCurDetectType;// current detection area type\A3\AC0-Polygon\A3\AC1-Detection line
    BYTE   byInterferenceSuppression; //Interference suppression, bitwise said, 0 - this option is 1 - check, bit0 - shadow, bit1 - hovering, bit2 - cart
    NET_VCA_POINT   struOSDPoint;//OSD Upper left corner
    BYTE   byDataUploadCycle;
    BYTE   bySECUploadEnable;
    BYTE   byEmailDayReport;
    BYTE   byEmailWeekReport;
    BYTE   byEmailMonthReport;
    BYTE   byEmailYearReport;
    BYTE   byRes2[6];
    NET_VCA_POLYGON          struPolygon; // Polygon
    NET_DVR_PDC_ENTER_DIRECTION  struEnterDirection; // Flow Enter Direction
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//Alarm Time
    NET_DVR_TIME_EX struDayStartTime; //Day Start Time
    NET_DVR_TIME_EX struNightStartTime; //Night Start Time
    NET_DVR_HANDLEEXCEPTION_V40 struAlarmHandleType; /*Alarm Handle Type*/
    BYTE   byDetecteSensitivity;//Sensitivity\A3\BARange:1-100\A3\ACDefault:50
    BYTE   byGenerateSpeedSpace;//Generate Speed Space\A3\BARange:1-100\A3\ACDefault:50
    BYTE   byGenerateSpeedTime;// Generate Speed Time\A3\BARange:1-100\A3\ACDefault:50
    BYTE   byCountSpeed;// Count Speed\A3\BARange:1-100\A3\ACDefault:50
    BYTE   byDetecteType;// Detecte Type\A3\BA0-Automatic \A3\AC1-head\A3\AC2-head and shoulders\A3\ACDefault0-Automatic
    BYTE   byTargetSizeCorrect;//Target Size Correction\A3\BARange:1-100\A3\ACDefault:50
    BYTE   byRes3[2];
    NET_VCA_LINE  struLine;//Detection line
    BYTE byHeightFilterEnable;//High filtration is open, 1 to shut down, 2 to open it
    BYTE byRes4[3];
    float fHeightFilter;//Filter height, unit: cm. Default value: 120 cm, range: 40-200 cm. ByHeightFilterEnable 1 is effective
    BYTE byCalibrateType;//1 calibration type, 0 - without the need for automatic calibration, 2 - manual calibration
    BYTE byRes6[3];
    float fTiltAngle;//Pitching Angle, unit: degree; Pitching Angle default: 0; Pitching Angle range: 0-180 degrees
    float fHeelAngle;//Tilt Angle, the unit: degree; Default: 0 slope Angle; Angle range: - 90-90 degrees
    float fHeight;//Height, height unit: cm long; Range of height default value is 300 cm, height: 200-500 cm, setting up effective when byCalibrateType is 2
    NET_VCA_POLYGON struCountPolygon;//Count area, read-only area
    NET_VCA_POLYGON struAutoCalibPolygon;//Calibration area, effective when byCalibrateType is 1
    BYTE   byRes[44];
}NET_DVR_PDC_RULE_CFG_V42, *LPNET_DVR_PDC_RULE_CFG_V42;
/********* IPC5.1.7 Traffic statistical rules End 2014-03-21***********/

typedef struct tagNET_DVR_TRIAL_VERSION_CFG
{
    DWORD dwSize;
    WORD wReserveTime; //Reserve time,0xffff--invalid, uint:day
    BYTE byRes[62];
}NET_DVR_TRIAL_VERSION_CFG, *LPNET_DVR_TRIAL_VERSION_CFG;

typedef struct tagNET_DVR_SYN_CHANNEL_NAME_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //channel
    BYTE  byRes[64];
}NET_DVR_SYN_CHANNEL_NAME_PARAM, *LPNET_DVR_SYN_CHANNEL_NAME_PARAM;

typedef struct tagNET_DVR_RESET_COUNTER_CFG
{
    DWORD dwSize;
    BYTE  byEnable; //Enable,0-no,1-yes
    BYTE  byMode; //Mode\A3\AC0-Timing, 1- manual
    BYTE  byRes1[2];
    NET_DVR_TIME_EX struTime[MAX_DAYS];//Reset counter time
    BYTE  byRes[64];
}NET_DVR_RESET_COUNTER_CFG, *LPNET_DVR_RESET_COUNTER_CFG;

typedef struct tagNET_DVR_VCA_CTRLINFO_COND
{
    DWORD dwSize;
    NET_DVR_STREAM_INFO  struStreamInfo;
    BYTE byRes[64];
}NET_DVR_VCA_CTRLINFO_COND, *LPNET_DVR_VCA_CTRLINFO_COND;

typedef struct tagNET_DVR_VCA_CTRLINFO_CFG
{
    DWORD  dwSize;
    BYTE   byVCAEnable;        //vca enable
    BYTE   byVCAType;        //vca type,VCA_CHAN_ABILITY_TYPE
    BYTE   byStreamWithVCA; //stream with vca
    BYTE   byMode;            //mode,VCA_CHAN_MODE_TYPE for ATM analysis,TFS_CHAN_MODE_TYPE for TFS analysis,BEHAVIOR_SCENE_MODE_TYPE for behavior full analysis
    BYTE   byControlType;   //contril type,bit,0-no,1-yes
    // byControlType &1 enable snap
    // byControlType &2 enable related ipc
    BYTE   byRes[83];         //
}NET_DVR_VCA_CTRLINFO_CFG, *LPNET_DVR_VCA_CTRLINFO_CFG;

//Set PDC statistic parameters
// HUMAN_GENERATE_RATE
// Speed for target generating. This parameter controls the time interval from target appear in the image to analysis starts. For video scene with various interference signals, please set a lower speed to avoid false alarm;  and for video scene with high speed objects, please set a higher speed to avoid event missing. Totally 5 levels, ranges from 1 (lowest speed)~ 5 (highest speed), and the default value is 3
//
// DETECT_SENSITIVE
//Object detection sensitivity level , ranges from 1(lowest) to 5 (highest) , default level: 3

typedef enum tagPDC_PARAM_KEY
{
    HUMAN_GENERATE_RATE = 50,                //Target  generating speed, start from 50
    DETECT_SENSITIVE    = 51,                //Detecting sensitivity
}PDC_PARAM_KEY;


typedef struct tagNET_DVR_PDC_TARGET_INFO
{
    DWORD       dwTargetID;                  //Target ID
    NET_VCA_RECT struTargetRect;             //Target brim
    BYTE      byRes1[8];                     //Reserved
}NET_DVR_PDC_TARGET_INFO,  *LPNET_DVR_PDC_TARGET_INFO;

typedef struct tagNET_DVR_PDC_TARGET_IN_FRAME
{
    BYTE           byTargetNum;                    //Target number
    BYTE            byRes1[3];
    NET_DVR_PDC_TARGET_INFO  struTargetInfo[MAX_TARGET_NUM];    //Target info array
    BYTE    byRes2[8];                   // Reserved
}NET_DVR_PDC_TARGET_IN_FRAME,  *LPNET_DVR_PDC_TARGET_IN_FRAME;

typedef struct tagNET_DVR_PDC_ALRAM_INFO
{
    DWORD                       dwSize;             // PDC alarm upload structure size
    BYTE                        byMode;             // 0 - single frame statistic result;  1- statistic result in min. time period
    BYTE                        byChannel;          // Alarm upload channel
    /********* IPC5.1.7 New Begin 2014-03-21***********/
    BYTE                        bySmart;         //0-Intelligence\A3\AC1-Smart
    BYTE                        byRes1;
    /********* IPC5.1.7 New End 2014-03-21***********/
    NET_VCA_DEV_INFO       struDevInfo;                 // PU device info
    union
    {
        struct   // For single frame statistic result
        {
            DWORD   dwRelativeTime;      // Relative time stamp
            DWORD   dwAbsTime;           // Absolute time stamp
            BYTE    byRes[92];
        }struStatFrame;
        struct
        {
            NET_DVR_TIME                      tmStart; // Statistic start time
            NET_DVR_TIME                      tmEnd;   //  Statistic end time
            BYTE byRes[92];
        }struStatTime;
    }uStatModeParam;
    DWORD                       dwLeaveNum;         // Number of left
    DWORD                       dwEnterNum;         // Number of entered
    BYTE                        byBrokenNetHttp;     //Offline continuingly flags, 0 - not the retransmission data, 1 - retransmission data
    BYTE                        byRes3;
    WORD                        wDevInfoIvmsChannelEx;     //NET_VCA_DEV_INFO->byIvmsChannel
    DWORD                       dwPassingNum;        // After the number (after wandering into the area did not trigger the number of people entering and leaving)
    BYTE                        byRes2[32];           // Reserved
}NET_DVR_PDC_ALRAM_INFO,  *LPNET_DVR_PDC_ALRAM_INFO;


//  PDC Info Query
typedef struct tagNET_DVR_PDC_QUERY
{
    NET_DVR_TIME tmStart;
    NET_DVR_TIME tmEnd;
    DWORD        dwLeaveNum;
    DWORD        dwEnterNum;
    BYTE         byRes1[256];
}NET_DVR_PDC_QUERY,  *LPNET_DVR_PDC_QUERY;


typedef struct tagNET_DVR_POSITION_RULE_CFG
{
    DWORD                   dwSize;              // Structure size
    NET_DVR_PTZ_POSITION    struPtzPosition;     // Video scene position info
    NET_VCA_RULECFG         struVcaRuleCfg;      //Video
    BYTE                    byRes2[80];          // Reserved
}NET_DVR_POSITION_RULE_CFG,  *LPNET_DVR_POSITION_RULE_CFG;

typedef struct tagNET_DVR_POSITION_RULE_CFG_V41
{
    DWORD                   dwSize;             // Structure size
    NET_DVR_PTZ_POSITION    struPtzPosition;    // Video scene position info
    NET_VCA_RULECFG_V41         struVcaRuleCfg;     //Video
    BYTE  byTrackEnable; //Enable track
    BYTE  byRes1;
    WORD wTrackDuration; //Track duration(s)
    BYTE                    byRes2[76];         //
}NET_DVR_POSITION_RULE_CFG_V41, *LPNET_DVR_POSITION_RULE_CFG_V41;

typedef struct tagNET_DVR_LIMIT_ANGLE
{
    BYTE                byEnable;      // Enable video scene position limitation
    BYTE                byRes1[3];
    NET_DVR_PTZPOS      struUp;      // upper limit position
    NET_DVR_PTZPOS      struDown;    // bottom limit position
    NET_DVR_PTZPOS      struLeft;    // left limit position
    NET_DVR_PTZPOS      struRight;   // right limit position
    BYTE                byRes2[20];
}NET_DVR_LIMIT_ANGLE,  *LPNET_DVR_LIMIT_ANGLE;

typedef struct tagNET_DVR_POSITION_INDEX
{
    BYTE    byIndex;    //video scene index
    BYTE    byRes1;
    WORD    wDwell;     // dwell time
    BYTE    byRes2[4];  // Reserved
}NET_DVR_POSITION_INDEX,  *LPNET_DVR_POSITION_INDEX;

#define  MAX_POSITION_NUM 10
typedef struct tagNET_DVR_POSITION_TRACK_CFG
{
    DWORD   dwSize;
    BYTE    byNum;  // video scene number
    BYTE    byRes1[3];
    NET_DVR_POSITION_INDEX   struPositionIndex[MAX_POSITION_NUM];
    BYTE    byRes2[8];
}NET_DVR_POSITION_TRACK_CFG,  *LPNET_DVR_POSITION_TRACK_CFG;

//Patrol path scene info
typedef struct tagNET_DVR_PATROL_SCENE_INFO
{
    WORD   wDwell;          // Dwell time [30- 300]
    BYTE   byPositionID;    // Scene number 1- 10, Default: 0 (do not add to patrol scene)
    BYTE   byRes[5];
}NET_DVR_PATROL_SCENE_INFO,  *LPNET_DVR_PATROL_SCENE_INFO;

// Patrol scene tracking info
typedef struct tagNET_DVR_PATROL_TRACKCFG
{
    DWORD  dwSize;                                  // Structure size
    NET_DVR_PATROL_SCENE_INFO struPatrolSceneInfo[10];     // patrol path
    BYTE   byRes[16];                               // Reserved
}NET_DVR_PATROL_TRACKCFG,  *LPNET_DVR_PATROL_TRACKCFG;

//Speed dome local rule configuration via menu
typedef struct tagNET_DVR_TRACK_PARAMCFG
{
    DWORD   dwSize;             // Structure size
    WORD    wAlarmDelayTime;    // Alarm delay time (speed dome only supports global intrusion detection mode) range:1-120s
    WORD    wTrackHoldTime;     // Alarm tracking holding time range 0-300s
    BYTE    byTrackMode;        //  Plz refer to IPDOME_TRACK_MODE
    BYTE    byPreDirection;     // Pre judge of tracking direction 0-disable 1-enable
    BYTE     byTrackSmooth;         //Smooth tracking 0-disable 1-enable
    BYTE    byZoomAdjust;         // Zoom adjustment
    BYTE    byMaxTrackZoom;     // Max. zoom ratio 0-default zoom ratio,1-15
    BYTE    byStopTrackWhenFindFace;  //stop track when find face 0-no 1-yes
    BYTE    byStopTrackThreshold;   //the value for stop track
    BYTE    byRes[9];               //  Reserved
}NET_DVR_TRACK_PARAMCFG,  *LPNET_DVR_TRACK_PARAMCFG;

typedef struct tagNET_DVR_DOME_MOVEMENT_PARAM
{
    WORD wMaxZoom;    // Max. zoom ratio
    BYTE    byRes[42];   // Reserved
}NET_DVR_DOME_MOVEMENT_PARAM,  *LPNET_DVR_DOME_MOVEMENT_PARAM;


/********************************Intelligent traffic event  begin****************************************/
#define  MAX_REGION_NUM            8       // Max. region list number
#define  MAX_TPS_RULE            8       // Max. rule number
#define  MAX_AID_RULE            8       // Max. event rule number
#define  MAX_LANE_NUM            8        // Max. traffic lane number

//Traffic event type
typedef enum tagTRAFFIC_AID_TYPE
{
    CONGESTION          = 0x01,     //Traffic jam
    PARKING             = 0x02,     //Parking
    INVERSE             = 0x04,     //Inverse travel
    PEDESTRIAN          = 0x08,     //Pedestrian
    DEBRIS              = 0x10,     //Debris
    SMOKE               = 0x20,     //Smoke
    OVERLINE            = 0x40,      //Over line
    VEHICLE_CONTROL_LIST  = 0x80,    //black list
    SPEED                 = 0x100,    //over speed
    LANECHANGE         = 0x200,      //lane change
    TURNAROUND         = 0x400,     //turn around
    VEHICLE_OCCUPANCY_NONVEHICLE = 0x800, //Occupy the non motorized vehicle parking spaces
    GASSER            = 0x1000    //gasser
}TRAFFIC_AID_TYPE;

typedef enum tagTRAFFIC_SCENE_MODE
{
    FREEWAY = 0,    //  High-speed outdoor scene
    TUNNEL,         //  High-speed tunnel scene
    BRIDGE          //  High-speed bridge scene
}TRAFFIC_SCENE_MODE;

typedef enum tagITS_ABILITY_TYPE
{
    ITS_CONGESTION_ABILITY             = 0x01,       //Traffic jam
    ITS_PARKING_ABILITY                = 0x02,       //Parking
    ITS_INVERSE_ABILITY                = 0x04,       //Inverse travel
    ITS_PEDESTRIAN_ABILITY             = 0x08,       //Pedestrian
    ITS_DEBRIS_ABILITY                 = 0x10,       //Debris
    ITS_SMOKE_ABILITY                  = 0x20,       //Smoke - tunnel
    ITS_OVERLINE_ABILITY               = 0x40,       //Over line
    ITS_VEHICLE_CONTROL_LIST_ABILITY   = 0x80,        //black list
    ITS_SPEED_ABILITY                   = 0x100,        //over speed
    ITS_LANECHANGE_ABILITY             = 0x200,     //lane change
    ITS_TURNAROUND_ABILITY             = 0x400,      //turn around
    ITS_LANE_VOLUME_ABILITY            = 0x010000,   //Flow  counting of traffic lane
    ITS_LANE_VELOCITY_ABILITY          = 0x020000,   //Vehicle velocity of traffic lane
    ITS_TIME_HEADWAY_ABILITY           = 0x040000,   //Vehicle headway counting (unit: time)
    ITS_SPACE_HEADWAY_ABILITY          = 0x080000,   //Vehicle headway counting (unit: distance)
    ITS_TIME_OCCUPANCY_RATIO_ABILITY   = 0x100000,   //Traffic lane occupancy (unit: time)
    ITS_SPACE_OCCUPANCY_RATIO_ABILITY  = 0x200000,   //Traffic lane occupancy (unit: distance)
    ITS_LANE_QUEUE_ABILITY             = 0x400000,   //Queue length
    ITS_VEHICLE_TYPE_ABILITY           = 0x800000,   //Vehicle type
    ITS_TRAFFIC_STATE_ABILITY          = 0x1000000   //Traffic state
}ITS_ABILITY_TYPE;

// Traffic statistics
typedef enum tagITS_TPS_TYPE
{
    LANE_VOLUME           = 0x01,     //Traffic lane flow
    LANE_VELOCITY         = 0x02,     //Vehicle velocity
    TIME_HEADWAY          = 0x04,     //Vehicle headway counting (unit: time)
    SPACE_HEADWAY         = 0x08,     //Vehicle headway counting (unit: distance)
    TIME_OCCUPANCY_RATIO  = 0x10,     //Traffic lane occupancy (unit: time)
    SPACE_OCCUPANCY_RATIO = 0x20,     //Traffic lane occupancy (unit: distance)
    QUEUE                 = 0x40,     //Queue length
    VEHICLE_TYPE          = 0x80,     //vehicle type
    TRAFFIC_STATE         = 0x100     //traffic state
}ITS_TPS_TYPE;

typedef struct tagNET_DVR_REGION_LIST
{
    DWORD    dwSize;     // Structure size
    BYTE    byNum;       // Region number
    BYTE    byRes1[3];     // Reserved
    NET_VCA_POLYGON struPolygon[MAX_REGION_NUM];  // Region
    BYTE    byRes2[20];     // Reserved
}NET_DVR_REGION_LIST, *LPNET_DVR_REGION_LIST;


// Direction structure
typedef struct tagNET_DVR_DIRECTION
{
    NET_VCA_POINT struStartPoint;    // Direction start point
    NET_VCA_POINT struEndPoint;      // Direction end point
}NET_DVR_DIRECTION,  *LPNET_DVR_DIRECTION;

// Single traffic lane
typedef struct tagNET_DVR_ONE_LANE
{
    BYTE    byEnable;  // Enable traffic lane
    BYTE    byRes1[11];     // Reserved
    BYTE    byLaneName[NAME_LEN];        // Traffic lane name
    NET_DVR_DIRECTION struFlowDirection;     // Flow direction of the traffic lane
    NET_VCA_POLYGON struPolygon;         // Traffic lane region
}NET_DVR_ONE_LANE,  *LPNET_DVR_ONE_LANE;

// Traffic lane configuration
typedef struct tagNET_DVR_LANE_CFG
{
    DWORD    dwSize;     // Structure size
    NET_DVR_ONE_LANE struLane[MAX_LANE_NUM];     // Traffic lane parameter, and the  subscript is corresponding to the traffic lane ID
    BYTE    byRes1[40];      // Reserved
}NET_DVR_LANE_CFG,  *LPNET_DVR_LANE_CFG;

// Traffic event parameters
typedef struct tagNET_DVR_AID_PARAM
{
    WORD    wParkingDuration;        // Parking time [10s- 120s]
    WORD    wPedestrianDuration;     // Pedestrian time [1s- 120s]
    WORD    wDebrisDuration;         // Debris time [10s- 120s]
    WORD    wCongestionLength;       // Traffic jam distance threshold [5m- 200m]
    WORD    wCongestionDuration;     // Traffic jam time length [10s- 120s]
    WORD    wInverseDuration;        // Inverse travel time [1s- 10s]
    WORD    wInverseDistance;        // Inverse travel distance [2m- 100m] (default: 10m)
    WORD    wInverseAngleTolerance;  // Inverse angle tolerance [90- 180] degree
    WORD    wIllegalParkingTime;     // Illegal parking time[4min,60min],take effect in mode TFS_CITYROAD
    WORD    wIllegalParkingPicNum;   // Illegal parking snap pic num[1,6], take effect in mode TFS_CITYROAD
    BYTE    byMergePic;              // Merge snap pics ,0- disable 1- enable ,take effect in mode TFS_CITYROAD
    BYTE    byRes1[23];              // reserved
}NET_DVR_AID_PARAM,  *LPNET_DVR_AID_PARAM;

// Traffic rule structure
typedef struct tagNET_DVR_ONE_AID_RULE
{
    BYTE    byEnable;                    //enable/disable event rules
    BYTE    byRes1[3];                   //Reserved
    BYTE    byRuleName[NAME_LEN];        //Rule name
    DWORD   dwEventType;                 //Traffic event detection type TRAFFIC_AID_TYPE
    NET_VCA_SIZE_FILTER struSizeFilter;  //Size filter
    NET_VCA_POLYGON     struPolygon;     //Rule region
    NET_DVR_AID_PARAM struAIDParam;      //Event parameters
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_2]; //Arm schedule
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;     // Handle method
    BYTE byRelRecordChan[MAX_CHANNUM_V30];             //Recording channel triggered by alarm, 1-trigger recording on this channel
    BYTE    byRes2[20];
}NET_DVR_ONE_AID_RULE,  *LPNET_DVR_ONE_AID_RULE;

// Traffic events
typedef struct tagNET_DVR_AID_RULECFG
{
    DWORD   dwSize;         // Structure size
    BYTE    byPicProType;     //0- do not upload snapshot on alarm;  1- upload snapshot on alarm
    BYTE    byRes1[3];      // Reserved
    NET_DVR_JPEGPARA struPictureParam;          //Snapshot parameter structure
    NET_DVR_ONE_AID_RULE  struOneAIDRule[MAX_AID_RULE];  //Rule array
    BYTE    byRes2[32];     //Reserved
}NET_DVR_AID_RULECFG,  *LPNET_DVR_AID_RULECFG;

typedef struct tagNET_DVR_ONE_AID_RULE_V41
{
    BYTE                        byEnable;                 // 0 - disable, 1 - enable
    BYTE                        byLaneNo;                 // Relate Lane No
    BYTE                        byRes1[2];                // Reserved
    BYTE                        byRuleName[NAME_LEN];     // Rule name
    DWORD                       dwEventType;              // Traffic event detection type TRAFFIC_AID_TYPE
    NET_VCA_SIZE_FILTER         struSizeFilter;           // Size filter
    NET_VCA_POLYGON             struPolygon;              // Rule region
    NET_DVR_AID_PARAM           struAIDParam;             // Event parameters
    NET_DVR_SCHEDTIME           struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//Arm schedule
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;              //Handle method
    BYTE                        byRelRecordChan[MAX_IVMS_IP_CHANNEL]; //Recording channel triggered by alarm, 1-trigger recording on this channel
    BYTE                        byRes2[60];               //Reserved
}NET_DVR_ONE_AID_RULE_V41, *LPNET_DVR_ONE_AID_RULE_V41;

typedef struct tagNET_DVR_AID_RULECFG_V41
{
    DWORD   dwSize;                     // Structure size
    BYTE    byPicProType;               // 0- do not upload snapshot on alarm;  1- upload snapshot on alarm
    BYTE    byRes1[3];                  // Reserved
    NET_DVR_JPEGPARA struPictureParam;     // Snapshot parameter structure
    NET_DVR_ONE_AID_RULE_V41  struAIDRule[MAX_AID_RULE];  //Rule array
    BYTE    byRes2[128];                //Reserved
} NET_DVR_AID_RULECFG_V41, *LPNET_DVR_AID_RULECFG_V41;

// Traffic statistics structure
typedef struct tagNET_DVR_ONE_TPS_RULE
{
    BYTE    byEnable;        // Enable traffic rule parameters
    BYTE    byLaneID;           // Traffic lane ID
    BYTE    byRes1[2];       //Reserved
    DWORD   dwCalcType;      // Statistics type ITS_TPS_TYPE
    NET_VCA_SIZE_FILTER struSizeFilter;  // Size filter
    NET_VCA_POLYGON struVitrualLoop;     // Virtual coil
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_2]; //Arm schedule
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;     //Handle mode (upload to center)
    BYTE    byRes2[20];   // Reserved
}NET_DVR_ONE_TPS_RULE,  *LPNET_DVR_ONE_TPS_RULE;

// Traffic statistics rule configuration structure
typedef struct tagNET_DVR_TPS_RULECFG
{
    DWORD   dwSize;               // Structure size
    NET_DVR_ONE_TPS_RULE struOneTpsRule[MAX_TPS_RULE];  // The subscript is corresponding to the traffic parameter's ID
    BYTE    byRes2[40];      // Reserved
}NET_DVR_TPS_RULECFG,  *LPNET_DVR_TPS_RULECFG;

typedef struct tagNET_DVR_ONE_TPS_RULE_V41
{
    BYTE    byEnable;                     //0 - disable,1 - enable
    BYTE    byLaneID;                      //Lane id
    BYTE    byRes1[2];                    //Reserved
    DWORD   dwCalcType;                   //Statistics type ITS_TPS_TYPE
    NET_VCA_SIZE_FILTER  struSizeFilter;  //Size filter
    NET_VCA_POLYGON      struVitrualLoop; //Virtual coil
    NET_DVR_SCHEDTIME    struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//Arm schedule
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;       //Handle mode
    BYTE    byRes2[60];                   // Reserved
}NET_DVR_ONE_TPS_RULE_V41, *LPNET_DVR_ONE_TPS_RULE_V41;

typedef struct tagNET_DVR_TPS_RULECFG_V41
{
    DWORD   dwSize;         //Structure size
    NET_DVR_ONE_TPS_RULE_V41 struOneTpsRule[MAX_TPS_RULE]; //The subscript is corresponding to the traffic parameter's ID
    BYTE    byRes[128];     //Reserved
}NET_DVR_TPS_RULECFG_V41, *LPNET_DVR_TPS_RULECFG_V41;

// Traffic event info
typedef struct tagNET_DVR_AID_INFO
{
    BYTE            byRuleID;    // Rule ID, which is equal to the subscript of the rule configuration structure ([0- 16])
    BYTE            byRes1[3];
    BYTE            byRuleName[NAME_LEN];  //  Rule ID
    DWORD           dwAIDType;   // Alarm event type
    NET_DVR_DIRECTION   struDirect;  // ALarm region
    BYTE    bySpeedLimit; //Limit speed\A3\ACkm/h[0,255]
    BYTE    byCurrentSpeed; //current speed\A3\ACkm/h[0,255]
    BYTE            byRes2[38];   // Reserved
}NET_DVR_AID_INFO,  *LPNET_DVR_AID_INFO;

// Traffic event alarm
typedef struct tagNET_DVR_AID_ALARM
{
    DWORD               dwSize;          // Structure length
    DWORD               dwRelativeTime;     // Relative time stamp
    DWORD               dwAbsTime;         // Absolute time stamp
    NET_VCA_DEV_INFO      struDevInfo;     // PU info
    NET_DVR_AID_INFO    struAIDInfo;     // Traffic event info
    DWORD               dwPicDataLen;    // Return snapshot picture length, 0- no snapshot;  else- snapshot data length
    BYTE                *pImage;         // pointer to the snapshot picture data
    BYTE                byRes[40];       // Reserved
}NET_DVR_AID_ALARM,  *LPNET_DVR_AID_ALARM;

// Queue structure of the Traffic Line
typedef struct tagNET_DVR_LANE_QUEUE
{
    NET_VCA_POINT   struHead;        //Head of the queue
    NET_VCA_POINT   struTail;        //End of the queue
    DWORD           dwLength;         //Actual queue length
}NET_DVR_LANE_QUEUE,  *LPNET_DVR_LANE_QUEUE;


typedef struct tagNET_DVR_LANE_PARAM
{
    BYTE    byRuleName[NAME_LEN];                  //Traffic lane rule name
    BYTE    byRuleID;                // Rule ID, which is equal to the subscript of the rule configuration structure ([0- 7])
    BYTE    byVaryType;       //Vehicle status for virtual coil, 1-vehicle passing, 0-no vehicle passing
    BYTE    byLaneType;             // Traffic lane type
    BYTE    byRes1;
    DWORD    dwLaneVolume;     // Traffic flow
    DWORD   dwLaneVelocity;       //velocity on this traffic lane (km/h)
    DWORD   dwTimeHeadway ;       //Vehicle headway counting (unit: time)
    DWORD   dwSpaceHeadway;        //Vehicle headway counting (unit: m)
    float   fSpaceOccupyRation;  //Occupation
    NET_DVR_LANE_QUEUE  struLaneQueue;          //Queue length of the traffic lane
    NET_VCA_POINT       struRuleLocation;      //Center position of the coil rule
    BYTE    byRes2[32];
}NET_DVR_LANE_PARAM,  *LPNET_DVR_LANE_PARAM;


typedef struct tagNET_DVR_TPS_INFO
{
    DWORD   dwLanNum;    // Traffic lane number for the rule
    NET_DVR_LANE_PARAM  struLaneParam[MAX_TPS_RULE];
}NET_DVR_TPS_INFO,  *LPNET_DVR_TPS_INFO;

typedef struct tagNET_DVR_TPS_ALARM
{
    DWORD       dwSize;               // Structure size
    DWORD       dwRelativeTime;       // relative time stamp
    DWORD       dwAbsTime;            // Absolute time stamp
    NET_VCA_DEV_INFO      struDevInfo;  // PU device info
    NET_DVR_TPS_INFO  struTPSInfo;    // Traffic event info
    BYTE        byRes1[32];           // Reserved
}NET_DVR_TPS_ALARM,  *LPNET_DVR_TPS_ALARM;

typedef enum tagTRAFFIC_DATA_VARY_TYPE_EX_ENUM
{
    ENUM_TRAFFIC_VARY_NO             = 0x00,   //No vary
    ENUM_TRAFFIC_VARY_VEHICLE_ENTER  = 0x01,   //Vehicle enter the virtual loop
    ENUM_TRAFFIC_VARY_VEHICLE_LEAVE  = 0x02,   //Vehicle leave the vitual loop
    ENUM_TRAFFIC_VARY_QUEUE          = 0x04,   //Queue vary
    ENUM_TRAFFIC_VARY_STATISTIC      = 0x08,   //Statistics vary
}TRAFFIC_DATA_VARY_TYPE_EX_ENUM;

typedef struct tagNET_DVR_LANE_PARAM_V41
{
    BYTE               byRuleName[NAME_LEN]; //Traffic lane rule name
    BYTE               byRuleID;             //Rule ID, which is equal to the subscript of the rule configuration structure ([0- 7])
    BYTE               byLaneType;             //Lane type,up or down
    BYTE               byTrafficState;       //Traffic state\A3\AC0-Invalid\A3\AC1-Smooth\A3\AC2-Crowd\A3\AC3-Blocked
    BYTE               byLaneNo;            //Relate Lane No
    DWORD              dwVaryType;           //Data vary type,refer to TRAFFIC_DATA_VARY_TYPE_EX_ENUM
    DWORD              dwTpsType;            //Tell which member of this structure is used,refer to ITS_TPS_TYPE
    DWORD              dwLaneVolume;         //Traffic flow
    DWORD              dwLaneVelocity;       //Velocity on this traffic lane (km/h)
    DWORD              dwTimeHeadway ;       //Vehicle headway counting (unit: time)
    DWORD              dwSpaceHeadway;       //Vehicle headway counting (unit: m)
    float              fSpaceOccupyRation;   //Space Occupation
    float              fTimeOccupyRation;    //Time Occupation
    DWORD              dwLightVehicle;       //Number of light vehicle
    DWORD              dwMidVehicle;         //Number of mid vehicle
    DWORD              dwHeavyVehicle;       //Number of heavy vehicle
    NET_DVR_LANE_QUEUE struLaneQueue;        //Queue length of the traffic lane
    NET_VCA_POINT      struRuleLocation;     //Center position of the coil rule
    DWORD               dwOversizeVehicle;    //Number of Oversize vehicle
    BYTE               byRes2[60];           //Reserved
}NET_DVR_LANE_PARAM_V41, *LPNET_DVR_LANE_PARAM_V41;


typedef struct tagNET_DVR_TPS_INFO_V41
{
    DWORD                   dwLanNum;          //Traffic lane number for the rule
    NET_DVR_LANE_PARAM_V41  struLaneParam[MAX_TPS_RULE]; //Lane param array
    DWORD                   dwSceneID;//scene ID
    BYTE                    byRes[28];         //Reserved
}NET_DVR_TPS_INFO_V41, *LPNET_DVR_TPS_INFO_V41;

// Face rule configuration
typedef struct tagNET_DVR_FACEDETECT_RULECFG
{
    DWORD          dwSize;              //Structure size
    BYTE           byEnable;            //Enable or not
    BYTE           byEventType;            //Event type: 0- abnormal face, 1- normal face, 2- abnormal face and normal face
    BYTE           byUpLastAlarm;       //2011-04-06 Whether upload last alarm firstly
    BYTE           byUpFacePic; //Enable upload face picture,0-no, 1-yes
    BYTE           byRuleName[NAME_LEN];
    NET_VCA_POLYGON     struVcaPolygon; //Face detection rule region
    BYTE           byPicProType;        //Picture handling mode when alarming: 0- not handle, none 0- upload
    BYTE           bySensitivity;       //Rule sensitivity
    WORD            wDuration;          //Time threshold to trigger face alarm
    NET_DVR_JPEGPARA    struPictureParam;         //Picture parameter
    NET_VCA_SIZE_FILTER struSizeFilter;         //Size filter
    NET_DVR_SCHEDTIME   struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_2];//Time parameter of fortification
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;      //Handling mode
    BYTE           byRelRecordChan[MAX_CHANNUM_V30];//Whether alarm triggers recording channel:1-trigger;0-not trigger
    BYTE          byPicRecordEnable;  /*2012-3-1 Whether record picture, 0-no, 1-yes*/
    BYTE            byRes2[39];         //Reserved
}NET_DVR_FACEDETECT_RULECFG, *LPNET_DVR_FACEDETECT_RULECFG;

typedef struct tagNET_DVR_FACE_PIPCFG
{
    BYTE byEnable; //enable PIP
    BYTE byBackChannel; //Back channel(panel channel)
    BYTE byPosition; //position,0-left top,1-left bottom,2-right top,3-right bottom
    BYTE byPIPDiv; //Division (face:panel),0-1:4,1-1:9,2-1:16
    BYTE byRes[4];
}NET_DVR_FACE_PIPCFG, *LPNET_DVR_FACE_PIPCFG;

typedef struct tagNET_DVR_FACEDETECT_RULECFG_V41
{
    DWORD dwSize;              //Structure size
    BYTE  byEnable;            //Enable or not
    BYTE  byEventType;            //Event type: 0- abnormal face, 1- normal face, 2- abnormal face and normal face
    BYTE  byUpLastAlarm;       //2011-04-06 Whether upload last alarm firstly
    BYTE  byUpFacePic; //Enable upload face picture,0-no, 1-yes
    BYTE  byRuleName[NAME_LEN];
    NET_VCA_POLYGON struVcaPolygon;    //Face detection rule region
    BYTE  byPicProType;    //Picture handling mode when alarming: 0- not handle, none 0- upload
    BYTE  bySensitivity;   //Rule sensitivity
    WORD  wDuration;      //Time threshold to trigger face alarm
    NET_DVR_JPEGPARA    struPictureParam;         //Picture parameter
    NET_VCA_SIZE_FILTER struSizeFilter;         //Size filter
    NET_DVR_SCHEDTIME   struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//Time parameter of fortification
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;      //Handling mode
    BYTE  byRelRecordChan[MAX_CHANNUM_V30];            //Whether alarm triggers recording channel:1-trigger;0-not trigger
    BYTE  byPicRecordEnable;  /*2012-10-22Whether record picture, 0-no, 1-yes*/
    BYTE  byRes1;
    WORD  wAlarmDelay; //2012-10-22 Alarm delay,0-5s,1-10,2-30s,3-60s,4-120s,5-300s,6-600s
    NET_DVR_FACE_PIPCFG struFacePIP; //2012-11-7 Face PIP
    WORD  wRelSnapChan[MAX_REL_SNAPCHAN_NUM]; /*Relate snap channel,when the main channel alarms,together upload the relate channel picture
                                               0-unused,other- channel number*/
    BYTE  byRes[22];         //Reserved
}NET_DVR_FACEDETECT_RULECFG_V41, *LPNET_DVR_FACEDETECT_RULECFG_V41;

typedef struct tagNET_DVR_FACEDETECT_ALARM
{
    DWORD  dwSize;                 // Structure size
    DWORD     dwRelativeTime;     // Relative time
    DWORD    dwAbsTime;            // Absolute time
    BYTE        byRuleName[NAME_LEN];       //Rule name
    NET_VCA_TARGET_INFO  struTargetInfo;    //Alarm target information
    NET_VCA_DEV_INFO       struDevInfo;        //Device information
    DWORD dwPicDataLen;                        //Returned picture length, 0 means no picture, larger than 0 means picture data follows the structure
    BYTE        byAlarmPicType;                //0- abnormal face alarm picture, 1- face picture,2-multi faces
    BYTE     byPanelChan;        /*2012-3-1 Related panel channel*/
    BYTE    byRelAlarmPicNum; //Related alarm picture num
    BYTE    byRes1; //Reserved
    DWORD   dwFacePicDataLen;//Face picture length
    DWORD   dwAlarmID;    //Alarm ID,marking the same group of alarmls\A3\AC0-unused
    WORD    wDevInfoIvmsChannelEx;     //NET_VCA_DEV_INFO->byIvmsChannel
    BYTE    byRes2[42];   //Reserved
    BYTE    *pFaceImage; //Pointer to face picture
    BYTE    *pImage;       //Pointer to picture
}NET_DVR_FACEDETECT_ALARM, *LPNET_DVR_FACEDETECT_ALARM;

typedef struct tagNET_DVR_EVENT_PARAM_UNION
{
    DWORD  uLen[3];        //Union size, 12 bytes
    DWORD  dwHumanIn;         //There are nobody or someone access, 0 -nobody, 1- someone
    float  fCrowdDensity;  //Aggregation value of people
}NET_DVR_EVENT_PARAM_UNION, *LPNET_DVR_EVENT_PARAM_UNION;

//Real-time alarm upload of someone and onbody event or people aggregation event
typedef struct tagNET_DVR_EVENT_INFO
{
    BYTE   byRuleID;                // Rule ID
    BYTE   byRes[3];                // Reserved
    BYTE   byRuleName[NAME_LEN];    // Rule name
    DWORD       dwEventType;        // See to VCA_EVENT_TYPE
    NET_DVR_EVENT_PARAM_UNION uEventParam;
}NET_DVR_EVENT_INFO, *LPNET_DVR_EVENT_INFO;

typedef struct tagNET_DVR_EVENT_INFO_LIST
{
    BYTE            byNum;      // Total number of event real-time information
    BYTE            byRes1[3];  // Reserved
    NET_DVR_EVENT_INFO struEventInfo[MAX_RULE_NUM];    // Event real-time information
}NET_DVR_EVENT_INFO_LIST,*LPNET_DVR_EVENT_INFO_LIST;

typedef struct tagNET_DVR_RULE_INFO_ALARM
{
    DWORD         dwSize;                       // Structure size
    DWORD         dwRelativeTime;         // Relative time
    DWORD        dwAbsTime;                // Absolute time
    NET_VCA_DEV_INFO      struDevInfo;    // Front-end device information
    NET_DVR_EVENT_INFO_LIST struEventInfoList;    //Event information list
    BYTE            byRes2[40];            // Reserved
}NET_DVR_RULE_INFO_ALARM, *LPNET_DVR_RULE_INFO_ALARM;

typedef struct tagNET_DVR_ONE_SCENE_TIME
{
    BYTE     byActive;                     //0 - Disabled,1\A8CEnabled
    BYTE     byRes1[3];                    //Reserved
    DWORD    dwSceneID;                    //Scene ID
    NET_DVR_SCHEDTIME struEffectiveTime;   //Scene onset time
    BYTE     byRes2[16];                   //Reserved
}NET_DVR_ONE_SCENE_TIME, *LPNET_DVR_ONE_SCENE_TIME ;

typedef struct tagNET_DVR_SCENE_TIME_CFG
{
    DWORD  dwSize;                                               //Structure size
    NET_DVR_ONE_SCENE_TIME struSceneTime[MAX_SCENE_TIMESEG_NUM]; //Scene time array
    BYTE   byRes[64];                                            //Reserved
}NET_DVR_SCENE_TIME_CFG, *LPNET_DVR_SCENE_TIME_CFG;

typedef struct  tagNET_DVR_ONE_SCENE_CFG_
{
    BYTE   byEnable;                 //Enable scene,0-disabled 1- enabled
    BYTE   byDirection;              //Monitoring direction: 1- up-road\A3\AC2- down-road, 3- two-way, 4- from east to west, 5- from south to north, 6- from west to east, 7- from north to south, 8- others
    BYTE   byRes1[2];                //Reserved
    DWORD  dwSceneID;                //Scene ID(Read only), 0 - Invalid
    BYTE   bySceneName[NAME_LEN];    //Scene name
    NET_DVR_PTZPOS struPtzPos;       //Ptz pos
    DWORD  dwTrackTime;              //Track time[5s,300s],take effect in TFS intelligent analysis
    BYTE   byRes2[24];               //Reserved
}NET_DVR_ONE_SCENE_CFG, *LPNET_DVR_ONE_SCENE_CFG;


typedef struct tagNET_DVR_SCENE_CFG
{
    DWORD dwSize;                                          //Structure size
    NET_DVR_ONE_SCENE_CFG struSceneCfg[MAX_ITS_SCENE_NUM]; //Scene configuration param
    BYTE   byRes[40];                                      //Reserved
}NET_DVR_SCENE_CFG,*LPNET_DVR_SCENE_CFG;


typedef struct tagNET_DVR_SCENE_COND
{
    DWORD   dwSize;       //Structure size
    LONG    lChannel;     //Channel number
    DWORD   dwSceneID;    //Scene ID, 0-Invalid
    BYTE    byRes[48];    //Reserved
}NET_DVR_SCENE_COND, *LPNET_DVR_SCENE_COND;

typedef struct tagNET_DVR_FORENSICS_MODE
{
    DWORD  dwSize;      //Structure size
    BYTE   byMode;      //Forentics mode,0-Manual ,1-Auto\A3\AC2-semiAutoTrack
    BYTE   byRes[23];   //Reserved
}NET_DVR_FORENSICS_MODE,*LPNET_DVR_FORENSICS_MODE;

typedef struct tagNET_DVR_SCENE_INFO_
{
    DWORD           dwSceneID;              //Scene ID, 0 - Invalid
    BYTE            bySceneName[NAME_LEN];  //Scene name
    BYTE            byDirection;            //Monitoring direction: 1- up-road\A3\AC2- down-road, 3- two-way, 4- from east to west, 5- from south to north, 6- from west to east, 7- from north to south, 8- others
    BYTE            byRes1[3];              //Reserved
    NET_DVR_PTZPOS  struPtzPos;             //Ptz Pos
    BYTE            byRes2[64] ;            //Reserved
}NET_DVR_SCENE_INFO,*LPNET_DVR_SCENE_INFO;

typedef struct tagNET_DVR_AID_ALARM_V41
{
    DWORD              dwSize;              //Structure size
    DWORD              dwRelativeTime;        //Relative time
    DWORD              dwAbsTime;            //Absolute time
    NET_VCA_DEV_INFO   struDevInfo;            //Device info
    NET_DVR_AID_INFO   struAIDInfo;         //Traffic event info
    NET_DVR_SCENE_INFO struSceneInfo;       //Scene info
    DWORD              dwPicDataLen;        //Picture length
    BYTE               *pImage;             //pointer to image data
    // 0- upload data directly; 1- cloud storage server URL (3.7Ver) image data into URL data the original picture into URL length
    BYTE               byDataType;
    BYTE               byLaneNo;  //Relate Lane No
    WORD               wMilliSecond;        //milliseconds
    BYTE                  byMonitoringSiteID[MONITORSITE_ID_LEN/*48*/];
    BYTE                 byDeviceID[DEVICE_ID_LEN/*48*/];
    BYTE               byRes[28];
}NET_DVR_AID_ALARM_V41, *LPNET_DVR_AID_ALARM_V41;

typedef struct tagNET_DVR_TPS_ALARM_V41
{
    DWORD                 dwSize;          //Structure size
    DWORD                 dwRelativeTime;  //Relative time
    DWORD                 dwAbsTime;       //Absolute time
    NET_VCA_DEV_INFO      struDevInfo;     //Device info
    NET_DVR_TPS_INFO_V41  struTPSInfo;     //Traffic parameter statistics information
    BYTE           byMonitoringSiteID[MONITORSITE_ID_LEN/*48*/];
    BYTE           byDeviceID[DEVICE_ID_LEN/*48*/];
    DWORD                dwStartTime;
    DWORD                dwStopTime;
    BYTE                   byRes[24];
} NET_DVR_TPS_ALARM_V41,*LPNET_DVR_TPS_ALARM_V41;

/*******************************Intelligent Traffic Function end*****************************************/

#define PRIVT_XXX_MAJOR_VERSION      2

#define PRIVT_XXX_SUB_VERSION        3 /* Sub version value, up to 31 */

#define PRIVT_XXX_REVISION_VERSION   4

typedef struct tagNET_DVR_VCA_VERSION
{
    WORD    wMajorVersion;         // Main version
    WORD    wMinorVersion;         // Sub version
    WORD    wRevisionNumber;     // Revision
    WORD    wBuildNumber;         // Build
    WORD    wVersionYear;         //Version date- Year
    BYTE    byVersionMonth;         //Version date- Month
    BYTE    byVersionDay;             //Version date- Day
    BYTE    byRes[8];             // Reserved
}NET_DVR_VCA_VERSION,  *LPNET_DVR_VCA_VERSION;

/******************************Intelligent function end***********************************/

/*******************************Video Management system***********************************/
//09- 11- 21
#define MAX_SUBSYSTEM_NUM    80   //Max. sub system number in the matrix
#define MAX_SERIALLEN        36   //Max. SN Length
#define MAX_LOOPPLANNUM        16   //Max loop group number
#define DECODE_TIMESEGMENT  4    //Time segment number of decoding schedule
typedef struct tagNET_DVR_SUBSYSTEMINFO
{
    BYTE        bySubSystemType; //Sub system type, 1- decoding, 2- encoding, 0- NULL (Read-only)
    BYTE        byChan; //Channel parameters for the sub system (Read-only)
    BYTE        byLoginType; //Registration type, 1- direct connect, 2- DNS, 3- Peanut Hull
    BYTE        byRes1[5];
    NET_DVR_IPADDR   struSubSystemIP;         /*IP Address */
    WORD        wSubSystemPort;         //Sub system port number
    BYTE        byRes2[6];
    NET_DVR_IPADDR  struSubSystemIPMask; //Subnet mask
    NET_DVR_IPADDR    struGatewayIpAddr;     /*Network Gateway*/
    BYTE        sUserName[NAME_LEN];     /* User name  (Read-only) */
    BYTE        sPassword[PASSWD_LEN];     /*Password (Read-only) */
    char        sDomainName[MAX_DOMAIN_NAME]; // Domain name
    char         sDnsAddress[MAX_DOMAIN_NAME]; /*DNS domain name or IP*/
    BYTE        sSerialNumber[SERIALNO_LEN]; //SN (Read-only)
}NET_DVR_SUBSYSTEMINFO,  *LPNET_DVR_SUBSYSTEMINFO;

typedef struct tagNET_DVR_ALLSUBSYSTEMINFO
{
    DWORD dwSize;
    NET_DVR_SUBSYSTEMINFO struSubSystemInfo[MAX_SUBSYSTEM_NUM];
    BYTE byRes[8];
}NET_DVR_ALLSUBSYSTEMINFO,  *LPNET_DVR_ALLSUBSYSTEMINFO;

typedef struct tagNET_DVR_ALARMMODECFG
{
    DWORD     dwSize;
    BYTE    byAlarmMode; //Alarm trigger mode, 1- loop, 2- Remain
    WORD    wLoopTime; //Loop cycle interval (unit: second)
    BYTE    byRes[9];
}NET_DVR_ALARMMODECFG, *LPNET_DVR_ALARMMODECFG;

typedef struct  tagNET_DVR_CODESPLITTERINFO
{
    DWORD            dwSize;
    NET_DVR_IPADDR   struIP;         /*IP of Code Distributor*/
    WORD        wPort;                     //Port number of Code Distributor
    BYTE        byRes1[6];
    BYTE        sUserName[NAME_LEN];     /* User name */
    BYTE        sPassword[PASSWD_LEN];     /*Password */
    BYTE        byChan; //485 port number of the Code Distributor
    BYTE        by485Port; //485 address of the Code Distributor
    BYTE        byRes2[14];
} NET_DVR_CODESPLITTERINFO,  *LPNET_DVR_CODESPLITTERINFO;

typedef struct tagNET_DVR_ASSOCIATECFG
{
    BYTE    byAssociateType; //Alarm linkage, 1- alarm out
    WORD    wAlarmDelay; //Alarm out delay, 0- 5 seconds;  1- 10 seconds; 2- 30 seconds; 3- 1 minute; 4- 2 minutes; 5- 5 minutes; 6- 10 minutesw;
    BYTE    byAlarmNum; //Alarm ID number
    BYTE    byRes[8];
} NET_DVR_ASSOCIATECFG, *LPNET_DVR_ASSOCIATECFG;

typedef struct tagNET_DVR_DYNAMICDECODE
{
    DWORD                            dwSize;
    NET_DVR_ASSOCIATECFG           struAssociateCfg; //Trigger dynamic decoding associated structure
    NET_DVR_PU_STREAM_CFG        struPuStreamCfg; //Dynamic decoding structure
    BYTE                            byRes[8];
}NET_DVR_DYNAMICDECODE, *LPNET_DVR_DYNAMICDECODE;

typedef struct  tagNET_DVR_DECODESCHED
{
    NET_DVR_SCHEDTIME  struSchedTime; //
    BYTE  byDecodeType; /*0- no, 1- loop decoding, 2- dynamic decoding*/
    BYTE  byLoopGroup; //Loop Group
    BYTE  byRes[6];
    NET_DVR_PU_STREAM_CFG struDynamicDec; //Dynamic decoding
} NET_DVR_DECODESCHED,  *LPNET_DVR_DECODESCHED;

typedef struct tagNET_DVR_PLANDECODE
{
    DWORD dwSize;
    NET_DVR_DECODESCHED struDecodeSched[MAX_DAYS][DECODE_TIMESEGMENT]; //Start from Monday, consistent with 9000
    BYTE byRes[8];
} NET_DVR_PLANDECODE, *LPNET_DVR_PLANDECODE;

typedef struct
{
    NET_DVR_TIME strLogTime;
    DWORD    dwMajorType;     //Main type 1- alarm;  2- abnormal;  3- operation;  0xff- all
    DWORD    dwMinorType;     //Hypo- Type 0- all;
    BYTE    sPanelUser[MAX_NAMELEN];  //user ID for local panel operation
    BYTE    sNetUser[MAX_NAMELEN]; //user ID for network operation
    NET_DVR_IPADDR    struRemoteHostAddr; //remote host IP
    DWORD    dwParaType; //parameter type
    DWORD    dwChannel; //channel number
    DWORD    dwDiskNumber; //HD number
    DWORD    dwAlarmInPort; //alarm input port
    DWORD    dwAlarmOutPort; //alarm output port
    DWORD   dwInfoLen;
    BYTE  byDevSequence; //Slot number
    BYTE  byMacAddr[MACADDR_LEN]; //MAC address, 6
    BYTE  sSerialNumber[SERIALNO_LEN]; //Serial Number, 48
    char  sInfo[LOG_INFO_LEN -  SERIALNO_LEN -  MACADDR_LEN -  1 ];
}NET_DVR_LOG_MATRIX,  *LPNET_DVR_LOG_MATRIX;

//2009- 11- 21 Video Management Platform
typedef struct tagVEDIOPLATLOG
{
    BYTE bySearchCondition; //Search condition, 0-  search by slot number, 1- Search by SN,  2- Search by MAC
    //Slot number, 0- 79: (corresponding to the slot number in the sub system);
    //0xff: Search all the logs
    //0xfe: Search logs on 78k;0xfd:Search logs on sub domain;0xfc:Search logs on domain
    BYTE byDevSequence;
    BYTE  sSerialNumber[SERIALNO_LEN]; //Serial Number, 48
    BYTE  byMacAddr[MACADDR_LEN]; //MAC, 6
} NET_DVR_VEDIOPLATLOG,  *LPNET_DVR_VEDIOPLATLOG;

//2009- 11- 21
#define VIDEOPLATFORM_SBUCODESYSTEM_ABILITY          0x211 //Encoding sub system ability
typedef struct tagNET_DVR_CODESYSTEMABILITY
{
    DWORD dwSize;
    DWORD dwAbilityVersion; //Ability version number, the highest 16 digits stands for the main version and the lowest 16 digits stands for the sub version
    DWORD dwSupportMaxVideoFrameRate; //Unit (Kbps)
    /*Recording mode by digit:
                                     0: continuous recording according to time schedule;
                                     1: continues| event trigger recording
                                     2: Motion detect
                                     3: Network alarm;
                                     4: Motion| Network Alarm;
                                     5: Motion & Network alarm;
                                     6: Perimeter alarm;
                                     7: Face recognition;
                                     8: LPR;
                9: Manual recording*/
    DWORD dwSupportRecordType;
    BYTE  bySupportLinkMode; //By digit: 0th-main stream; 1st: sub stream
    BYTE  bySupportStringRow;//Supported character string rows
    BYTE  byRes1[2];
    //Resolution:0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF 5-(Reserved),
    //16-VGA(640*480), 17-UXGA(1600*1200), 18-SVGA(800*600),
    //19-HD720p(1280*720),20-XVGA,  21-HD900p, 27-HD1080i,
    //28-2560*1920, 29-1600*304, 30-2048*1536, 31-2448*2048
    BYTE  byMainStreamSupportResolution[32]; //Supported resolution of main stream(added in v1.1 ability)
    BYTE  bySubStreamSupportResolution[32];  //Supported resolution of sub stream(added in v1.1 ability)
    BYTE  byEventStreamSupportResolution[32];//Supported resolution of event stream(added in v1.1 ability)
    BYTE  byRes2[28];//Reserved
}NET_DVR_CODESYSTEMABILITY,  *LPNET_DVR_CODESYSTEMABILITY;

//2010- 03- 31 Add ability set of the video management system
typedef struct tagNET_DVR_SUBSYSTEM_ABILITY
{
    BYTE  bySubSystemType; //Sub system type, 1- Decoding, 2- Encoding, 0- NULL
    BYTE  byChanNum; //Channel number in the sub system
    BYTE  byStartChan; //Start channel of the sub system
    BYTE  byRes1[5];
    union
    {
        BYTE Res[200];
        struct
        {
            BYTE  byVGANums; // Display channel number of VGA( start from 1)
            BYTE  byBNCNums; // Display channel number of BNC(start from 9)
            BYTE  byHDMINums; // Display channel number of HDMI (start from 25)
            BYTE  byDVINums; // Display channel number of DVI(start from 29)
            BYTE  byRes[196];
        }struDecoderSystemAbility;
        struct
        {
            BYTE  byRes[200];
        }struCoderSystemAbility;
    }struAbility;
}NET_DVR_SUBSYSTEM_ABILITY,  *LPNET_DVR_SUBSYSTEM_ABILITY;

typedef struct tagNET_DVR_VIDEOPLATFORM_ABILITY
{
    DWORD dwSize;
    BYTE  byCodeSubSystemNums; //number of encoding sub system
    BYTE  byDecodeSubSystemNums; //number of decoding sub system
    BYTE  bySupportNat; //0- does not support NAT, 1- support NAT
    BYTE  byRes1[17];
    NET_DVR_SUBSYSTEM_ABILITY struSubSystemAbility[MAX_SUBSYSTEM_NUM];
    BYTE  byRes2[640];
}NET_DVR_VIDEOPLATFORM_ABILITY,  *LPNET_DVR_VIDEOPLATFORM_ABILITY;

/********************************end*******************************************/

/******************************Intelligent Traffic Surveillance Camera*******************************************/
//IO input
typedef struct tagNET_DVR_IO_INCFG
{
    DWORD   dwSize;
    BYTE    byIoInStatus; //Input IO status, 0- Falling edge, 1- Rising edge, 2- Falling edge and Rising edge, 3- HIGH, 4- LOW
    BYTE    byRes[3]; //Reserved
}NET_DVR_IO_INCFG,  *LPNET_DVR_IO_INCFG;

//IO output
typedef struct tagNET_DVR_IO_OUTCFG
{
    DWORD   dwSize;
    BYTE    byDefaultStatus; //Default IO status: 0- LOW, 1- HIGH
    BYTE    byIoOutStatus; //IO valid status: 0- LOW, 1- HIGH, 2- PULSE
    WORD    wAheadTime; //Advance time of IO Output, Unit: us
    DWORD   dwTimePluse; //Pulse interval (unit: us)
    DWORD   dwTimeDelay; //IO delay time (unit: us)
    BYTE    byFreqMulti;        //frequence,[1,15]
    BYTE    byDutyRate;        //duty rate,[0,40%]
    BYTE    byRes2[2];
}NET_DVR_IO_OUTCFG,  *LPNET_DVR_IO_OUTCFG;

//Flashlight
typedef struct tagNET_DVR_FLASH_OUTCFG
{
    DWORD  dwSize;
    BYTE   byMode;// 0- not flashing, 1- flashing, 2- alarm linkage, 3- loop mode
    BYTE   byRelatedIoIn;//Corresponding IO (for alarm linkage mode)
    BYTE   byRecognizedLane;  /*Corresponding IO, expressed by bit, bit0 means whether IO1 is related: 0-not related, 1-related*/
    BYTE   byDetectBrightness;/*Detect brightness enable flashlight automatically:0-not detect;1-detect*/
    BYTE   byBrightnessThreld;/*Brightness threshold of enable flashlight:[0,100].Flashlight works when up to the threshold*/
    BYTE   byStartHour;            //Start time--hour, value range: 0-23
    BYTE   byStartMinute;        //Start time--minute, value range: 0-59
    BYTE   byEndHour;            //End time--hour, value range: 0-23
    BYTE   byEndMinute;            //End time--minute, value range: 0-59
    BYTE   byFlashLightEnable;    //Set flashlight time enable: 0 - off, 1 - open
    BYTE   byRes[2];
}NET_DVR_FLASH_OUTCFG, *LPNET_DVR_FLASH_OUTCFG;

//Traffic light
typedef struct tagNET_DVR_LIGHTSNAPCFG
{
    DWORD   dwSize;
    BYTE    byLightIoIn; //Traffic Light IO
    BYTE    byTrigIoIn; //Triggered IO
    BYTE    byRelatedDriveWay; //Corresponding traffic lane
    BYTE    byTrafficLight;  //0- HIGH status for red light and LOW for green light; 1- HIGH status for green light and LOW for red light
    BYTE     bySnapTimes1;  //Red light snapshot time, 0- disable, else- snapshot time (up to 5)
    BYTE     bySnapTimes2;  //Green light snapshot time, 0-disable, else- snapshot time (up to 5)
    BYTE    byRes1[2];
    WORD    wIntervalTime1[4]; //Red light snapshot interval (unit: ms)
    WORD    wIntervalTime2[4]; //Green light snapshot interval (unit: ms)
    BYTE    byRecord; //Record when driving on red light, 0- disable, 1- enable
    BYTE    bySessionTimeout; //Time out session for red light recording (unit: s)
    BYTE    byPreRecordTime; //Pre-Recording time for red light recording (unit: s)
    BYTE    byVideoDelay; //Post--Recording time for red light recording (unit: s)
    BYTE    byRes2[32]; //Reserved
}NET_DVR_LIGHTSNAPCFG,  *LPNET_DVR_LIGHTSNAPCFG;

//Speed Measurement
typedef struct tagNET_DVR_MEASURESPEEDCFG
{
    DWORD   dwSize;
    BYTE    byTrigIo1;    //Testing coil 1
    BYTE    byTrigIo2;    //Testing coil 2
    BYTE    byRelatedDriveWay; //Corresponding traffic lane
    BYTE    byTestSpeedTimeOut; //Timeout for speed testing (unit: s)
    DWORD   dwDistance; //Coil distance, cm
    BYTE    byCapSpeed; //Capture speed starts from (unit:km/h)
    BYTE    bySpeedLimit; //Speed limitation (km/h)
    BYTE     bySnapTimes1;  //Snapshot time for coil 1, 0- disable, else- snapshot time (up to 5)
    BYTE     bySnapTimes2;  //Snapshot time for coil 2, 0- disable, else- snapshot time (up to 5)
    WORD    wIntervalTime1[4]; //Snapshot interval for Coil 1 (unit: ms)
    WORD    wIntervalTime2[4]; //Snapshot interval for Coil 2 (unit: ms)
    BYTE    byRes[32]; //Reserved
}NET_DVR_MEASURESPEEDCFG,  *LPNET_DVR_MEASURESPEEDCFG;


typedef struct tagNET_DVR_CLOUDSTORAGE_COND
{
    DWORD  dwSize;
    DWORD  dwChannel;
    BYTE    byRes1[64];
}NET_DVR_CLOUDSTORAGE_COND,*LPNET_DVR_CLOUDSTORAGE_COND;


typedef struct tagNET_DVR_POOLPARAM
{
    DWORD  dwPoolID;// Pool ID
    BYTE    byRes[4];
}NET_DVR_POOLPARAM,*LPNET_DVR_POOLPARAM;

typedef struct tagNET_DVR_CLOUDSTORAGE_CFG
{
    DWORD   dwSize;
    BYTE    byEnable;
    BYTE    byRes[3];
    NET_DVR_IPADDR  struIP;
    WORD    wPort; //Data Port
    BYTE    byRes1[2];
    char    szUser[CLOUD_NAME_LEN/*48*/]; //User
    char    szPassword[CLOUD_PASSWD_LEN/*48*/];     // Password
    NET_DVR_POOLPARAM  struPoolInfo[16];//Array 0 bayonet video pool, an array of 1 said illegal video pool
    BYTE    byRes2[128];
}NET_DVR_CLOUDSTORAGE_CFG,*LPNET_DVR_CLOUDSTORAGE_CFG;

typedef  struct  tagNET_DVR_PARKLAMP_COND
{
    DWORD  dwSize;
    DWORD  dwChannel;
    BYTE   byParkingIndex;//ParkingIndex(1~4)
    BYTE   byRes[15];
}NET_DVR_PARKLAMP_COND, *LPNET_DVR_PARKLAMP_COND;

typedef  struct  tagNET_DVR_PARKLAMP_INFOCFG
{
    DWORD dwSize;
    char  sLicense[MAX_LICENSE_LEN/*16*/];//Plate License
    char  sParkingNo[MAX_LICENSE_LEN/*16*/];//Parking No(Actual)
    BYTE   byLampFlicker;//0 \A1\AB no flashing 1 \A1\ABflashing
    BYTE   byLampColor;//0-close 1-red 2-green 3-yellow 4-blue 5-magenta  6-cyan 7-white (lamp work)
    BYTE   byStatus; //Parking state 0- no car, 1- car
    BYTE   byColorDepth; //Body color shades\A3\AC0-Dark\A3\AC1-Light
    BYTE   byColor;//Body color\A3\AC0-other colors\A3\AC1-white\A3\AC2-Silver\A3\AC3-gray\A3\AC4-black\A3\AC5-red\A3\AC6-Deep Blue\A3\AC7-Blue\A3\AC8-yellow\A3\AC9-Green\A3\AC10-brown\A3\AC11-pink\A3\AC12-purple\A3\AC0xff-Body color recognition not performed
    //Identify the type of vehicle brands\A3\BB Reference enumerated type: VLR_VEHICLE_CLASS
    BYTE   byVehicleLogoRecog;
    BYTE   byRes[250];//Reservations
}NET_DVR_PARKLAMP_INFOCFG, *LPNET_DVR_PARKLAMP_INFOCFG;

//Video parameter configuration
typedef struct tagNET_DVR_VIDEOEFFECT
{
    BYTE byBrightnessLevel;  /*0- 100*/
    BYTE byContrastLevel;  /*0- 100*/
    BYTE bySharpnessLevel;  /*0- 100*/
    BYTE bySaturationLevel;  /*0- 100*/
    BYTE byHueLevel;  /*0- 100,  (Reserved) */
    BYTE byEnableFunc; //enable,bit0-SMART IR,bit1-illumination,bit2-light inhibit,0-no,1-yes
    BYTE byLightInhibitLevel; //light inhibit level,[1-3]
    BYTE byGrayLevel; //gray level,0-[0-255],1-[16-235]
}NET_DVR_VIDEOEFFECT,  *LPNET_DVR_VIDEOEFFECT;

//Gain Configuration
typedef struct tagNET_DVR_GAIN
{
    BYTE byGainLevel;  /*Gain: 0- 100*/
    BYTE byGainUserSet;  /*Customize Gain level adjustment ([0- 100]) for CCD mode*/
    BYTE byRes[2];
    DWORD dwMaxGainValue; /*Max. Gain level (unit: dB)*/
}NET_DVR_GAIN,  *LPNET_DVR_GAIN;

//White Balance
typedef struct tagNET_DVR_WHITEBALANCE
{
    BYTE byWhiteBalanceMode;  /*0-MWB,1-AWB1,2-AWB2,3-Locked WB\A3\AC
                             4-Outdoor,5-Indoor,6-Fluorescent Lamp\A3\AC7-Sodium Lamp\A3\AC
                             8-Auto-Track,9-One Push,10-Auto-Outdoor\A3\AC
                             11-Auto-Sodiumlight,12-Mercury Lamp,13-Auto,
                             14-IncandescentLamp,15-Warm Light Lamp,16-Natural Light */
    BYTE byWhiteBalanceModeRGain;  /*R Gain for Manual White Balance mode*/
    BYTE byWhiteBalanceModeBGain;  /*B Gain for Manual White Balance mode*/
    BYTE byRes[5];
}NET_DVR_WHITEBALANCE,  *LPNET_DVR_WHITEBALANCE;

//Exposure Control
typedef struct tagNET_DVR_EXPOSURE
{
    BYTE  byExposureMode;  /*0 - manual exposure 1- auto exposure*/
    BYTE  byAutoApertureLevel; /* Auto Aperture Level, 0-10 */
    BYTE  byRes[2];
    DWORD dwVideoExposureSet;  /* Exposure time for manual mode or Max. exposure time for auto mode(unit: us) 20-1s(1000000us)*/
    DWORD dwExposureUserSet;  /* Exposure time (Shutter speed for CCD mode)*/
    DWORD dwRes;
} NET_DVR_EXPOSURE,  *LPNET_DVR_EXPOSURE;

//WDR configuration
typedef struct tagNET_DVR_WDR
{
    BYTE byWDREnabled;  /*WDR: 0 disable  1 enable 2 auto*/
    BYTE byWDRLevel1;  /*0- F*/
    BYTE byWDRLevel2;  /*0- F*/
    BYTE byWDRContrastLevel;  /*0- 100*/
    BYTE byRes[16];
} NET_DVR_WDR,  *LPNET_DVR_WDR;

typedef struct tagNET_DVR_WDR_CFG
{
    DWORD  dwSize;
    NET_DVR_WDR  struWDR;
} NET_DVR_WDR_CFG, *LPNET_DVR_WDR_CFG;


//Day/Night Switching
typedef struct tagNET_DVR_DAYNIGHT
{
    BYTE byDayNightFilterType;  /*Day/Night mode: 0 day, 1 night, 2 auto,3-timing,4-alarm in trigger\A3\AC5 - automatic mode 2 (no light) */
    BYTE bySwitchScheduleEnabled;  /*0 disable  1 enable (Reserved) */
    //Mode 1
    BYTE byBeginTime;  /*begin time hour,0-23*/
    BYTE byEndTime;  /*end time hour,0-23*/
    //Mode 2 (Reserved)
    BYTE byDayToNightFilterLevel;  //0- 7
    BYTE byNightToDayFilterLevel;  //0- 7
    BYTE byDayNightFilterTime; // (60 sec)
    BYTE byBeginTimeMin; //begin time min,0-59
    BYTE byBeginTimeSec; //begin time sec,0-59
    BYTE byEndTimeMin; //end time min,0-59
    BYTE byEndTimeSec; //end time sec,0-59
    BYTE byAlarmTrigState; //alarm in trigger state,0-day,1-night
} NET_DVR_DAYNIGHT,  *LPNET_DVR_DAYNIGHT;

//Gamma correction
typedef struct tagNET_DVR_GAMMACORRECT
{
    BYTE byGammaCorrectionEnabled;  /*0- disable;  1- enable*/
    BYTE byGammaCorrectionLevel;  /*0- 100*/
    BYTE byRes[6];
} NET_DVR_GAMMACORRECT,  *LPNET_DVR_GAMMACORRECT;

//BLC
typedef struct tagNET_DVR_BACKLIGHT
{
    BYTE byBacklightMode;  /*BLC: 0-off  1- UP, 2- DOWN, 3- LEFT, 4- RIGHT, 5- MIDDLE, 6-USERSET \A3\AC10-start\A3\AC11-auto\A3\AC12-Multi regional backlight compensation*/
    BYTE byBacklightLevel;  /*0x0- 0xF*/
    BYTE byRes1[2];
    DWORD dwPositionX1;  // (X coordinate 1)
    DWORD dwPositionY1;  // (Y coordinate 1)
    DWORD dwPositionX2;  // (X coordinate 2)
    DWORD dwPositionY2;  // (Y coordinate 2)
    BYTE byRes2[4];
} NET_DVR_BACKLIGHT,  *LPNET_DVR_BACKLIGHT;

//DNR
typedef struct tagNET_DVR_NOISEREMOVE
{
    BYTE byDigitalNoiseRemoveEnable;  /*DNR: 0- disable  1- normal mode, 2-expert mode*/
    BYTE byDigitalNoiseRemoveLevel;  /*0x0- 0xF*/
    BYTE bySpectralLevel;   /*expert mode Spatial intensity, 0-100*/
    BYTE byTemporalLevel;   /*expert mode Time-domain intensity, 0-100*/
    BYTE byDigitalNoiseRemove2DEnable;
    BYTE byDigitalNoiseRemove2DLevel;
    BYTE byRes[2];
} NET_DVR_NOISEREMOVE,  *LPNET_DVR_NOISEREMOVE;

//Lens configuration under CMOS mode
typedef struct tagNET_DVR_CMOSMODCFG
{
    BYTE byCaptureMod;    //Snapshot mode: 0- mode1; 1- mode2
    BYTE byBrightnessGate; //Brightness threshold
    BYTE byCaptureGain1;    //Snapshot Gain1, 0- 100
    BYTE byCaptureGain2;    //Snapshot Gain2, 0- 100
    DWORD dwCaptureShutterSpeed1; //Snapshot Shutter speed 1
    DWORD dwCaptureShutterSpeed2; //Snapshot Shutter speed 2
    BYTE    byRes[4];
}NET_DVR_CMOSMODECFG,  *LPNET_DVR_CMOSMODECFG;

//IPC CCD Parameter Configuration
typedef struct tagNET_DVR_CAMERAPARAMCFG
{
    DWORD dwSize;
    NET_DVR_VIDEOEFFECT struVideoEffect; /*Brightness, Contrast, Saturation, Sharpness, Hue Configuration*/
    NET_DVR_GAIN struGain; /*Auto Gain*/
    NET_DVR_WHITEBALANCE struWhiteBalance; /*White Balance*/
    NET_DVR_EXPOSURE struExposure;  /*Exposure Control*/
    NET_DVR_GAMMACORRECT struGammaCorrect; /*Gamma Correction*/
    NET_DVR_WDR struWdr; /*WDR*/
    NET_DVR_DAYNIGHT struDayNight; /*Day/Night*/
    NET_DVR_BACKLIGHT struBackLight; /*BLC*/
    NET_DVR_NOISEREMOVE struNoiseRemove; /*DNR*/
    BYTE byPowerLineFrequencyMode;  /*0- 50HZ;  1- 60HZ*/
    /*
        0-Auto Iris,
        1-Manual Iris,
        2-P-Iris1,
        3-Union 3-9mm F1.6-2.7 (T5280-PQ1) [IPC5.1.7]
        4-Union 2.8-12mm F1.6-2.7 (T5289-PQ1) [IPC5.1.7]
        5-HIK 3.8-16mm F1.5\A3\A8HV3816P-8MPIR)
        6-HIK 11-40mm F1.7 (HV1140P-8MPIR)
        7-HIK 2.7-12mm F1.2\A3\A8TV2712P-MPIR\A3\A9
    */
    BYTE byIrisMode;
    BYTE byMirror ;   /* Mirror: 0 off, 1- leftright, 2- updown, 3-center */
    BYTE byDigitalZoom;   /*Digital zoom: 0 disable  1 enable*/
    BYTE byDeadPixelDetect;    /*Corrupted Pixel detect, 0-disable  1-enable*/
    BYTE byBlackPwl; /*Black Power Level ,   0- 255*/
    BYTE byEptzGate; // EPTZ: 0-off; 1-Eletronic PTZ
    BYTE byLocalOutputGate; //Local output 0- local output closed; 1- Local BNC output open; 2- HDMI output closed
    //20- HDMI_720P50 output open
    //21- HDMI_720P60 output open
    //22- HDMI_1080I60 output open
    //23- HDMI_1080I50 output open
    //24- HDMI_1080P24 output open
    //25- HDMI_1080P25 output open
    //26- HDMI_1080P30 output open
    //27- HDMI_1080P50 output open
    //28- HDMI_1080P60 output open

    //40-SDI_720P50,
    //41-SDI_720P60,
    //42-SDI_1080I50,
    //43-SDI_1080I60,
    //44-SDI_1080P24,
    //45-SDI_1080P25,
    //46-SDI_1080P30,
    //47-SDI_1080P50,
    //48-SDI_1080P60
    BYTE byCoderOutputMode; //Encoder's FPGA output mode
    BYTE byLineCoding; //Enable line coding or not: 0- enable, 1- disable
    BYTE byDimmerMode; //Dimming mode: 0- semi-automatic, 1- automatic
    BYTE byPaletteMode; //Color palette: 0- incandescence, 1- Black heat, 2- palette 2, ..., 8- palette 8
    BYTE byEnhancedMode; //Enhance mode (around detected object): 0- not enhance, 1- 1, 2- 2, 3- 3, 4- 4
    BYTE byDynamicContrastEN;     //Increase Dynamic Contrast 0- 1
    BYTE byDynamicContrast;     //Dynamic Contrast 0- 100
    BYTE byJPEGQuality;     //JPEG Quality: 0- 100
    NET_DVR_CMOSMODECFG struCmosModeCfg; //Configuration under CMOS mode
    BYTE byFilterSwitch; //Filter switch: 0- disable, 1- enable
    BYTE byFocusSpeed;  //Focus speed: 0-10
    BYTE byAutoCompensationInterval; //Scheduled automatic shutter compensation: 1-120, unit: minute
    BYTE bySceneMode;  //Scene mode: 0- outdoor, 1- indoor, 2- default, 3 - lowLight
}NET_DVR_CAMERAPARAMCFG,  *LPNET_DVR_CAMERAPARAMCFG;

typedef struct tagNET_DVR_DEFOGCFG
{
    BYTE byMode; //mode 0-disable\A3\AC1-auto\A3\AC2-enble
    BYTE byLevel; //level 1-100
    BYTE byRes[6];
}NET_DVR_DEFOGCFG, *LPNET_DVR_DEFOGCFG;

typedef struct tagNET_DVR_ELECTRONICSTABILIZATION
{
    BYTE byEnable;
    BYTE byLevel; //level 1-100
    BYTE byRes[6];
}NET_DVR_ELECTRONICSTABILIZATION, *LPNET_DVR_ELECTRONICSTABILIZATION;

typedef struct tagNET_DVR_CORRIDOR_MODE_CCD
{
    BYTE       byEnableCorridorMode; // 0\A1\ABNO enable\A3\AC 1\A1\AB enable
    BYTE       byRes[11];
}NET_DVR_CORRIDOR_MODE_CCD, *LPNET_DVR_CORRIDOR_MODE_CCD;

typedef struct tagNET_DVR_SMARTIR_PARAM
{
    BYTE  byMode;//0\A1\ABAutomatic\A3\AC1\A1\ABmanual
    BYTE  byIRDistance;//Infrared distance class (grade, distance is proportional) level:1~100 default: 50 (manual mode increase)
    BYTE  byShortIRDistance;// Short IR Distance(1~100)
    BYTE  byLongIRDistance;// Long IR Distance(1~100)
}NET_DVR_SMARTIR_PARAM,*LPNET_DVR_SMARTIR_PARAM;

typedef struct tagNET_DVR_PIRIS_PARAM
{
    BYTE  byMode;//0\A1\ABAutomatic\A3\AC1\A1\ABmanual
    BYTE  byPIrisAperture;//Infrared aperture size grade (grade, aperture size is proportional) level:1~100 default: 50 (manual mode increase)
    BYTE  byRes[6];
}NET_DVR_PIRIS_PARAM,*LPNET_DVR_PIRIS_PARAM;

//laser parameter 2014-02-25
typedef struct tagNET_DVR_LASER_PARAM_CFG
{
    //Length = 16
    BYTE    byControlMode;        //control mode            0-invalid\A3\AC1-auto\A3\AC2-manual  the default is auto
    BYTE    bySensitivity;        //laser sensitivity        0-100  the default is 50
    BYTE    byTriggerMode;        //laser trigger mode    0-invalid\A3\AC1-Camera Module Trigger\A3\AC2-Photoresistance Trigger  the default is 1
    BYTE    byBrightness;        //Manual mode\A3\BBlaser brightness        0-255  the default is 100
    BYTE    byAngle;            //laser angle            0-invalid\A3\AC1-36  the default is 12
    BYTE    byLimitBrightness;  //Auto mode\A3\BBLaser lamp brightness limit 0~100      2014-01-26
    BYTE    byEnabled ;         //Enabled
    BYTE    byIllumination;     //Illumination; 0~100
    BYTE    byLightAngle;       //Light Angle 0~100
    BYTE    byRes[7];
} NET_DVR_LASER_PARAM_CFG, *LPNET_DVR_LASER_PARAM_CFG;

typedef struct tagNET_DVR_FFC_PARAM
{
    //1-Schedule Mode,2-Temperature Mode, 3-Off
    BYTE   byMode;
    //(time: according to ability display unit minutes, options 10,20,30,40,50,60,120,180,240\A3\A9
    BYTE   byRes1;
    WORD  wCompensateTime; //Timing mode effect
    BYTE   byRes2[4];
}NET_DVR_FFC_PARAM,*LPNET_DVR_FFC_PARAM;

typedef struct tagNET_DVR_DDE_PARAM
{
    BYTE  byMode;//1-Off,2-Normal Mode,3-Expert Mode
    BYTE  byNormalLevel;//Normal Mode Level[1,100]\A3\ACNormal mode effect
    BYTE  byExpertLevel;//Exper Mode Level[1,100]\A3\ACExper Mode effect
    BYTE  byRes[5];
}NET_DVR_DDE_PARAM,*LPNET_DVR_DDE_PARAM;

typedef struct tagNET_DVR_AGC_PARAM
{
    BYTE  bySceneType;//1-Normal Sence,2-Highlight Sence,3-Manual Sence
    BYTE  byLightLevel;//Light Level[1,100]\A3\BBManual Mode effect
    BYTE  byGainLevel; //Gain Level[1,100]\A3\BBManual Mode effect
    BYTE  byRes[5];
}NET_DVR_AGC_PARAM,*LPNET_DVR_AGC_PARAM;

//Snap CCD CFG
typedef struct tagNET_DVR_SNAP_CAMERAPARAMCFG
{
    BYTE byWDRMode;   // WDR Mode
    BYTE byWDRType;    // WDR Type
    BYTE byWDRLevel;   // WDR Level
    BYTE byRes1;
    NET_DVR_TIME_EX struStartTime; //Start WDR Time
    NET_DVR_TIME_EX struEndTime; //Stop WDR Time
    BYTE byDayNightBrightness; //Day Night Brightness
    //MCE
    BYTE byMCEEnabled;//MCE Enabled\A3\AC
    BYTE byMCELevel;//MCE Level
    //Auto Contrast
    BYTE byAutoContrastEnabled;//Auto Contrast Enabled
    BYTE byAutoContrastLevel;//Auto Contrast Level
    //LSE Detail
    BYTE byLSEDetailEnabled;//LSE Detail Enabled
    BYTE byLSEDetailLevel;//LSE Detail Level
    // License Plate Definition Enhancement
    BYTE byLPDEEnabled;//LPDE Enabled
    BYTE byLPDELevel;//LPDE Level
    BYTE byRes[35];
} NET_DVR_SNAP_CAMERAPARAMCFG,*LPNET_DVR_SNAP_CAMERAPARAMCFG;

//Optical Dehaze
typedef struct tagNET_DVR_OPTICAL_DEHAZE
{
    BYTE byEnable; //0~disable\A3\AC1~Enable
    BYTE byRes[7];
} NET_DVR_OPTICAL_DEHAZE, *LPNET_DVR_OPTICAL_DEHAZE;

//IPC CCD Parameter Configuration
typedef struct tagNET_DVR_CAMERAPARAMCFG_EX
{
    DWORD dwSize;
    NET_DVR_VIDEOEFFECT struVideoEffect; /*Brightness, Contrast, Saturation, Sharpness, Hue Configuration*/
    NET_DVR_GAIN struGain; /*Auto Gain*/
    NET_DVR_WHITEBALANCE struWhiteBalance; /*White Balance*/
    NET_DVR_EXPOSURE struExposure;  /*Exposure Control*/
    NET_DVR_GAMMACORRECT struGammaCorrect; /*Gamma Correction*/
    NET_DVR_WDR struWdr; /*WDR*/
    NET_DVR_DAYNIGHT struDayNight; /*Day/Night*/
    NET_DVR_BACKLIGHT struBackLight; /*BLC*/
    NET_DVR_NOISEREMOVE struNoiseRemove; /*DNR*/
    BYTE byPowerLineFrequencyMode;  /*0- 50HZ;  1- 60HZ*/
    BYTE byIrisMode;  /*0-Auto Iris 1-Manual Iris, 2-P-Iris1, 3-Union 3-9mm F1.6-2.7 (T5280-PQ1), 4-Union 2.8-12mm F1.6-2.7 (T5289-PQ1)*/ //2014-03-21
    BYTE byMirror ;   /* Mirror: 0 off, 1- leftright, 2- updown, 3-center */
    BYTE byDigitalZoom;   /*Digital zoom: 0 disable, 1-\A1\C12\A3\AC2-\A1\C14\A3\AC3-\A1\C18,4-\A1\C116,5-\A1\C132*/
    BYTE byDeadPixelDetect;    /*Corrupted Pixel detect, 0-disable  1-enable*/
    BYTE byBlackPwl; /*Black Power Level ,   0- 255*/
    BYTE byEptzGate; // EPTZ: 0-off; 1-Eletronic PTZ
    BYTE byLocalOutputGate; //Local output 0- local output closed; 1- Local BNC output open; 2- HDMI output closed
    //20- HDMI_720P50 output open
    //21- HDMI_720P60 output open
    //22- HDMI_1080I60 output open
    //23- HDMI_1080I50 output open
    //24- HDMI_1080P24 output open
    //25- HDMI_1080P25 output open
    //26- HDMI_1080P30 output open
    //27- HDMI_1080P50 output open
    //28- HDMI_1080P60 output open
    BYTE byCoderOutputMode; //Encoder's FPGA output mode
    BYTE byLineCoding; //Enable line coding or not: 0- enable, 1- disable
    BYTE byDimmerMode; //Dimming mode: 0- semi-automatic, 1- automatic
    BYTE byPaletteMode; //Color palette: 0- incandescence, 1- Black heat, 2- palette 2, ..., 8- palette 8
    BYTE byEnhancedMode; //Enhance mode (around detected object): 0- not enhance, 1- 1, 2- 2, 3- 3, 4- 4
    BYTE byDynamicContrastEN;     //Increase Dynamic Contrast 0- 1
    BYTE byDynamicContrast;     //Dynamic Contrast 0- 100
    BYTE byJPEGQuality;     //JPEG Quality: 0- 100
    NET_DVR_CMOSMODECFG struCmosModeCfg; //Configuration under CMOS mode
    BYTE byFilterSwitch; //Filter switch: 0- disable, 1- enable
    BYTE byFocusSpeed;  //Focus speed: 0-10
    BYTE byAutoCompensationInterval; //Scheduled automatic shutter compensation: 1-120, unit: minute
    BYTE bySceneMode;  //Scene mode: 0- outdoor, 1- indoor, 2- default, 3 - lowLight
    NET_DVR_DEFOGCFG struDefogCfg;//
    NET_DVR_ELECTRONICSTABILIZATION struElectronicStabilization;//
    NET_DVR_CORRIDOR_MODE_CCD struCorridorMode;//
    BYTE   byExposureSegmentEnable; //0~ is not enabled, 1~ enables the exposure time and gain ladder adjustment, such as exposure to adjust, improve the exposure time to the intermediate value, and then increase the gain to the intermediate value, and then improve the exposure to a maximum value, finally improve the gain to the maximum
    BYTE   byBrightCompensate;//Brightness enhancement [0~100]
    /*
    0-close\A1\A21-640*480@25fps\A1\A22-640*480@30ps\A1\A23-704*576@25fps\A1\A24-704*480@30fps\A1\A25-1280*720@25fps\A1\A26-1280*720@30fps\A1\A2
    7-1280*720@50fps\A1\A28-1280*720@60fps\A1\A29-1280*960@15fps\A1\A210-1280*960@25fps\A1\A211-1280*960@30fps\A1\A2
    12-1280*1024@25fps\A1\A213--1280*1024@30fps\A1\A214-1600*900@15fps\A1\A215-1600*1200@15fps\A1\A216-1920*1080@15fps\A1\A2
    17-1920*1080@25fps\A1\A218-1920*1080@30fps\A1\A219-1920*1080@50fps\A1\A220-1920*1080@60fps\A1\A221-2048*1536@15fps\A1\A222-2048*1536@20fps\A1\A2
    23-2048*1536@24fps\A1\A224-2048*1536@25fps\A1\A225-2048*1536@30fps\A1\A226-2560*2048@25fps\A1\A227-2560*2048@30fps\A1\A2
    28-2560*1920@7.5fps\A1\A229-3072*2048@25fps\A1\A230-3072*2048@30fps\A1\A231-2048*1536@12.5\A1\A232-2560*1920@6.25\A1\A2
    33-1600*1200@25\A1\A234-1600*1200@30\A1\A235-1600*1200@12.5\A1\A236-1600*900@12.5\A1\A237-1280*960@12.5fps\A1\A238-800*600@25fps\A1\A239-800*600@30fps40\A1\A2
    4000*3000@12.5fps\A1\A241-4000*3000@15fps\A1\A242-4096*2160@20fps\A1\A243-3840*2160@20fps \A1\A244-960*576@25fps\A1\A245-960*480@30fps\A1\A246-752*582@25fps\A1\A2
    47-768*494@30fps\A1\A248-2560*1440@25fps\A1\A249-2560*1440@30fps \A1\A250-720P@100fps\A1\A251-720P@120fps\A1\A252-2048*1536@50fps\A1\A253-2048*1536@60fps\A1\A2
    54-3840*2160@25fps\A1\A255-3840*2160@30fps\A1\A256-4096*2160@25fps\A1\A257-4096*2160@30fps \A1\A258-1280*1024@50fps\A1\A259-1280*1024@60fps\A1\A2
    60-3072*2048@50fps\A1\A261-3072*2048@60fps\A1\A262-3072*1728@25fps\A1\A263-3072*1728@30fps\A1\A264-3072*1728@50fps\A1\A265-3072*1728@60fps\A1\A266-336*256@50fps\A1\A267-336*256@60fps\A1\A2
    68-384*288@50fps\A1\A269-384*288@60fps \A1\A270- 640 * 512@50fps \A1\A271- 640 * 512@60fps\A1\A272-2592*1944@25fps\A1\A273-2592*1944@30fps\A1\A274-2688*1536@25fps\A1\A275-2688*1536@30fps
    76-2592*1944@20fps\A1\A277-2592*1944@15fps\A1\A278-2688*1520@20fps\A1\A279-2688*1520@15fps\A1\A280-2688*1520@25fps\A1\A281-2688*1520@30fps\A1\A282- 2720*2048@25fps\A1\A2 83- 2720*2048@30fps\A1\A2
    84- 336*256@25fps\A1\A285- 384*288@25fps\A1\A286-640*512@25fps\A1\A287-1280*960@50fps\A1\A288-1280*960@60fps\A1\A289-1280*960@100fps\A1\A290-1280*960@120fps\A1\A291-4000*3000@20fps\A1\A2
    92-1920*1200@25fps\A1\A293-1920*1200@30fps\A1\A294-2560*1920@25fps\A1\A295-2560*1920@20fps\A1\A296-2560*1920@30fps\A1\A297-1280*1920@25fps\A1\A298-1280*1920@30fps\A1\A2
    99-4000*3000@24fps\A1\A2100-4000*3000@25fps\A1\A2101-4000*3000@10fps\A1\A2102- 384*288@30fps\A1\A2103-2560*1920@15fps\A1\A2104-2400*3840@25fps\A1\A2105-1200*1920@25fps
    106-4096*1800@30fps\A1\A2107-3840*1680@30fps\A1\A2108-2560*1120@30fps\A1\A2109-704*320@30fps\A1\A2110-1280*560@30fps\A1\A2111-4096*1800@25fps\A1\A2112-3840*1680@25fps
    113-2560*1120@25fps\A1\A2114-704*320@25fps\A1\A2115-1280*560@25fps\A1\A2116-2400*3840@24fps\A1\A2117-3840*2400@24fps\A1\A2118-3840*2400@25fps\A1\A2119-2560*1920@12.5fps
    120-2560*2048@12fps\A1\A2121-2560*2048@15fps\A1\A2122-2560*1536@25fps\A1\A2123-2560*1536@30fps\A1\A2124-2256*2048@25fps\A1\A2125-2256*2048@30fps\A1\A2126-2592*2592@12.5fps\A1\A2127-2592*2592@15fps
    128 - 640*512@30fps\A1\A2129-2048*1520@30fps\A1\A2130-2048*1520@25fps\A1\A2131-3840*2160@24fps\A1\A2132-2592*1520@25fps\A1\A2133-2592*1520@30fps\A1\A2134-2592*1536@25fps\A1\A2135-2592*1536@30fps
    136-640*960@25fps\A1\A2137-640*960@24fps*/
    BYTE   byCaptureModeN;
    BYTE   byCaptureModeP;
    NET_DVR_SMARTIR_PARAM struSmartIRParam;
    NET_DVR_PIRIS_PARAM struPIrisParam;//The PIris configuration information corresponding to the byIrisMode field come into force from 2-PIris1
    NET_DVR_LASER_PARAM_CFG struLaserParam;    //laser parameter
    NET_DVR_FFC_PARAM  struFFCParam;
    NET_DVR_DDE_PARAM  struDDEParam;
    NET_DVR_AGC_PARAM  struAGCParam;
    BYTE   byLensDistortionCorrection;//Lens distortion correction 0-Disable,1-Enable
    BYTE   byRes1[3];
    NET_DVR_SNAP_CAMERAPARAMCFG struSnapCCD ; //Snap CCD CFG
    NET_DVR_OPTICAL_DEHAZE struOpticalDehaze;//Optical Dehaze
    BYTE   byRes2[180];
}NET_DVR_CAMERAPARAMCFG_EX,  *LPNET_DVR_CAMERAPARAMCFG_EX;

typedef struct tagNET_DVR_FOCUSING_POSITION_STATE
{
    DWORD  dwSize;
    BYTE    byState;//Focusing Position State: 0-not in place\A3\AC1-in place
    BYTE    byRes[31];
} NET_DVR_FOCUSING_POSITION_STATE, *LPNET_DVR_FOCUSING_POSITION_STATE;

//plate color
typedef enum _VCA_PLATE_COLOR_
{
    VCA_BLUE_PLATE  = 0,       //Blue license plate
    VCA_YELLOW_PLATE,          //Yellow license plate
    VCA_WHITE_PLATE,           //White license plate
    VCA_BLACK_PLATE,           //Black license plate
    VCA_GREEN_PLATE,           //Green license plate
    VCA_BKAIR_PLATE,           //Civil aviation balck license plate
    VCA_OTHER = 0xff           //Other
}VCA_PLATE_COLOR;

//plate type
typedef enum _VCA_PLATE_TYPE_
{
    VCA_STANDARD92_PLATE = 0,    //Standard civil car and military car
    VCA_STANDARD02_PLATE,        //civil car license plate of form 02
    VCA_WJPOLICE_PLATE,            //Armed police car
    VCA_JINGCHE_PLATE,            //Police car
    STANDARD92_BACK_PLATE,      //Dual-line rear plate of civil car
    VCA_SHIGUAN_PLATE,          //Embassy license plate
    VCA_NONGYONG_PLATE,         //Agricultural vehicles
    VCA_MOTO_PLATE              //Motorcycle
}VCA_PLATE_TYPE;

//Vehicle Color
typedef enum _VCR_CLR_CLASS
{
    VCR_CLR_UNSUPPORT  = 0,      //Not supported
    VCR_CLR_WHITE       = 1,   //White
    VCR_CLR_SILVER        = 2,   //Silver
    VCR_CLR_GRAY       = 3,      //Gray
    VCR_CLR_BLACK      = 4,      //Black
    VCR_CLR_RED           = 5,      //Red
    VCR_CLR_DARKBLUE   = 6,      //Darkblue
    VCR_CLR_BLUE       = 7,      //Blue
    VCR_CLR_YELLOW     = 8,      //Yellow
    VCR_CLR_GREEN      = 9,      //Green
    VCR_CLR_BROWN      = 10,  //Brown
    VCR_CLR_PINK       = 11,  //Pink
    VCR_CLR_PURPLE     = 12,  //Purple
    VCR_CLR_DARKGRAY   = 13,  //Darkgray
    VCR_CLR_CYAN       = 14   //Cyan
}VCR_CLR_CLASS;

//Vehicle Operate Type 2013-11-04
typedef enum _VCA_OPERATE_TYPE_
{
    VCA_LICENSE_TYPE       = 0x1,  //License
    VCA_PLATECOLOR_TYPE    = 0x2,  //Plate Color
    VCA_CARDNO_TYPE        = 0x4,  //Card No
    VCA_PLATETYPE_TYPE     = 0x8,  //Plate Type
    VCA_LISTTYPE_TYPE      = 0x10, //List Type
    VCA_INDEX_TYPE         = 0x20,  //Data Index
    VCA_OPERATE_INDEX_TYPE = 0x40   //Operate Index Type 2014-03-03
}VCA_OPERATE_TYPE;

typedef enum _VCA_ILLEGAL_TYPE_
{
    VCA_POSTPIC_TYPE          = 0x1,
    VCA_LOWSPEED_TYPE         = 0x2,
    VCA_HIGHSPEED_TYPE        = 0x4,
    VCA_RETROGRADE_TYPE       = 0x8,
    VCA_RUSH_REDLIGHT_TYPE    = 0x10,
    VCA_PRESS_LANE_TYPE       = 0x20,
    VCA_VIOLATE_GUIDE_TYPE    = 0x40,
    VCA_ROAD_STRAND_TYPE      = 0x80,
    VCA_VEHICLE_ILLEGAL_LANE_TYPE  = 0x100,
    VCA_ILLEGAL_LANE_CHANGE_TYPE   = 0x200,
    VCA_ILLEGAL_LANE_DRIVE_TYPE    = 0x400,
    VCA_VIOLATE_BAN_TYPE           = 0x800,
    VCA_CROSS_PARKING_TYPE           = 0x1000,
    VCA_GREEN_PARKING_TYPE         = 0x2000
}VCA_ILLEGAL_TYPE;

typedef enum _VCA_VEHICLE_TYPE_
{
    VCA_OTHER_TYPE         = 0x1,
    VCA_SMALLCAR_TYPE      = 0x2,
    VCA_BIGCAR_TYPE        = 0x4,
    VCA_BUS_TYPE           = 0x8,
    VCA_TRUCK_TYPE         = 0x10,
    VCA_CAR_TYPE           = 0x20,
    VCA_MINIBUS_TYPE       = 0x40,
    VCA_SMALL_TRUCK_TYPE   = 0x80
}VCA_VEHICLE_TYPE;

typedef enum _VLR_VEHICLE_CLASS
{
    VLR_OTHER      = 0,
    VLR_VOLKSWAGEN = 1,
    VLR_BUICK      = 2,
    VLR_BMW        = 3,
    VLR_HONDA      = 4,
    VLR_PEUGEOT    = 5,
    VLR_TOYOTA     = 6,
    VLR_FORD       = 7,
    VLR_NISSAN     = 8,
    VLR_AUDI       = 9,
    VLR_MAZDA      = 10,
    VLR_CHEVROLET  = 11,
    VLR_CITROEN    = 12,
    VLR_HYUNDAI    = 13,
    VLR_CHERY      = 14,
    VLR_KIA        = 15,
    VLR_ROEWE      = 16,
    VLR_MITSUBISHI = 17,
    VLR_SKODA      = 18,
    VLR_GEELY      = 19,
    VLR_ZHONGHUA   = 20,
    VLR_VOLVO      = 21,
    VLR_LEXUS      = 22,
    VLR_FIAT       = 23,
    VLR_EMGRAND    = 24,
    VLR_DONGFENG   = 25,
    VLR_BYD        = 26,
    VLR_SUZUKI     = 27,
    VLR_JINBEI     = 28,
    VLR_HAIMA      = 29,
    VLR_SGMW       = 30,
    VLR_JAC        = 31,
    VLR_SUBARU     = 32,
    VLR_ENGLON     = 33,
    VLR_GREATWALL  = 34,
    VLR_HAFEI      = 35,
    VLR_ISUZU      = 36,
    VLR_SOUEAST    = 37,
    VLR_CHANA      = 38,
    VLR_FOTON      = 39,
    VLR_XIALI      = 40,
    VLR_BENZ       = 41,
    VLR_FAW        = 42,
    VLR_NAVECO     = 43,
    VLR_LIFAN      = 44,
    VLR_BESTURN    = 45,
    VLR_CROWN      = 46,
    VLR_RENAULT    = 47,
    VLR_JMC        = 48,
    VLR_MG         = 49,
    VLR_KAMA       = 50,
    VLR_ZOTYE      = 51,
    VLR_CHANGHE    = 52,
    VLR_XMKINGLONG = 53,
    VLR_HUIZHONG   = 54,
    VLR_SZKINGLONG = 55,
    VLR_HIGER      = 56,
    VLR_YUTONG     = 57,
    VLR_CNHTC      = 58,
    VLR_BEIBEN     = 59,
    VLR_XINGMA     = 60,
    VLR_YUEJIN     = 61,
    VLR_HUANGHAI   = 62,
    VLR_OLDWALL     = 63,
    VLR_CHANACOMMERCIAL = 64,
    VLR_PORSCHE                   = 65,
    VLR_CADILLAC                  = 66,
    VLR_INFINITI                  = 67,
    VLR_GLEAGLE                   = 68,
    VLR_JEEP                      = 69,
    VLR_LANDROVER                 = 70,
    VLR_CHANGFENG                 = 71,
    VLR_BENNI                     = 72,
    VLR_ERA                       = 73,
    VLR_TAURUS                    = 74,
    VLR_EADO                      = 75,
    VLR_SHANQI                    = 76,
    VLR_HONGYAN                   = 77,
    VLR_DRAGON                    = 78,
    VLR_JACTEXT                   = 79,
    VLR_JACBUS                    = 80,
    VLR_ANKAI                     = 81,
    VLR_SHENLONG                  = 82,
    VLR_DAEWOO                    = 83,
    VLR_WUZHENG                   = 84,
    VLR_MAN                       = 85,
    VLR_ZHONGTONG                 = 86,
    VLR_BAOJUN                    = 87,
    VLR_BQWEIWANG                 = 88,
    VLR_TRUMPCHE                  = 89,
    VLR_LUFENG                    = 90,
    VLR_HMZHENGZHOU               = 91,
    VLR_BEIJING                   = 92,
    VLR_ZHONGSHUN                 = 93,
    VLR_WEILIN                    = 94,
    VLR_OPEL                      = 95,
    VLR_KARRY                     = 96,
    VLR_SMA                       = 97,
    VLR_SMATEXT                   = 98,
    VLR_YUWIN                     = 99,
    VLR_MINI                      = 100,
    VLR_MARK                      = 101,
    VLR_HAVAL                     = 102,
    VLR_OGA                       = 103,
    VLR_VENUCIA                   = 104,
    VLR_BYD2                      = 105,
    VLR_SMART                     = 106,
    VLR_BAW                       = 107,
    VLR_LUXGEN                    = 108,
    VLR_YEMA                      = 109,
    VLR_ZTE                       = 110,
    VLR_EVERUS                    = 111,
    VLR_CHRYSLER                  = 112,
    VLR_GONOW                     = 113,
    VLR_SHJIANG                   = 114,
    VLR_RUILIN                    = 115,
    VLR_FORTA                     = 116,
    VLR_GAGUAR                    = 117,
    VLR_HEIBAO                    = 118,
    VLR_TKING                     = 119,
    VLR_TKINGTEXT                 = 120,
    VLR_FODAY                     = 121,
    VLR_LOTUS                     = 122,
    VLR_NANJUN                    = 123,
    VLR_SHUANGHUAN                = 124,
    VLR_SAIBAO                    = 125,
    VLR_HAWTAI                    = 126,
    VLR_LIFO                      = 127,
    VLR_JONWAY                    = 128,
    VLR_FULONGMA                  = 129,
    VLR_WEILI                     = 130,
    VLR_ANCHI                     = 131,
    VLR_PAIXI                     = 132,
    VLR_HIGERTEXT                 = 133,
    VLR_RIYECAR                   = 134,
    VLR_RIYETRUCK                 = 135,
    VLR_JIANGNAN                  = 136,
    VLR_OLDZOTYE                  = 137,
    VLR_OLDXIALI                  = 138,
    VLR_NEWAOCHI                  = 139,
    VLR_CDW                       = 140,
    VLR_CDWTEXT                   = 141,
    VLR_CIIMO                     = 142,
    VLR_CHANADS                   = 143,
    VLR_DS                        = 144,
    VLR_ROHENS                    = 145,
    VLR_YANTAI                    = 146,
    VLR_SHUANGLONG                = 147,
    VLR_FENGLING                  = 148,
    VLR_XINKAI                    = 149,
    VLR_GMC                       = 150,
    VLR_DATONG                    = 151,
    VLR_BQYINXIANG                = 152,
    VLR_NEWCHERY                  = 153,
    VLR_MUDAN                     = 154,
    VLR_DAYUN                     = 155,
    VLR_DONGWO                    = 156,
    VLR_UNION                     = 157,
    VLR_CHUNZHOU                  = 158,
    VLR_SANY                      = 159,
    VLR_YAXING                    = 160,
    VLR_HENGTONG                  = 161,
    VLR_SHAOLIN                   = 162,
    VLR_YOUNG                     = 163,
    VLR_STOM                      = 164,
    VLR_SANHUAN                   = 165,
    VLR_XUGONG                    = 166,
    VLR_BEIFANG                   = 167,
    VLR_JIANGHUAN                 = 168,
    VLR_BJFARM                    = 169,
    VLR_NEWDADI                   = 170,
    VLR_SUNWIN                    = 171,
    VLR_YINGTIAN                  = 172,
    VLR_QINGQI                    = 173,
    VLR_CHUFENG                   = 174,
    VLR_SCANIA                    = 175,
    VLR_JIULONG                   = 176,
    VLR_YOUYI                     = 177,
    VLR_SHANGRAO                  = 178,
    VLR_JIJIANG                   = 179,
    VLR_YANGZI                    = 180,
    VLR_XIWO                      = 181,
    VLR_CHANGJIANG                = 182,
    VLR_WUYI                      = 183,
    VLR_CHENGDU                   = 184,
    VLR_TIANMA                    = 185,
    VLR_BAOLONG                   = 186,
    VLR_NEWYATU                   = 187,
    VLR_BARUI                     = 188,
    VLR_GUANZHI                   = 189,
    VLR_XIYATE                    = 190,
    VLR_BINLI                     = 191,
    VLR_DADI                      = 192,
    VLR_FUQI                      = 193,
    VLR_HANGTIAN                  = 194,
    VLR_HENGTIAN                  = 195,
    VLR_JMCCAR                    = 196,
    VLR_KAERSEN                   = 197,
    VLR_KAWEI                     = 198,
    VLR_LANBOJINI                 = 199,
    VLR_MASHALADI                 = 200,
    VLR_SHUCHI                    = 201,
    VLR_SHILI                     = 202,
    VLR_HUABEI                    = 203,
    VLR_YIZHENG                   = 204,
    VLR_CHUNLAN                   = 205,
    VLR_DAFA                      = 206,
    VLR_SHENYE                    = 207,
    VLR_FALALI                    = 208,
    VLR_FUXING                    = 209,
    VLR_ANYUAN                    = 210,
    VLR_JINGHUA                   = 211,
    VLR_TAIHU                     = 212,
    VLR_WUZHOULONG                = 213,
    VLR_CHANGLONG                 = 214,
    VLR_YUEXI                     = 215,
    VLR_SHENMA                    = 216,
    VLR_LUSHAN                    = 217,
    VLR_WANFENG                   = 218,
    VLR_GZYUNBAO                  = 219,
    VLR_ZHONGDA                   = 220,
    VLR_THREEWHEEL                = 221,
    VLR_TWOWHEEL                  = 222,
    VLR_JBC                       = 223,
    VLR_YZJIANG                   = 224,
    VLR_CNJ                       = 225,
    VLR_FORLAND                   = 226,
    VLR_FARMCAR                   = 227,
    VLR_DONGFANGHONG              = 228,
    VLR_STEYR                     = 229,
    VLR_HONGQI                    = 230,
    VLR_USER1       = 231,
    VLR_USER2       = 232,
    VLR_USER3       = 233,
    VLR_USER4       = 234,
    VLR_USER5       = 235,
    VLR_USER6       = 236,
    VLR_USER7       = 237,
    VLR_USER8       = 238
}VLR_VEHICLE_CLASS;

/********************Vehicle Brand Sub Type Begin*************************/
//VOLKSWAGEN
typedef enum _VSB_VOLKSWAGEN_CLASS
{
    VSB_VOLKSWAGEN_OTHER          = 0,
    VSB_VOLKSWAGEN_LAVIDA         = 1,
    VSB_VOLKSWAGEN_CROSSLAVIDA    = 2,
    VSB_VOLKSWAGEN_TIGUAN         = 3,
    VSB_VOLKSWAGEN_TOURAN         = 4,
    VSB_VOLKSWAGEN_SANTANA        = 5,
    VSB_VOLKSWAGEN_SANTANA2000    = 6,
    VSB_VOLKSWAGEN_SANTANA3000    = 7,
    VSB_VOLKSWAGEN_VISTA          = 8,
    VSB_VOLKSWAGEN_PASSAT         = 9,
    VSB_VOLKSWAGEN_PASSATLINGYU   = 10,
    VSB_VOLKSWAGEN_POLO           = 11,
    VSB_VOLKSWAGEN_POLOCROSS      = 12,
    VSB_VOLKSWAGEN_POLOGTI        = 13,
    VSB_VOLKSWAGEN_SAGITAR        = 14,
    VSB_VOLKSWAGEN_MAGOTAN        = 15,
    VSB_VOLKSWAGEN_JETTA          = 16,
    VSB_VOLKSWAGEN_BORA           = 17,
    VSB_VOLKSWAGEN_NEWGOLF        = 18,
    VSB_VOLKSWAGEN_GOLFGTI        = 19,
    VSB_VOLKSWAGEN_GOL            = 20,
    VSB_VOLKSWAGEN_CADDY          = 21,
    VSB_VOLKSWAGEN_PHAETON        = 22,
    VSB_VOLKSWAGEN_TOUREG         = 23,
    VSB_VOLKSWAGEN_SCIROCCO       = 24,
    VSB_VOLKSWAGEN_BEETLE         = 25,
    VSB_VOLKSWAGEN_SHARAN         = 26,
    VSB_VOLKSWAGEN_MULTIVAN       = 27,
    VSB_VOLKSWAGEN_CARBONCOPY     = 28,
    VSB_VOLKSWAGEN_VISTACHANGDA   = 29,
    VSB_VOLKSWAGEN_BORASPORTLINE  = 30,
    VSR_VOLKSWAGEN_CC_1             =31,
    VSR_VOLKSWAGEN_Cross_POLO_1     = 32,
    VSR_VOLKSWAGEN_Cross_POLO_2     = 33,
    VSR_VOLKSWAGEN_MULTIVAN_1       = 34,
    VSR_VOLKSWAGEN_POLO_1           = 35,
    VSR_VOLKSWAGEN_POLO_2           = 36,
    VSR_VOLKSWAGEN_POLO_JINQU_1     = 37,
    VSR_VOLKSWAGEN_POLO_JINQU_2     = 38,
    VSR_VOLKSWAGEN_Tiguan_1         = 39,
    VSR_VOLKSWAGEN_Tiguan_2         = 40,
    VSR_VOLKSWAGEN_XIALANG_1        = 41,
    VSR_VOLKSWAGEN_BAOLAI_1         = 42,
    VSR_VOLKSWAGEN_BAOLAI_2         = 43,
    VSR_VOLKSWAGEN_BAOLAI_3         = 44,
    VSR_VOLKSWAGEN_BAOLAI_4         = 45,
    VSR_VOLKSWAGEN_SHANGKU_1        = 46,
    VSR_VOLKSWAGEN_PASATE_1         = 47,
    VSR_VOLKSWAGEN_PASATE_2         = 48,
    VSR_VOLKSWAGEN_PASATE_3         = 49,
    VSR_VOLKSWAGEN_PASATE_4         = 50,
    VSR_VOLKSWAGEN_PASATE_5         = 51,
    VSR_VOLKSWAGEN_JIEDA_1          = 52,
    VSR_VOLKSWAGEN_JIEDA_2          = 53,
    VSR_VOLKSWAGEN_JIEDA_3          = 54,
    VSR_VOLKSWAGEN_JIEDA_4          = 55,
    VSR_VOLKSWAGEN_LANGYI_1         = 56,
    VSR_VOLKSWAGEN_LANGYI_2         = 57,
    VSR_VOLKSWAGEN_SANGTANA_1       = 58,
    VSR_VOLKSWAGEN_SANGTANA_2       = 59,
    VSR_VOLKSWAGEN_SANGTANA_3       = 60,
    VSR_VOLKSWAGEN_SANGTANA_4       = 61,
    VSR_VOLKSWAGEN_SANGTANAZHIJUN_1 = 62,
    VSR_VOLKSWAGEN_SANGTANAZHIJUN_2 = 63,
    VSR_VOLKSWAGEN_JIAKECHONG_1     = 64,
    VSR_VOLKSWAGEN_JIAKECHONG_2     = 65,
    VSR_VOLKSWAGEN_HUITENG_2        = 66,
    VSR_VOLKSWAGEN_MAITENG_1        = 67,
    VSR_VOLKSWAGEN_MAITENG_2        = 68,
    VSR_VOLKSWAGEN_TUAN_3           = 69,
    VSR_VOLKSWAGEN_TUAN_1           = 70,
    VSR_VOLKSWAGEN_TUAN_2           = 71,
    VSR_VOLKSWAGEN_TUGUAN_1         = 72,
    VSR_VOLKSWAGEN_TURUI_1          = 73,
    VSR_VOLKSWAGEN_TURUI_2          = 74,
    VSR_VOLKSWAGEN_SUTENG_1         = 75,
    VSR_VOLKSWAGEN_SUTENG_2         = 76,
    VSR_VOLKSWAGEN_SUTENG_3         = 77,
    VSR_VOLKSWAGEN_GAOERFU_1        = 78,
    VSR_VOLKSWAGEN_GAOERFU_2        = 79,
    VSR_VOLKSWAGEN_GAOERFU_3        = 80,
    VSR_VOLKSWAGEN_LANGYI_3         = 81,
    VSR_VOLKSWAGEN_HUITENG_1        = 82
} VSB_VOLKSWAGEN_CLASS;


typedef enum _VBR_BUICK_CLASS
{
    VBR_BUICK_OTHER        = 0,
    VBR_BUICK_ENCORE       = 1,
    VBR_BUICK_GL8          = 2,
    VBR_BUICK_LEGAL        = 3,
    VBR_BUICK_LACROSS      = 4,
    VBR_BUICK_EXCELLE      = 5,
    VBR_BUICK_EXCELLEGT    = 6,
    VBR_BUICK_WXCELLEXT    = 7,
    VBR_BUICK_ENCLAVE      = 8,
    VBR_BUICK_ROYAUM       = 9,
    VBR_BUICK_SAIL         = 10,
    VBR_BUICK_EXCELLEHRV   = 11,
    VBR_BUICK_PARKAVENUE   = 12,
    VBR_BUICK_CENTURY      = 13,
    VBR_BUICK_GL8_1          = 14,
    VBR_BUICK_GL8_2          = 15,
    VBR_BUICK_GL8_3          = 16,
    VBR_BUICK_GL8_4          = 17,
    VBR_BUICK_GL8_5          = 18,
    VBR_BUICK_ENCORE_1       = 19,
    VBR_BUICK_ENCLAVE_1      = 20,
    VBR_BUICK_LEGAL_1        = 21,
    VBR_BUICK_LEGAL_2        = 22,
    VBR_BUICK_LEGAL_3        = 23,
    VBR_BUICK_LEGAL_4        = 24,
    VBR_BUICK_LEGAL_5        = 25,
    VBR_BUICK_LEGAL_6        = 26,
    VBR_BUICK_LACROSS_1      = 27,
    VBR_BUICK_LACROSS_2      = 28,
    VBR_BUICK_LACROSS_3      = 29,
    VBR_BUICK_EXCELLE_1      = 30,
    VBR_BUICK_EXCELLE_2      = 31,
    VBR_BUICK_EXCELLE_3      = 32,
    VBR_BUICK_EXCELLE_4      = 33,
    VBR_BUICK_PARKAVENUE_1   = 34,
    VBR_BUICK_SAIL_1         = 35,
    VBR_BUICK_EXCELLEGT_1    = 36,
    VBR_BUICK_WXCELLEXT_1    = 37,
    VBR_BUICK_CENTURY_1      = 38,
    VBR_BUICK_RONGYU_1       = 39
}VBR_BUICK_CLASS;


typedef enum _VSB_BMW_CLASS
{
    VSB_BMW_OTHER       = 0,
    VSB_BMW_3SERIES     = 1,
    VSB_BMW_5SERIES     = 2,
    VSB_BMW_X1          = 3,
    VSB_BMW_1SERIES     = 4,
    VSB_BMW_7SERIES     = 5,
    VSB_BMW_X3          = 6,
    VSB_BMW_X5          = 7,
    VSB_BMW_X6          = 8,
    VSB_BMW_Z4          = 9,
    VSB_BMW_MINI        = 10,
    VSB_BMW_6SERIES     = 11,
    VSB_BMW_YIXI_1      = 12,
    VSB_BMW_YIXI_2      = 13,
    VSB_BMW_SANXI_1     = 14,
    VSB_BMW_SANXI_2     = 15,
    VSB_BMW_SANXI_3     = 16,
    VSB_BMW_SANXI_4     = 17,
    VSB_BMW_WUXI_1      = 18,
    VSB_BMW_WUXI_2      = 19,
    VSB_BMW_LIUXI_1     = 20,
    VSB_BMW_QIXI_1      = 21,
    VSB_BMW_QIXI_2      = 22,
    VSB_BMW_X1_1        = 23,
    VSB_BMW_X1_2        = 24,
    VSB_BMW_X3_1        = 25,
    VSB_BMW_X3_2        = 26,
    VSB_BMW_X5_1        = 27,
    VSB_BMW_X5_2        = 28,
    VSB_BMW_X5_3        = 29,
    VSB_BMW_X6_1        = 30,
    VSB_BMW_Z4_1        = 31
}VSB_BMW_CLASS;


typedef enum _VSB_HONDA_CLASS
{
    VSB_HONDA_OTHER       = 0,
    VSB_HONDA_CRV         = 1,
    VSB_HONDA_JADE        = 2,
    VSB_HONDA_CIVIC       = 3,
    VSB_HONDA_SPIRIOR     = 4,
    VSB_HONDA_CIIMO       = 5,
    VSB_HONDA_ELYSION     = 6,
    VSB_HONDA_OBYSSEY     = 7,
    VSB_HONDA_FIT         = 8,
    VSB_HONDA_NEWCITY     = 9,
    VSB_HONDA_CROSSTOUR   = 10,
    VSB_HONDA_CRIDER      = 11,
    VSB_HONDA_ACCORD      = 12,
    VSB_HONDA_CITY        = 13,
    VSB_HONDA_ANTILOCK    = 14,
    VSB_HONDA_CRZ         = 15,
    VSB_HONDA_CRV_1       = 16,
    VSB_HONDA_CRV_2       = 17,
    VSB_HONDA_CRV_3       = 18,
    VSB_HONDA_CRV_4       = 19,
    VSB_HONDA_CRV_5       = 20,
    VSB_HONDA_CRIDER_1    = 21,
    VSB_HONDA_OBYSSEY_1   = 22,
    VSB_HONDA_OBYSSEY_2   = 23,
    VSB_HONDA_OBYSSEY_3   = 24,
    VSB_HONDA_OBYSSEY_4   = 25,
    VSB_HONDA_CIVIC_1     = 26,
    VSB_HONDA_CIVIC_5     = 27,
    VSB_HONDA_CIVIC_2     = 28,
    VSB_HONDA_CIVIC_3     = 29,
    VSB_HONDA_CIVIC_4     = 30,
    VSB_HONDA_CITY_1      = 31,
    VSB_HONDA_SPIRIOR_1   = 32,
    VSB_HONDA_SIMING_1    = 33,
    VSB_HONDA_JIEDE_1     = 34,
    VSB_HONDA_CROSSTOUR_1 = 35,
    VSB_HONDA_AILISHEN_1  = 36,
    VSB_HONDA_NEWCITY_1   = 37,
    VSB_HONDA_NEWCITY_2   = 38,
    VSB_HONDA_NEWCITY_3   = 39,
    VSB_HONDA_ACCORD_1    = 40,
    VSB_HONDA_ACCORD_2    = 41,
    VSB_HONDA_ACCORD_3    = 42,
    VSB_HONDA_ACCORD_4    = 43,
    VSB_HONDA_ACCORD_5    = 44,
    VSB_HONDA_ACCORD_6    = 45,
    VSB_HONDA_ACCORD_7    = 46,
    VSB_HONDA_ACCORD_8    = 47,
    VSB_HONDA_ACCORD_9    = 48,
    VSB_HONDA_ACCORD_10   = 49,
    VSB_HONDA_FIT_1       = 50,
    VSB_HONDA_FIT_2       = 51,
    VSB_HONDA_FIT_3       = 52,
    VSB_HONDA_FIT_4       = 53,
    VSB_HONDA_FIT_5       = 54,
    VSB_HONDA_FIT_6       = 55
}VSB_HONDA_CLASS;


typedef enum _VSB_PEUGEOT_CLASS
{
    VSB_PEUGEOT_OTHER      = 0,
    VSB_PEUGEOT_2008       = 1,
    VSB_PEUGEOT_207        = 2,
    VSB_PEUGEOT_SENNA      = 3,
    VSB_PEUGEOT_3008       = 4,
    VSB_PEUGEOT_301        = 5,
    VSB_PEUGEOT_307        = 6,
    VSB_PEUGEOT_308        = 7,
    VSB_PEUGEOT_408        = 8,
    VSB_PEUGEOT_508        = 9,
    VSB_PEUGEOT_206        = 10,
    VSB_PEUGEOT_407        = 11,
    VSB_PEUGEOT_206_1      = 12,
    VSB_PEUGEOT_207_1      = 13,
    VSB_PEUGEOT_207_2      = 14,
    VSB_PEUGEOT_3008_1     = 15,
    VSB_PEUGEOT_301_1      = 16,
    VSB_PEUGEOT_307_1      = 17,
    VSB_PEUGEOT_307_2      = 18,
    VSB_PEUGEOT_307_3      = 19,
    VSB_PEUGEOT_308_1      = 20,
    VSB_PEUGEOT_407_1      = 21,
    VSB_PEUGEOT_408_1      = 22,
    VSB_PEUGEOT_408_2      = 23,
    VSB_PEUGEOT_508_1      = 24,
    VSB_PEUGEOT_207_3      = 25,
    VSB_PEUGEOT_307_4      = 26

}VSB_PEUGEOT_CLASS;


typedef enum _VSB_TOYOTA_CLASS
{
    VSB_TOYOTA_OTHER            = 0,
    VSB_TOYOTA_HIGHLANDER       = 1,
    VSB_TOYOTA_CAMRY            = 2,
    VSB_TOYOTA_YARIS            = 3,
    VSB_TOYOTA_YARISL           = 4,
    VSB_TOYOTA_VERSO            = 5,
    VSB_TOYOTA_HUAGUAN          = 6,
    VSB_TOYOTA_CROWN            = 7,
    VSB_TOYOTA_COROLLA          = 8,
    VSB_TOYOTA_COSTER           = 9,
    VSB_TOYOTA_PRADO            = 10,
    VSB_TOYOTA_PRIUS            = 11,
    VSB_TOYOTA_RAV4             = 12,
    VSB_TOYOTA_REZI             = 13,
    VSB_TOYOTA_VIOS             = 14,
    VSB_TOYOTA_PREVIA           = 15,
    VSB_TOYOTA_HIACE            = 16,
    VSB_TOYOTA_86               = 17,
    VSB_TOYOTA_SPEQUOIA         = 18,
    VSB_TOYOTA_LANDCRUISER      = 19,
    VSB_TOYOTA_SIENNA           = 20,
    VSB_TOYOTA_CAMRYHYBRID      = 21,
    VSB_TOYOTA_GRACE            = 22,
    VSB_TOYOTA_ALPHARD          = 23,
    VSB_TOYOTA_RAV4_1           = 24,
    VSB_TOYOTA_RAV4_2           = 25,
    VSB_TOYOTA_86_1             = 26,
    VSB_TOYOTA_JIAMEI_2         = 27,
    VSB_TOYOTA_JIAMEI_3         = 28,
    VSB_TOYOTA_LANDEKLZ_1       = 29,
    VSB_TOYOTA_KAIMEIRUI_1      = 30,
    VSB_TOYOTA_KAIMEIRUI_2      = 31,
    VSB_TOYOTA_KAIMEIRUI_3      = 32,
    VSB_TOYOTA_KAIMEIRUI_4      = 33,
    VSB_TOYOTA_KAIMEIRUI_5      = 34,
    VSB_TOYOTA_KAIMEIRUI_6      = 35,
    VSB_TOYOTA_KALUOLA_1        = 36,
    VSB_TOYOTA_KALUOLA_2        = 37,
    VSB_TOYOTA_AIERFA_1         = 38,
    VSB_TOYOTA_AIERFA_2         = 39,
    VSB_TOYOTA_WEICHI_1         = 40,
    VSB_TOYOTA_WEICHI_2         = 41,
    VSB_TOYOTA_WEICHI_3         = 42,
    VSB_TOYOTA_WEICHI_4         = 43,
    VSB_TOYOTA_WEICHI_5         = 44,
    VSB_TOYOTA_PULADUO_1        = 45,
    VSB_TOYOTA_PULADUO_2        = 46,
    VSB_TOYOTA_PULADUO_3        = 47,
    VSB_TOYOTA_PURUIWEIYA_1     = 48,
    VSB_TOYOTA_PURUIWEIYA_4     = 49,
    VSB_TOYOTA_PURUIWEIYA_2     = 50,
    VSB_TOYOTA_PURUIWEIYA_3     = 51,
    VSB_TOYOTA_KESIDA_1         = 52,
    VSB_TOYOTA_KESIDA_2         = 53,
    VSB_TOYOTA_HANLANDA_1       = 54,
    VSB_TOYOTA_HANLANDA_2       = 55,
    VSB_TOYOTA_HANLANDA_3       = 56,
    VSB_TOYOTA_HAISHI_1         = 57,
    VSB_TOYOTA_HUANGGUAN_1      = 58,
    VSB_TOYOTA_HUANGGUAN_2      = 59,
    VSB_TOYOTA_HUANGGUAN_3      = 60,
    VSB_TOYOTA_HUANGGUAN_4      = 61,
    VSB_TOYOTA_HONGSHAN_1       = 62,
    VSB_TOYOTA_HUAGUAN_1        = 63,
    VSB_TOYOTA_HUAGUAN_2        = 64,
    VSB_TOYOTA_HUAGUAN_3        = 65,
    VSB_TOYOTA_YIZHI_1          = 66,
    VSB_TOYOTA_RUIZHI_1         = 67,
    VSB_TOYOTA_RUIZHI_2         = 68,
    VSB_TOYOTA_RUIZHI_3         = 69,
    VSB_TOYOTA_RUIZHI_4         = 70,
    VSB_TOYOTA_LUDIXUNYANG_1    = 71,
    VSB_TOYOTA_YALISHI_1        = 72,
    VSB_TOYOTA_YALISHI_2        = 73,
    VSB_TOYOTA_RAV4_3           = 74,
    VSB_TOYOTA_YARiSL_1         = 75,
    VSB_TOYOTA_JIAMEI_1         = 76,
    VSB_TOYOTA_PLATZ_1          = 77,
    VSB_TOYOTA_LANDEKLZ_2       = 78
}VSB_TOYOTA_CLASS;


typedef enum _VSB_FORD_CLASS
{
    VSB_FORD_OTHER       = 0,
    VSB_FORD_FOCUS       = 1,
    VSB_FORD_FIESTA      = 2,
    VSB_FORD_SMAX        = 3,
    VSB_FORD_MONDEO      = 4,
    VSB_FORD_ECOSPORT    = 5,
    VSB_FORD_ESCAPE      = 6,
    VSB_FORD_ZHISHENG    = 7,
    VSB_FORD_ESCORT      = 8,
    VSB_FORD_EXPLORER    = 9,
    VSB_FORD_EDGE        = 10,
    VSB_FORD_TRANSIT     = 11,
    VSB_FORD_QUANSHUN_1      = 12,
    VSB_FORD_JIANIANHUA_1    = 13,
    VSB_FORD_JIANIANHUA_2    = 14,
    VSB_FORD_JIANIANHUA_3    = 15,
    VSB_FORD_JIANIANHUA_4    = 16,
    VSB_FORD_TANXIANZHE_1    = 17,
    VSB_FORD_FOCUS_1         = 18,
    VSB_FORD_FOCUS_2         = 19,
    VSB_FORD_FOCUS_3         = 20,
    VSB_FORD_FOCUS_4         = 21,
    VSB_FORD_FOCUS_5         = 22,
    VSB_FORD_FOCUS_6         = 23,
    VSB_FORD_YIBO_1          = 24,
    VSB_FORD_YIHU_1          = 25,
    VSB_FORD_MENGDIOU_1      = 26,
    VSB_FORD_MENGDIOU_2      = 27,
    VSB_FORD_MENGDIOU_3      = 28,
    VSB_FORD_MENGDIOU_4      = 29,
    VSB_FORD_MENGDIOU_5      = 30,
    VSB_FORD_MENGDIOU_6      = 31,
    VSB_FORD_RUIJIE_1        = 32,
    VSB_FORD_MAIKESI_1       = 33
}VSB_FORD_CLASS;


typedef enum _VSB_NISSAN_CLASS
{
    VSB_NISSAN_OTHER              = 0,
    VSB_NISSAN_XTRAIL             = 1,
    VSB_NISSAN_MURANO             = 2,
    VSB_NISSAN_LIVINA             = 3,
    VSB_NISSAN_MARCH              = 4,
    VSB_NISSAN_TIIDA              = 5,
    VSB_NISSAN_TEANA              = 6,
    VSB_NISSAN_QASHQAI            = 7,
    VSB_NISSAN_SYLPHY             = 8,
    VSB_NISSAN_SUNNY              = 9,
    VSB_NISSAN_D22PICKUP          = 10,
    VSB_NISSAN_D22VAN             = 11,
    VSB_NISSAN_CABSTAR            = 12,
    VSB_NISSAN_HV200              = 13,
    VSB_NISSAN_PALADIN            = 14,
    VSB_NISSAN_YIDA               = 15,
    VSB_NISSAN_DUCK               = 16,
    VSB_NISSAN_CEFIRO             = 17,
    VSB_NISSAN_FENGSHENBLUEBIRD   = 18,
    VSB_NISSAN_FENGSHENSUNNY      = 19,
    VSB_NISSAN_SUCCE              = 20,
    VSB_NISSAN_FUGA               = 21,
    VSB_NISSAN_BLUEBIRD4          = 22,
    VSB_NISSAN_VENUCIA            = 23,
    VSB_NISSAN_QUEST              = 24,
    VSB_NISSAN_GENISS             = 25,
    VSB_NISSAN_NV200_1            = 26,
    VSB_NISSAN_TIANLAI_1          = 27,
    VSB_NISSAN_TIANLAI_2          = 28,
    VSB_NISSAN_TIANLAI_3          = 29,
    VSB_NISSAN_TIANLAI_4          = 30,
    VSB_NISSAN_TIANLAI_5          = 31,
    VSB_NISSAN_TIANLAI_6          = 32,
    VSB_NISSAN_QIJUN_1            = 33,
    VSB_NISSAN_QIJUN_2            = 34,
    VSB_NISSAN_PALADING_1         = 35,
    VSB_NISSAN_LOULAN_1           = 36,
    VSB_NISSAN_LOULAN_2           = 37,
    VSB_NISSAN_LANNIAO_1          = 38,
    VSB_NISSAN_LANNIAO_2          = 39,
    VSB_NISSAN_LANNIAO_3          = 40,
    VSB_NISSAN_GUISHI_1           = 41,
    VSB_NISSAN_XUANYI_1           = 42,
    VSB_NISSAN_XUANYI_2           = 43,
    VSB_NISSAN_XUANYI_3           = 44,
    VSB_NISSAN_XIAOKE_1           = 45,
    VSB_NISSAN_XIAOKE_2           = 46,
    VSB_NISSAN_SUNNY_3            = 47,
    VSB_NISSAN_SUNNY_1            = 48,
    VSB_NISSAN_SUNNY_2            = 49,
    VSB_NISSAN_YIDA_1             = 50,
    VSB_NISSAN_YIDA_2             = 51,
    VSB_NISSAN_FENGDU_1           = 52,
    VSB_NISSAN_FENGYA_1           = 53,
    VSB_NISSAN_LIWEI_1            = 54,
    VSB_NISSAN_LIWEI_2            = 55,
    VSB_NISSAN_LIWEI_3            = 56,
    VSB_NISSAN_LIWEI_4            = 57,
    VSB_NISSAN_JUNYI_1            = 58,
    VSB_NISSAN_QIDA_1             = 59,
    VSB_NISSAN_QIDA_2             = 60,
    VSB_NISSAN_QIDA_3             = 61,
    VSB_NISSAN_RUIQI_1            = 62
}VSB_NISSAN_CLASS;


typedef enum _VSB_AUDI_CLASS
{
    VSB_AUDI_OTHER        = 0,
    VSB_AUDI_A3           = 1,
    VSB_AUDI_A4L          = 2,
    VSB_AUDI_A6L          = 3,
    VSB_AUDI_Q3           = 4,
    VSB_AUDI_Q5           = 5,
    VSB_AUDI_A1           = 6,
    VSB_AUDI_A4           = 7,
    VSB_AUDI_A5           = 8,
    VSB_AUDI_A6           = 9,
    VSB_AUDI_A7           = 10,
    VSB_AUDI_A8L          = 11,
    VSB_AUDI_Q7           = 12,
    VSB_AUDI_S5           = 13,
    VSB_AUDI_TT           = 14,
    VSB_AUDI_100          = 15,
    VSB_AUDI_200          = 16,
    VSB_AUDI_S7           = 17,
    VSB_AUDI_S8           = 18,
    VSB_AUDI_100_1        = 19,
    VSB_AUDI_200_1        = 20,
    VSB_AUDI_A1_1         = 21,
    VSB_AUDI_A3_1         = 22,
    VSB_AUDI_A3_2         = 23,
    VSB_AUDI_A4_1         = 24,
    VSB_AUDI_A4_2         = 25,
    VSB_AUDI_A4L_1        = 26,
    VSB_AUDI_A5_1         = 27,
    VSB_AUDI_A6_1         = 28,
    VSB_AUDI_A6L_1        = 29,
    VSB_AUDI_A6L_2        = 30,
    VSB_AUDI_A6L_3        = 31,
    VSB_AUDI_A7_1         = 32,
    VSB_AUDI_A8L_1        = 33,
    VSB_AUDI_A8L_2        = 34,
    VSB_AUDI_A8L_3        = 35,
    VSB_AUDI_A8L_4        = 36,
    VSB_AUDI_Q3_1         = 37,
    VSB_AUDI_Q5_1         = 38,
    VSB_AUDI_Q5_2         = 39,
    VSB_AUDI_Q5_3         = 40,
    VSB_AUDI_Q5_4         = 41,
    VSB_AUDI_Q7_1         = 42,
    VSB_AUDI_Q7_2         = 43,
    VSB_AUDI_S7_1         = 44,
    VSB_AUDI_S8_1         = 45,
    VSB_AUDI_TT_2         = 46,
    VSB_AUDI_TT_3         = 47,
    VSB_AUDI_TT_4         = 48,
    VSB_AUDI_TT_1         = 49
}VSB_AUDI_CLASS;


typedef enum _VSB_MAZDA_CLASS
{
    VSB_MAZDA_OTHER         = 0,
    VSB_MAZDA_CX5           = 1,
    VSB_MAZDA_2             = 2,
    VSB_MAZDA_3             = 3,
    VSB_MAZDA_6             = 4,
    VSB_MAZDA_8             = 5,
    VSB_MAZDA_COREWING      = 6,
    VSB_MAZDA_CX7           = 7,
    VSB_MAZDA_X5            = 8,
    VSB_MAZDA_5             = 9,
    VSB_MAZDA_PREMACY       = 10,
    VSB_MAZDA_MPV           = 11,
    VSB_MAZDA_CX5_1         = 12,
    VSB_MAZDA_CX7_1         = 13,
    VSB_MAZDA_2_1           = 14,
    VSB_MAZDA_3_1           = 15,
    VSB_MAZDA_3_2           = 16,
    VSB_MAZDA_3_3           = 17,
    VSB_MAZDA_3_4           = 18,
    VSB_MAZDA_5_1           = 19,
    VSB_MAZDA_5_2           = 20,
    VSB_MAZDA_6_2           = 21,
    VSB_MAZDA_6_3           = 22,
    VSB_MAZDA_8_1           = 23,
    VSB_MAZDA_PREMACY_1     = 24,
    VSB_MAZDA_PREMACY_2     = 25,
    VSB_MAZDA_COREWING_1    = 26,
    VSB_MAZDA_COREWING_2    = 27,
    VSB_MAZDA_COREWING_3    = 28,
    VSB_MAZDA_2_2           = 29,
    VSB_MAZDA_6_1           = 30,
    VSB_MAZDA_6_4           = 31
}VSB_MAZDA_CLASS;


typedef enum _VSB_CHEVROLET_CLASS
{
    VSB_CHEVROLET_OTHER          = 0,
    VSB_CHEVROLET_NEWAVEO        = 1,
    VSB_CHEVROLET_EPICA          = 2,
    VSB_CHEVROLET_CRUZE          = 3,
    VSB_CHEVROLET_CAPTIVA        = 4,
    VSB_CHEVROLET_MALIBU         = 5,
    VSB_CHEVROLET_SAIL           = 6,
    VSB_CHEVROLET_CAMARO         = 7,
    VSB_CHEVROLET_LECHENG        = 8,
    VSB_CHEVROLET_LOVA           = 9,
    VSB_CHEVROLET_OLDAVEO        = 10,
    VSB_CHEVROLET_SPARK          = 11,
    VSB_CHEVROLET_SAILSRV        = 12,
    VSB_CHEVROLET_LOVA_1         = 13,
    VSB_CHEVROLET_LOVA_2         = 14,
    VSB_CHEVROLET_SPARK_1        = 15,
    VSB_CHEVROLET_SPARK_2        = 16,
    VSB_CHEVROLET_OLDAVEO_1      = 17,
    VSB_CHEVROLET_OLDAVEO_2      = 18,
    VSB_CHEVROLET_EPICA_1        = 19,
    VSB_CHEVROLET_EPICA_3        = 20,
    VSB_CHEVROLET_EPICA_4        = 21,
    VSB_CHEVROLET_EPICA_5        = 22,
    VSB_CHEVROLET_NEWAVEO_1      = 23,
    VSB_CHEVROLET_CAPTIVA_1      = 24,
    VSB_CHEVROLET_CAPTIVA_2      = 25,
    VSB_CHEVROLET_KEMAILUO_1     = 26,
    VSB_CHEVROLET_CRUZE_1        = 27,
    VSB_CHEVROLET_SAIL_1         = 28,
    VSB_CHEVROLET_SAIL_2         = 29,
    VSB_CHEVROLET_MALIBU_1       = 30,
    VSB_CHEVROLET_EPICA_2        = 31
}VSB_CHEVROLET_CLASS;


typedef enum _VSB_CITROEN_CLASS
{
    VSB_CITROEN_OTHER                 = 0,
    VSB_CITROEN_C2                    = 1,
    VSB_CITROEN_C4L                   = 2,
    VSB_CITROEN_C5                    = 3,
    VSB_CITROEN_ELYSEE                = 4,
    VSB_CITROEN_CQUATRELIANGXIANG     = 5,
    VSB_CITROEN_CQUATRESANXIANG       = 6,
    VSB_CITROEN_SAEAPICASSO           = 7,
    VSB_CITROEN_PICASSO               = 8,
    VSB_CITROEN_CTRIOMPHE             = 9,
    VSB_CITROEN_XSARA                 = 10,
    VSB_CITROEN_SHENLONGFUKANG        = 11,
    VSB_CITROEN_CHANGANDS             = 12,
    VSB_CITROEN_C2_1                  = 13,
    VSB_CITROEN_C4L_1                 = 14,
    VSB_CITROEN_C4PICASSO_1           = 15,
    VSB_CITROEN_C5_1                  = 16,
    VSB_CITROEN_CQUATRESANXIANG_1     = 17,
    VSB_CITROEN_CQUATRELIANGXIANG_1   = 18,
    VSB_CITROEN_CTRIOMPHE_1           = 19,
    VSB_CITROEN_FUKANG_1              = 20,
    VSB_CITROEN_ELYSEE_1              = 21,
    VSB_CITROEN_ELYSEE_2              = 22,
    VSB_CITROEN_SAEAPICASSO_1         = 23
}VSB_CITROEN_CLASS;


typedef enum _VSB_HYUNDAI_CLASS
{
    VSB_HYUNDAI_OTHER            = 0,
    VSB_HYUNDAI_IX35             = 1,
    VSB_HYUNDAI_LANGDONG         = 2,
    VSB_HYUNDAI_MOINCA           = 3,
    VSB_HYUNDAI_SHENGDA          = 4,
    VSB_HYUNDAI_VERNA            = 5,
    VSB_HYUNDAI_RUIYI            = 6,
    VSB_HYUNDAI_SONATAEIGHT      = 7,
    VSB_HYUNDAI_TUCSON           = 8,
    VSB_HYUNDAI_YUEDONG          = 9,
    VSB_HYUNDAI_ELANTRA          = 10,
    VSB_HYUNDAI_GRANDSANTAFE     = 11,
    VSB_HYUNDAI_COUPE            = 12,
    VSB_HYUNDAI_MATRIX           = 13,
    VSB_HYUNDAI_ACCENT           = 14,
    VSB_HYUNDAI_IX30             = 15,
    VSB_HYUNDAI_SONATA           = 16,
    VSB_HYUNDAI_REFINE           = 17,
    VSB_HYUNDAI_MISTRA           = 18,
    VSB_HYUNDAI_SONATAYUFENG     = 19,
    VSB_HYUNDAI_SANTAFE          = 20,
    VSB_HYUNDAI_HUIYI            = 21,
    VSB_HYUNDAI_I30_1            = 22,
    VSB_HYUNDAI_IX35_1           = 23,
    VSB_HYUNDAI_YILANTE_1        = 24,
    VSB_HYUNDAI_YILANTE_2        = 25,
    VSB_HYUNDAI_YILANTE_3        = 26,
    VSB_HYUNDAI_SHENGDA_1        = 27,
    VSB_HYUNDAI_MINGTU_1         = 28,
    VSB_HYUNDAI_MINGYU_1         = 29,
    VSB_HYUNDAI_SHENGDAFEI_1     = 30,
    VSB_HYUNDAI_YUXIANG_1        = 31,
    VSB_HYUNDAI_YUXIANG_2        = 32,
    VSB_HYUNDAI_YUEDONG_1        = 33,
    VSB_HYUNDAI_YUEDONG_2        = 34,
    VSB_HYUNDAI_SHENGDA_2        = 35,
    VSB_HYUNDAI_SHENGDA_3        = 36,
    VSB_HYUNDAI_LANGDONG_1       = 37,
    VSB_HYUNDAI_GERUI_1          = 38,
    VSB_HYUNDAI_RUIYI_1          = 39,
    VSB_HYUNDAI_RUINA_1          = 40,
    VSB_HYUNDAI_RUINA_2          = 41,
    VSB_HYUNDAI_RUIFENG_1        = 42,
    VSB_HYUNDAI_SUONATA_1        = 43,
    VSB_HYUNDAI_SUONATA_2        = 44,
    VSB_HYUNDAI_SOUNATA_3        = 45,
    VSB_HYUNDAI_WEILAKESI_1      = 46,
    VSB_HYUNDAI_MEIJIA_1         = 47,
    VSB_HYUNDAI_JINKOUHUIYI_1    = 48,
    VSB_HYUNDAI_TUSHENG_1        = 49,
    VSB_HYUNDAI_TUSHENG_2        = 50,
    VSB_HYUNDAI_TUSHENG_3        = 51,
    VSB_HYUNDAI_KUPAI_1          = 52,
    VSB_HYUNDAI_YASHENTE_1       = 53,
    VSB_HYUNDAI_YASHENTE_2       = 54,
    VSB_HYUNDAI_LINGXIANG_1      = 55,
    VSB_HYUNDAI_FEISI_1          = 56
}VSB_HYUNDAI_CLASS;


typedef enum _VSB_CHERY_CLASS
{
    VSB_CHERY_OTHER        = 0,
    VSB_CHERY_A1           = 1,
    VSB_CHERY_A3           = 2,
    VSB_CHERY_EASTAR       = 3,
    VSB_CHERY_FULWIN       = 4,
    VSB_CHERY_QQ           = 5,
    VSB_CHERY_E5           = 6,
    VSB_CHERY_COWIN        = 7,
    VSB_CHERY_TIGGO        = 8,
    VSB_CHERY_A5           = 9,
    VSB_CHERY_S16          = 10,
    VSB_CHERY_YOUYA        = 11,
    VSB_CHERY_V5           = 12,
    VSB_CHERY_E3           = 13,
    VSB_CHERY_A1_1                = 14,
    VSB_CHERY_A3LIANGXIANG_1      = 15,
    VSB_CHERY_A5_1                = 16,
    VSB_CHERY_QQ_1                = 17,
    VSB_CHERY_QQ_2                = 18,
    VSB_CHERY_QQ_3                = 19,
    VSB_CHERY_QQ_4                = 20,
    VSB_CHERY_QQ_5                = 21,
    VSB_CHERY_DONGFANGZHIZI_1     = 22,
    VSB_CHERY_DONGFANGZHIZI_2     = 23,
    VSB_CHERY_DONGFANGZHIZI_3     = 24,
    VSB_CHERY_YOUYA_1             = 25,
    VSB_CHERY_E3_1                = 26,
    VSB_CHERY_E5_1                = 27,
    VSB_CHERY_QIYUN1_1            = 28,
    VSB_CHERY_QIYUN1_2            = 29,
    VSB_CHERY_QIYUN_1             = 30,
    VSB_CHERY_QIYUN_2             = 31,
    VSB_CHERY_QIYUN2_1            = 32,
    VSB_CHERY_QIYUN2_2            = 33,
    VSB_CHERY_QIYUN3_1            = 34,
    VSB_CHERY_RUIHU_1             = 35,
    VSB_CHERY_RUIHU_2             = 36,
    VSB_CHERY_RUIHU_3             = 37,
    VSB_CHERY_RUIHU_4             = 38,
    VSB_CHERY_RUIHU_5             = 39,
    VSB_CHERY_FENGYUN2SANXIANG_1  = 40,
    VSB_CHERY_AIRUIZE7_1          = 41
}VSB_CHERY_CLASS;


typedef enum _VSB_KIA_CLASS
{
    VSB_KIA_OTHER        = 0,
    VSB_KIA_K2           = 1,
    VSB_KIA_K3           = 2,
    VSB_KIA_K5           = 3,
    VSB_KIA_RIO          = 4,
    VSB_KIA_CERATO       = 5,
    VSB_KIA_SPORTAGER    = 6,
    VSB_KIA_SOUL         = 7,
    VSB_KIA_ZHIPAO       = 8,
    VSB_KIA_CARENS       = 9,
    VSB_KIA_CARNIVAL     = 10,
    VSB_KIA_OPTIMA       = 11,
    VSB_KIA_OPIRUS       = 12,
    VSB_KIA_MAXIMA       = 13,
    VSB_KIA_FORTE        = 14,
    VSB_KIA_SORENTO      = 15,
    VSB_KIA_K2_1         = 16,
    VSB_KIA_K3_1         = 17,
    VSB_KIA_K5_1         = 18,
    VSB_KIA_RUIOU_1      = 19,
    VSB_KIA_QIANLIMA_1   = 20,
    VSB_KIA_QIANLIMA_2   = 21,
    VSB_KIA_JIAHUA_1     = 22,
    VSB_KIA_XINJIALE_1   = 23,
    VSB_KIA_ZHIPAO_1     = 24,
    VSB_KIA_SHIPAO_1     = 25,
    VSB_KIA_SHIPAO_2     = 26,
    VSB_KIA_SHIPAO_3     = 27,
    VSB_KIA_SHIPAO_4     = 28,
    VSB_KIA_FURUIDI_1    = 29,
    VSB_KIA_FURUIDI_2    = 30,
    VSB_KIA_XIUER_1      = 31,
    VSB_KIA_SUOLANTUO_1  = 32,
    VSB_KIA_SUOLANTUO_2  = 33,
    VSB_KIA_SAILATU_1    = 34,
    VSB_KIA_SAILATU_2    = 35,
    VSB_KIA_SAILATU_3    = 36,
    VSB_KIA_YUANJIAN_1   = 37
}VSB_KIA_CLASS;


typedef enum _VSB_BENZ_CLASS
{
    VSB_BENZ_OTHER         = 0,
    VSB_BENZ_C             = 1,
    VSB_BENZ_E             = 2,
    VSB_BENZ_GLK           = 3,
    VSB_BENZ_WEITING       = 4,
    VSB_BENZ_SPRINTER      = 5,
    VSB_BENZ_VIANO         = 6,
    VSB_BENZ_M             = 7,
    VSB_BENZ_CLK           = 8,
    VSB_BENZ_G             = 9,
    VSB_BENZ_GL            = 10,
    VSB_BENZ_R             = 11,
    VSB_BENZ_S             = 12,
    VSB_BENZ_A             = 13,
    VSB_BENZ_SMART         = 14,
    VSB_BENZ_B             = 15,
    VSB_BENZ_SLK           = 16,
    VSB_BENZ_MB100         = 17,
    VSB_BENZ_VITO          = 18,
    VSB_BENZ_CLS           = 19,
    VSB_BENZ_SL            = 20,
    VSB_BENZ_AJI_1         = 21,
    VSB_BENZ_AJI_2         = 22,
    VSB_BENZ_BJI_1         = 23,
    VSB_BENZ_CJI_1         = 24,
    VSB_BENZ_CJI_2         = 25,
    VSB_BENZ_CJI_3         = 26,
    VSB_BENZ_EJI_1         = 27,
    VSB_BENZ_EJI_2         = 28,
    VSB_BENZ_EJI_3         = 29,
    VSB_BENZ_EJI_4         = 30,
    VSB_BENZ_GLKJI_1       = 31,
    VSB_BENZ_GLKJI_2       = 32,
    VSB_BENZ_GLKJI_3       = 33,
    VSB_BENZ_GLJI_1        = 34,
    VSB_BENZ_GLJI_2        = 35,
    VSB_BENZ_GLJI_3        = 36,
    VSB_BENZ_GJI_1         = 37,
    VSB_BENZ_MB100_1       = 38,
    VSB_BENZ_MLJI_1        = 39,
    VSB_BENZ_MLJI_2        = 40,
    VSB_BENZ_MLJI_3        = 41,
    VSB_BENZ_RJI_1         = 42,
    VSB_BENZ_RJI_2         = 43,
    VSB_BENZ_RJI_3         = 44,
    VSB_BENZ_SLKJI_2       = 45,
    VSB_BENZ_SLKJI_3       = 46,
    VSB_BENZ_SLKJI_1       = 47,
    VSB_BENZ_SJI_1         = 48,
    VSB_BENZ_SJI_2         = 49,
    VSB_BENZ_SJI_3         = 50,
    VSB_BENZ_SJI_4         = 51,
    VSB_BENZ_LINGTE_1      = 52,
    VSB_BENZ_WEIYANUO_1    = 53,
    VSB_BENZ_WEIYANUO_2    = 54,
    VSB_BENZ_WEITING_1     = 55,
    VSB_BENZ_KECHE_1       = 56
}VSB_BENZ_CLASS;


typedef enum _VSB_SKODA_CLASS
{
    VSB_SKODA_OTHER            = 0,
    VSB_SKODA_HAORUI           = 1,
    VSB_SKODA_FABIA            = 2,
    VSB_SKODA_OCTAVIA          = 3,
    VSB_SKODA_SUPERB           = 4,
    VSB_SKODA_SPACEBACK        = 5,
    VSB_SKODA_RAPID            = 6,
    VSB_SKODA_YETI             = 7,
    VSB_SKODA_HAORUI_1         = 8,
    VSB_SKODA_MINGRUI_1        = 9,
    VSB_SKODA_MINGRUI_2        = 10,
    VSB_SKODA_MINGRUI_3        = 11,
    VSB_SKODA_XINRUI_1         = 12,
    VSB_SKODA_JINGRUI_1        = 13,
    VSB_SKODA_JINGRUI_2        = 14,
    VSB_SKODA_JINGRUI_3        = 15,
    VSB_SKODA_SUPAI_1          = 16,
    VSB_SKODA_YEDI_1           = 17
}VSB_SKODA_CLASS;


typedef enum _VSB_DONGFENG_CLASS
{
    VSB_DONGFENG_OTHER                 = 0,
    VSB_DONGFENG_JOYEARX5              = 1,
    VSB_DONGFENG_LINGZHI               = 2,
    VSB_DONGFENG_JOYEARX3              = 3,
    VSB_DONGFENG_JOYEAR                = 4,
    VSB_DONGFENG_FENGXINGCM7           = 5,
    VSB_DONGFENG_YUFENG                = 6,
    VSB_DONGFENG_FENGSHENA60           = 7,
    VSB_DONGFENG_FENGSHENS30           = 8,
    VSB_DONGFENG_FENGSHENH30CROSS      = 9,
    VSB_DONGFENG_PICKUP                = 10,
    VSB_DONGFENG_ZHONGXINGMIANBAOCHE   = 11,
    VSB_DONGFENG_XIAOXINGMIANBAOCHE    = 12,
    VSB_DONGFENG_ZHONGXINGVAN          = 13,
    VSB_DONGFENG_QINGXINGXIANGSHIVAN   = 14,
    VSB_DONGFENG_QINGZHONGXINGVAN      = 15,
    VSB_DONGFENG_FENGSHENMERCURY       = 16,
    VSB_DONGFENG_SUCCE                 = 17,
    VSB_DONGFENG_ODIN                  = 18,
    VSB_DONGFENG_YUMSUN                = 19,
    VSB_DONGFENG_RUIQI                 = 20,
    VSB_DONGFENG_FENGGUANG             = 21,
    VBR_DONGFENG_C35_1                 = 22,
    VBR_DONGFENG_K07_1                 = 23,
    VBR_DONGFENG_K07_2                 = 24,
    VBR_DONGFENG_V21_1                 = 25,
    VBR_DONGFENG_JIALONG_1             = 26,
    VBR_DONGFENG_XKFG_1                = 27,
    VBR_DONGFENG_CV03_1                = 28,
    VBR_DONGFENG_KAIPUTE_1             = 29,
    VBR_DONGFENG_DUOLIKA_1             = 30,
    VBR_DONGFENG_DUOLIKA_2             = 31,
    VBR_DONGFENG_DUOLIKA_3             = 32,
    VBR_DONGFENG_TIANJIN_1             = 33,
    VBR_DONGFENG_TIANJIN_2             = 34,
    VBR_DONGFENG_XBW_1                 = 35,
    VBR_DONGFENG_XBW_2                 = 36,
    VBR_DONGFENG_MENGKA_1              = 37,
    VBR_DONGFENG_FURUIKA_1             = 38,
    VBR_DONGFENG_RUIQI_1               = 39,
    VBR_DONGFENG_A60_1                 = 40,
    VBR_DONGFENG_H30_1                 = 41,
    VBR_DONGFENG_H30_2                 = 42,
    VBR_DONGFENG_H30_3                 = 43,
    VBR_DONGFENG_JINGYI_1              = 44,
    VBR_DONGFENG_JINGYI_2              = 45,
    VBR_DONGFENG_JINGYI_3              = 46,
    VBR_DONGFENG_LINGZHI_1             = 47,
    VBR_DONGFENG_LINGZHI_2             = 48,
    VBR_DONGFENG_LINGZHI_3             = 49,
    VBR_DONGFENG_LINGZHI_4             = 50,
    VBR_DONGFENG_LINGZHI_5             = 51
}VSB_DONGFENG_CLASS;


typedef enum _VSB_BYD_CLASS
{
    VSB_BYD_OTHER         = 0,
    VSB_BYD_F0            = 1,
    VSB_BYD_F3            = 2,
    VSB_BYD_F3R           = 3,
    VSB_BYD_F6            = 4,
    VSB_BYD_G3            = 5,
    VSB_BYD_G3R           = 6,
    VSB_BYD_G6            = 7,
    VSB_BYD_L3            = 8,
    VSB_BYD_M6            = 9,
    VSB_BYD_S6            = 10,
    VSB_BYD_SURUI         = 11,
    VSB_BYD_FOLEL         = 12,
    VSB_BYD_SIRUI         = 13,
    VSB_BYD_MT5           = 14,
    VSB_BYD_F0_1          = 15,
    VSB_BYD_F3R_1         = 16,
    VSB_BYD_F6_1          = 17,
    VSB_BYD_G3R_1         = 18,
    VSB_BYD_G6_1          = 19,
    VSB_BYD_L3_1          = 20,
    VSB_BYD_M6_1          = 21,
    VSB_BYD_S6_1          = 22,
    VSB_BYD_FULAIER_1     = 23,
    VSB_BYD_SURUI_1       = 24
}VSB_BYD_CLASS;


typedef enum _VSB_SUZUKI_CLASS
{
    VSB_SUZUKI_OTHER           = 0,
    VSB_SUZUKI_ALTO            = 1,
    VSB_SUZUKI_SCROSS          = 2,
    VSB_SUZUKI_SWIFT           = 3,
    VSB_SUZUKI_SX4             = 4,
    VSB_SUZUKI_LINGYANG        = 5,
    VSB_SUZUKI_BEIDOUXING      = 6,
    VSB_SUZUKI_LIANAA6         = 7,
    VSB_SUZUKI_LANDY           = 8,
    VSB_SUZUKI_SPLASH          = 9,
    VSB_SUZUKI_GRANDVITARA     = 10,
    VSB_SUZUKI_JIMNY           = 11,
    VSB_SUZUKI_KAZASHI         = 12,
    VSB_SUZUKI_LIANA           = 13,
    VSB_SUZUKI_LIANA_1           = 14,
    VSB_SUZUKI_LIANA_2           = 15,
    VSB_SUZUKI_BEIDOUXING_1      = 16,
    VSB_SUZUKI_BEIDOUXING_2      = 17,
    VSB_SUZUKI_BEIDOUXING_3      = 18,
    VSB_SUZUKI_BEIDOUXING_4      = 19,
    VSB_SUZUKI_JIMUNI_1          = 20,
    VSB_SUZUKI_JIMUNI_2          = 21,
    VSB_SUZUKI_SX4_1             = 22,
    VSB_SUZUKI_SX4_2             = 23,
    VSB_SUZUKI_SX4_3             = 24,
    VSB_SUZUKI_SX4_4             = 25,
    VSB_SUZUKI_SX4_5             = 26,
    VSB_SUZUKI_ALTO_1            = 27,
    VSB_SUZUKI_ALTO_2            = 28,
    VSB_SUZUKI_ALTO_3            = 29,
    VSB_SUZUKI_ALTO_4            = 30,
    VSB_SUZUKI_SPLASH_1          = 31,
    VSB_SUZUKI_LANDY_1           = 32,
    VSB_SUZUKI_LINGYANG_2        = 33,
    VSB_SUZUKI_LINGYANG_3        = 34,
    VSB_SUZUKI_LINGYANG_4        = 35,
    VSB_SUZUKI_LINGYANG_5        = 36,
    VSB_SUZUKI_GRANDVITARA_1     = 37,
    VSB_SUZUKI_FENGYU_1          = 38,
    VSB_SUZUKI_SWIFT_1           = 39,
    VSB_SUZUKI_SWIFT_2           = 40,
    VSB_SUZUKI_KINGCHANG_1       = 41,
    VSB_SUZUKI_LINGYANG_1        = 42
}VSB_SUZUKI_CLASS;


typedef enum _VSB_SGMW_CLASS
{
    VSB_SGMW_OTHER               = 0,
    VSB_SGMW_HONGGUANG           = 1,
    VSB_SGMW_HONGGUANGS          = 2,
    VSB_SGMW_ZHIGUANG            = 3,
    VSB_SGMW_RONGGUANGS          = 4,
    VSB_SGMW_RONGGUANG           = 5,
    VSB_SGMW_HONGTU              = 6,
    VSB_SGMW_XINGWANG            = 7,
    VSB_SGMW_YANGGUANG           = 8,
    VSB_SGMW_XIAOXUANFENG        = 9,
    VSB_SGMW_WULINGZHIGUANG_1    = 10,
    VSB_SGMW_WULINGZHIGUANG_2    = 11,
    VSB_SGMW_WULINGZHIGUANG_3    = 12,
    VSB_SGMW_XINGWANG_1          = 13,
    VSB_SGMW_XINGWANG_2          = 14,
    VSB_SGMW_XINGWANG_3          = 15,
    VSB_SGMW_HONNGUANG_1         = 16,
    VSB_SGMW_HONNGUANG_2         = 17,
    VSB_SGMW_XIAOXUANFENG_1      = 18,
    VSB_SGMW_YANGGUANG_1         = 19,
    VSB_SGMW_YANGGUANG_2         = 20,
    VSB_SGMW_YANGGUANG_3         = 21,
    VSB_SGMW_RONGGUANG_1         = 22,
    VSB_SGMW_RONGGUANG_2         = 23,
    VSB_SGMW_HONGTU_1            = 24
}VSB_SGMW_CLASS;


typedef enum _VSB_CHANA_CLASS
{
    VSB_CHANA_OTHER                = 0,
    VSB_CHANA_HONOR                = 1,
    VSB_CHANA_XINGKA               = 2,
    VSB_CHANA_ZHIXING              = 3,
    VSB_CHANA_PICKUP               = 4,
    VSB_CHANA_ZHIXING2             = 5,
    VSB_CHANA_TAURUS               = 6,
    VSB_CHANA_XINGGUANG            = 7,
    VSB_CHANA_BENNI                = 8,
    VSB_CHANA_ALSVIN               = 9,
    VSB_CHANA_CX20                 = 10,
    VSB_CHANA_CX30                 = 11,
    VSB_CHANA_EADO                 = 12,
    VSB_CHANA_ZHIXINGS460          = 13,
    VSB_CHANA_CM8                  = 14,
    VSB_CHANA_XINBAO               = 15,
    VSB_CHANA_XUNLONG              = 16,
    VSB_CHANA_YUNTONG              = 17,
    VSB_CHANA_LEIMENG              = 18,
    VSB_CHANA_XINGYUN              = 19,
    VSB_CHANA_OULIWEI              = 20,
    VSB_CHANA_EADOXT               = 21,
    VSB_CHANA_XINGYUN_1            = 22,
    VSB_CHANA_OULIWEI_1            = 23,
    VSB_CHANA_YUNTONG_1            = 24,
    VSB_CHANA_TAURUS_1             = 25,
    VSB_CHANA_LEIMENG_1            = 26,
    VSB_CHANA_ZHIXING_1            = 27,
    VSB_CHANA_ZHIXING_2            = 28,
    VSB_CHANA_ZHIXING_3            = 29,
    VSB_CHANA_ZHIXING_4            = 30,
    VSB_CHANA_ZHIXING_5            = 31,
    VSB_CHANA_ZHIXING_6            = 32,
    VSB_CHANA_PICKUP_1             = 33,
    VSB_CHANA_XINGGUANG_1          = 34,
    VSB_CHANA_XINGGUANG_2          = 35,
    VSB_CHANA_HONOR_1              = 36
}VSB_CHANA_CLASS;


typedef enum _VSB_EADO_CLASS
{
    VSB_EADO_OTHER                = 0,
    VSB_EADO_CS_1                 = 1,
    VSB_EADO_CX_1                 = 2,
    VSB_EADO_CX_2                 = 3,
    VSB_EADO_BENBEN_1             = 4,
    VSB_EADO_BENBEN_2             = 5,
    VSB_EADO_BENBEN_3             = 6,
    VSB_EADO_BENBEN_4             = 7,
    VSB_EADO_BENBEN_5             = 8,
    VSB_EADO_YUEXIANG_1           = 9,
    VSB_EADO_YUEXIANG_2           = 10,
    VSB_EADO_YUEXIANG_3           = 11,
    VSB_EADO_YUEXIANG_4           = 12,
    VSB_EADO_YIDONG_1             = 13
}VSB_EADO_CLASS;


typedef enum _VSB_JINBEI_CLASS
{
    VSB_JINBEI_OTHER           = 0,
    VSB_JINBEI_GRACE           = 1,
    VSB_JINBEI_HIACE           = 2,
    VSB_JINBEI_HAIXING         = 3,
    VSB_JINBEI_BADAO           = 4,
    VSB_JINBEI_LINGQI          = 5,
    VSB_JINBEI_JINQI           = 6,
    VSB_JINBEI_LINGCHI         = 7,
    VSB_JINBEI_QIYUN           = 8,
    VSB_JINBEI_ZHISHANG_1      = 9,
    VSB_JINBEI_HAIXING_1       = 10,
    VSB_JINBEI_HAIXING_2       = 11,
    VSB_JINBEI_HIACE_1         = 12,
    VSB_JINBEI_HIACE_2         = 13,
    VSB_JINBEI_HIACE_3         = 14,
    VSB_JINBEI_JINDIAN_1       = 15,
    VSB_JINBEI_GRACE_1         = 16,
    VSB_JINBEI_GRACE_2         = 17,
    VSB_JINBEI_BADAO_1         = 18

}VSB_JINBEI_CLASS;


typedef enum _VSB_GEELY_CLASS
{
    VSB_GEELY_OTHER              = 0,
    VSB_GEELY_EC7                = 1,
    VSB_GEELY_EC8                = 2,
    VSB_GEELY_SC3                = 3,
    VSB_GEELY_SC5RV              = 4,
    VSB_GEELY_SC6                = 5,
    VSB_GEELY_JINGYING           = 6,
    VSB_GEELY_JINGGANG           = 7,
    VSB_GEELY_SX7                = 8,
    VSB_GEELY_HAOQING            = 9,
    VSB_GEELY_MEIRI              = 10,
    VSB_GEELY_YINGLUNSC7         = 11,
    VSB_GEELY_PANDA              = 12,
    VSB_GEELY_YUANJING           = 13,
    VSB_GEELY_ZIYOUJIAN          = 14
}VSB_GEELY_CLASS;


typedef enum _VSB_MITSUBISHI_CLASS
{
    VSB_MITSUBISHI_OTHER                 = 0,
    VSB_MITSUBISHI_GALANT                = 1,
    VSB_MITSUBISHI_ZINGER                = 2,
    VSB_MITSUBISHI_LANCER                = 3,
    VSB_MITSUBISHI_LANCEREX              = 4,
    VSB_MITSUBISHI_PAJERO                = 5,
    VSB_MITSUBISHI_PAJEROSPORT           = 6,
    VSB_MITSUBISHI_JINGXUANASX           = 7,
    VSB_MITSUBISHI_GRANDIS               = 8,
    VSB_MITSUBISHI_OUTLANDER             = 9,
    VSB_MITSUBISHI_QINXINGYUEYE          = 10,
    VSB_MITSUBISHI_GTO                   = 11,
    VSB_MITSUBISHI_SOVERAN               = 12,
    VSB_MITSUBISHI_LIONVEL               = 13,
    VSB_MITSUBISHI_HAFEISIMBO            = 14,
    VSB_MITSUBISHI_LANCEREX_1            = 15,
    VSB_MITSUBISHI_JINGXUAN_1            = 16,
    VSB_MITSUBISHI_ZINGER_1              = 17,
    VSB_MITSUBISHI_PAJERO_1              = 18,
    VSB_MITSUBISHI_PAJERO_2              = 19,
    VSB_MITSUBISHI_PAJERO_3              = 20,
    VSB_MITSUBISHI_PAJEROSPORT_1         = 21,
    VSB_MITSUBISHI_GALANT_1              = 22,
    VSB_MITSUBISHI_GALANDI_1             = 23,
    VSB_MITSUBISHI_GALANDI_2             = 24,
    VSB_MITSUBISHI_OUTLANDER_1           = 25,
    VSB_MITSUBISHI_OUTLANDER_2           = 26,
    VSB_MITSUBISHI_LINGYUE_1             = 27,
    VSB_MITSUBISHI_LANCER_1              = 28
}VSB_MITSUBISHI_CLASS;


typedef enum _VSB_LEXUS_CLASS
{
    VSB_LEXUS_OTHER             = 0,
    VSB_LEXUS_ES                = 1,
    VSB_LEXUS_CT                = 2,
    VSB_LEXUS_RX                = 3,
    VSB_LEXUS_IS                = 4,
    VSB_LEXUS_LX                = 5,
    VSB_LEXUS_GS                = 6,
    VSB_LEXUS_GX                = 7,
    VSB_LEXUS_LS                = 8,
    VSB_LEXUS_CT_1              = 9,
    VSB_LEXUS_ES_1              = 10,
    VSB_LEXUS_ES_2              = 11,
    VSB_LEXUS_ES_3              = 12,
    VSB_LEXUS_GS_1              = 13,
    VSB_LEXUS_GX_1              = 14,
    VSB_LEXUS_IS_1              = 15,
    VSB_LEXUS_LS_1              = 16,
    VSB_LEXUS_LS_2              = 17,
    VSB_LEXUS_LS_3              = 18,
    VSB_LEXUS_LX_1              = 19,
    VSB_LEXUS_RX_1              = 20,
    VSB_LEXUS_RX_2              = 21,
    VSB_LEXUS_RX_3              = 22
}VSB_LEXUS_CLASS;


typedef enum _VSB_ROEWE_CLASS
{
    VSB_ROEWE_OTHER              = 0,
    VSB_ROEWE_350                = 1,
    VSB_ROEWE_550                = 2,
    VSB_ROEWE_W5                 = 3,
    VSB_ROEWE_950                = 4,
    VSB_ROEWE_750                = 5,
    VSB_ROEWE_350_1              = 6,
    VSB_ROEWE_350_2              = 7,
    VSB_ROEWE_550_1              = 8,
    VSB_ROEWE_750_1              = 9,
    VSB_ROEWE_750_2              = 10,
    VSB_ROEWE_950_1              = 11
}VSB_ROEWE_CLASS;



typedef enum _VSB_HAIMA_CLASS
{
    VSB_HAIMA_OTHER               = 0,
    VSB_HAIMA_PREMARIN            = 1,
    VSB_HAIMA_S7                  = 2,
    VSB_HAIMA_PRINCE              = 3,
    VSB_HAIMA_CUPID               = 4,
    VSB_HAIMA_HATCHBACK           = 5,
    VSB_HAIMA_KNIGHT              = 6,
    VSB_HAIMA_HAPPIN              = 7,
    VSB_HAIMA_FAMILY              = 8,
    VSB_HAIMA_M3                  = 9,
    VSB_HAIMA_CUPID_1             = 10,
    VSB_HAIMA_PREMARIN_1          = 11,
    VSB_HAIMA_PREMARIN_2          = 12,
    VSB_HAIMA_HATCHBACK_1         = 13,
    VSB_HAIMA_HAPPIN_1            = 14,
    VSB_HAIMA_HAPPIN_2            = 15,
    VSB_HAIMA_M3_1                = 16,
    VSB_HAIMA_FAMILY_1            = 17,
    VSB_HAIMA_FAMILY_2            = 18,
    VSB_HAIMA_FAMILY_3            = 19,
    VSB_HAIMA_FAMILY_4            = 20,
    VSB_HAIMA_KNIGHT_1            = 21,
    VSB_HAIMA_KNIGHT_2            = 22,
    VSB_HAIMA_NEWHONGDA_1         = 23,
    VSB_HAIMA_NEWHONDGA_2         = 24,
    VSB_HAIMA_PRINCE_1            = 25,
    VSB_HAIMA_RONGDA_1            = 26

}VSB_HAIMA_CLASS;


typedef enum _VSB_GREATWALL_CLASS
{
    VSB_GREATWALL_OTHER               = 0,
    VSB_GREATWALL_SING                = 1,
    VSB_GREATWALL_SAIJUN              = 2,
    VSB_GREATWALL_HAVAL               = 3,
    VSB_GREATWALL_SAFE                = 4,
    VSB_GREATWALL_SAIKU               = 5,
    VSB_GREATWALL_SAILING             = 6,
    VSB_GREATWALL_KINGDEER            = 7,
    VSB_GREATWALL_DEER                = 8,
    VSB_GREATWALL_WINGLE              = 9,
    VSB_GREATWALL_COOLBEAR            = 10,
    VSB_GREATWALL_LINGAO              = 11,
    VSB_GREATWALL_CROSS               = 12,
    VSB_GREATWALL_GWPERI              = 13,
    VSB_GREATWALL_COWRY               = 14,
    VSB_GREATWALL_M4                  = 15,
    VSB_GREATWALL_LINGAO_1            = 16,
    VSB_GREATWALL_HAVAL_1             = 17,
    VSB_GREATWALL_HAVAL_2             = 18,
    VSB_GREATWALL_HAVAL_3             = 19,
    VSB_GREATWALL_HAVAL_4             = 20,
    VSB_GREATWALL_HAVAL_5             = 21,
    VSB_GREATWALL_HAVAL_6             = 22,
    VSB_GREATWALL_HAVAL_8             = 23,
    VSB_GREATWALL_HAVAL_9             = 24,
    VSB_GREATWALL_HAVAL_10            = 25,
    VSB_GREATWALL_HAVAL_11            = 26,
    VSB_GREATWALL_HAVAL_12            = 27,
    VSB_GREATWALL_CROSS_1             = 28,
    VSB_GREATWALL_CROSS_2             = 29,
    VSB_GREATWALL_JINGLING_1          = 30,
    VSB_GREATWALL_SING_1              = 31,
    VSB_GREATWALL_SAIKU_1             = 32,
    VSB_GREATWALL_SAILING_1           = 33,
    VSB_GREATWALL_DIER_1              = 34,
    VSB_GREATWALL_COOLBEAR_1          = 35,
    VSB_GREATWALL_KINGDEER_1          = 36,
    VSB_GREATWALL_GREATWALL_1         = 37,
    VSB_GREATWALL_GREATWALL_2         = 38,
    VSB_GREATWALL_GREATWALL_3         = 39,
    VSB_GREATWALL_GREATWALL_4         = 40,
    VSB_GREATWALL_GREATWALL_5         = 41,
    VSB_GREATWALL_GREATWALL_6         = 42,
    VSB_GREATWALL_WINGLE_1            = 43,
    VSB_GREATWALL_WINGLE_2            = 44,
    VSB_GREATWALL_HAVAL_7             = 45
}VSB_GREATWALL_CLASS;


typedef enum _VSB_DS_CLASS
{
    VSB_DS_OTHER                      = 0,
    VSB_DS_KUBO_1                     = 1,
    VSB_DS_KUWEI_1                    = 2,
    VSB_DS_KUWEI_2                    = 3
}VSB_DS_CLASS;


typedef enum _VSB_LANDROVER_CLASS
{
    VSB_LANDROVER_OTHER              = 0,
    VSB_LANDROVER_FAXIAN_1           = 1,
    VSB_LANDROVER_FAXIAN_2           = 2,
    VSB_LANDROVER_LANSHENG_1         = 3,
    VSB_LANDROVER_LANSHENG_2         = 4,
    VSB_LANDROVER_LANSHENG_3         = 5,
    VSB_LANDROVER_LANSHENG_4         = 6,
    VSB_LANDROVER_SXZ_1              = 7
}VSB_LANDROVER_CLASS;


typedef enum _VSB_MG_CLASS
{
    VSB_MG_OTHER             = 0,
    VSB_MG_3SW_1             = 1,
    VSB_MG_MG3_1             = 2,
    VSB_MG_MG5_1             = 3,
    VSB_MG_MG6_1             = 4,
    VSB_MG_MG7_1             = 5,
}VSB_MG_CLASS;


typedef enum _VSB_FAW_CLASS
{
    VSB_FAW_OTHER                                       = 0,
    VSB_FAW_501_1                                        = 1,
    VSB_FAW_N3_1                                        = 2,
    VSB_FAW_N3_2                                        = 3,
    VSB_FAW_JIABAO_1                                    = 4,
    VSB_FAW_JIABAO_2                                    = 5,
    VSB_FAW_JIABAO_3                                    = 6,
    VSB_FAW_JIABAO_4                                    = 7,
    VSB_FAW_JIABAO_5                                    = 8,
    VSB_FAW_JIABAO_6                                    = 9,
    VSB_FAW_JIABAO_7                                    = 10,
    VSB_FAW_XIALI_1                                        = 11,
    VSB_FAW_XIALI_2                                        = 12,
    VSB_FAW_XIALI_3                                        = 13,
    VSB_FAW_XIALI_4                                        = 14,
    VSB_FAW_XIALI_5                                        = 15,
    VSB_FAW_XIALI_6                                        = 16,
    VSB_FAW_AOWEI_1                                        = 17,
    VSB_FAW_AOWEI_2                                        = 18,
    VSB_FAW_AOWEI_3                                        = 19,
    VSB_FAW_AOWEI_4                                        = 20,
    VSB_FAW_AOXING_1                                    = 21,
    VSB_FAW_WEILE_1                                        = 22,
    VSB_FAW_WEILE_2                                        = 23,
    VSB_FAW_WEIZI_1                                        = 24,
    VSB_FAW_WEIZHI_1                                    = 25,
    VSB_FAW_WEIZHI_2                                    = 26,
    VSB_FAW_WEIZHI_3                                    = 27,
    VSB_FAW_WEIZHI_4                                    = 28,
    VSB_FAW_WEIZHI_5                                    = 29,
    VSB_FAW_XIAOJIEFANG_1                                = 30,
    VSB_FAW_HANWEI_1                                    = 31,
    VSB_FAW_HANWEI_2                                    = 32,
    VSB_FAW_HANWEI_3                                    = 33,
    VSB_FAW_XINDAWEI_1                                    = 34,
    VSB_FAW_XINHANWEI_1                                    = 35,
    VSB_FAW_SENYA_1                                        = 36,
    VSB_FAW_TENGWEI_1                                    = 37,
    VSB_FAW_JIEFANG_1                                    = 38,
    VSB_FAW_JIEFANG_2                                    = 39,
    VSB_FAW_JIEFANG_3                                    = 40,
    VSB_FAW_JIEFANG_4                                    = 41,
    VSB_FAW_JIEFANG_5                                    = 42,
    VSB_FAW_JIEFANG_6                                    = 43,
    VSB_FAW_SAILONG_1                                    = 44,
    VSB_FAW_JUNWEI_1                                    = 45,
    VSB_FAW_B50_1                                        = 46,
    VSB_FAW_B50_2                                        = 47
}VSB_FAW_CLASS;



typedef enum _VSB_SAICMOTOR_CLASS
{
    VSB_SAICMOTOR_OTHER               = 0,
    VSB_HONGYAN_JIESHI_1              = 1,
    VSB_DATONG_V80_1                  = 2
}VSB_SAICMOTOR_CLASS;


typedef enum _VSB_SOUEAST_CLASS
{
    VSB_SOUEAST_OTHER                 = 0,
    VSB_SOUEAST_V3_1                  = 1,
    VSB_SOUEAST_V3_2                  = 2,
    VSB_SOUEAST_V3_3                  = 3,
    VSB_SOUEAST_V3_4                  = 4,
    VSB_SOUEAST_V5_1                  = 5,
    VSB_SOUEAST_XIWANG_1              = 6,
    VSB_SOUEAST_DELIKA_1              = 7,
    VSB_SOUEAST_DELIKA_2              = 8,
    VSB_SOUEAST_DELIKA_3              = 9,
    VSB_SOUEAST_DELIKA_4              = 10,
    VSB_SOUEAST_LINGSHUAI_1           = 11,
    VSB_SOUEAST_FULIKA_1              = 12,
    VSB_SOUEAST_FULIKA_2              = 13
}VSB_SOUEAST_CLASS;



typedef enum _VSB_ZTE_CLASS
{
    VSB_ZTE_OTHER                     = 0,
    VSB_ZTE_WEIHU_1                   = 1,
    VSB_ZTE_WEIHU_2                   = 2,
    VSB_ZTE_WUXIAN_1                  = 3,
    VSB_ZTE_WUXIAN_2                  = 4
}VSB_ZTE_CLASS;



typedef enum _VSB_ZHONGHUA_CLASS
{
    VSB_ZHONGHUA_OTHER                = 0,
    VSB_ZHONGHUA_H230_1               = 1,
    VSB_ZHONGHUA_H320_1               = 2,
    VSB_ZHONGHUA_H330_1               = 3,
    VSB_ZHONGHUA_H530_1               = 4,
    VSB_ZHONGHUA_V5_1                 = 5,
    VSB_ZHONGHUA_ZUNCHI_1             = 6,
    VSB_ZHONGHUA_ZUNCHI_2             = 7,
    VSB_ZHONGHUA_KUBAO_1              = 8,
    VSB_ZHONGHUA_JUNJIE_1             = 9,
    VSB_ZHONGHUA_JUNJIE_2             = 10,
    VSB_ZHONGHUA_JUNJIECROSS_1        = 11,
    VSB_ZHONGHUA_JUNJIEFRV_1          = 12,
    VSB_ZHONGHUA_JUNJIEFRV_2          = 13,
    VSB_ZHONGHUA_JUNJIEFSV_1          = 14,
    VSB_ZHONGHUA_JUNJIEFSV_2          = 15,
    VSB_ZHONGHUA_JUNJIEFSV_3          = 16
}VSB_ZHONGHUA_CLASS;



typedef enum _VSB_CNHTC_CLASS
{
    VSB_CNHTC_OTHER                   = 0,
    VSB_CNHTC_HOKA_2                  = 1,
    VSB_CNHTC_HOWO_1                  = 2,
    VSB_CNHTC_HOWO_2                  = 3,
    VSB_CNHTC_HOWO_3                  = 4,
    VSB_CNHTC_HOWO_4                  = 5,
    VSB_CNHTC_HOWO_5                  = 6,
    VSB_CNHTC_HOWO_6                  = 7,
    VSB_CNHTC_HOWO_7                  = 8,
    VSB_CNHTC_HOWO_8                  = 9,
    VSB_CNHTC_SITAIERWANG_1           = 10,
    VSB_CNHTC_HAOHAN_1                = 11,
    VSB_CNHTC_HAOYUN_1                = 12,
    VSB_CNHTC_JINWANGZI_1             = 13,
    VSB_CNHTC_HOKA_1                  = 14
}VSB_CNHTC_CLASS;


typedef enum _VSB_ZHONGTONG_CLASS
{
    VSB_ZHONGTONG_OTHER               = 0,
    VSB_ZHONGTONG_KAICHI_1            = 1,
    VSB_ZHONGTONG_LINGYU_1            = 2,
    VSB_ZHONGTONG_LINGXIU_1           = 3,
    VSB_ZHONGTONG_LINGHANG_1          = 4,
    VSB_ZHONGTONG_SHIJI_1             = 5,
    VSB_ZHONGTONG_KAIXUAN_1           = 6,
    VSB_ZHONGTONG_LINGYUN_1           = 7,
    VSB_ZHONGTONG_YANGGUANG_1         = 8
}VSB_ZHONGTONG_CLASS;



typedef enum _VSB_JIULONG_CLASS
{
    VSB_JIULONG_OTHER                 = 0,
    VSB_JIULONG_JIULONGA5_1           = 1,
}VSB_JIULONG_CLASS;


typedef enum _VSB_ZOTYE_CLASS
{
    VSB_ZOTYE_OTHER                  = 0,
    VSB_ZOTYE_2008_2                  = 1,
    VSB_ZOTYE_5008_1                  = 2,
    VSB_ZOTYE_Z300_1                  = 3,
    VSB_ZOTYE_2008_1                  = 4
}VSB_ZOTYE_CLASS;


typedef enum _VSB_NAVECO_CLASS
{
    VSB_NAVECO_OTHER                  = 0,
    VSB_NAVECO_Daily_1                = 1,
    VSB_NAVECO_Power_1                = 2,
    VSB_NAVECO_Turbo_1                = 3,
    VSB_NAVECO_Venice_1               = 4,
    VSB_NAVECO_BAODI_1                = 5,
    VSB_NAVECO_DEYIHUOCHE_1           = 6,
    VSB_NAVECO_DULING_1               = 7
}VSB_NAVECO_CLASS;


typedef enum _VSB_PORSCHE_CLASS
{
    VSB_PORSCHE_OTHER                 = 0,
    VBR_PORSCHE_PANAMERA_1            = 1,
    VBR_PORSCHE_CAYENNE_1             = 2,
}VSB_PORSCHE_CLASS;



typedef enum _VSB_CHRYSLER_CLASS
{
    VSB_CHRYSLER_OTHER                = 0,
    VSB_CHRYSLER_300C_1               = 1,
    VSB_CHRYSLER_PTMANBUZHE_1         = 2,
}VSB_CHRYSLER_CLASS;


typedef enum _VSB_CADILLAC_CLASS
{
    VSB_CADILLAC_OTHER                = 0,
    VSB_CADILLAC_ATS_1                = 1,
    VSB_CADILLAC_CTS_1                = 2,
    VSB_CADILLAC_CTS_3                = 3,
    VSB_CADILLAC_SLS_1                = 4,
    VSB_CADILLAC_SLS_2                = 5,
    VSB_CADILLAC_SRX_1                = 6,
    VSB_CADILLAC_CTS_2                = 7,
    VSB_CADILLAC_KAILEIDE_1           = 8
}VSB_CADILLAC_CLASS;



typedef enum _VSB_KAMA_CLASS
{
    VSB_KAMA_OTHER                    = 0,
    VSB_KAMA_QINGKA_2                 = 1,
    VSB_KAMA_FULAIKA_1                = 2,
    VSB_KAMA_JINYUNKA_1               = 3,
    VSB_KAMA_JUNWEIKA_1               = 4,
    VSB_KAMA_QINGKA_1                 = 5
}VSB_KAMA_CLASS;


typedef enum _VSB_LIFAN_CLASS
{
    VSB_LIFAN_OTHER                   = 0,
    VSB_LIFAN_320_1                   = 1,
    VSB_LIFAN_520_1                   = 2,
    VSB_LIFAN_520_2                   = 3,
    VSB_LIFAN_620_1                   = 4,
    VSB_LIFAN_X60_1                   = 5,
    VSB_LIFAN_FENGSHUN_1              = 6
}VSB_LIFAN_CLASS;



typedef enum _VSB_BEIJING_CLASS
{
    VSB_BEIJING_OTHER                 = 0,
    VSB_BEIJING_E_1                   = 1,
}VSB_BEIJING_CLASS;


typedef enum _VSB_BEIBEN_CLASS
{
    VSB_BEIBEN_OTHER                  = 0,
    VSB_BEIBEN_NG80_1                 = 1,
    VSB_BEIBEN_NG80_2                 = 2,
    VSB_BEIBEN_NG80_3                 = 3,
    VSB_BEIBEN_V3_1                   = 4,
    VSB_BEIBEN_V3_2                   = 5
}VSB_BEIBEN_CLASS;


typedef enum _VSB_BEIFANG_CLASS
{
    VSB_BEIFANG_OTHER                 = 0,
    VSB_BEIFANG_A_1                   = 1
}VSB_BEIFANG_CLASS;



typedef enum _VSB_BAW_CLASS
{
    VSB_BAW_OTHER                     = 0,
    VSB_BAW_YUSHENG007_1              = 1,
    VSB_BAW_QILING_1                  = 2,
    VSB_BAW_LUBA_1                    = 3,
    VSB_BAW_QISHI_1                   = 4
}VSB_BAW_CLASS;


typedef enum _VSB_BQWEIWANG_CLASS
{
    VSB_BQWEIWANG_OTHER               = 0,
    VSB_BQWEIWANG_205_1               = 1,
    VSB_BQWEIWANG_306_1               = 2
}VSB_BQWEIWANG_CLASS;



typedef enum _VSB_SMA_CLASS
{
    VSB_SMA_OTHER                     = 0,
    VSB_SMA_HAIYU_1                   = 1,
    VSB_SMA_HAIYU_2                   = 2,
    VSB_SMA_HAISHANG_1                = 3,
    VSB_SMA_HAIJING_1                 = 5,
    VSB_SMA_HAIXUN_1                  = 4,
    VSB_SMA_HAIXUN_2                  = 6,
}VSB_SMA_CLASS;


typedef enum _VSB_XINGMA_CLASS
{
    VSB_XINGMA_OTHER                  = 0,
    VSB_XINGMA_XINGKAIMA_1            = 1
}VSB_XINGMA_CLASS;


typedef enum _VSB_SHUANGHUAN_CLASS
{
    VSB_SHUANGHUAN_OTHER              = 0,
    VSB_SHUANGHUAN_SCEO_1             = 1,
}VSB_SHUANGHUAN_CLASS;


typedef enum _VSB_JEEP_CLASS
{
    VSB_JEEP_OTHER                    = 0,
    VSB_JEEP_DAQIENUOJI_1             = 1,
    VSB_JEEP_DAQIENUOJI_2             = 2,
    VSB_JEEP_ZHINANZHE_1              = 3,
    VSB_JEEP_ZHINANZHE_2              = 4,
    VSB_JEEP_MUMAREN_1                = 5,
    VSB_JEEP_MUMAREN_2                = 6,
    VSB_JEEP_ZIYOUKE                  = 7,
}VSB_JEEP_CLASS;


typedef enum _VSB_VENUCIA_CLASS
{
    VSB_VENUCIA_OTHER                 = 0,
    VSB_VENUCIA_D50_1                 = 1
}VSB_VENUCIA_CLASS;


typedef enum _VSB_HAFEI_CLASS
{
    VSB_HAFEI_OTHER                   = 0,
    VSB_HAFEI_XINMINYI_1              = 1,
    VSB_HAFEI_XINMINYI_2              = 2,
    VSB_HAFEI_MINYI_1                 = 3,
    VSB_HAFEI_MINYI_2                 = 4,
    VSB_HAFEI_SAIBAO_1                = 5,
    VSB_HAFEI_SAIMA_1                 = 6,
    VSB_HAFEI_SAIMA_2                 = 7,
    VSB_HAFEI_SAIMA_3                 = 8,
    VSB_HAFEI_LUBAO_1                 = 9,
    VSB_HAFEI_LUBAO_2                 = 10,
    VSB_HAFEI_LUBAO_3                 = 11,
    VSB_HAFEI_LUZUNXIAOBAWANG_1       = 12,
    VSB_HAFEI_RUIYI_1                 = 13,
    VSB_HAFEI_JUNYI_1                 = 14
}VSB_HAFEI_CLASS;


typedef enum _VSB_TKING_CLASS
{
    VSB_TKING_OTHER                   = 0,
    VSB_TKING_OUGUAN_1                = 1,
    VSB_TKING_OUGUAN_2                = 2,
    VSB_TKING_OUTENG_1                = 3,
    VSB_TKING_FUXING_1                = 4,
    VSB_TKING_QINGKAWANG_1            = 5,
    VSB_TKING_AFANDA_1                = 6,
    VSB_TKING_JUNQI_1                 = 7
}VSB_TKING_CLASS;


typedef enum _VSB_DAEWOO_CLASS
{
    VSB_DAEWOO_OTHER                  = 0,
    VBR_DAEWOO_6960H3_1               = 1
}VSB_DAEWOO_CLASS;


typedef enum _VSB_DAYUN_CLASS
{
    VSB_DAYUN_OTHER                   = 0,
    VBR_DAYUN_ZHONGKA_1               = 1
}VSB_DAYUN_CLASS;


typedef enum _VSB_BESTURN_CLASS
{
    VSB_BESTURN_OTHER                 = 0,
    VSB_BESTURN_B70_1                 = 1,
    VSB_BESTURN_B70_2                 = 2,
    VSB_BESTURN_B70_3                 = 3,
    VSB_BESTURN_B70_4                 = 4,
    VSB_BESTURN_B90_1                 = 5,
    VSB_BESTURN_AOXING_1              = 6
}VSB_BESTURN_CLASS;


typedef enum _VSB_WEILIN_CLASS
{
    VSB_WEILIN_OTHER                 = 0,
    VSB_WEILIN_H3_1                   = 1,
    VSB_WEILIN_V5_1                   = 2,
    VSB_WEILIN_X5_1                   = 3
}VSB_WEILIN_CLASS;


typedef enum _VSB_YUTONG_CLASS
{
    VSB_YUTONG_OTHER                  = 0,
    VSB_YUTONG_8XI_1                  = 1,
    VSB_YUTONG_KECHE_1                = 2,
    VSB_YUTONG_KECHE_3                = 3,
    VSB_YUTONG_KECHE_4                = 4,
    VSB_YUTONG_KECHE_5                = 5,
    VSB_YUTONG_KECHE_2                = 6
}VSB_YUTONG_CLASS;


typedef enum _VSB_ANKAI_CLASS
{
    VSB_ANKAI_OTHER                   = 0,
    VSB_ANKAI_KECHE_1                 = 1,
    VSB_ANKAI_KECHE_2                 = 2
}VSB_ANKAI_CLASS;


typedef enum _VSB_BAOJUN_CLASS
{
    VSB_BAOJUN_OTHER            = 0,
    VSB_BAOJUN_630_1                  = 1
}VSB_BAOJUN_CLASS;


typedef enum _VSB_BINLI_CLASS
{
    VSB_BINLI_OTHER                   = 0,
    VSB_BINLI_OULU_1                  = 1
}VSB_BINLI_CLASS;


typedef enum _VSB_TRUMPCHE_CLASS
{
    VSB_TRUMPCHE_OTHER                = 0,
    VSB_TRUMPCHE_GA5_1                = 1,
    VSB_TRUMPCHE_GA5_2                = 3,
    VSB_TRUMPCHE_GS5_1                = 2
}VSB_TRUMPCHE_CLASS;


typedef enum _VSB_GONOW_CLASS
{
    VSB_GONOW_OTHER                   = 0,
    VSB_GONOW_G3_1                    = 1,
    VSB_GONOW_G5_1                    = 2,
    VSB_GONOW_SHUAIJIAN_1             = 4,
    VSB_GONOW_XINGWANGM1_1            = 3,
    VSB_GONOW_CAIYUN500_1             = 5
}VSB_GONOW_CLASS;


typedef enum _VSB_ISUZU_CLASS
{
    VSB_ISUZU_OTHER                   = 0,
    VSB_ISUZU_ZHONGXINGSHANGYONG_1    = 1,
    VSB_ISUZU_WUSHILINGPIKA_1         = 2,
    VSB_ISUZU_WUSHILINGPIKA_2         = 3,
    VSB_ISUZU_JINGJIZHE_1             = 4
}VSB_ISUZU_CLASS;



typedef enum _VSB_KARRY_CLASS
{
    VSB_KARRY_OTHER                   = 0,
    VSB_KARRY_YOU_2                   = 1,
    VSB_KARRY_YOUJIN_1                = 2,
    VSB_KARRY_YOUSHENG_1              = 3,
    VSB_KARRY_YOUSHENG_2              = 4,
    VSB_KARRY_YOUYA                   = 5,
    VSB_KARRY_YOU_1                   = 6
}VSB_KARRY_CLASS;


typedef enum _VSB_GAGUAR_CLASS
{
    VSB_GAGUAR_OTHER                  = 0,
    VSB_GAGUAR_XF_1                   = 1,
    VSB_GAGUAR_XJ_1                   = 2
}VSB_GAGUAR_CLASS;


typedef enum _VSB_SUBARU_CLASS
{
    VSB_SUBARU_OTHER                  = 0,
    VSB_SUBARU_AOHU_1                 = 1,
    VSB_SUBARU_LISHI_1                = 2,
    VSB_SUBARU_LISHI_2                = 3,
    VSB_SUBARU_XV_1                   = 4,
    VSB_SUBARU_SENLINREN_1            = 5,
    VSB_SUBARU_SENLINREN_2            = 6
}VSB_SUBARU_CLASS;


typedef enum _VSB_ERA_CLASS
{
    VSB_ERA_OTHER                     = 0,
    VSB_ERA_XIAOKA_1                  = 1,
    VSB_ERA_XIAOKA_3                  = 2,
    VSB_ERA_XIAOKA_4                  = 3,
    VSB_ERA_KANGRUI_1                 = 4,
    VSB_ERA_KANGRUI_2                 = 5,
    VSB_ERA_KANGRUI_3                 = 6,
    VSB_ERA_RUIWO_1                   = 7,
    VSB_ERA_RUIWO_2                   = 8,
    VSB_ERA_RUIWO_3                   = 9,
    VSB_ERA_JINGANG                   = 10,
    VSB_ERA_LINGHANG_1                = 11,
    VSB_ERA_LINGHANG_2                = 12,
    VSB_ERA_YULING_1                  = 13,
    VSB_ERA_YULING_2                  = 14,
    VSB_ERA_YULING_3                  = 15,
    VSB_ERA_YULING_4                  = 17,
    VSB_ERA_XIAOKA_2                  = 17,
}VSB_ERA_CLASS;


typedef enum _VSB_CHANGHE_CLASS
{
    VSB_CHANGHE_OTHER           = 0,
    VSB_CHANGHE_CH6321_1        = 1,
    VSB_CHANGHE_DANSHUANGPAI_1  = 2,
    VSB_CHANGHE_AIDIER_1        = 3,
    VSB_CHANGHE_AIDIER_2        = 4,
    VSB_CHANGHE_FURUIDA_1       = 5
}VSB_CHANGHE_CLASS;


typedef enum _VSB_OPEL_CLASS
{
    VSB_OPEL_OTHER              = 0,
    VSB_OPEL_YATE_1             = 1
}VSB_OPEL_CLASS;


typedef enum _VSB_JONWAY_CLASS
{
    VSB_JONWAY_OTHER            = 0,
    VSB_JONWAY_A380_1           = 1
}VSB_JONWAY_CLASS;


typedef enum _VSB_JIANGNAN_CLASS
{
    VSB_JIANGNAN_OTHER          = 0,
    VSB_JIANGNAN_TT_1           = 1
}VSB_JIANGNAN_CLASS;


typedef enum _VSB_GLEAGLE_CLASS
{
    VSB_GLEAGLE_OTHER                      = 0,
    VSB_GLEAGLE_EAGLE_GC7_1                = 1,
    VSB_GLEAGLE_EAGLE_GX2_1                = 2,
    VSB_GLEAGLE_EAGLE_GX7_1                = 3,
    VSB_GLEAGLE_EAGLE_PANDA_1              = 4,
    VSB_GLEAGLE_EAGLE_ZIYOUJIAN_1          = 5,
    VSB_GLEAGLE_EAGLE_ZIYOUJIAN_2          = 6,
    VSB_GLEAGLE_EAGLE_ZIYOUJIAN_3          = 7,
    VSB_GLEAGLE_EAGLE_YUANJING_1           = 8,
    VSB_GLEAGLE_EAGLE_YUANJING_2           = 9,
}VSB_GLEAGLE_CLASS;


typedef enum _VSB_EMGRAND_CLASS
{
    VSB_EMGRAND_OTHER                      = 0,
    VSB_EMGRAND_EC7_2                      = 1,
    VSB_EMGRAND_EC7_3                      = 2,
    VSB_EMGRAND_EC8_1                      = 3,
    VSB_EMGRAND_EC7_1                      = 4
}VSB_EMGRAND_CLASS;



typedef enum _VSB_ENGLON_CLASS
{
    VSB_ENGLON_OTHER                       = 0,
    VSB_ENGLON_SC3_1                       = 1,
    VSB_ENGLON_SC5_1                       = 2,
    VSB_ENGLON_SC6_1                       = 3,
    VSB_ENGLON_SC7_1                       = 4,
    VSB_ENGLON_SX7_1                       = 5,
    VSB_ENGLON_JINGANG_1                   = 6,
    VSB_ENGLON_JINYING_1                   = 7
}VSB_ENGLON_CLASS;



typedef enum _VSB_JAC_CLASS
{
    VSB_JAC_OTHER               = 0,
    VSB_JAC_TONGYUE_1           = 1,
    VSB_JAC_HEYUE_1             = 2,
    VSB_JAC_HEYUEA30_2          = 3,
    VSB_JAC_HEYUERS_3           = 4,
    VSB_JAC_HAOYUN_1            = 5,
    VSB_JAC_WEILING_2           = 6,
    VSB_JAC_WEILING_3           = 7,
    VSB_JAC_WEILING_4           = 8,
    VSB_JAC_KECHE_1             = 9,
    VSB_JAC_BINYUE_1            = 10,
    VSB_JAC_SHUAILING_2         = 11,
    VSB_JAC_KANGLING_1          = 12,
    VSB_JAC_KANGLING_2          = 13,
    VSB_JAC_YUEYUE_1            = 14,
    VSB_JAC_XINGRUI_1           = 15,
    VSB_JAC_GEERFA_H_1          = 16,
    VSB_JAC_GEERFA_K_2          = 17,
    VSB_JAC_GEERFA_K_3          = 18,
    VSB_JAC_GEERFA_M_4          = 19,
    VSB_JAC_RUIFENG_1           = 20,
    VSB_JAC_RUIFENG_2           = 21,
    VSB_JAC_RUIFENG_3           = 22,
    VSB_JAC_RUIFENG_4           = 23,
    VSB_JAC_RUIYING_1           = 24,
    VSB_JAC_RUIYING_2           = 25,
    VSB_JAC_JUNLING_2           = 26,
    VSB_JAC_WEILING_1           = 27,
    VSB_JAC_SHUAILING_1         = 28,
    VSB_JAC_RUILING_1           = 29,
    VSB_JAC_JUNLING_1           = 30
}VSB_JAC_CLASS;



typedef enum _VSB_JMC_CLASS
{
    VSB_JMC_OTHER               = 0,
    VSB_JMC_KAIYUN_1            = 1,
    VSB_JMC_KAIYUN_2            = 2,
    VSB_JMC_YUHU_1              = 3,
    VSB_JMC_BAODIAN_1           = 4,
    VSB_JMC_BAODIAN_2           = 5,
    VSB_JMC_BAODIAN_3           = 6,
    VSB_JMC_BAOWEI_1            = 7,
    VSB_JMC_BAOWEI_2            = 8,
    VSB_JMC_QUANSHUN_1          = 9,
    VSB_JMC_QUANSHUN_2          = 10,
    VSB_JMC_QUANSHUN_3          = 11,
    VSB_JMC_SHUNDA_1            = 12,
    VSB_JMC_SHUNDA_2            = 13,
    VSB_JMC_YUSHENG_1           = 14,
    VSB_JMC_YUSHENG_2           = 15
}VSB_JMC_CLASS;


typedef enum _VSB_VOLVO_CLASS
{
    VSB_VOLVO_OTHER             = 0,
    VSB_VOLVO_C30_1             = 1,
    VSB_VOLVO_S40_1             = 2,
    VSB_VOLVO_S60_1             = 3,
    VSB_VOLVO_S60_2             = 4,
    VSB_VOLVO_S80L_1            = 5,
    VSB_VOLVO_XC60_1            = 6,
    VSB_VOLVO_XC90_1            = 7
}VSB_VOLVO_CLASS;


typedef enum _VSB_HIGER_CLASS
{
    VSB_HIGER_OTHER             = 0,
    VSB_HIGER_H8_1              = 1,
    VSB_HIGER_H92_1             = 2,
    VSB_HIGER_V7_1              = 3,
    VSB_HIGER_KECHE_1           = 4,
    VSB_HIGER_LONGWEI_1         = 5,
    VSB_HIGER_H7V_1             = 6
}VSB_HIGER_CLASS;


typedef enum _VSB_RUILIN_CLASS
{
    VSB_RUILIN_OTHER            = 0,
    VSB_RUILIN_G3_1             = 1,
    VSB_RUILIN_G5_1             = 2,
    VSB_RUILIN_M1_1             = 3,
    VSB_RUILIN_X1_1             = 4,
    VSB_RUILIN_X1_2             = 5
}VSB_RUILIN_CLASS;


typedef enum _VSB_SHENLONG_CLASS
{
    VSB_SHENLON_OTHER                  = 0,
    VSB_SHENLONG_KECHE_1               = 1
}VSB_SHENLONG_CLASS;


typedef enum _VSB_FOTON_CLASS
{
    VSB_FOTON_OTHER                    = 0,
    VSB_FOTON_AOLING_1                 = 1,
    VSB_FOTON_AOLING_2                 = 2,
    VSB_FOTON_AOLING_3                 = 3,
    VSB_FOTON_OUMAN_1                  = 4,
    VSB_FOTON_OUMAN_2                  = 5,
    VSB_FOTON_OUMAN_3                  = 6,
    VSB_FOTON_OUMAN_4                  = 7,
    VSB_FOTON_OUHUI_1                  = 8,
    VSB_FOTON_OUMAKE_1                 = 9,
    VSB_FOTON_OUMAKE_2                 = 10,
    VSB_FOTON_SAPU_1                   = 11,
    VSB_FOTON_SAPU_3                   = 12,
    VSB_FOTON_MENGPAIKE_1              = 13,
    VSB_FOTON_MIDI_1                   = 14,
    VSB_FOTON_FENGJING_1               = 15,
    VSB_FOTON_SAPU_2                  = 16
}VSB_FOTON_CLASS;


typedef enum _VSB_FODAY_CLASS
{
    VSB_FODAY_OTHER                    = 0,
    VSB_FODAY_CHAOREN_1                = 1,
    VSB_FODAY_CHAOREN_2                = 2,
    VSB_FODAY_TANSUOZHE_1              = 3,
    VSB_FODAY_TANSUOZHE_2              = 4,
    VSB_FODAY_TANSUOZHE_3              = 5,
    VSB_FODAY_XIONGSHI_1               = 6
}VSB_FODAY_CLASS;


typedef enum _VSB_HONGQI_CLASS
{
    VSB_HONGQI_OTHER                   = 0,
    VSB_HONGQI_MINGSHI_1               = 1
}VSB_HONGQI_CLASS;



typedef enum _VSB_LUXGEN_CLASS
{
    VSB_LUXGEN_OTHER                   = 0,
    VSB_LUXGEN_DASEVEN_1               = 1
}VSB_LUXGEN_CLASS;


typedef enum _VSB_XIALI_CLASS
{
    VSB_XIALI_OTHER                    = 0,
    VSB_XIALI_QIBING_1                 = 1,
}VSB_XIALI_CLASS;


typedef enum _VSB_SHUCHI_CLASS
{
    VSB_SHUCHI_OTHER                   = 0,
    VSB_SHUCHI_A_1                     = 1
}VSB_SHUCHI_CLASS;


typedef enum _VSB_INFINITI_CLASS
{
    VSB_INFINITI_OTHER                 = 0,
    VSB_INFINITI_EX_1                  = 1,
    VSB_INFINITI_FX_1                  = 2,
    VSB_INFINITI_FX_2                  = 3,
    VSB_INFINITI_FX_3                  = 4,
    VSB_INFINITI_G_1                   = 5,
    VSB_INFINITI_JX_1                  = 6
}VSB_INFINITI_CLASS;



typedef enum _VSB_LOTUS_CLASS
{
    VSB_LOTUS_OTHER                    = 0,
    VSB_LOTUS_L3_1                     = 1,
    VSB_LOTUS_L3_2                     = 2
}VSB_LOTUS_CLASS;


typedef enum _VSB_FIAT_CLASS
{
    VSB_FIAT_OTHER                     = 0,
    VSB_FIAT_FEIYUE_1                  = 1
}VSB_FIAT_CLASS;


typedef enum _VSB_OGA_CLASS
{
    VSB_OGA_OTHER                      = 0,
    VSB_OGA_MDX_1                      = 1,
    VSB_OGA_MDX_2                      = 2
}VSB_OGA_CLASS;




typedef enum _VSB_YUEJIN_CLASS
{
    VSB_YUEJIN_OTHER                   = 0,
    VSB_YUEJIN_SHUAIHU_1               = 1,
    VSB_YUEJIN_CAISHEN_1               = 2,
    VSB_YUEJIN_CAISHEN_2               = 3,
    VSB_YUEJIN_CAISHEN_3               = 4
}VSB_YUEJIN_CLASS;


typedef enum _VSB_YEMA_CLASS
{
    VSB_YEMA_OTHER                     = 0,
    VSB_YEMA_F99_1                     = 1
}VSB_YEMA_CLASS;


typedef enum _VSB_SZKINGLONG_CLASS
{
    VSB_SZKINGLONG_OTHER               = 0,
    VSB_SZKINGLONG_BUS11_1             = 1,
    VSB_SZKINGLONG_BUS12_1             = 2,
    VSB_SZKINGLONG_BUS13_1             = 3,
    VSB_SZKINGLONG_BUS14_1             = 4,
    VSB_SZKINGLONG_BUS16_1             = 5,
    VSB_SZKINGLONG_BUS18_1             = 6,
    VSB_SZKINGLONG_BUS1_1              = 7,
    VSB_SZKINGLONG_BUS20_1             = 8,
    VSB_SZKINGLONG_BUS2_1              = 9,
    VSB_SZKINGLONG_BUS5_1              = 10,
    VSB_SZKINGLONG_BUS6_1              = 11,
    VSB_SZKINGLONG_BUS9_1              = 12,
    VSB_SZKINGLONG_BUS10_1             = 13,
    VSB_SZKINGLONG_BUS15_1             = 14
}VSB_SZKINGLONG_CLASS;


typedef enum _VSB_CHANGFENG_CLASS
{
    VSB_CHANGFENG_OTHER                = 0,
    VSB_CHANGFENG_CS7_1                = 1,
    VSB_CHANGFENG_QIBING_1             = 2,
    VSB_CHANGFENG_LIEBAO_1             = 3,
    VSB_CHANGFENG_FULING_1             = 4,
    VSB_CHANGFENG_FEIYANG_1            = 5,
    VSB_CHANGFENG_FEITENG_1            = 6,
    VSB_CHANGFENG_BLACKJINGANG_1       = 7,
}VSB_CHANGFENG_CLASS;


typedef enum _VSB_LUFENG_CLASS
{
    VSB_LUFENG_OTHER                   = 0,
    VSB_LUFENG_X6_1                    = 1,
    VSB_LUFENG_X6_2                    = 2,
    VSB_LUFENG_X6_3                    = 3,
    VSB_LUFENG_LUFENGX5_1              = 4,
    VSB_LUFENG_LUFENGX8_1              = 5,
    VSB_LUFENG_LUFENGX8_2              = 6,
    VSB_LUFENG_FENGHUA_1               = 7,
    VSB_LUFENG_X6_4                    = 8,
    VSB_LUFENG_FENGSHANG_1             = 9
}VSB_LUFENG_CLASS;


typedef enum _VSB_SHANQI_CLASS
{
    VSB_SHANQI_OTHER                   = 0,
    VSB_SHANQI_AOLONG_1                = 1,
    VSB_SHANQI_AOLONG_2                = 2,
    VSB_SHANQI_DELONG_1                = 3,
    VSB_SHANQI_DELONG_2                = 4,
    VSB_SHANQI_DELONG_3                = 5,
}VSB_SHANQI_CLASS;



typedef enum _VSB_RENAULT_CLASS
{
    VSB_RENAULT_OTHER                  = 0,
    VSB_RENAULT_MEIGANNA_1             = 1,
    VSB_RENAULT_KELEIAO_1              = 2,
    VSB_RENAULT_KELEIAO_2              = 3,
    VSB_RENAULT_SCENE_1                = 4,
    VSB_RENAULT_FENGLANG_1             = 5,
    VSB_RENAULT_TAFEIKE_1              = 6
}VSB_RENAULT_CLASS;


typedef enum _VSB_HUANGHAI_CLASS
{
    VSB_HUANGHAI_OTHER                 = 0,
    VSB_HUANGHAI_DACAISHEN_1           = 1,
    VSB_HUANGHAI_DACAISHEN_2           = 2,
    VSB_HUANGHAI_BUS4_1                = 3,
    VSB_HUANGHAI_CHALLENGER_1          = 4,
    VSB_HUANGHAI_AOLONGCUV_1           = 5,
    VSB_HUANGHAI_AOJUN_1               = 6,
    VSB_HUANGHAI_AOJUN_2               = 7,
    VSB_HUANGHAI_QISHENGV3_1           = 8,
    VSB_HUANGHAI_LINGHANGZHE_1         = 9,
    VSB_HUANGHAI_FENGCHI_1             = 10
}VSB_HUANGHAI_CLASS;
/********************Vehicle Brand Sub Type End*************************/

//LPR sub structure
typedef struct tagNET_DVR_PLATE_INFO
{
    BYTE  byPlateType;                     //license type
    BYTE  byColor;                         //License color
    BYTE  byBright;                         //License brightness
    BYTE  byLicenseLen;                     //Character number of the license plate
    BYTE  byEntireBelieve;                     //Accuracy of the license plate (percentage)
    BYTE  byRegion;     //Region index value, 0 reserved, 1 Europe, 2 Russia(Russian regions), 3-EU&CIS,0xff- all
    BYTE  byCountry;     // Country INdex\A3\ACReference :COUNTRY_INDEX(not support "COUNTRY_ALL = 0xff, //ALL")
    BYTE  byRes[33];                     //Reserved
    NET_VCA_RECT    struPlateRect;         //License plate position
    char sLicense[MAX_LICENSE_LEN];         //license content
    BYTE byBelieve[MAX_LICENSE_LEN];     //Accuracy of each letter
}NET_DVR_PLATE_INFO,  *LPNET_DVR_PLATE_INFO;

//Vehicle info
typedef struct tagNET_DVR_VEHICLE_INFO_
{
    DWORD dwIndex;                     //Vehicle index
    BYTE  byVehicleType;         //Vehicle type
    BYTE  byColorDepth;         //Vehicle color (dark/light)
    BYTE  byColor;                     //Vehicle color,refer to VCR_CLR_CLASS
    BYTE  byRadarState;  //Radar State
    WORD  wSpeed;                     //Speed (km/h)
    WORD  wLength;                     //Vehicle length of the previous one
    BYTE  byIllegalType;            //0- normal; 1- low speed, 2- High speed, 3- traverse travelling,4-run red light,5-drive line,6-direction, 7 - intersection stranded, 8 - machines accounting for non-9 - illegal lane change,10-no with line 11-violate ban\A3\AC12-park in cross \A3\AC13-park with green
    BYTE  byVehicleLogoRecog; //
    BYTE  byVehicleSubLogoRecog; //
    BYTE  byVehicleModel; //
    BYTE  byCustomInfo[16];  //Custom information
    WORD  wVehicleLogoRecog;  //
    BYTE  byRes3[14];
}NET_DVR_VEHICLE_INFO,  *LPNET_DVR_VEHICLE_INFO;


//License Recognition
typedef struct tagNET_DVR_PLATE_RESULT
{
    DWORD   dwSize;                         //Structure length
    BYTE    byResultType;             //0- video recognition result, 1- Image  recognition result
    BYTE    byChanIndex;             //Channel number
    WORD    wAlarmRecordID;        //The alarm recording ID (used to query video only when byResultType 2)
    DWORD   dwRelativeTime;         //relative time
    BYTE    byAbsTime[32];         //Relative time, yyyymmddhhmmssxxx, e.g.20090810235959999 (unit: ms)
    DWORD   dwPicLen;                     //Picture length
    DWORD    dwPicPlateLen;             //License plate snapshot length
    DWORD   dwVideoLen;                     //recoding video length
    BYTE    byTrafficLight;                 //0- non traffic light snapshot, 1- Green light snapshot; 2- Red light snapshot
    BYTE    byPicNum;                 //Picture index on multi-shot mode
    BYTE    byDriveChan;                 //Traffic lane index
    BYTE     byVehicleType;     //Vehicle type, refer to VTR_RESULT
    DWORD   dwBinPicLen; //Bin picture length
    DWORD   dwCarPicLen;//car picture length
    DWORD   dwFarCarPicLen;  //far car picture length
    BYTE    *pBuffer3;   //bin picture
    BYTE    *pBuffer4;  //car picture
    BYTE    *pBuffer5;  //far car picture
    BYTE    byRelaLaneDirectionType;
    BYTE    byCarDirectionType; //Car Direction Type
    BYTE    byRes3[6];
    NET_DVR_PLATE_INFO  struPlateInfo;     //License plate info structure
    NET_DVR_VEHICLE_INFO struVehicleInfo;  //Vehicle info
    BYTE    *pBuffer1;                    // Pointer to the upload snapshot or video, set it as NULL if no upload is required
    BYTE    *pBuffer2;                   // Pointer to the snapshot picture
}NET_DVR_PLATE_RESULT,  *LPNET_DVR_PLATE_RESULT;
//For snapshot, the data would be arranged as video scene snapshot picture + license snapshot picture

//Picture overlay info configuration
typedef struct tagNET_DVR_IMAGEOVERLAYCFG
{
    DWORD        dwSize;
    BYTE        byOverlayInfo; //0- disable overlay 1- enable overlay
    BYTE        byOverlayMonitorInfo; //Overlay info of the monitor spot, 0- disable, 1- enable
    BYTE        byOverlayTime; //Overlay time, 0- disable, 1- enable
    BYTE        byOverlaySpeed; //Overlay speed, 0- disable, 1- enable
    BYTE        byOverlaySpeeding; //Overlay over-speed proportion, 0- disable, 1- enable
    BYTE        byOverlayLimitFlag; //Overlay speed-limitation mark, 0- disable, 1- enable
    BYTE        byOverlayPlate; //Overlay license plate, 0- disable, 1- enable
    BYTE        byOverlayColor; //Overlay vehicle color, 0- disable, 1- enable
    BYTE        byOverlayLength; //Overlay vehicle length, 0- disable, 1- enable
    BYTE        byOverlayType; //Overlay vehicle type, 0- disable, 1- enable
    BYTE        byOverlayColorDepth; //Overlay vehicle color depth, 0- disable, 1- enable
    BYTE        byOverlayDriveChan; //Overlay traffic lane info, 0- disable, 1- enable
    BYTE        byOverlayMilliSec;  //Overlay millisecond info: 0- disable, 1- enable
    BYTE        byOverlayIllegalInfo;  //Overlay illegal record info: 0- disable, 1- enable
    BYTE        byOverlayRedOnTime;   //Overlay time duration after red Light is on: 0- disable, 1- enable
    BYTE        byFarAddPlateJpeg;      //Far picture overlay plate jpeg,0- disable, 1- enable
    BYTE        byNearAddPlateJpeg;      //Near picture overlay plate jpeg,0- disable, 1- enable
    BYTE        byRes1[3];     //Reserved
    BYTE        byMonitorInfo1[32];     //Monitor spot info 1
    BYTE        byMonitorInfo2[44];  //Monitor spot info 2
    BYTE        byRes2[52];     //Reserved
}NET_DVR_IMAGEOVERLAYCFG,  *LPNET_DVR_IMAGEOVERLAYCFG;

//Single IO Triggering
typedef struct tagNET_DVR_SNAPCFG
{
    DWORD   dwSize;
    BYTE    byRelatedDriveWay; //Traffic lane
    BYTE     bySnapTimes;  //Snapshot time 0- disable, else- snapshot time (up to 5)
    WORD    wSnapWaitTime;   //Snapshot wait time (unit: ms) , [67, 60000]
    WORD    wIntervalTime[4]; //multi-shot interval 1, (unit:ms)
    DWORD   dwSnapVehicleNum; //Snap Vehicle Num
    NET_DVR_JPEGPARA  struJpegPara;//Snap Picture Param
    BYTE    byRes2[16];
}NET_DVR_SNAPCFG,  *LPNET_DVR_SNAPCFG;

typedef enum _ITC_MAINMODE_ABILITY_
{
    ITC_MODE_UNKNOW    = 0x0,
    ITC_POST_MODE  = 0x1,  //post
    ITC_EPOLICE_MODE      = 0x2,  //epolice
    ITC_POSTEPOLICE_MODE  = 0x4  //post epolice
}ITC_MAINMODE_ABILITY;

typedef enum _ITC_RECOG_REGION_TYPE_
{
    ITC_REGION_RECT     = 0x0,  //rect
    ITC_REGION_POLYGON  = 0x1,  //polygon
}ITC_RECOG_REGION_TYPE;

typedef struct tagNET_DVR_SNAP_ABILITY
{
    DWORD dwSize;
    BYTE  byIoInNum; //IO input number
    BYTE  byIoOutNum; //IO output number
    BYTE  bySingleSnapNum; //Group number of Single IO triggering
    BYTE  byLightModeArrayNum; //Group number of Traffic Light Mode
    BYTE  byMeasureModeArrayNum; //Speed Measure mode group number
    BYTE  byPlateEnable;  //LPR ability
    BYTE  byLensMode; //Lens mode: 0- CCD, 1- CMOS
    BYTE  byPreTriggerSupport; //Support original trigger mode,0-yes,1-no
    DWORD dwAbilityType; //Trigger ability, bit Express, see ITC_MAINMODE_ABILITY
    BYTE  byIoSpeedGroup; //IO speed group number
    BYTE  byIoLightGroup; //IO light group number
    BYTE  byRecogRegionType; //Plate region type, see ITC_RECOG_REGION_TYPE
    BYTE  bySupport; //The equipment capacity bitwise 0 - not support - Support
    // bySupport&0x1\A3\ACIndicates whether the support extended characters superimposed configuration
    // bySupport&0x2\A3\ACIndicates whether to support the expansion of the school allocation structure
    // bySupport&0x4, Indicates whether to support multiple network interface cards (multi network isolation)
    // bySupport&0x8, Indicates whether the support network card bonding function (network fault tolerance)
    // bySupport&0x10, Indicates whether to support voice intercom
    WORD wSupportMultiRadar;
    // wSupportMultiRadar&0x1\A3\ACSaid bayonet RS485 radar support Lane associated radar processing
    // wSupportMultiRadar&0x2\A3\ACSaid bayonet virtual coil support Lane associated radar processing
    // wSupportMultiRadar&0x4\A3\ACSaid mixed bayonet support Lane associated radar processing
    // wSupportMultiRadar&0x8\A3\ACSaid video detection support Lane associated radar processing
    BYTE  byICRPresetNum;
    // Said ICR preset point support (filter offset point) number
    BYTE  byICRTimeSlot;//That period of time in support of the ICR number (1 ~ 8)
    BYTE  bySupportRS485Num;//Said support RS485 port number
    BYTE  byExpandRs485SupportSensor;
    // byExpandRs485SupportSensor &0x1\A3\ACSaid support sensors electric car detector
    // byExpandRs485SupportSensor &0x2\A3\ACSaid card support sensors electric car detector
    BYTE  byExpandRs485SupportSignalLampDet;
    // byExpandRs485SupportSignalLampDet &0x1\A3\ACSaid electric cars detector support external signal detector
    // byExpandRs485SupportSignalLampDet &0x2\A3\ACSaid cassette electric car detector support external signal detector
    BYTE  byRelayNum;// Relay Num 2013-11-04
    BYTE  bySupport1;
    // bySupport1&amp; 0x1, indicating whether or not the support custom timing information configuration
    // bySupport1&amp; 0x2, said whether to support video trigger optimization scheme
    // bySupport1&amp; 0x4, said whether to support the DDNS configuration scheme
    // bySupport1&amp; 0x8, said whether to support the access equipment current trigger mode interface command
    // bySupport1&amp; 0x10, said whether to support the entrance configuration 2014-03-03
    BYTE  bySupport2;// bySupport2&0x01,  Stream With Vca Info
    // bySupport2&0x02, Support "byOSDMilliSecondEnable"(INTER_PICCFG_V30)
    BYTE  bySupportWhiteBalance; //Support WhiteBalance\A1\A3
    // bySupportWhiteBalance &0x01,  Support Fluorescent Lamp
    // bySupportWhiteBalance &0x02,  Support Natural Light
    // bySupportWhiteBalance &0x04,  Support Warm Light Lamp
    // bySupportWhiteBalance &0x08,  SupportIncandescent Lamp
    BYTE  byRes[9];
} NET_DVR_SNAP_ABILITY,  *LPNET_DVR_SNAP_ABILITY;

typedef struct tagNET_ITC_ICRTIMECFG
{
    NET_DVR_SCHEDTIME  struTime;
    BYTE   byAssociateRresetNo;//The preset number 1 to 8, 0 for no
    BYTE   bySubSwitchMode;//1~day\A3\AC2~night (when byAssociateRresetNo == 0)
    BYTE   byRes[10];
}NET_ITC_ICRTIMECFG, *LPNET_ITC_ICRTIMECFG;

typedef struct tagNET_ITC_ICR_TIMESWITCH_PARAM
{
    NET_ITC_ICRTIMECFG  struAutoCtrlTime[MAX_TIMESEGMENT_V30];//Automatic switching time (time automatic switching under effective now supports 4 group, 4 group reservation)
    BYTE  byICRPreset[MAX_ICR_NUM]; //According to the actual effective capacity set [0~100] dynamic display array subscript said preset number 1 ~ 8 (0 ~ 7 relative)
    BYTE  byRes[20];
}NET_ITC_ICR_TIMESWITCH_PARAM, *LPNET_ITC_ICR_TIMESWITCH_PARAM;

typedef struct tagNET_ITC_ICR_MANUALSWITCH_PARAM
{
    BYTE  byICRPreset[MAX_ICR_NUM]; //According to the actual effective capacity set [0~100] dynamic display
    BYTE  bySubSwitchMode;//1~day\A3\AC2~night
    BYTE  byRes[147];
}NET_ITC_ICR_MANUALSWITCH_PARAM, *LPNET_ITC_ICR_MANUALSWITCH_PARAM;

typedef struct tagNET_ITC_ICR_AOTOSWITCH_PARAM
{
    BYTE  byICRPreset[MAX_ICR_NUM]; //According to the actual effective capacity set [0~100] dynamic display array subscript said preset number 1 ~ 8 (0 ~ 7 relative)
    BYTE  byICRAutoSwitch; // ICR Auto Switch[0 100]
    BYTE  byRes[147];
}NET_ITC_ICR_AOTOSWITCH_PARAM, *LPNET_ITC_ICR_AOTOSWITCH_PARAM;

//algAotoSwitch
typedef struct tagNET_ITC_ICR_ALGAOTOSWITCH_PARAM
{
    BYTE  byDetectThreshold;//Detect Threshold [0,100],default 58
    BYTE  byAbBrightnessThreshold; //Abnormal brightness threshold\A3\AC[0,100] default 12
    BYTE  byRes[154];
}NET_ITC_ICR_ALGAOTOSWITCH_PARAM, *LPNET_ITC_ICR_ALGAOTOSWITCH_PARAM;

typedef union tagNET_ITC_ICR_PARAM_UNION
{
    BYTE uLen[156];
    NET_ITC_ICR_AOTOSWITCH_PARAM struICRAutoSwitch;
    NET_ITC_ICR_MANUALSWITCH_PARAM struICRManualSwitch;
    NET_ITC_ICR_TIMESWITCH_PARAM struICRTimeSwitch;
    NET_ITC_ICR_ALGAOTOSWITCH_PARAM strICRAlgorithmAutoSwitch;
}NET_ITC_ICR_PARAM_UNION,*LPNET_ITC_ICR_PARAM_UNION;

typedef struct tagNET_ITC_ICRCFG
{
    DWORD dwSize;
    BYTE  bySwitchType;//1~ automatic switching, 2~ manual switch, 3~ switch,4~Algorithm auto Switch
    BYTE  byRes[3];
    NET_ITC_ICR_PARAM_UNION uICRParam;
}NET_ITC_ICRCFG, *LPNET_ITC_ICRCFG;

typedef struct
{
    DWORD   dwHandleType;////Way to handle,  result of operation OR
    /*0x00:  No response*/
    /*0x01:  Alarm on monitor*/
    /*0x02:  Audio Alarm*/
    /*0x04:  Upload to center*/
    /*0x08:  Trigger alarm output*/
    /*0x10:  Grab JPEG image and EMail it*/
    /*0x20:  wireless voice and light alarm*/
    /*0x40:  Trigger electric map(only PCNVR supports)*/
    /*0x200: capture jpeg and update to FTP*/
    BYTE     byEnable; //0\A1\ABno enable\A3\AC1\A1\ABenable
    BYTE    byRes;
    WORD    wDuration;//(units /s)
    BYTE    byAlarmOutTriggered[MAX_ITC_EXCEPTIONOUT];//triggered Alarm Out
    BYTE    byRes1[8];
} NET_ITC_HANDLEEXCEPTION, *LPNET_ITC_HANDLEEXCEPTION;

typedef struct
{
    DWORD dwSize;
    NET_ITC_HANDLEEXCEPTION struSnapExceptionType[MAX_EXCEPTIONNUM_V30]; //Each element of the array represents an anomaly, an array of 0- hard disk error, a 1- cable fault, 2-IP address conflict, abnormal 3- sensors, 4- signal detector abnormality

}NET_ITC_EXCEPTION,*LPNET_ITC_EXCEPTION;

typedef struct tagNET_DVR_TRIGCOORDINATE
{
    WORD wTopLeftX;  /*X axis coordinate of the coil's upper left corner (2 bytes) */
    WORD wTopLeftY;  /*Y axis coordinate of the coil's upper left corner (2 bytes) */
    WORD wWdith;  /*Coil width (2 bytes) */
    WORD wHeight;  /*Coil height (2 bytes) */
} NET_DVR_TRIGCOORDINATE,  *LPNET_DVR_TRIGCOORDINATE;

typedef enum _PROVINCE_CITY_IDX_
{
    ANHUI_PROVINCE             = 0,              //An Hui
    AOMEN_PROVINCE             = 1,              //Macao
    BEIJING_PROVINCE           = 2,              //Bei Jing
    CHONGQING_PROVINCE         = 3,              //Chong Qing
    FUJIAN_PROVINCE            = 4,              //Fu Jian
    GANSU_PROVINCE             = 5,              //Gan Su
    GUANGDONG_PROVINCE         = 6,              //Guang Dong
    GUANGXI_PROVINCE           = 7,              //Guang Xi
    GUIZHOU_PROVINCE           = 8,              //Gui Zhou
    HAINAN_PROVINCE            = 9,              //Hai Nan
    HEBEI_PROVINCE             = 10,             //He Bei
    HENAN_PROVINCE             = 11,             //He Nan
    HEILONGJIANG_PROVINCE      = 12,             //Hei Long Jiang
    HUBEI_PROVINCE             = 13,             //Hu Bei
    HUNAN_PROVINCE             = 14,             //Hu Nan
    JILIN_PROVINCE             = 15,             //Ji Lin
    JIANGSU_PROVINCE           = 16,             //Jiang Su
    JIANGXI_PROVINCE           = 17,             //Jiang Xi
    LIAONING_PROVINCE          = 18,             //Liao Ning
    NEIMENGGU_PROVINCE         = 19,             //Nei Meng Gu
    NINGXIA_PROVINCE           = 20,             //Ning Xia
    QINGHAI_PROVINCE           = 21,             //Qing Hai
    SHANDONG_PROVINCE          = 22,             //Shan Dong
    SHANXI_JIN_PROVINCE        = 23,             //Shan Xi
    SHANXI_SHAN_PROVINCE       = 24,             //Shaan Xi
    SHANGHAI_PROVINCE          = 25,             //Shang Hai
    SICHUAN_PROVINCE           = 26,             //Si Chuan
    TAIWAN_PROVINCE            = 27,             //Tai Wan
    TIANJIN_PROVINCE           = 28,             //Tian Jin
    XIZANG_PROVINCE            = 29,             //Xi Zang
    XIANGGANG_PROVINCE         = 30,             //HongKong
    XINJIANG_PROVINCE          = 31,             //Xin Jiang
    YUNNAN_PROVINCE            = 32,             //Yun Nan
    ZHEJIANG_PROVINCE          = 33              //Zhe Jiang
}PROVINCE_CITY_IDX;

typedef struct tagNET_DVR_GEOGLOCATION
{
    int iRes[2];  /*Reserved*/
    DWORD dwCity; /*City, see to PROVINCE_CITY_IDX */
}NET_DVR_GEOGLOCATION, *LPNET_DVR_GEOGLOCATION;

//Scene mode
typedef enum _SCENE_MODE_
{
    UNKOWN_SCENE_MODE   = 0,            //Unknown
    HIGHWAY_SCENE_MODE  = 1,            //High-speed outdoor scene mode
    SUBURBAN_SCENE_MODE = 2,            //Suburban scene mode
    URBAN_SCENE_MODE    = 3,            //Urban scene mode
    TUNNEL_SCENE_MODE   = 4             //High-speed tunnel scene mode
}SCENE_MODE;

typedef struct tagNET_DVR_VTPARAM
{
    DWORD   dwSize;
    BYTE    byEnable;   /* Enable virtual coil: 0- disable, 1- enable*/
    BYTE    byIsDisplay;  /* display virtual coil,0- disable, 1- enable*/
    BYTE    byLoopPos; //night loop position:0-up,1-down
    BYTE    bySnapGain; /*snap gain*/
    DWORD   dwSnapShutter; /*snap shutter*/
    NET_DVR_TRIGCOORDINATE struTrigCoordinate;
    NET_DVR_TRIGCOORDINATE struRes[5];
    BYTE    byTotalLaneNum; /*traffic lane 1*/
    BYTE    byPolarLenType;  /*Polar Len type, 0-disable; 1-Schneider Polar len*/
    BYTE    byDayAuxLightMode;  /*Day time aux Lighting, 0- disable; 1-LED; 2- Flash light*/
    BYTE    byLoopToCalRoadBright;  /*Traffic lane used for counting road brightness (Virtual coil) */
    BYTE    byRoadGrayLowTh;  /*Low threshold of road brightness, default:1*/
    BYTE    byRoadGrayHighTh;  /*High threshold of road brightness, default:140*/
    WORD    wLoopPosBias;  /*Loop position bias for Night mode,default: 30*/
    DWORD   dwHfrShtterInitValue;  /*Continuous exposure time, default:2000*/
    DWORD   dwSnapShtterInitValue;  /*Exposure time, default:500*/
    DWORD   dwHfrShtterMaxValue;  /*Max. Exposure time for multi-shot*/
    DWORD   dwSnapShtterMaxValue;  /*Max. Exposure time for snapshot*/
    DWORD   dwHfrShtterNightValue;  /*Exposure time for multi-shot at night: default: 3000*/
    DWORD   dwSnapShtterNightMinValue;  /*Min. Exposure time for multi-shot at night: default: 3000*/
    DWORD   dwSnapShtterNightMaxValue;  /*Max. Exposure time for multi-shot at night: default: 5000*/
    DWORD   dwInitAfe;  /*Gain, default:200*/
    DWORD   dwMaxAfe;  /*Max. Gain: default: 400*/
    WORD    wResolutionX; /* Resolution (horizontal)*/
    WORD    wResolutionY; /* Resolution (height)*/
    DWORD   dwGainNightValue; /*night gain:default:70*/
    DWORD   dwSceneMode; /*scene type, see SCENE_MODE */
    DWORD   dwRecordMode; /*record flag: 0-disable,1-enable*/
    NET_DVR_GEOGLOCATION struGeogLocation; /*geolocation*/
    BYTE    byTrigFlag[MAX_VL_NUM]; /*trigger flag,0-car front;1-car end;2-car front and car end all*/
    BYTE    byTrigSensitive[MAX_VL_NUM];  /*sensitive 1-100*/
    BYTE    byRes2[62];
}NET_DVR_VTPARAM,  *LPNET_DVR_VTPARAM;

typedef struct tagNET_DVR_SNAPENABLECFG
{
    DWORD        dwSize;
    BYTE        byPlateEnable; //0- disable LPR 1- enable
    BYTE        byRes1[2];   //Reserved
    BYTE        byFrameFlip;    //Flip image 0- disable; 1- enable
    WORD        wFlipAngle;     //Flip angle: 0, 90, 180, 270
    WORD        wLightPhase;    //Phase, [0,  360]
    BYTE        byLightSyncPower;   //Power synchronize for the flash light, 0- disable; 1- enable
    BYTE        byFrequency;        //signal frequency
    BYTE        byUploadSDEnable;  //upload SD picture,0-no,1-yes
    BYTE        byPlateMode; //recognition mode:0-video trigger,1-IO trigger
    BYTE        byUploadInfoFTP; //UploadInfoFTP,0-no,1-yes
    BYTE        byAutoFormatSD; //Auto Format SD,0-no,1-yes
    WORD        wJpegPicSize; //Jpeg pic size[64-8196]
    BYTE        bySnapPicResolution;  //Snap Picture Resolution
    BYTE        byRes[55];
}NET_DVR_SNAPENABLECFG,  *LPNET_DVR_SNAPENABLECFG;

/* ftp Upload*/
typedef struct
{
    DWORD    dwSize;
    DWORD    dwEnableFTP;             /*Enable FTP upload*/
    char    sFTPIP[16];                 /*FTP IP*/
    DWORD    dwFTPPort;                 /*FTP port number*/
    BYTE    sUserName[NAME_LEN];     /*User name*/
    BYTE    sPassword[PASSWD_LEN];     /*Password*/
    DWORD    dwDirLevel;     /*0 - Save in root directory, 1 - 1st directory, 2= 2nd directory*/
    WORD     wTopDirMode;     /* 1st directory, 0x1 = device name, 0x2 = device ID, 0x3 = device IP, 0x4=Monitor spot, 0x5= time (YM)Custom 0x=6, 0x7= type of violation, the direction of 0x8=, 0x9= location*/
    WORD     wSubDirMode;     /* 2nd directory, 0x1 = channel name, 0x2 = Channel number, , 0x3= time (YMD) , 0x4=traffic lane number,Custom 0x=5, 0x6= type of violation, the direction of 0x7=, 0x8= location*/
    BYTE    byEnableAnony; //anony enable,0-no,1-yes
    BYTE    byPicArchivingInterval;//Picture Archiving Interval[1~30]
    BYTE    byRes[22];
}NET_DVR_FTPCFG,  *LPNET_DVR_FTPCFG;

/*Snapshot naming elements*/
#define PICNAME_ITEM_DEV_NAME         1        /*device name*/
#define PICNAME_ITEM_DEV_NO         2        /*Device ID*/
#define PICNAME_ITEM_DEV_IP         3        /*IP*/
#define PICNAME_ITEM_CHAN_NAME         4        /*channel name*/
#define PICNAME_ITEM_CHAN_NO         5        /*Channel number*/
#define PICNAME_ITEM_TIME             6        /*time*/
#define PICNAME_ITEM_CARDNO            7        /*card number*/
#define PICNAME_ITEM_PLATE_NO       8       /*license number*/
#define PICNAME_ITEM_PLATE_COLOR    9       /*license color*/
#define PICNAME_ITEM_CAR_CHAN       10      /*traffic lane*/
#define PICNAME_ITEM_CAR_SPEED      11      /*speed*/
#define PICNAME_ITEM_CARCHAN        12      /*monitor spot*/
#define PICNAME_ITEM_PIC_NUMBER     13      //picture number
#define PICNAME_ITEM_CAR_NUMBER     14      //car number
#define PICNAME_MAXITEM             15

#define PICNAME_ITEM_SPEED_LIMIT_VALUES    15 //Speed limit
#define PICNAME_ITEM_ILLEGAL_CODE          16 //illegal Code
#define PICNAME_ITEM_CROSS_NUMBER          17 //cross number
#define PICNAME_ITEM_DIRECTION_NUMBER      18 //direction number

typedef struct
{
    BYTE     byItemOrder[PICNAME_MAXITEM];
    BYTE     byDelimiter;         /*delimiter'_'*/
}NET_DVR_PICTURE_NAME,  *LPNET_DVR_PICTURE_NAME;

//Naming rules 2013-09-27
#define PICNAME_ITEM_PARK_DEV_IP             1        /*Device IP*/
#define PICNAME_ITEM_PARK_PLATE_NO          2       /*Plate number*/
#define PICNAME_ITEM_PARK_TIME                 3        /*Park Time*/
#define PICNAME_ITEM_PARK_INDEX             4       /*Park Index*/
#define PICNAME_ITEM_PARK_STATUS            5       /*park status*/
#define PICNAME_ITEM_BUILDING_NUMBER        6       /*building number*/
#define PICNAME_ITEM_OUTDOOR_UNIT_ID        7       /*outdoor uint id*/
#define PICNAME_ITEM_UNLOCK_TYPE            8       /*unlock type*/
#define PICNAME_ITEM_DEVICE_NAME            9       //device name
#define PICNAME_ITEM_PERIOD_NO              10      //period no
#define PICNAME_ITEM_DEV_INDEX              11      //device index
#define PICNAME_PREFIX                      32      /*Pictrue Name Prefix*/
// 2013-09-27
typedef struct
{
    BYTE     byItemOrder[PICNAME_MAXITEM];
    BYTE     byDelimiter;                     /*delimiter'_'*/
    BYTE    byPicNamePrefix[PICNAME_PREFIX/*32*/];  //Pictrue Name Prefix
}NET_DVR_PICTURE_NAME_EX, *LPNET_DVR_PICTURE_NAME_EX;

/* Serial port snapshot*/
typedef struct
{
    BYTE    byStrFlag;     /*serial port data start*/
    BYTE     byEndFlag;     /*data end*/
    WORD    wCardIdx;     /*card number start digit (relative)*/
    DWORD     dwCardLen;     /*card number length*/
    DWORD   dwTriggerPicChans;     /*Channel number, by bit. Count from the first bit, and 0x2 means channel NO.1*/
}NET_DVR_SERIAL_CATCHPIC_PARA,  *LPNET_DVR_SERIAL_CATCHPIC_PARA;

//DVR snapshot
typedef struct
{
    DWORD    dwSize;
    NET_DVR_JPEGPARA struJpegPara[MAX_CHANNUM_V30];     /*image parameter for each channel*/
    WORD    wBurstMode;                             /*snapshot trigger mode, 0x1=alarm in, 0x2=Motion 0x4=232, 0x8=485, 0x10=network*/
    WORD    wUploadInterval;                     /*snapshot upload interval (seconds) [0, 65535]*/
    NET_DVR_PICTURE_NAME     struPicNameRule;     /* snapshot naming rule */
    BYTE    bySaveToHD;         /*Save to HD*/
    BYTE    byRes1;
    WORD    wCatchInterval;         /*Snapshot interval (unit: ms) [0, 65535]*/
    BYTE    byRes2[12];
    NET_DVR_SERIAL_CATCHPIC_PARA struRs232Cfg;
    NET_DVR_SERIAL_CATCHPIC_PARA struRs485Cfg;
    DWORD dwTriggerPicTimes[MAX_CHANNUM_V30];     /* Snapshot number for each channel */
    DWORD dwAlarmInPicChanTriggered[MAX_ALARMIN_V30];  /*Alarm linked snapshot channel*/
}NET_DVR_JPEGCFG_V30,  *LPNET_DVR_JPEGCFG_V30;

//Reserved
typedef struct tagNET_DVR_MANUALSNAP
{
    BYTE   byOSDEnable;//0-not close\A3\AC1-close
    BYTE   byLaneNo;//Lane No.
    BYTE   byRes[22]; //res
}NET_DVR_MANUALSNAP,  *LPNET_DVR_MANUALSNAP;

typedef struct tagNET_DVR_SPRCFG
{
    DWORD dwSize;
    BYTE byDefaultCHN[3];  /*Set short-form of province name*/
    BYTE byPlateOSD;     /*license snapshot: 0-disable , 1- enable*/
    BYTE bySendJPEG1;    /*Send JPEG snapshot 1:  0-disable , 1- enable*/
    BYTE bySendJPEG2;    /*Send JPEG snapshot 2:  0-disable , 1- enable*/
    WORD wDesignedPlateWidth;    /*license width*/
    BYTE byTotalLaneNum;   /*Traffic lane number*/
    BYTE byRes1;       /*Reserved*/
    WORD wRecognizedLane;  /*Recognized lane, represented by bit. Bit0: whether lane 1 is recognized or not, 0- no, 1- yes*/
    NET_VCA_RECT struLaneRect[MAX_LANERECT_NUM];   /*Traffic lane region*/
    DWORD dwRecogMode;  /*Recognition type,
                        bit0- Recognition direction: 0- from front,1- from back ;
                       bit1- Big plate of little plate: 0- small plate,1- big plate ;
                       bit2- Color recognition: 0- disable color recognition, when recognizing from back or recognizing small plate, 1- enable color recognition;
                       bit3- Agricultural car recognition: 0-disable,1-enable;
                       bit4- Blur recognition: 0-disable,1-enable;
                       bit5- Frame or scene location: 0-fram location,1-scene location;
                       bit6- Frame or scene recognition: 0-fram recognition,1-scene recognition;
                       bit7- Day or night: 0-Day,1-Night */
    BYTE  bySendPRRaw;           //Send raw picture:0-disable,1-enable
    BYTE  bySendBinImage;      //Send bin picture:0-disable,1-enable
    BYTE  byDelayCapture;  //snap delay,uint:frame
    BYTE  byUseLED;    //LED control:0-no,1-yes
    BYTE  byRes2[68];    //Reserved
}NET_DVR_SPRCFG,  *LPNET_DVR_SPRCFG;

typedef struct tagNET_DVR_PLCCFG
{
    DWORD dwSize;
    BYTE byPlcEnable;    //Whether to open brightness compensation of license plate or not(default:open): 0-close, 1-open
    BYTE byPlateExpectedBright;    //Expected brightness of license plate(default:50),range:[0, 100]
    BYTE byRes1[2];
    BYTE byTradeoffFlash;     //Whether to consider flashlight: 0 - no;  1 - yes(default);
    //When flash works, if consider to weaken brightness compensation of flashlight, set it to 1, or to 0
    BYTE byCorrectFactor;     //Correct factor, range:[0, 100], default:50 (resume to default when cut tradeoff_flash)
    WORD wLoopStatsEn;  //Whether to count loop brightness, represented by bit, 0- no, 1- yes
    BYTE byPlcBrightOffset;
    BYTE byRes[19];
}NET_DVR_PLCCFG, *LPNET_DVR_PLCCFG;

#define NET_DVR_GET_DEVICESTATECFG              1096   //Get current state parameters of device

typedef struct tagNET_DVR_DEVICESTATECFG
{
    DWORD dwSize;
    WORD wPreviewNum; //Preview number
    WORD wFortifyLinkNum; //Fortify link number
    NET_DVR_IPADDR struPreviewIP[MAX_LINK];  //User IP address of preview
    NET_DVR_IPADDR struFortifyIP[MAX_FORTIFY_NUM]; //User IP address of fortify
    DWORD dwVideoFrameRate;    //Frame rate:0-all; 1-1/16; 2-1/8; 3-1/4; 4-1/2; 5-1; 6-2; 7-4; 8-6; 9-8; 10-10; 11-12; 12-16; 13-20; 14-15; 15-18; 16-22;
    BYTE byResolution;      //Resolution:0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF 5(reserved),16-VGA(640*480), 17-UXGA(1600*1200), 18-SVGA (800*600),19-HD720p(1280*720),20-XVGA,  21-HD900p, 27-HD1080i, 28-2560*1920, 29-1600*304, 30-2048*1536, 31-2448*2048
    BYTE bySnapResolution;      //Resolution of snap:0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF 5(reserved),16-VGA(640*480), 17-UXGA(1600*1200), 18-SVGA (800*600),19-HD720p(1280*720),20-XVGA,  21-HD900p, 27-HD1080i, 28-2560*1920, 29-1600*304, 30-2048*1536, 31-2448*2048
    BYTE byStreamType; //Stream type:0-major stream;1-minor stream
    BYTE byTriggerType; //Trigger mode:0-video trigger;1-normal trigger
    DWORD dwSDVolume;  //Volume of SD card
    DWORD dwSDFreeSpace; //Free space of SD card
    BYTE byDetectorState[MAX_DRIVECHAN_NUM][MAX_COIL_NUM];  //State of magnetic vehicle detector: 0-unused;1-normal;2-exceptional
    BYTE byDetectorLinkState; //Connection state of magnetic vehicle detector: 0-disconnected;1-connected
    BYTE bySDStatus;    //SD state 0\A3\ADactivity,1\A3\ADDormancy,2\A3\ADAbnormal, 3-no sd
    BYTE byFortifyLevel[MAX_FORTIFY_NUM]; //Fortify level,0-no,1-level 1(high),2-level 2(middle),3-level 3(low)
    BYTE byRes2[116]; //Reserved
}NET_DVR_DEVICESTATECFG, *LPNET_DVR_DEVICESTATECFG;

typedef struct tagNET_DVR_POSTEPOLICECFG
{
    DWORD dwSize;
    DWORD dwDistance;//Coil distance, cm, [0,20000]
    DWORD dwLightChan[MAX_SIGNALLIGHT_NUM];    // Channel number of signal light
    BYTE  byCapSpeed;//Sign speed limit, unit: km/h, value range: [0,255]
    BYTE  bySpeedLimit;//Speed limit value, unit: km/h, value range:[0,255]
    BYTE  byTrafficDirection;//Traffic direction: 0-from east to west, 1-from west to east, 2-from south to north, 3-from north to south
    BYTE  byRes1; //Reserved
    WORD  wLoopPreDist;        /*Trigger delay distance,unit:dm*/
    WORD  wTrigDelay;             /*Trigger delay time,unit: ms*/
    BYTE  byRes[124];//Reserved
}NET_DVR_POSTEPOLICECFG, *LPNET_DVR_POSTEPOLICECFG;


//Signal lamp for anomaly detection
typedef struct  tagNET_DVR_SIGNALLAMP_DETCFG
{
    DWORD   dwSize;
    //Absolute time,yyyymmddhhmmssxxx,e.g.20090810235959999  The last three for the number of milliseconds
    BYTE    byAbsTime[32];
    NET_DVR_IPADDR    struAlarmCamIP;//Alarm camera IP
    DWORD   dwPic1Len;     //Abnormal image 1 length
    DWORD   dwPic2Len;     //Abnormal image 2 length
    char    *pPic1Buffer;    //Superposition Lane
    char    *pPic2Buffer;    //Superposition Lamp
    BYTE    byRes[128];
}NET_DVR_SIGNALLAMP_DETCFG, *LPNET_DVR_SIGNALLAMP_DETCFG;

typedef struct tagNET_DVR_EXDEVDET_COND
{
    DWORD         dwSize;
    DWORD         dwChannel;        //Channel
    BYTE          byExternalDevType;// 0-Invalid value (reserved);1-Signal lamp;2-flash
    BYTE          byRes[63];
}NET_DVR_EXDEVDET_COND,*LPNET_DVR_EXDEVDET_COND;

typedef struct tagNET_DVR_EXDEVDET_CFG
{
    DWORD         dwSize;
    BYTE          byExternalDevStatus;// 0-Normal;1-Abnormal
    BYTE          byRes[63];
} NET_DVR_EXDEVDET_CFG,*LPNET_DVR_EXDEVDET_CFG;

/***************************** end *********************************************/

#define IPC_PROTOCOL_NUM      50   //max number of ipc protocol

typedef struct tagNET_DVR_PTZPOS_INFO
{
    DWORD    dwPanPos;    // P parameters (level parameter)
    DWORD    dwTiltPos;    // T parameter (vertical parameters)
    DWORD    dwZoomPos;  // Z parameters (zoom parameters)
}NET_DVR_PTZPOS_INFO, *LPNET_DVR_PTZPOS_INFO;
#define MAX_ALERTLINE_NUM    8 //max number of alterline

typedef struct tagNET_VCA_HUMAN_FEATURE
{
    BYTE byAgeGroup;
    BYTE bySex;
    BYTE byEyeGlass;
    BYTE byRes [13];
}NET_VCA_HUMAN_FEATURE ,*LPNET_VCA_HUMAN_FEATURE;


typedef struct tagNET_DVR_OBJECT_FEATURE
{
    BYTE  byColorRatel;
    BYTE  byRed;
    BYTE  byGreen;
    BYTE  byBlue;
    BYTE  byRes[32];
}NET_DVR_OBJECT_FEATURE ,*LPNET_DVR_OBJECT_FEATURE;


typedef union tagNET_DVR_ADVANCE_COND_UNION
{
    BYTE                  byLen[36];
    NET_VCA_HUMAN_FEATURE      struHumanFeature;
    NET_DVR_OBJECT_FEATURE     struObjectFeature;
}NET_DVR_ADVANCE_COND_UNION,*LPNET_DVR_ADVANCE_COND_UNION;

typedef struct tagNET_DVR_TRAVERSE_PLANE_SEARCHCOND
{
    NET_VCA_TRAVERSE_PLANE struVcaTraversePlane[MAX_ALERTLINE_NUM/*8*/];
    DWORD dwPreTime;   /*Alarm ahead of time units: seconds*/
    DWORD dwDelayTime; /*Alarm delay time units: seconds*/
    NET_DVR_PTZPOS_INFO struPTZPosInfo;   //PTZ Info
    BYTE  byAdvanceType;//type,0-no use, 1-humu feature,2-object color
    BYTE  byRes1[3];
    NET_DVR_ADVANCE_COND_UNION uAdvanceCond;
    BYTE byRes[5604];
}NET_DVR_TRAVERSE_PLANE_SEARCHCOND, *LPNET_DVR_TRAVERSE_PLANE_SEARCHCOND;

#define MAX_INTRUSIONREGION_NUM    8 //max number of intrusion region
typedef struct tagNET_DVR_INTRUSION_SEARCHCOND
{
    NET_VCA_INTRUSION struVcaIntrusion[MAX_INTRUSIONREGION_NUM/*8*/];
    DWORD dwPreTime;   /*Alarm ahead of time units: seconds*/
    DWORD dwDelayTime; /*Alarm delay time units: seconds*/
    NET_DVR_PTZPOS_INFO struPTZPosInfo;  //PTZ Info
    BYTE  byAdvanceType;//type,0-no use, 1-humu feature,2-object color
    BYTE  byRes1[3];
    NET_DVR_ADVANCE_COND_UNION uAdvanceCond;
    BYTE byRes[5348];
} NET_DVR_INTRUSION_SEARCHCOND, *LPNET_DVR_INTRUSION_SEARCHCOND;

typedef struct tagNET_DVR_FACEDETECTION_SEARCHCOND
{
    NET_VCA_POLYGON  struFacePolygon; //Face Polygon
    DWORD           dwPreTime;   //PreTime
    DWORD           dwDelayTime; //DelayTime
    BYTE byRes[5972];
}NET_DVR_FACEDETECTION_SEARCHCOND, *LPNET_DVR_FACEDETECTION_SEARCHCOND;

typedef union tagNET_DVR_AREA_SMARTSEARCH_COND_UNION
{
    BYTE    byLen[6144];  //union Len
    BYTE    byMotionScope[64][96]; //Detect region: 96*64 macro blocks, 1-enable; 0-disable
    NET_DVR_TRAVERSE_PLANE_SEARCHCOND struTraversPlaneCond; //Travers plane
    NET_DVR_INTRUSION_SEARCHCOND struIntrusionCond; //Intrusion
    NET_DVR_FACEDETECTION_SEARCHCOND struFaceSnapCond; //Face Snap
}NET_DVR_AREA_SMARTSEARCH_COND_UNION,
        *LPNET_DVR_AREA_SMARTSEARCH_COND_UNION;
//Smart search
typedef struct tagNET_DVR_SMART_SEARCH_PARAM
{
    BYTE      byChan;                   //Channel number
    BYTE      bySearchCondType;       //Find Cond NET_DVR_AREA_SMARTSEARCH_COND_UNION's Index,
    /*0-Detect region \A3\AC1-traverse plane search cond\A3\AC 2-intrusion search cond*/
    WORD      wChan;                  //chan no,you can use this wchan replace byChan
    NET_DVR_TIME struStartTime;         //Recording start time
    NET_DVR_TIME struEndTime;         //Recording stop time
    NET_DVR_AREA_SMARTSEARCH_COND_UNION uSmartSearchCond;  //Find Cond
    BYTE  bySensitivity;                //sensitivity,  1- >80%,  2-40%~80%,  3-1%~40%
    BYTE byRes2[11];
}NET_DVR_SMART_SEARCH_PARAM,  *LPNET_DVR_SMART_SEARCH_PARAM;

typedef struct tagNET_DVR_SMART_SEARCH_PARAM_V40
{
    DWORD                   dwSize;
    NET_DVR_STREAM_INFO   struIDInfo;
    BYTE                   bySearchCondType;      //Find Cond NET_DVR_AREA_SMARTSEARCH_COND_UNION's Index,
    /*0-Detect region \A3\AC1-traverse plane search cond\A3\AC 2-intrusion search cond*/
    BYTE                  bySensitivity; //Detect sensitivity,1- >80%,  2-40%~80%,  3-1%~40%
    BYTE                  byRes1[2];
    NET_DVR_TIME_EX       struStartTime;
    NET_DVR_TIME_EX       struEndTime;
    NET_DVR_AREA_SMARTSEARCH_COND_UNION uSmartSearchCond;
    BYTE                  byRes2[256];
}NET_DVR_SMART_SEARCH_PARAM_V40,*LPNET_DVR_SMART_SEARCH_PARAM_V40;

typedef struct tagNET_DVR_SMART_SEARCH_RET
{
    NET_DVR_TIME struStartTime;     //Motion detect start time
    NET_DVR_TIME struEndTime;    //event stop time
    BYTE byRes[64];
}NET_DVR_SMART_SEARCH_RET,  *LPNET_DVR_SMART_SEARCH_RET;

// IPSAN search directory
typedef struct tagNET_DVR_IPSAN_SERACH_PARAM
{
    NET_DVR_IPADDR  struIP;     // IPSAN IPaddress
    WORD            wPort;      // IPSAN  port
    BYTE            byRes[10];  //
}NET_DVR_IPSAN_SERACH_PARAM, *LPNET_DVR_IPSAN_SERACH_PARAM;

typedef struct tagNET_DVR_IPSAN_SERACH_RET
{
    BYTE byDirectory[128];  // Directory
    BYTE byRes[20];
}NET_DVR_IPSAN_SERACH_RET, *LPNET_DVR_IPSAN_SERACH_RET;

//DVR device parameters
typedef struct
{
    DWORD dwSize;
    BYTE sDVRName[NAME_LEN];      //DVR name
    DWORD dwDVRID;                 //DVR ID //V1.4 (0- 99) ,  V1.5 (0- 255)
    DWORD dwRecycleRecord;         //cycle record, 0-disable, 1-enable
    //Read-only
    BYTE sSerialNumber[SERIALNO_LEN];   //SN
    DWORD dwSoftwareVersion;             //Software version
    DWORD dwSoftwareBuildDate;             //Build, 0xYYYYMMDD
    DWORD dwDSPSoftwareVersion;             //DSP Version: 16 high bit is the major version, and 16 low bit is the minor version
    DWORD dwDSPSoftwareBuildDate;         // DSP Build, 0xYYYYMMDD
    DWORD dwPanelVersion;                 // Front panel version
    DWORD dwHardwareVersion;     // Hardware version
    BYTE byAlarmInPortNum;         //DVR Alarm input
    BYTE byAlarmOutPortNum;         //DVR Alarm output
    BYTE byRS232Num;             //DVR 232 port number
    BYTE byRS485Num;             //DVR 485 port number
    BYTE byNetworkPortNum;         //Network port number
    BYTE byDiskCtrlNum;             //DVR HDD number
    BYTE byDiskNum;                 //DVR disk number
    BYTE byDVRType;                 //DVR type,  1: DVR 2: ATM DVR 3: DVS ......- -
    BYTE byChanNum;                 //DVR channel number
    BYTE byStartChan;             //start Channel number, DVS- 1, DVR -  1
    BYTE byDecordChans;             //DVR decoding
    BYTE byVGANum;                 //VGA number
    BYTE byUSBNum;                 //USB number
    BYTE byAuxoutNum;             //Aux output number
    BYTE byAudioNum;             //voice interface number
    BYTE byIPChanNum;             //Max. IP channel number
    BYTE byZeroChanNum;             //Zero channel number
    BYTE bySupport;         //Ability set
    //bySupport & 0x1,  smart search
    //bySupport & 0x2,  backup
    //bySupport & 0x4,  compression ability set
    //bySupport & 0x8,  multiple network adapter
    //bySupport & 0x10, remote SADP
    //bySupport & 0x20  support Raid
    //bySupport & 0x40  support IPSAN
    //bySupport & 0x80, support RTP over RTSP
    BYTE byEsataUseage;         //Default E-SATA: 0- backup, 1- record
    BYTE byIPCPlug;             //0- disable plug-and-play, 1- enable plug-and-play
    BYTE byStorageMode;          //Hard Disk Mode:0-group,1-quota,2-drawframe
    BYTE bySupport1;          //Ability set
    // bySupport1 & 0x1, support snmp v30
    // bySupport1& 0x2\A3\ACsupport distinguish download and playback
    //bySupport1 & 0x4, support deployment level
    //bySupport1 & 0x8, support vca alarm time extension
    //bySupport1 & 0x10, support muti disks(more than 33)
    //bySupport1 & 0x20, support rtsp over http
    WORD wDevType;//Device type
    BYTE  byDevTypeName[DEV_TYPE_NAME_LEN];//Device model name
    BYTE bySupport2; //The ability to set extension, bit 0 indicates does not support one expressed support for
    //bySupport2 & 0x1, Whether to support extended the OSD character overlay (terminal and capture machine expansion distinguish)
    BYTE byAnalogAlarmInPortNum; //Analog alarm in number
    BYTE byStartAlarmInNo;    //Analog alarm in Start No.
    BYTE byStartAlarmOutNo;  //Analog alarm Out Start No.
    BYTE byStartIPAlarmInNo;  //IP alarm in Start No.  0-Invalid
    BYTE byStartIPAlarmOutNo; //IP Alarm Out Start No.  0-Invalid
    BYTE byHighIPChanNum;     //Ip Chan Num High 8 Bit
    BYTE byEnableRemotePowerOn;//enable the equipment in a dormant state remote boot function, 0- is not enabled, the 1- enabled
    WORD wDevClass; //device class
    BYTE byRes2[6];	//res
}NET_DVR_DEVICECFG_V40,  *LPNET_DVR_DEVICECFG_V40;

//DVR device parameters
typedef struct
{
    DWORD dwSize;
    BYTE sDVRName[NET_DEV_NAME_LEN];      //DVR name
    DWORD dwDVRID; 				//DVR ID //V1.4 (0- 99) ,  V1.5 (0- 255)
    DWORD dwRecycleRecord; 		//cycle record, 0-disable, 1-enable
    //Read-only
    BYTE sSerialNumber[SERIALNO_LEN];   //SN
    DWORD dwSoftwareVersion; 			//Software version
    DWORD dwSoftwareBuildDate; 			//Build, 0xYYYYMMDD
    DWORD dwDSPSoftwareVersion; 		    //DSP Version: 16 high bit is the major version, and 16 low bit is the minor version
    DWORD dwDSPSoftwareBuildDate; 		// DSP Build, 0xYYYYMMDD
    DWORD dwPanelVersion; 				// Front panel version
    DWORD dwHardwareVersion; 	// Hardware version
    BYTE byAlarmInPortNum; 		//DVR Alarm input
    BYTE byAlarmOutPortNum; 		//DVR Alarm output
    BYTE byRS232Num; 			//DVR 232 port number
    BYTE byRS485Num; 			//DVR 485 port number
    BYTE byNetworkPortNum; 		//Network port number
    BYTE byDiskCtrlNum; 			//DVR HDD number
    BYTE byDiskNum; 				//DVR disk number
    BYTE byDVRType; 				//DVR type,  1: DVR 2: ATM DVR 3: DVS ......- -
    BYTE byChanNum; 				//DVR channel number
    BYTE byStartChan; 			//start Channel number, DVS- 1, DVR -  1
    BYTE byDecordChans; 			//DVR decoding
    BYTE byVGANum; 				//VGA number
    BYTE byUSBNum; 				//USB number
    BYTE byAuxoutNum; 			//Aux output number
    BYTE byAudioNum; 			//voice interface number
    BYTE byIPChanNum; 			//Max. IP channel number
    BYTE byZeroChanNum; 			//Zero channel number
    BYTE bySupport;         //Ability set
    //bySupport & 0x1,  smart search
    //bySupport & 0x2,  backup
    //bySupport & 0x4,  compression ability set
    //bySupport & 0x8,  multiple network adapter
    //bySupport & 0x10, remote SADP
    //bySupport & 0x20  support Raid
    //bySupport & 0x40  support IPSAN
    //bySupport & 0x80, support RTP over RTSP
    BYTE byEsataUseage; 		//Default E-SATA: 0- backup, 1- record
    BYTE byIPCPlug; 			//0- disable plug-and-play, 1- enable plug-and-play
    BYTE byStorageMode;		  //Hard Disk Mode:0-group,1-quota,2-drawframe
    BYTE bySupport1;		  //Ability set
    // bySupport1 & 0x1, support snmp v30
    // bySupport1& 0x2\A3\ACsupport distinguish download and playback
    //bySupport1 & 0x4, support deployment level
    //bySupport1 & 0x8, support vca alarm time extension
    //bySupport1 & 0x10, support muti disks(more than 33)
    //bySupport1 & 0x20, support rtsp over http
    WORD wDevType;//Device type
    BYTE  byDevTypeName[NET_DEV_TYPE_NAME_LEN];//Device model name
    BYTE bySupport2; //The ability to set extension, bit 0 indicates does not support one expressed support for
    //bySupport2 & 0x1, Whether to support extended the OSD character overlay (terminal and capture machine expansion distinguish)
    BYTE byAnalogAlarmInPortNum; //Analog alarm in number
    BYTE byStartAlarmInNo;    //Analog alarm in Start No.
    BYTE byStartAlarmOutNo;  //Analog alarm Out Start No.
    BYTE byStartIPAlarmInNo;  //IP alarm in Start No.  0-Invalid
    BYTE byStartIPAlarmOutNo; //IP Alarm Out Start No.  0-Invalid
    BYTE byHighIPChanNum;     //Ip Chan Num High 8 Bit
    BYTE byEnableRemotePowerOn;//enable the equipment in a dormant state remote boot function, 0- is not enabled, the 1- enabled
    BYTE byRes2[256];
}NET_DVR_DEVICECFG_V50, *LPNET_DVR_DEVICECFG_V50;
#define MAX_ZEROCHAN_NUM    16
//Zero Channel
typedef struct tagNET_DVR_ZEROCHANCFG
{
    DWORD dwSize;             //Structure length
    BYTE  byEnable;             //0- Disable 0 channel encoding, 1-enable  0 channel encoding
    BYTE  byRes1[3];             //Reserved
    DWORD dwVideoBitrate;      //Video bit rate: 0- Reserved; 1- 16K (Reserved);  2- 32K; 3- 48k; 4- 64K; 5- 80K; 6- 96K; 7- 128K; 8- 160k; 9- 192K; 10- 224K; 11- 256K; 12- 320K
    // 13- 384K; 14- 448K; 15- 512K; 16- 640K; 17- 768K; 18- 896K; 19- 1024K; 20- 1280K; 21- 1536K; 22- 1792K; 23- 2048K
    //If the 31st digit is set as 1, then the 0- 30th digit stands for customized bit rate value (MIN- 32K MAX- 8192K)
    DWORD dwVideoFrameRate;     //Frame rate 0- full;  1- 1/16;  2- 1/8;  3- 1/4;  4- 1/2;  5- 1;  6- 2;  7- 4;  8- 6;  9- 8;  10- 10;  11- 12;  12- 16;  13- 20,  //V2.0: 14- 15,  15- 18,  16- 22;
    BYTE  byRes2[32];         //Reserved
}NET_DVR_ZEROCHANCFG,  *LPNET_DVR_ZEROCHANCFG;

//0 Channel zooming
typedef struct tagNET_DVR_ZERO_ZOOMCFG
{
    DWORD dwSize;                 //Structure length
    NET_VCA_POINT  struPoint;     //point
    BYTE byState;                 //status, 0- zoom in, 1- zoom out
    BYTE byPreviewNumber;        //Live view, 0- 1 screen-split, 1- 4 screen-split, 2- 9 screen-split, 3- 16 screen-split (read-only)
    BYTE byPreviewSeq[MAX_WINDOW_V30]; //channel info (read-only)
    BYTE byRes[30];                 //Reserved
}NET_DVR_ZERO_ZOOMCFG,  *LPNET_DVR_ZERO_ZOOMCFG;

#define DESC_LEN_64 64
typedef struct tagNET_DVR_SNMPCFG
{
    DWORD   dwSize;             //Structure length
    BYTE    byEnable;             //0- disable SNMP, 1- enable SNMP
    BYTE    byRes1[3];             //Reserved
    WORD    wVersion;         //snmp version v1 = 1,  v2 =2,  v3 =3 (V3 is reserved)
    WORD    wServerPort;  //snmp port, default: 161
    BYTE    byReadCommunity[NAME_LEN];  //Read community, max: 31bytes, default: "public"
    BYTE    byWriteCommunity[NAME_LEN]; //Write community: max: 31 bytes, default:  "private"
    BYTE     byTrapHostIP [DESC_LEN_64];     //Trap host ip
    WORD    wTrapHostPort;    // trap host port
    BYTE    byTrapName[NAME_LEN];
    BYTE    byRes2[70];         // Reserved
}NET_DVR_SNMPCFG,  *LPNET_DVR_SNMPCFG;

typedef struct tagNET_DVR_SNMPv3_USER
{
    BYTE    byUserName[NAME_LEN];
    BYTE    bySecLevel;                        // Secure level 1: no auth, 2: no Privacy auth, 3: Privacy auth
    BYTE    byAuthtype;                        // auth type 0: MD5 1: SHA; 2: none
    BYTE    byPrivtype;                        // private type 0: DES; 1: AES; 2: none;
    BYTE    byRes[5];
    BYTE    byAuthpass[PASSWD_LEN];
    BYTE    byPrivpass[PASSWD_LEN];
}NET_DVR_SNMPv3_USER, *LPNET_DVR_SNMPv3_USER;

// snmpv30
typedef struct tagNET_DVR_SNMPCFG_V30
{
    DWORD            dwSize;                        // Structure length
    BYTE            byEnableV1;                    //0-disable SNMP V1\A3\AC1-enable SNMP V1
    BYTE            byEnableV2;                    //0-disable SNMP V2\A3\AC1-enable SNMP V2
    BYTE            byEnableV3;                    //0-disable SNMP V3\A3\AC1-enable SNMP V3
    BYTE            byRes1[3];
    WORD            wServerPort;                // snmp port, default: 161
    BYTE            byReadCommunity[NAME_LEN];    // Read community, max: 31bytes, default: "public"
    BYTE            byWriteCommunity[NAME_LEN];    // Write community: max: 31 bytes, default:  "private"
    BYTE             byTrapHostIP [DESC_LEN_64];    // Trap host ip
    WORD            wTrapHostPort;                // trap host port
    BYTE            byRes2[2];                    // reserve
    NET_DVR_SNMPv3_USER    struRWUser;                // Read&Write user
    NET_DVR_SNMPv3_USER    struROUser;                // Read only user
    BYTE            byTrapName[NAME_LEN];
}NET_DVR_SNMPCFG_V30, *LPNET_DVR_SNMPCFG_V30;

#define  PROCESSING          0     //on processing
#define  PROCESS_SUCCESS     100   //complete
#define  PROCESS_EXCEPTION   400   //processing exception
#define  PROCESS_FAILED      500   //processing failed
#define  PROCESS_QUICK_SETUP_PD_COUNT 501 //A configuration requires at least three idle hard disk

#define  SOFTWARE_VERSION_LEN 48
typedef struct tagNET_DVR_SADPINFO
{
    NET_DVR_IPADDR  struIP;      // IP
    WORD            wPort;       // port number
    WORD            wFactoryType;    // manufacture
    char        chSoftwareVersion[SOFTWARE_VERSION_LEN];
    char        chSerialNo[16];  // SN
    WORD       wEncCnt;        // Encoding channel number
    BYTE        byMACAddr[MACADDR_LEN];         // MAC
    NET_DVR_IPADDR  struSubDVRIPMask;    // DVR IP
    NET_DVR_IPADDR  struGatewayIpAddr;   // Gateway
    NET_DVR_IPADDR    struDnsServer1IpAddr;             /* IP of DNS1*/
    NET_DVR_IPADDR    struDnsServer2IpAddr;             /* IP of DNS2 */
    BYTE        byDns;
    BYTE        byDhcp;
    BYTE        szGB28181DevID[DEV_ID_LEN];  //GB28181 protocol access device for ID, IPC to GB28181 protocol access
    BYTE        byActivated;//0-invalid,1-activated,2-not activated
    BYTE        byRes[125];      // Reserved
}NET_DVR_SADPINFO,  *LPNET_DVR_SADPINFO;

#define  MAX_SADP_NUM   256   // Max device number for searching
typedef struct tagNET_DVR_SADPINFO_LIST
{
    DWORD               dwSize;    //  Structure size
    WORD                wSadpNum;    // detected device number
    BYTE                byRes[6];    // Reserved
    NET_DVR_SADPINFO    struSadpInfo[MAX_SADP_NUM];
}NET_DVR_SADPINFO_LIST,  *LPNET_DVR_SADPINFO_LIST;

typedef struct tagNET_DVR_SADP_VERIFY
{
    char chPassword[PASSWD_LEN];
    NET_DVR_IPADDR struOldIP;
    WORD        wOldPort;
    BYTE        byRes[62];
}NET_DVR_SADP_VERIFY,  *LPNET_DVR_SADP_VERIFY;

/*******************************Backup begin********************************/

#define DESC_LEN_32          32   //description length
#define MAX_NODE_NUM         256  //node number

typedef struct tagNET_DVR_DESC_NODE
{
    int  iValue;
    BYTE  byDescribe[DESC_LEN_32];  //description
    DWORD  dwFreeSpace;            //unit:Mbps
    BYTE  byRes[12];               //Reserved
}NET_DVR_DESC_NODE,  *LPNET_DVR_DESC_NODE;

typedef struct tagNET_DVR_DISKABILITY_LIST
{
    DWORD     dwSize;             //Structure length
    DWORD     dwNodeNum;          //ability node number
    NET_DVR_DESC_NODE  struDescNode[MAX_NODE_NUM];   //description
}NET_DVR_DISKABILITY_LIST,  *LPNET_DVR_DISKABILITY_LIST;

//backup process
#define BACKUP_SUCCESS                100  //complete
#define BACKUP_CHANGE_DEVICE          101  //backup device is full, change the device and contiue backup

#define BACKUP_SEARCH_DEVICE          300  //Search backup device
#define BACKUP_SEARCH_FILE            301  //Search recording files
#define BACKUP_SEARCH_LOG_FILE        302  //Search log files
#define BACKUP_CHANGE_DISK            303  //Replace disks

#define BACKUP_EXCEPTION              400  //Backup exception
#define BACKUP_FAIL                      500  //Backup failed

#define BACKUP_TIME_SEG_NO_FILE       501  //No recording files
#define BACKUP_NO_RESOURCE            502  //Not enough resource
#define BACKUP_DEVICE_LOW_SPACE       503  //NOt enough space on backup device
#define BACKUP_DISK_FINALIZED         504  //Backup disk finalized
#define BACKUP_DISK_EXCEPTION         505  //Backup disk exception
#define BACKUP_DEVICE_NOT_EXIST       506  //Backup disk not exist
#define BACKUP_OTHER_BACKUP_WORK      507  //Other backup on progress
#define BACKUP_USER_NO_RIGHT          508  //No user right
#define BACKUP_OPERATE_FAIL           509  //Operation failure
#define BACKUP_NO_LOG_FILE            510  //No log files


typedef struct tagNET_DVR_BACKUP_NAME_PARAM
{
    DWORD dwFileNum;    //File number
    NET_DVR_FINDDATA_V30 struFileList[MAX_RECORD_FILE_NUM];  //File list
    BYTE byDiskDes[DESC_LEN_32];    //Backup disk
    BYTE byWithPlayer;       //Backup with player
    BYTE byContinue;    //Continue backup or not
    BYTE byRes[34];     //Reserved
}NET_DVR_BACKUP_NAME_PARAM,  *LPNET_DVR_BACKUP_NAME_PARAM;

//Backup by time
typedef struct tagNET_DVR_BACKUP_TIME_PARAM
{
    LONG            lChannel;         //Channel number
    NET_DVR_TIME    struStartTime;    //Start time
    NET_DVR_TIME    struStopTime;     //End time
    BYTE byDiskDes[DESC_LEN_32];      //Backup disk
    BYTE byWithPlayer;                //0 not backup with player 1  backup with player
    BYTE byContinue;                  //0 not continue 1 continue
    BYTE            byDrawFrame;
    BYTE            byUseBackCfgParam;   //user backup cfg Param, 0-invalid,1-enable,2-disable
    DWORD           dwStreamType;
    BYTE            byRes[28];
}NET_DVR_BACKUP_TIME_PARAM,  *LPNET_DVR_BACKUP_TIME_PARAM;

/********************************* end *******************************************/

typedef enum _COMPRESSION_ABILITY_TYPE_
{
    COMPRESSION_STREAM_ABILITY = 0,  //Stream type
    MAIN_RESOLUTION_ABILITY    = 1,  //Main stream resolution
    SUB_RESOLUTION_ABILITY     = 2,  //Sub stream resolution
    EVENT_RESOLUTION_ABILITY   = 3,  //Event encoding resolution
    FRAME_ABILITY              = 4,  //Frame rate capability set
    BITRATE_TYPE_ABILITY       = 5,  //bit rate type capability set
    BITRATE_ABILITY            = 6,  //Max. bit rate
    THIRD_RESOLUTION_ABILITY   = 7,     //Third resolution ability
    STREAM_TYPE_ABILITY           = 8,  //Stream type ability
    PIC_QUALITY_ABILITY        = 9,  //Pic quality ability
    INTERVAL_BPFRAME_ABILITY   = 10, //BP interval ability
    VIDEO_ENC_ABILITY          = 11, //Video encode ability
    AUDIO_ENC_ABILITY          = 12, //Audio encode ability
    VIDEO_ENC_COMPLEXITY_ABILITY = 13, //video encode complexity ability
    FORMAT_ABILITY             = 14, //Video format ability
}COMPRESSION_ABILITY_TYPE;

//Capability
typedef struct tagNET_DVR_ABILITY_LIST
{
    DWORD     dwAbilityType;         // COMPRESSION_ABILITY_TYPE
    BYTE      byRes[32];            //Reserved
    DWORD     dwNodeNum;            //node number
    NET_DVR_DESC_NODE  struDescNode[MAX_NODE_NUM];   //Description
}NET_DVR_ABILITY_LIST,  *LPNET_DVR_ABILITY_LIST;

#define MAX_ABILITYTYPE_NUM  12   //Max. ability set

//Compression parameter capability set
typedef struct tagNET_DVR_COMPRESSIONCFG_ABILITY
{
    DWORD     dwSize;             //Structure length
    DWORD     dwAbilityNum;         //capability  number
    NET_DVR_ABILITY_LIST struAbilityNode[MAX_ABILITYTYPE_NUM];  //description
}NET_DVR_COMPRESSIONCFG_ABILITY,  *LPNET_DVR_COMPRESSIONCFG_ABILITY;


/********************************9000RH begin****************************************/
#define SUPPORT_PD_NUM            16
#define SUPPORT_ARRAY_NUM        8
#define SUPPORT_VD_NUM            128
#define SUPPORT_PD_NUM_            16
#define SUPPORT_PD_NUM_PARTTWO    8


typedef enum tagRAID_MODE
{
    RAID0 = 1,
    RAID1,
    RAID10,
    RAID1E,
    RAID5,
    RAID6,
    RAID50,
    JBOD,
    RAID60
}RAID_MODE;

typedef enum tagHD_SUPPORT_TYPE
{
    HD_TYPE_SATA    = 0x01,
    HD_TYPE_PATA    = 0x02,
    HD_TYPE_SAS     = 0x04,
    HD_TYPE_ATAPI   = 0x08,
    HD_TYPE_TAPE    = 0x10,
    HD_TYPE_SES     = 0x20
}HD_SUPPORT_TYPE;

// 0-do not support; 1-support
typedef enum tagSUPPORT_RAID_TYPE
{
    RAID0_ABILITY   = 0x0001,
    RAID1_ABILITY   = 0x0002,
    RAID10_ABILITY  = 0x0004,
    RAID1E_ABILITY  = 0x0008,
    RAID5_ABILITY   = 0x0010,
    RAID6_ABILITY   = 0x0020,
    RAID50_ABILITY  = 0x0040,
    JBOD_ABILITY    = 0x0080,
    RAID60_ABILITY  = 0x0100
}SUPPORT_RAID_TYPE;

// Physical HD
typedef struct tagNET_DVR_PHY_DISK_INFO
{
    WORD    wPhySlot;          // HD slot
    BYTE    byType;          // HD info; 0 -normal, 1-global hot-swap, 2- array hot-swap 3-raid array
    BYTE    byStatus;        // HD status;  1- normal
    BYTE    byMode[40];    // HD type
    DWORD   dwHCapacity;     //  HD capacity (Highest 32bit) Unit:kb
    DWORD   dwLCapacity;     //   HD capacity (Lowest 32bit)
    BYTE    byArrrayName[MAX_NAMELEN];
    WORD    wArrayID;           // Array ID
    BYTE    byRes[102];          // Reserved
}NET_DVR_PHY_DISK_INFO,  *LPNET_DVR_PHY_DISK_INFO;

typedef struct tagNET_DVR_PHY_DISK_LIST
{
    DWORD   dwSize;
    DWORD   dwCount;
    NET_DVR_PHY_DISK_INFO struPhyDiskInfo[SUPPORT_PD_NUM];
}NET_DVR_PHY_DISK_LIST,  *LPNET_DVR_PHY_DISK_LIST;

typedef enum tagBGA_TYPE
{
    BGA_REBUILD           = 0x01,     // Rebuild
    BGA_CONSISTENCY_FIX   = 0x02,     //Consistency fix
    BGA_CONSISTENCY_CHECK = 0x04,     // Consistency check
    BGA_INIT_QUICK        = 0x08,     // Fast init
    BGA_INIT_BACK         = 0x10,     // Full init
    BGA_MIGRATION         = 0x20,     // Migration
    BGA_INIT_FORE         = 0x40,     // Init
    BGA_COPYBACK          = 0x80      // Copy back
}BGA_TYPE;

typedef enum tagBGA_STATE
{
    BGA_STATE_NONE = 0,      //  no bga task
    BGA_STATE_RUNNING,       //  bga is running
    BGA_STATE_ABORTED,       //  bga is aborted
    BGA_STATE_PAUSED       //  bga is pause
}BGA_STATE;

typedef struct tagNET_DVR_BGA_INFO
{
    BYTE    byBga;   // Background task
    BYTE    byBgaState;            /*FunctionReturn- - Background task status*/
    WORD    wBgaPercentage;      /*FunctionReturn- - Background task process in percentage, if it's 65535, pecentage is invalid */
    BYTE    byRes[4];   // Reserved
}NET_DVR_BGA_INFO,  *LPNET_DVR_BGA_INFO;

// Array info
typedef struct tagNET_DVR_ARRAY_INFO
{
    WORD    wArrayID;  // Array ID
    BYTE    byRaidMode;  //Please refer to RAID_MODE
    BYTE    byStatus;   // 0- on-line; 1- No HD; 2- off-line
    DWORD   dwHCapacity;  // Array capacity (Highest 32 bit)
    DWORD   dwLCapacity;  // Array capacity (Lowest 32 bit)
    DWORD   dwHFreeSpace;    // Array free space  (Highest 32 bit)
    DWORD   dwLFreeSpace;    // Array free space  (Lowest 32 bit)
    BYTE    byArrayName[MAX_NAMELEN];  // Array name
    BYTE    byPDCount;   // Physical HD number
    BYTE    bySpareCount;    // Spare count
    BYTE    byRes1[2];
    WORD    wPDSlots[SUPPORT_PD_NUM];     // Physical HD index
    WORD    wSparePDSlots[SUPPORT_PD_NUM];     // Spare HD index
    NET_DVR_BGA_INFO    struBgaInfo;     // Background task status
    WORD    wPDSlotsPartTwo[SUPPORT_PD_NUM_PARTTWO];   //If the value is 0, which indicates invalid
    WORD    wSparePDSlotsPartTwo[SUPPORT_PD_NUM_PARTTWO];  //If the value is 0, which indicates invalid
    BYTE    byRes2[48];
}NET_DVR_ARRAY_INFO,  *LPNET_DVR_ARRAY_INFO;

typedef struct tagNET_DVR_ARRAY_LIST
{
    DWORD   dwSize;      // Structure size
    DWORD   dwCount;     // Array number
    NET_DVR_ARRAY_INFO struArrayInfo[SUPPORT_ARRAY_NUM];
}NET_DVR_ARRAY_LIST,  *LPNET_DVR_ARRAY_LIST;

//Virtual HD info
typedef struct tagNET_DVR_VD_INFO
{
    WORD    wSlot;     //Virtual HD slot
    BYTE    byStatus;  // Status: 0- normal 1- Demote 2- deleted 3- HD not found 4- off-line 5- sub-normal 6- foreign 7-Exception 0xff-not exist
    BYTE    byRaidMode;  // Please refer to RAID_MODE
    WORD    wArrayID;       // array ID
    BYTE    byRepair;   // Need repair  0 -don not need repair 1-need repair
    BYTE    byUsage;          //  0-IPSAN 1-FCSAN 2-DVR net disk 3-NAS 4-record volume
    BYTE    byArrayName[MAX_NAMELEN];
    BYTE    byName[MAX_NAMELEN];     // virtual disk name
    DWORD   dwHCapacity;     // Virtual disk capacity (Highest 32 bit)
    DWORD   dwLCapacity;     //  Virtual disk capacity (lowest 32 bit)
    DWORD   dwHFreeSpace;    //  Virtual disk free space (Highest 32 bit)
    DWORD   dwLFreeSpace;    //  Virtual disk capacity (lowest 32 bit)
    NET_DVR_BGA_INFO    struBgaInfo;     // Background running status
    DWORD                dwBlockSize;    // block size
    NET_DVR_IPADDR        struWarrantIP;    // warrant ip
    char                szArrayGroup[NAME_LEN];     //Array group
    BYTE                byRes[20];
}NET_DVR_VD_INFO,  *LPNET_DVR_VD_INFO;

typedef struct tagNET_DVR_VD_LIST
{
    DWORD   dwSize;      // Structure size
    DWORD   dwCount;     // VD number
    NET_DVR_VD_INFO struVDInfo[SUPPORT_VD_NUM];   //Virtual HD info
}NET_DVR_VD_LIST,  *LPNET_DVR_VD_LIST;

typedef struct tagNET_DVR_ADAPTER_VERSION
{
    WORD    wMajorVersion;
    WORD    wMinorVersion;
    WORD    wRevisionNumber;
    WORD    wBuildNumber;
}NET_DVR_ADAPTER_VERSION,  *LPNET_DVR_ADAPTER_VERSION;

typedef struct tagNET_DVR_VD_SLOT
{
    WORD wVDSlot;
    BYTE  byAlloc;   // Allocated status
    BYTE    byRes[5];
    DWORD dwHVDSlotSize;     // Virtual disk space  (Highest 32 bit)
    DWORD dwLVDSlotSize;     //  Virtual disk space  (Lowest 32 bit)
}NET_DVR_VD_SLOT,  *LPNET_DVR_VD_SLOT;

typedef struct tagNET_DVR_ARRAY_SPACE_ALLOC_INFO
{
    BYTE    byVDSlotCount;                         /*current number of slots in DG*/
    BYTE    byRes1[3];               // Reserved
    NET_DVR_VD_SLOT struVDSlots[SUPPORT_VD_NUM];
}NET_DVR_ARRAY_SPACE_ALLOC_INFO,  *LPNET_DVR_ARRAY_SPACE_ALLOC_INFO;

typedef struct tagNET_DVR_RAID_ADAPTER_INFO
{
    DWORD dwSize;     // Structure size
    NET_DVR_ADAPTER_VERSION struVersion;     // Adapter version
    BYTE    bySlotCount;     //Slot count
    BYTE    bySupportMigrate;   // Migrate (1- support  0- not support)
    BYTE    bySupportExpand;    // Expand (1- support  0- not support)
    BYTE    bySupportRebuild;   // Array rebuild  (1- support  0- not support)
    WORD    wSlotSupportType;  //  HD_SUPPORT_TYPE
    WORD    wSupportRaidType;       // Support RAID type
    BYTE    byAutoRebuild;       // Auto-rebuild 0-disable  1-enable
    BYTE    byRes[27];       // Reserved
}NET_DVR_RAID_ADAPTER_INFO,  *LPNET_DVR_RAID_ADAPTER_INFO;

typedef struct tagNET_DVR_OPERATE_ARRAY_PARAM
{
    BYTE    byRaidMode;      // RAID type
    BYTE    byPDCount;   // Physical HD number
    WORD    wArrayID;    // Array ID
    WORD    wPDSlots[SUPPORT_PD_NUM]; // Physical disk
    BYTE    byName[MAX_NAMELEN];   // array name
    BYTE    byInitMode;              //init mode
    BYTE    byRes1;
    WORD    wPDSlotsPartTwo[SUPPORT_PD_NUM_PARTTWO];//Physical disk, If the value is 0, which indicates invalid
    BYTE    byRes2[2];
}NET_DVR_OPERATE_ARRAY_PARAM,  *LPNET_DVR_OPERATE_ARRAY_PARAM;


typedef struct tagNET_DVR_OPERATE_VD_PARAM
{
    WORD    wArrayID;         // Array ID
    BYTE    bySlot;         // Slot for virtual disk
    BYTE    byInitType;     // Type of initialization when creating virtual disk, 0 - fast initialization, 1 - full initialization in foreground, 2 - full initialization in background
    DWORD    dwHCapacity;     // Virtual disk capacity (Highest 32 bit)
    DWORD    dwLCapacity;     // Virtual disk capacity (Lowest 32 bit)
    BYTE    byName[MAX_NAMELEN];  // Virtual disk name
    BYTE    byRes2[16];           // Reserved
}NET_DVR_OPERATE_VD_PARAM,  *LPNET_DVR_OPERATE_VD_PARAM;


typedef struct tagNET_DVR_SPARE_DISK_PARAM
{
    WORD    wPDSlot;         // Virtual disk slot
    WORD    wArrayID;        // Array
    BYTE    bySpareType;     // Spare type 1- global  2- array
    BYTE    byRes[7];        // Reserved
}NET_DVR_SPARE_DISK_PARAM,  *LPNET_DVR_SPARE_DISK_PARAM;


/********************************9000RH End****************************************/

#define MATRIX_MAXDECSUBSYSTEMCHAN    4//Decoding system channel number of Video management system's

//Linkage status for decoding sub system
typedef struct tagNET_DVR_DECSUBSYSTEMJIONSTATUS
{
    BYTE        byJoinStatus; //link status, 0- not linked, 1- linked
    BYTE        byJoinSubSystem; //linked sub system slot number
    BYTE        byJoinDispNum; // display channel number
    BYTE        byJoinSubWindowNum; //sub-window number
    BYTE        byRes[4];
}NET_DVR_DECSUBSYSTEMJIONSTATUS, LPNET_DVR_DECSUBSYSTEMJIONSTATUS;

typedef struct tagNET_DVR_SINGLESUBSYSTEMJOININFO
{
    BYTE    bySubSystemType; //sub-system type, 0- no sub-system, 1- decoding sub-system, 2- encoding sub-system
    BYTE    byRes1[3];
    NET_DVR_DECSUBSYSTEMJIONSTATUS struDecSub [MATRIX_MAXDECSUBSYSTEMCHAN];
    BYTE  byRes[8];
}NET_DVR_SINGLESUBSYSTEMJOININFO, LPNET_DVR_SINGLESUBSYSTEMJOININFO;

typedef struct tagNET_DVR_ALLDECSUBSYSTEMJOININFO
{
    DWORD dwSize;
    NET_DVR_SINGLESUBSYSTEMJOININFO struSingleSubSystemJoinInfo [MAX_SUBSYSTEM_NUM]; //80
    BYTE  byRes[8];
}NET_DVR_ALLDECSUBSYSTEMJOININFO,  *LPNET_DVR_ALLDECSUBSYSTEMJOININFO;

//2010- 04- 13 NAT configuration
typedef struct tagNET_DVR_NATASSOCIATECFG
{
    DWORD                  dwSize;
    NET_DVR_NETCFG_V30  struNatIpAddress[2]; //NAT IP
    BYTE                byNATEnable; //0- disable NAT, not 0- enable NAT
    BYTE                  byRes[63];
}NET_DVR_NATASSOCIATECFG,  *LPNET_DVR_NATASSOCIATECFG;

//2010- 06- 01 Video management system alarm
typedef struct tagNET_DVR_TEMPERATUREALARMCFG
{
    BYTE     byEnableTemperatureAlarm; //Over temperature alarm: 0- disable, 1- enable
    BYTE     byRes1[3];
    int      iTemperatureUpLimited;     //2 digit after the decimal, i.e. 1234 stands for 12.34 degree
    int      iTemperatureDownLimited;
    NET_DVR_HANDLEEXCEPTION_V30 struTempHandleType;     /* handle mode */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];  /*Arm schedule*/
    BYTE     byRes2[32];
}NET_DVR_TEMPERATUREALARMCFG,  *LPNET_DVR_TEMPERATUREALARMCFG;

typedef struct tagNET_DVR_BOARDALARMCFG
{
    BYTE   byEnablePullAlarm; //hot-swap alarm,  0- disable, 1- enable
    BYTE   byRes1[3];
    NET_DVR_HANDLEEXCEPTION_V30 struBoardHandleType;     /* handle mode */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];  /*Arm schedule*/
    BYTE   byRes2[32];
}NET_DVR_BOARDALARMCFG,  *LPNET_DVR_BOARDALARMCFG;


typedef struct tagNET_DVR_VIDEOPLATFORMALARMCFG
{
    DWORD                          dwSize;
    NET_DVR_TEMPERATUREALARMCFG  struTempAlarmCfg;
    NET_DVR_BOARDALARMCFG          struBoardAlarmCfg;
    NET_DVR_HANDLEEXCEPTION_V30  struHandleException[MAX_EXCEPTIONNUM]; //Exception type: 0- fan 1- sub-system, 2- IP conflict, 3- network disconnect, 4- illegal access
    BYTE                         byRes[32];
}NET_DVR_VIDEOPLATFORMALARMCFG, *LPNET_DVR_VIDEOPLATFORMALARMCFG;
//2010- 05- 17
typedef struct  tagNET_DVR_CODESPLITTERASSOCIATE
{
    DWORD        dwSize;
    NET_DVR_IPADDR   struIP;         /*encoder IP*/
    WORD        wPort;         //port number
    BYTE        byRes1[6];
    BYTE        sUserName[NAME_LEN];     /* user  */
    BYTE        sPassword[PASSWD_LEN];     /*password */
    BYTE        byChan; //encoder's Channel number
    BYTE        byRes2[15];
} NET_DVR_CODESPLITTERASSOCIATE,  *LPNET_DVR_CODESPLITTERASSOCIATE;

//2010- 06- 01 Alarm upload for VMS
typedef struct tagNET_DVR_VIDEOPLATFORM_ALRAMINFO
{
    DWORD  dwSize;       //Structure size
    BYTE   byAlarmType;     // 0- unplug sub-board , 1- plug sub-board , 2- temperature too high, 3- temperature too low, 4- fan exception, 5- sub-system exception 6- illegal access
    BYTE   byBoardNum;     //board number\A3\ACstart from 1\A3\AC0xff-invalid
    BYTE   byRes1[2];
    BYTE   bySubSystemChan[8];  //sub-system channel number. There are 8 sub-system for the sub board
    int    iTemperature;   //Temperature (valid when there is temperature alarm)
    BYTE   byMainboardSeq; // 1- main board, 2-else (valid when there is temperature alarm)
    BYTE   byRes2[3];
    BYTE   byFanSequence[32]; //Exception fan, byFanSequence[i] = 1,fan i+1 unnormal; byFanSequence[i] = 0, fan i+1 normal
    BYTE   byRes3[100];
}NET_DVR_VIDEOPLATFORM_ALRAMINFO, *LPNET_DVR_VIDEOPLATFORM_ALRAMINFO;

/*************************** Trial DVR begin *****************************/
#define MAX_INQUEST_PIP_NUM     3     //Picture-split number for the channel
#define MAX_INQUEST_CDRW_NUM    4     //Max. CD/DVD writer number
#define MAX_INQUEST_PIP_NUM_EX    16        //Picture-split number for the channel

typedef struct
{
    DWORD      dwSize;
    DWORD      dwNum;                        //CD/DVD writer number
    DWORD      dwRwSelectPara[MAX_CHANNUM_V30]; // Select the CD/DVD writer
    DWORD      dwModeSelect;                 //0-cycle mode 1-Parallel mode (default)
    BYTE       byRes[24];                    //Reserved
    DWORD       dwStartCDRW;                  //DVR local writing started
    DWORD      dwHdExcp;                     //HD exception
    DWORD       dwInterval;                   //Time interval, 0-10 min, 1- 20 min , 2- 30 min
    char        sLable[64];                   //Disc number
}NET_DVR_INQUEST_CDRW_CFG,  *LPNET_DVR_INQUEST_CDRW_CFG;

typedef struct
{
    char      sFileName[36];              //file name
    DWORD     dwFileLen;                  //file length
}NET_DVR_INQUEST_FILEINFO,  *LPNET_DVR_INQUEST_FILEINFO;

typedef struct
{
    DWORD     dwFileNum;                      // Delete or copy file number, Max.20
    NET_DVR_INQUEST_FILEINFO struFileInfo[MAX_RECORD_FILE_NUM];
    //For CD/DVD writing
    DWORD     dwCDIndex;                     //CD/DVD writer index : 1: 1st CD/DVD writer; 2: 2nd CD/DVD writer;  3: 3rd CD/DVD writer, 4: 4th CD/DVD writer, 5: all
    DWORD      bFinalizeDisc;                  // Finalize the CD/DVD after writing finished: 0-disable; 1-enable
}NET_DVR_INQUEST_FILES,  *LPNET_DVR_INQUEST_FILES;

typedef struct {
    DWORD     dwEnable;            //0-Invalid,1-Valid
    DWORD     dwStatus;            /* when dwType=0,
                                0-CD Normal, 1-No CD or CD Exception,
                                  when dwType=1 or 2,
                                0-Normal, 1-No CD or CD Exception,
                                2-CD is covered(81not support), 3-CD low space,
                                4-Exception caused Inquest stop(81not support)
                                when dwType=3,
                                0-Normal, 1-No CD or CD Exception,
                                2-CD is covered(81not support), 3-CD low space,
                                when dwType=4,
                                0-Normal, 1-No CD or CD Exception,
                                2-CD is covered(81not support), 3-CD low space,
                                when dwType=5,
                                0-Normal, 1-No CD or CD Exception,
                                2-CD is covered(81not support)
                                when dwType=6 or 7,
                                0-Normal, 1-No CD or CD Exception,
                                2-CD is covered(81not support), 3-CD low space*/
    DWORD    dwVolumn;            //Disk volume, M
    DWORD    dwFreeSpace;        //Disk free space,M
    DWORD    dwTimeLeft;     // Time left second
    BYTE          byCDType;         // cd type
    BYTE       byRes[3];
}NET_DVR_INQUEST_CDRW, *LPNET_DVR_INQUEST_CDRW;

typedef struct {
    DWORD    dwType;         /*State: 0-Inquest begin,
                             1-CD write while inquest, 2-Inquest stop,
                             3-Write inquest file,
                             4-Backup
                             5-Empty
                             6-Initialize hard disk
                             7-Resume inquest event*/
    NET_DVR_INQUEST_CDRW   strCDRWNum[MAX_INQUEST_CDRW_NUM];
    NET_DVR_TIME_EX            struInquestStartTime;        //Inquest start time
    BYTE                    byRes[16];
}NET_DVR_INQUEST_CDRW_STATUS, *LPNET_DVR_INQUEST_CDRW_STATUS;

typedef struct
{
    BYTE     byPipChan;               //channel of picture-in-picture mode, 0xFF-close
    BYTE     byRes[3];               //Reserved
    WORD     wTopLeftX;               //X coordinate of picture-in-picture
    WORD     wTopLeftY;               //Y coordinate of picture-in-picture
}NET_DVR_INQUEST_PIP_PARAM,  *LPNET_DVR_INQUEST_PIP_PARAM;

typedef struct
{
    BYTE     byBaseChan;           //Display channel of picture-in-picture mode
    BYTE     byBackChan;           //Display background channel of picture-in-picture mode
    BYTE     byPIPMode;            //picture-in-picture mode,  0-disable; 1-enable
    BYTE     byRes;                //Reserved
    NET_DVR_INQUEST_PIP_PARAM  strPipPara[MAX_INQUEST_PIP_NUM];   //position
}NET_DVR_INQUEST_PIP_STATUS,  *LPNET_DVR_INQUEST_PIP_STATUS;

typedef struct tagNET_DVR_INQUEST_PIP_PARAM_V40
{
    BYTE     byPipChan;      /*channel of picture-in-picture mode, 0xFF-close*/
    BYTE     byRes1[3];
    WORD     wTopLeftX;         /*X coordinate of picture-in-picture*/
    WORD     wTopLeftY;         /*Y coordinate of picture-in-picture*/
    WORD     wHeight;            /*Height coordinate of picture-in-picture*/
    WORD     wWidth;            /*Width oordinate of picture-in-picture*/
    BYTE     byRes2[32];
}NET_DVR_INQUEST_PIP_PARAM_V40, *LPNET_DVR_INQUEST_PIP_PARAM_V40;

typedef struct tagNET_DVR_STRUCTHEAD
{
    WORD	wLength;		//struct size
    BYTE	byVersion ;	    /*High and low 4 respectively represent the high and low version,
							subsequent editions and length to extend the length of the different versions of limit*/
    BYTE	byRes;
}NET_DVR_STRUCTHEAD, *LPNET_DVR_STRUCTHEAD;

typedef struct tagNET_DVR_INQUEST_PIP_STATUS_V40
{
    NET_DVR_STRUCTHEAD    struStructHead;
    BYTE             byBaseChan;     /*Display channel of picture-in-picture mode*/
    BYTE             byBackChan;     /*Display background channel of picture-in-picture mode*/
    BYTE             byPIPMode;      /*picture-in-picture mode, 0-disable
                                            1 one pictrue
                                            2 two pictrue
                                            3 three pictrue
                                            5 five picture
                                            7 seven pictrue
                                            255  close pictrue*/
    BYTE                         byPipCount;          /*pictrue count*/
    BYTE                        byPicShowMode;
    BYTE                        byRes[31];
    NET_DVR_INQUEST_PIP_PARAM_V40     strPipPara[MAX_INQUEST_PIP_NUM_EX];  /*position*/
}NET_DVR_INQUEST_PIP_STATUS_V40, *LPNET_DVR_INQUEST_PIP_STATUS_V40;

typedef struct
{
    BYTE    sSecretKey[16];         //secrete key
    BYTE    byRes[64];              /*Reserved*/
}NET_DVR_INQUEST_SECRET_INFO,  *LPNET_DVR_INQUEST_SECRET_INFO;

/***************************DVR end *****************************/
/********************************Interface Parameter Structure (end) *********************************/


/************************************************************************/
#define MAX_ALARMHOST_ALARMIN_NUM            512 //Max number of alarm host alarm input ports
#define MAX_ALARMHOST_ALARMOUT_NUM            512 //Max number of alarm host alarm output ports
#define ALARMHOST_MAX_AUDIOOUT_NUM            32  //Max number of alarm host audio output ports
#define ALARMHOST_MAX_ELECTROLOCK_NUM        32  //Max number of alarm host electric locks
#define ALARMHOST_MAX_MOBILEGATE_NUM        32  //Max number of alarm host mobile gate
#define ALARMHOST_MAX_SIREN_NUM             8   //Max number of sirens
#define MAX_ALARMHOST_SUBSYSTEM             32// Max number of subsystem
#define ALARMHOST_DETECTOR_SERIAL_LEN       9
#define MAX_DETECTOR_NUM                    128

typedef enum tagSENSOR_TYPE
{
    SENSOR_TYPE_NONE = 0,        //None
    SENSOR_TYPE_TEMPERATURE = 1, //Temperature
    SENSOR_TYPE_HUMIDITY ,       //Humidity
    SENSOR_TYPE_WINDSPEED,       //Wind speed
    SENSOR_TYPE_GAS,             //Gas
    SENSOR_AC_VOLTAGE,                // AC Voltage
    SENSOR_AC_CURRENT,                // AC Current
    SENSOR_DC_VOLTAGE,                // DC Voltage
    SENSOR_DC_CURRENT,                // DC Current
    SENSOR_WATER_PRESSURE,            // Water pressure
    SENSOR_PRESSURE_TRANSMITTER,    // Pressure transmitter
    SENSOR_FLOW_TRANSMITTER,        // Flow Transmitter
    SENSOR_WATER_LEAKAGE,            // Water leakage
    SENSOR_INTERGRATED_TEMPERATURE_DETECTOR,    //Intergrated temerature detector
    SENSOR_ISOLATION_TEMPERATURE_DETECTOR,        //Isolation temperature detector
    SENSOR_RESIDUAL_CHLORINE,                    //Residual chlorine
    SENSOR_TYPE_AC_TERMINAL = 16,           //AC Terminal
    SENSOR_TYPE_AC_SOCKET = 17,             //AC Socket
    SENSOR_TYPE_UNKNOW = 255     //Undefined
}SENSOR_TYPE;

typedef struct tagNET_DVR_SENSOR_INFO
{
    DWORD   dwSize;                  //Structure size
    BYTE    byName[NAME_LEN];       //Sensor name
    BYTE    byEnable;               //Enable or not
    BYTE    byValid;                //Valid or not, sensor is normal or abnormal(read-only)
    BYTE    byType;                 //Type
    BYTE    byAlarmMode;            //Alarm mode, five kinds: 15-HHHH, 14-HHHL, 12-HHLL, 8-HLLL, 0-LLLL,
    //that is, 1111(UP UP UP UP), 1110(UP UP UP DOWN), 1100(UP UP DOWN DOWN), 1000(UP DOWN DOWN DOWN), 0000(DOWN DOWN DOWN DOWN)
    float   fMeasureHigh;           //Upper limit of measuring range
    float   fMeasureLow;            //Lower limit of measuring range
    //Alarm limit 1-4, increases in turn
    float    fAlarm1;           //Alarm limit 1
    float    fAlarm2;           //Alarm limit 2
    float    fAlarm3;           //Alarm limit 3
    float    fAlarm4;           //Alarm limit 4
    DWORD   dwOsdCfg;          //Analog OSD, indicated by bit, 0-15 corresponds to video channel 1-16
    float    fSensitive;           //Sensitivity
    BYTE    bySensorStandard;    //Sensor standard\A3\AC0- 0~20mA\A3\AC1, 0~5V
    BYTE    byChan;                //sensor chan
    BYTE    byRes3[114];       // Reserved
}NET_DVR_SENSOR_INFO, *LPNET_DVR_SENSOR_INFO;

typedef struct tagNET_DVR_SIREN_PARAM
{
    DWORD   dwSize;             //Structure size
    BYTE    byName[NAME_LEN];   //Name
    WORD    wDelay;             //Output delay, unit: s, 0 means output all the time 0~5999
    DWORD   dwOverallEventJointSirenOn;    //Overall event joint siren on\A3\ACevery bit means a event type\A3\ACbit0-Tamper Alarm\A3\AC bit1-overall keypad emergency alarm, bit2-AC power off,bit3-Low battery voltage,bit4-The phone off line,bit5-The wired network anomaly,bit6-Wireless network anomaly,bit7-Keyboard 485 break
    DWORD    dwSubsystemEventJointSirenOn[MAX_ALARMHOST_SUBSYSTEM/*32*/];//subsystem event joint siren on\A3\ACevery bit means a event type, the array index is subsystem no\A3\ACbit0-Emergency Keypad Alarms
    BYTE    byRes2[448];
}NET_DVR_SIREN_PARAM, *LPNET_DVR_SIREN_PARAM;

typedef struct tagNET_DVR_AIR_CONDITION_PARAM
{
    DWORD    dwSize;            //Structure size
    BYTE    byEnable;        //0- open, 1- shutdown
    BYTE    byMode;            //Air conditioning mode
    BYTE    byTemperature;    //Temperature, general value is 16-30\A1\E3
    BYTE    byRes[9];        //Reserved
}NET_DVR_AIR_CONDITION_PARAM, *LPNET_DVR_AIR_CONDITION_PARAM;

typedef enum tagDETECTOR_TYPE
{
    PANIC_BUTTON = 0,               //Panic button
    MAGNETIC_CONTACT,               //Magnetic contact
    SMOKE_DETECTOR,                 //Smoke detector
    ACTIVE_INFRARED_DETECTOR,       //Active infrared detector
    PASSIVE_INFRARED_DETECTOR,      //Passive infrared detector
    GLASS_BREAK_DETECTOR,           //Glass break detector
    VIBRATION_DETECTOR,             //Vibration detector
    DUAL_TECHNOLOGY_PIR_DETECTOR,   //Dual technology motion detector
    TRIPLE_TECHNOLOGY_PIR_DETECTOR, //Triple technology detector
    HUMIDITY_DETECTOR,              //Humidity detector
    TEMPERATURE_DETECTOR,           //Temperature detector
    COMBUSTIBLE_GAS_DETECTOR,       //Combustible gas detector
    DYNAMIC_SWITCH,                    //dynamic switch
    CONTROL_SWITCH,                    //control switch
    SMART_LOCK,                        //smart lock
    WATER_DETECTOR,                 //water detector
    OTHER_DETECTOR = 0xffff         //Other detector
}DETECTOR_TYPE;

typedef struct tagNET_DVR_ALARMIN_PARAM
{
    DWORD   dwSize;
    BYTE    byName[NAME_LEN];
    WORD    wDetectorType; //see to DETECTOR_TYPE
    BYTE    byType;        //Alarm in type,0: immediately alarm in,1-24hour audible alarm in,2-delay alarm in ,3-inside alarm in\A3\AC4-key alarm in 5-Fire alarm in 6-perimeter Alarm in 7. 24-hour silent alarm in 8-24 hour auxiliary alarm in\A3\AC9-24hour vibration alarm in,10 - door emergency open protection zones, 11 - door emergency shutdown protection zones, 0xff - no Alarm in
    BYTE    byUploadAlarmRecoveryReport;    //upload alarm recovery report\A3\AC0-no\A3\AC1-yes
    DWORD    dwParam;       //Area parameter, the delay time of delay area
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];/*Time period of fortification*/
    BYTE    byAssociateAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM];  //Alarm output channel associated with the alarm input
    BYTE    byAssociateSirenOut[8];        //Siren output, subscript 0 means siren NO.1, the value equals to 1 means output, 0 means not output
    BYTE    bySensitivityParam;//Sensitivity parameter, 0-10ms\A1\A21-250ms\A1\A22-500ms\A1\A23-750ms
    BYTE    byArrayBypass; //0-not support bypass,1-support bypass
    BYTE    byJointSubSystem; //subsystem no. this parameter can not be set
    BYTE    byModuleStatus;    //Module status 1-on-line 2-off-line
    WORD    wModuleAddress;    //Module address\A3\ACexternal module from 0 to 255\A3\AC0xFFFF means invalid
    BYTE    byModuleChan;    //Module Channel\A3\ACMax number is decide by the module type\A3\AC0xFF means invalid
    BYTE    byModuleType;   //Module type\A3\AC1-local zone\A3\AC2-single zone\A3\AC3-double zone\A3\AC4-8 zone\A3\AC5-8 sensor zone\A3\AC 6-1Zone&Trigger 7-1 door controller 8-2 doors controller 9-4 doors controller
    WORD    wZoneIndex;        //zone no.       this parameter can not be set
    WORD    wInDelay;      //delay in,0-255s
    WORD    wOutDelay;    //delay out,0-255s
    BYTE    byAlarmType;     //Alarm type 0- is invalid, 1- 2- normally open, normally close
    BYTE    byZoneResistor;    // 0-invalid 1--2.2 \A3\AC2--3.3\A3\AC3--4.7\A3\AC4--5.6 \A3\AC 5--8.2 \A3\AC0xff--manual
    float    fZoneResistorManual;
    BYTE    byDetectorSerialNo[ALARMHOST_DETECTOR_SERIAL_LEN]; //detector serial number,read only
    BYTE    byZoneSignalType;    //0-wired zone,1-wireless zone
    BYTE    byDisableDetectorTypeCfg;    //0-enable\A3\AC1-disable
    BYTE    byRes2[21];
}NET_DVR_ALARMIN_PARAM, *LPNET_DVR_ALARMIN_PARAM;

#define MAX_MAX_ALARMIN_NUM			64	/* Maximum number of sectors */
typedef	struct tagNET_DVR_MULTI_ALARMIN_COND
{
    DWORD	dwSize;
    int		iZoneNo[MAX_MAX_ALARMIN_NUM];	//sector number
    BYTE	byRes[256];
}NET_DVR_MULTI_ALARMIN_COND, *LPNET_DVR_MULTI_ALARMIN_COND;

typedef struct tagNET_DVR_SINGLE_ALARMIN_PARAM
{
    DWORD   dwSize;
    WORD	wZoneNo;		//sector number
    BYTE	byJointSubSystem; //subsystem number of sectors
    BYTE    byType;			//sector type
    BYTE    byName[NAME_LEN];
    WORD    wDetectorType;	// DETECTOR_TYPE
    WORD    wInDelay;		//Enter the time delay, 0-255 seconds
    WORD    wOutDelay;		//Leave the time delay, 0-255 seconds
    BYTE    byAlarmType;    //Alarm type
    BYTE    byZoneSignalType;    //0-wired zone,1-wireless zone
    BYTE    byDetectorSerialNo[ALARMHOST_DETECTOR_SERIAL_LEN]; //detector serial number,read only
    BYTE    byDisableDetectorTypeCfg;    //0-enable\A3\AC1-disable
    BYTE    byRes3[118];
}NET_DVR_SINGLE_ALARMIN_PARAM, *LPNET_DVR_SINGLE_ALARMIN_PARAM;

typedef struct tagNET_DVR_ALARMIN_PARAM_LIST
{
    DWORD	dwSize;
    NET_DVR_SINGLE_ALARMIN_PARAM	struSingleAlarmInParam[MAX_MAX_ALARMIN_NUM];
    BYTE	byRes[128];
}NET_DVR_ALARMIN_PARAM_LIST, *LPNET_DVR_ALARMIN_PARAM_LIST;

typedef struct tagNET_DVR_ALARMOUT_PARAM
{
    DWORD   dwSize;             //Structure size
    BYTE    byName[NAME_LEN];   //Name
    WORD    wDelay;             //Output delay, unit: s, 0 means output all the time
    WORD    wTriggerIndex;        //trigger no. this parameter can not be set
    BYTE    byAssociateAlarmIn[MAX_ALARMHOST_ALARMIN_NUM];   //Alarm input channel followed by siren(multi alarm inputs trigger one siren output)
    //Subscript 0 means alarm input 1, 0- not follow, 1- follow
    BYTE    byModuleType;    //trigger type\A3\AC1-local trigger\A3\AC 2-4-way trigger \A3\AC3 8-way trigger\A3\AC 4-1Zone&trigger , 5-32Trigger, 6-1 door controller 7-2 doors controller 8-4 doors controller
    BYTE    byModuleStatus;    //Trigger status 1 on-line 2-off-line
    WORD    wModuleAddress;    //Trigger address\A3\AC0~255\A3\AC0xFFFF means invalid
    BYTE    byModuleChan;    //channel no. of trigger\A3\AC0xFF means invalid
    BYTE    byWorkMode;        //work mode\A3\AC1-linkage\A3\AC2-dynamic
    BYTE    byAlarmOutMode;    //alarmout\A3\AC1-none pulse\A3\AC2-pulse
    BYTE    byTimeOn;        //time on 1~60s
    BYTE    byTimeOff;        //time off 1~60s
    BYTE       byRes2[51];
}NET_DVR_ALARMOUT_PARAM, *LPNET_DVR_ALARMOUT_PARAM;

typedef struct tagNET_DVR_ALARMIN_SETUP
{
    BYTE byAssiciateAlarmIn[MAX_ALARMHOST_ALARMIN_NUM];//Alarm input channel, subscript 0 corresponds to channel NO.1
    BYTE byRes[100];//Reserved
}NET_DVR_ALARMIN_SETUP, *LPNET_DVR_ALARMIN_SETUP;

typedef struct tagNET_DVR_ALARMHOST_MAIN_STATUS
{
    DWORD  dwSize;
    BYTE   bySetupAlarmStatus[MAX_ALARMHOST_ALARMIN_NUM];   //Arming status of alarm input port(support to query max 512 alarm input ports), 0- disarmed, 1- armed
    BYTE   byAlarmInStatus[MAX_ALARMHOST_ALARMIN_NUM];      //Alarm status of alarm input port(support to query max 512 alarm input ports), 0- without alarm, 1- with alarm
    BYTE   byAlarmOutStatus[MAX_ALARMHOST_ALARMOUT_NUM];    //Status of alarm output port(support to query max 512 alarm output ports), 0- without alarm, 1- with alarm
    BYTE   byBypassStatus[MAX_ALARMHOST_ALARMIN_NUM];       //Bypass status
    BYTE   bySubSystemGuardStatus[MAX_ALARMHOST_SUBSYSTEM]; //subsystem status, 0-close state\A3\AC1-setup state
    BYTE   byAlarmInFaultStatus[MAX_ALARMHOST_ALARMIN_NUM];// fault status of alarm in\A1\A3 0-Noarmal status\A3\AC1-Fault status
    BYTE   byRes[56];
}NET_DVR_ALARMHOST_MAIN_STATUS, *LPNET_DVR_ALARMHOST_MAIN_STATUS;

typedef struct tagNET_DVR_ALARMHOST_MAIN_STATUS_V40
{
    DWORD  dwSize;
    BYTE   bySetupAlarmStatus[MAX_ALARMHOST_ALARMIN_NUM];
    BYTE   byAlarmInStatus[MAX_ALARMHOST_ALARMIN_NUM];
    BYTE   byAlarmOutStatus[MAX_ALARMHOST_ALARMOUT_NUM];
    BYTE   byBypassStatus[MAX_ALARMHOST_ALARMIN_NUM];
    BYTE   bySubSystemGuardStatus[MAX_ALARMHOST_SUBSYSTEM/*32*/];
    BYTE   byAlarmInFaultStatus[MAX_ALARMHOST_ALARMIN_NUM];
    BYTE   byAlarmInMemoryStatus[MAX_ALARMHOST_ALARMIN_NUM];
    BYTE   byAlarmInTamperStatus[MAX_ALARMHOST_ALARMIN_NUM];
    BYTE   byEnableSubSystem[MAX_ALARMHOST_SUBSYSTEM/*32*/];
    BYTE   bySubSystemGuardType[MAX_ALARMHOST_SUBSYSTEM];
    BYTE   byRes[448];
}NET_DVR_ALARMHOST_MAIN_STATUS_V40, *LPNET_DVR_ALARMHOST_MAIN_STATUS_V40;

typedef struct tagNET_DVR_ALARMHOST_OTHER_STATUS
{
    DWORD  dwSize;
    BYTE   bySirenStatus[ALARMHOST_MAX_SIREN_NUM];    //Siren output status, 0- in the status without alarm, 1- in the status with alarm
    BYTE   byRes[92];             // Reserved
}NET_DVR_ALARMHOST_OTHER_STATUS, *LPNET_DVR_ALARMHOST_OTHER_STATUS;

typedef struct tagNET_DVR_ALARMHOST_OTHER_STATUS_V50
{
    DWORD  dwSize;
    BYTE   bySirenStatus[ALARMHOST_MAX_SIREN_NUM];  //Siren output status, 0- in the status without alarm, 1- in the status with alarm
    BYTE   byDetetorPower[MAX_DETECTOR_NUM];        //0-100,low power when less than 20
    BYTE   byDetetorConnection[MAX_DETECTOR_NUM];   //0-unregedited\A3\AC1-offline\A3\AC 2-online
    BYTE   byRes[1024];
}NET_DVR_ALARMHOST_OTHER_STATUS_V50, *LPNET_DVR_ALARMHOST_OTHER_STATUS_V50;

//Enable status configuration
typedef struct tagNET_DVR_ALARMHOST_ENABLECFG
{
    DWORD dwSize;
    BYTE  byAudioOutEnable[ALARMHOST_MAX_AUDIOOUT_NUM];//Enable audio output or not, 0- disable, 1- enable
    BYTE  byElectroLockEnable[ALARMHOST_MAX_ELECTROLOCK_NUM];//Enable electronic lock or not, 0- disable, 1- enable
    BYTE  byMobileGateEnable[ALARMHOST_MAX_MOBILEGATE_NUM];//Enable mobile gateway or not, 0- disable, 1- enable
    BYTE  bySirenEnable[ALARMHOST_MAX_SIREN_NUM];//Enable siren or not, 0- disable, 1- enable
    BYTE  bySerialPurpose;//Serial purpose, 0- used to cascade with alarm host, 1- used to PTZ control
    BYTE  byRes[63];
}NET_DVR_ALARMHOST_ENABLECFG, *LPNET_DVR_ALARMHOST_ENABLECFG;

typedef struct tagNET_DVR_ALARMHOST_ABILITY
{
    DWORD   dwSize;                    //Structure size
    WORD    wTotalAlarmInNum;       //Total number of alarm input ports(alarm areas), including cascade
    WORD    wLocalAlarmInNum;       //Total number of local alarm input ports
    WORD    wExpandAlarmInNum;      //Total number of expandable alarm input ports
    WORD    wTotalAlarmOutNum;      //Total number of alarm output ports(supported by device)
    WORD    wLocalAlarmOutNum;      //Total number of local alarm output ports
    WORD    wExpandAlarmOutNum;     //Total number of expandable alarm output ports
    WORD    wTotalRs485Num;         //Total number of RS-485 ports(supported by device)
    WORD    wLocalRs485Num;         //Total number of local RS-485 ports
    WORD    wExpandRs485Num;        //Total number of expandable RS-485 ports
    WORD    wFullDuplexRs485Num;    //Total number of full duplex RS-485 ports
    WORD    wTotalSensorNum;        //Total number of analog(supported by device)
    WORD    wLocalSensorNum;        //Total number of local analog
    WORD    wExpandSensorNum;       //Total number of expandable local analog
    WORD    wAudioOutNum;            //Total number of audio outputs
    WORD    wGatewayNum;            //Total number of mobile gateways
    WORD    wElectroLockNum;        //Total number of electronic locks
    WORD    wSirenNum;                 //Total number of sirens
    WORD    wSubSystemNum;            //Total number of divided subsystems
    WORD    wNetUserNum;            //Total number of network users
    WORD    wKeyboardNum;            //Total number of keyboard
    WORD    wOperatorUserNum;       //Total number of operator users

    BYTE    bySupportDetector;        //Is support detector\A3\AC1-support\A3\AC0-not support
    BYTE    bySupportSensitivity;   //Is support sensitivity\A3\AC1-support\A3\AC0-not support
    BYTE    bySupportArrayBypass;   //Is support array Bypass\A3\AC1-support\A3\AC0-not support
    BYTE    bySupportAlarmInDelay;  //Is support alarm in delay,1-support\A3\AC0-not support
    BYTE    bySupportAlarmInType[16];//Alarm in type,0: immediately alarm in,1-24hour audible alarm in,2-delay alarm in ,3-inside alarm in\A3\AC4-key alarm in 5-Fire alarm in 6-perimeter Alarm in 7. 24-hour silent alarm in 8-24 hours auxiliary sectors, 9-24 hours vibration protection zones, 10 - door emergency open protection zones, 11 - door emergency shutdown protection zones  15-no
    BYTE    byTelNum;                //Total number of telephone
    BYTE    byCenterGroupNum;        //Total number of center group number
    BYTE    byGPRSNum;                //Total number of GPRS number ,the max number is 4
    BYTE    byNetNum;                //Total number of net number ,the max number is 4
    BYTE    byAudioNum;                //Total Audio number
    BYTE    by3GNum;                //Total 3G module number
    BYTE    byAnalogVideoChanNum;    //Channel number of analog video.
    BYTE    byDigitalVideoChanNum;        //Channel number of digital video.
    BYTE    bySubSystemArmType;        //arm type of subsystem\A3\AC0-not support\A3\AC1-support\A1\A3bit0-normal arm\A3\ACbit1-Quick arm\A3\ACbit2-stay arm\A1\A3
    BYTE    byPublicSubSystemNum;    //Public subsystem number
    DWORD    dwSupport1;    //0-not support\A3\AC1-support
    // bit0:    event cause alarm out open
    // bit1:    event cause alarm out close
    // bit2:    subsystem enable
    // bit3;    ZONE arm
    // bit4;    auto arm and disarm
    // bit5:    fault cause sound output
    // bit6:    ZONE code
    // bit7:    trigger code
    // bit8:    search fault status
    // bit9:    subsystem external config
    // bit12:   support LED screen config
    // bit13:   support fault link LED
    DWORD    dwSubSystemEvent;        //subsystem event\A3\ACbit0-enter delay time\A3\ACbit1-exit delay time\A3\ACbit2-arm\A3\ACbit3-disarm\A3\ACbit4-alarm\A3\AC bit5-clear alarm
    DWORD    dwOverallEvent;            //overall event\A3\AC0- not support, 1-support,\A3\ACbit0-AC outage\A3\ACbit1-low voltage of battery\A3\ACbit2-telephone off_line\A3\ACbit3-network abnormal\A3\ACbit4-Wireless network abnormal
    DWORD    dwFaultType;            //fault type\A3\AC0- not support, 1-support, bit0-AC outage\A3\ACbit1-low voltage of battery\A3\ACbit2-device prevent disassemble\A3\ACbit3-telephone off_line\A3\ACbit4-485 device abnormal\A3\ACbit5-network abnormal\A3\ACbit6-wireless abnormal\A3\ACbit7-expand bus abnormal\A3\ACbit8-hard disk abnormal
    BYTE    byPublicSubsystemAssociateSubsystemNum;    //number of associate subsystem by public subsystem
    BYTE    byOverallKeyboard;
    WORD    wSafetyCabinSupport; //safety cabin ablity\A3\AC0-not support,1-support
    //bit0: work mode config
    //bit1: person signal sensor config
    //bit2: curtain sensor config
    //bit3: infrared sensor
    //bit4: safety cabin using time out config
    BYTE    by485SlotNum;        //  485 slot number
    BYTE    bySubSystemAttributeAbility;    //forbid No.1-subsystem enable closed
    WORD    wKeyboardAddrNum;      // keyboard address num
    BYTE    byRes[118];            //  res
}NET_DVR_ALARMHOST_ABILITY, *LPNET_DVR_ALARMHOST_ABILITY;

typedef struct tagNET_DVR_485LIST_INFO
{
    DWORD        dwSize;
    BYTE        byAll;    //0-not all\A3\AC1-all
    BYTE        byres[3];
    BYTE        byIndex[256];            //485 chan
    BYTE           byRes[64];      //res
}NET_DVR_485LIST_INFO,*LPNET_DVR_485LIST_INFO;

typedef struct tagNET_DVR_485_SLOT_LIST_INFO
{
    DWORD        dwSize;
    BYTE        byAll;    //0-not all\A3\AC1-all
    BYTE        byres[3];
    BYTE        byIndex[256];            //485 chan
    BYTE           byRes[64];      //res
}NET_DVR_485_SLOT_LIST_INFO,* LPNET_DVR_485_SLOT_LIST_INFO;

typedef struct tagNET_DVR_ALARM_RS485CFG
{
    DWORD   dwSize;                 //Structure size
    BYTE    sDeviceName[NAME_LEN];  //Front-end device name
    WORD    wDeviceType;            //Device type, get from NET_DVR_GetDeviceTypeList
    WORD    wDeviceProtocol;        //Device protocol, got from protocol list
    DWORD   dwBaudRate;             //Baud rate(bps), 0- 50, 1- 75, 2- 110, 3- 150, 4- 300, 5- 600, 6-1200, 7- 2400,
    //8- 4800, 9- 9600, 10- 19200, 11- 38400, 12- 57600, 13- 76800, 14-115.2k
    BYTE    byDataBit;              //Data bit: 0- 5 bit, 1- 6 bit, 2- 7 bit, 3- 8 bit
    BYTE    byStopBit;              //Stop bit: 0- 1 bit, 1- 2bit
    BYTE    byParity;               //Parity or not: 0- no parity, 1- odd parity, 2- even parity
    BYTE    byFlowcontrol;          //Flow control or not: 0- none, 1- soft flow control, 2- hard flow control
    BYTE    byDuplex;                //0 - half-duplex, 1- full-duplex, only channel no.1 supports full duplex, others support half duplex only
    BYTE    byWorkMode;                //work mode, 0- console, 1- transparent channel
    BYTE    byChannel;                //485 chan
    BYTE    bySerialType;            //serial type: 0--485, 1--232
    BYTE    byMode;                 //mode 0-Connect card reader  1-Connect client  2-Connect extension module
    BYTE    byRes[35];                // Reserved
}NET_DVR_ALARM_RS485CFG, *LPNET_DVR_ALARM_RS485CFG;

#define MAX_DEVICE_PROTO_NUM       256
#define MAX_DEVICE_TYPE_NUM            256

// Protocol list supported by RS-485 front-end device
typedef struct tagNET_DVR_DEVICE_PROTO_LIST
{
    DWORD   dwSize;             //Structure size
    DWORD   dwProtoNum;         //Total number of protocol
    NET_DVR_PROTO_TYPE struProtoType[MAX_DEVICE_PROTO_NUM];  //Protocol type
    BYTE    byRes[12];          // Reserved
}NET_DVR_DEVICE_PROTO_LIST, *LPNET_DVR_DEVICE_PROTO_LIST;

typedef struct tagNET_DVR_DEVICE_TYPE
{
    DWORD    dwType;
    BYTE    byDescribe[DESC_LEN];
}NET_DVR_DEVICE_TYPE, *LPNET_DVR_DEVICE_TYPE;

typedef struct tagNET_DVR_DEVICE_TYPE_LIST
{
    DWORD    dwSize;                //Structure size
    DWORD    dwTypeNum;            //Total number of types
    NET_DVR_DEVICE_TYPE struDeviceType[MAX_DEVICE_TYPE_NUM];
    BYTE    byRes[12];
}NET_DVR_DEVICE_TYPE_LIST, *LPNET_DVR_DEVICE_TYPE_LIST;

#define ALARMHOST_ABILITY     0x500 //Network alarm host ability

#define    MAX_ALARMHOST_VIDEO_CHAN    64
typedef struct tagNET_DVR_ALARM_DEVICE_USER
{
    DWORD  dwSize;                  //Structure size
    BYTE   sUserName[NAME_LEN];     //User name
    BYTE    sPassword[PASSWD_LEN];    //Password
    NET_DVR_IPADDR    struUserIP;        //User IP (0 stands for no IP restriction)
    BYTE    byMACAddr[MACADDR_LEN];    //MAC
    BYTE        byUserType;         //0- general user, 1- administrator user
    BYTE   byAlarmOnRight;          //Arming authority
    BYTE   byAlarmOffRight;         //Disarming authority
    BYTE   byBypassRight;           //Bypass authority
    BYTE   byOtherRight[MAX_RIGHT]; //Other authority
    // 0 -- log
    // 1 -- reboot/shutdown
    // 2 -- set parameter
    // 3 -- get parameter
    // 4 -- resume
    // 5 -- siren
    // 6 -- PTZ
    // 7 -- remote upgrade
    // 8 -- preview
    // 9 -- manual record
    // 10 --remote playback
    BYTE    byNetPreviewRight[MAX_ALARMHOST_VIDEO_CHAN/8];    // preview channels\A3\ACeg. bit0-channel 1\A3\AC0-no permission 1-permission enable
    BYTE    byNetRecordRight[MAX_ALARMHOST_VIDEO_CHAN/8];    // record channels\A3\ACeg. bit0-channel 1\A3\AC0-no permission 1-permission enable
    BYTE    byNetPlaybackRight[MAX_ALARMHOST_VIDEO_CHAN/8]; // playback channels\A3\ACeg. bit0-channel 1\A3\AC0-no permission 1-permission enable
    BYTE    byNetPTZRight[MAX_ALARMHOST_VIDEO_CHAN/8];        // PTZ channels\A3\ACeg. bit0-channel 1\A3\AC0-no permission 1-permission enable
    BYTE    byRes2[168];
}NET_DVR_ALARM_DEVICE_USER, *LPNET_DVR_ALARM_DEVICE_USER;


typedef struct tagNET_DVR_KEYBOARD_USER
{
    DWORD     dwSize;     //Structure size
    DWORD    dwID;        //Keyboard user ID
    BYTE    byDefanceArea[MAX_ALARMHOST_ALARMIN_NUM]; //Area authority, indicated by subscript, it supports max 512 areas. 0 - no authority, 1 - privileged
    BYTE    byRes[560];        // Reserved
}NET_DVR_KEYBOARD_USER, *LPNET_DVR_KEYBOARD_USER;


typedef struct tagNET_DVR_OPERATE_USER
{
    DWORD    dwSize;
    BYTE    sUserName[NAME_LEN];    // UserName
    BYTE    sPassword[PASSWD_LEN];  // Password
    BYTE    bySubSystemPermission;
    BYTE    byRes[63];              // res
}NET_DVR_OPERATE_USER, *LPNET_DVR_OPERATE_USER;

typedef struct tagNET_DVR_GATEWAY_CFG
{
    DWORD    dwSize;                //Structure size
    BYTE    byName[NAME_LEN];    //Access control name
    BYTE    byEnable;            //Enable or not
    BYTE    byLocalEnable;      //Disabled or enabled in local
    WORD    wDelayTime;            //Delay time of opening, unit:s, value range: 0-65535, 0 means open all the time
    BYTE    byLockWorkMode;        //lock work mode\A3\AC0- start when power on\A3\AC1- start when power off
    BYTE    byRes2[31];            // Reserved
}NET_DVR_GATEWAY_CFG, *LPNET_DVR_GATEWAY_CFG;

typedef struct tagNET_DVR_SENSOR_ALARM
{
    DWORD dwSize;        //Structure size
    DWORD dwAbsTime;    //Absolute time, OSD display information

    BYTE   byName[NAME_LEN];   //Analog name
    BYTE   bySensorChannel;    //Analog channel
    BYTE   byType;             //Analog type
    BYTE    byAlarmType;       //1- UP4, 2- UP3, 3- UP2, 4- UP1, 5- DOWN1, 6- DOWN2, 7- DOWN3, 8- DOWN4, related to current mode
    //E.g. when it equals to 1000, there are four alarm types: UP1 and DOWN1,2,3.
    BYTE    byAlarmMode;       //Alarm mode, five kinds: -HHHH, -HHHL, -HHLL, HLLL, -LLLL, used to judge function alarm level for platform
    //That is: 1111(UP UP UP UP), 1110(UP UP UP DOWM), 1100(UP UP DOWM DOWM), 1000(UP DOWM DOWM DOWM), 0000(DOWM DOWM DOWM DOWM)
    float        fValue;           // Current analog value
    BYTE    byRes2[32];           // Reserved
}NET_DVR_SENSOR_ALARM, *LPNET_DVR_SENSOR_ALARM;
typedef struct
{
    /*Reserved,currently alarm of alarm host has no type(fortification network sequence, listening host sequence)*/
    DWORD  dwAlarmType;
    /*Array 0 is corresponding to NO.1 input pot*/
    BYTE   byAlarmInputNumber[MAX_ALARMHOST_ALARMIN_NUM];
    BYTE    byRes[160];
}NET_DVR_ALARMHOST_ALARMINFO,*LPNET_DVR_ALARMHOST_ALARMINFO;

//Switch alarm upload

typedef struct tagNET_DVR_SWITCH_ALARM
{
    DWORD dwSize;
    BYTE   byName[NAME_LEN];     //Switch name
    WORD  wSwitchChannel;       //Switch channel
    BYTE    byAlarmType;        //Alarm type
    BYTE     byRes[41];            //Reserved
}NET_DVR_SWITCH_ALARM, *LPNET_DVR_SWITCH_ALARM;

typedef union tagNET_DVR_ALARMHOST_EXCEPTION_PARAM
{
    DWORD   dwUnionSize[20];        //Union size
}NET_DVR_ALARMHOST_EXCEPTION_PARAM, *LPNET_DVR_ALARMHOST_EXCEPTION_PARAM;


typedef struct tagNET_DVR_ALARMHOST_EXCEPTION_ALARM
{
    DWORD   dwSize;             // structure size
    //Exception parameter, 1- device tamper alarm, 2- resume to normal after device tamper, 3- alarm of major power off, 4- resume after major power off
    //5- internal communication failure alarm, 6- resume after internal communication failure, 7- telephone line dropped,
    //8- resume telephone line dropped, 9- self-test failure alarm,  10- resume after self-test failure   11-storage battery low voltage
    //12- voltage of storage battery resume 13- storage battery trouble 14- MBUS module dropped 15-MBUS module dropped resume 16-keyboard dropped 17-keyboard dropped resume
    //18-device moved, 19-device moved resume, 20-485 peripheral circuit broken alarm, 21-resume after peripheral circuit broken
    //25-daughter board1 inserted on,26-daughter board1 pulled out, 27-daughter board2 inserted on,28-daughter board1 pulled out
    DWORD   dwExceptionType;
    BYTE   byRes[36];          // reserved
}NET_DVR_ALARMHOST_EXCEPTION_ALARM, *LPNET_DVR_ALARMHOST_EXCEPTION_ALARM;

//
#define MAX_CENTERNUM                4        //G1,G2 G3 G4 or N1\A3\ACN2\A3\ACN3\A3\ACN4 or T1\A3\ACT2\A3\ACT3\A3\ACT4
#define MAX_PHONE_NUM                32
typedef struct tagNET_DVR_PHONECENTERDIALCFG
{
    BYTE sCenterName[NAME_LEN];
    BYTE byPhoneNum[MAX_PHONE_NUM/*32*/];  //center number
    BYTE byRepeatCall;          //time of repeat call \A3\AC1~15times
    BYTE byPstnProtocol;        //protocol\A3\AC0-CID\A3\BB
    BYTE byDialDelay;           //time of dial delay, max time is 150s
    BYTE byPstnTransMode;       //trans mode\A3\AC0-DTMF 5/S\A3\AC1-DTMF 10/S\A3\BB
    BYTE byRes1[6];
    BYTE byReceiverId[6];         //receive account ID\A3\BB
    BYTE byRes2[32];
}NET_DVR_PHONECENTERDIALCFG, *LPNET_DVR_PHONECENTERDIALCFG;

typedef struct tagNET_DVR_ALARMHOSTDIALCFG
{
    DWORD dwSize;
    NET_DVR_PHONECENTERDIALCFG struPhoneCenterParam[MAX_CENTERNUM];//parameter of center
    WORD wReportPeriod;      //period of report:hour (max period is 168 hour)
    WORD wFirstReportTime;     //the time of sending first report\A3\AC1~3600min
    BYTE  byReportValid;    //turn on the report mode 0-valid 1-invalidation
    BYTE  byRes[19];
}NET_DVR_ALARMHOSTDIALCFG, *LPNET_DVR_ALARMHOSTDIALCFG;

typedef struct tagNET_DVR_ALARMHOSTDIALSETUPMODE
{
    DWORD dwSize;
    BYTE byEnableMode;//enable mode 0\A3\BAclose\A3\AC1\A3\BAopen \A3\AC2:open while the net is cutted down\A3\ACclose while natural\A3\BB
    BYTE byCallType; //report mode\A3\AC1-one center\A3\AC2-two centers\A3\AC3\A3\ACone is main center and the other is standby
    BYTE byRes1[14];
}NET_DVR_ALARMHOSTDIALSETUPMODE, *LPNET_DVR_ALARMHOSTDIALSETUPMODE;

#define  MAX_ALARM_CAM_NUM    32        // Total number of alarm triggered CAMs

typedef struct tagNET_DVR_PTZ_CTRL
{
    BYTE    byEnable;   //Enable PTZ control or not
    BYTE    byType;     //PTZ control type: 1- preset, 2- cruise  3- track
    BYTE    byPtzNo;    //Preset, cruise, or track number of PTZ control
    BYTE    byRes[5];   //Reserved
}NET_DVR_PTZ_CTRL, *LPNET_DVR_PTZ_CTRL;

typedef struct tagNET_DVR_ALARM_CAM_INFO
{
    DWORD            dwCamID;         //Operation of triggered CAM channel
    DWORD           dwRecordTime;    //Triggered record time, unit: s, -1- continuously record, 0- do not record
    DWORD           dwMonID;         //Trigger Cam to Mon display
    DWORD           dwResidentTime;  //Polling stay time, unit: s  -1- continuously stay, 0- do not stay
    NET_DVR_PTZ_CTRL    struPtzCtrl; //PTZ control information
    BYTE            byAlarmOffMode;  //Canceling mode of alarm switching to the wall, 0- cancel immediately, 1- cancel automatically, 2- cancel manually
    BYTE            byDevType;         //When it is intelligent device, valid means stream resource of intelligent alarmer: 1- decode card, 2- encode card
    BYTE            byDecChan;         //When the channel is decoding channel, it is decoding channel number
    BYTE            byRes[17];       //Reserved
}NET_DVR_ALARM_CAM_INFO, *LPNET_DVR_ALARM_CAM_INFO;

typedef struct tagNET_DVR_ALARM_CAM_CFG
{
    DWORD        dwSize;            //Structure size
    BYTE        byEnable;       //Enable alarm triggering CAM interaction or not, default: disabled
    BYTE        byRes[7];       //Reserved
    DWORD        dwNum;            //The number of triggering CAM interaction, that is, take the first few data of array to handle
    NET_DVR_ALARM_CAM_INFO struAlarmCam[MAX_ALARM_CAM_NUM];
}NET_DVR_ALARM_CAM_CFG, *LPNET_DVR_ALARM_CAM_CFG;

#define MAX_GATEWAY_NUM         8  // max gateway num
typedef struct tagNET_DVR_ALARMHOST_AUDIO_ASSOCIATE_ALARM
{
    DWORD         dwSize;
    BYTE        byEnterDoor[8];    // Subscript is number of enter door, the value is assiociate information\A3\AC0-not associated\A3\AC 1-8 is the audio index of associated
    BYTE        byExitDoor[8];     //  Subscript is number of exit door, the value is assiociate information\A3\AC0-not associated\A3\AC 1-8 is the audio index of associated
    BYTE         byAlarmIn[MAX_ALARMHOST_ALARMIN_NUM/*512*/];  // Subscript is number of alarm in, the value is assiociate information\A3\AC0-not associated\A3\AC 1-8 is the audio index of associated
    BYTE         byRes[128];
}NET_DVR_ALARMHOST_AUDIO_ASSOCIATE_ALARM, *LPNET_DVR_ALARMHOST_AUDIO_ASSOCIATE_ALARM;

typedef struct tagNET_DVR_UPLOAD_PARAM
{
    DWORD         dwSize;
    BYTE        byUploadType;    /*Upload type\A3\AC1-get data by reading file\A3\AC 2-get data from buffer*/
    BYTE        byDataType;        //data type\A3\BA1-audio type
    BYTE        byDataNum;        //data index
    BYTE        byAudioType;        //audio type\A3\AC0-wave
    char        sFileName[260];        //path of data file
    char        *lpBuffer;            //data buffer
    DWORD        dwBufferSize;        //length of the buffer
    BYTE        byRes2[128];
}NET_DVR_UPLOAD_PARAM, *LPNET_DVR_UPLOAD_PARAM;

typedef void (CALLBACK *DATADOWNLOAD)(LONG nDownloadHandle, DWORD dwDataType, void* pBuffer, DWORD dwBufSize, void *pUser);
typedef struct tagNET_DVR_DOWNLOAD_PARAM
{
    DWORD         dwSize;
    BYTE        byDownType;        /*type of saving data\A3\AC1-save data to the file by path\A3\AC 2-get data by callaback function*/
    BYTE        byDataType;        //data type\A3\BA1-audio type
    BYTE        byDataNum;        //data index
    BYTE        byRes1;
    char        sFileName[260];        //path of file
    DATADOWNLOAD lpDataCallBack; //handle of callback function
    void*        pUserData;    //user data
    BYTE        byRes2[128];
}NET_DVR_DOWNLOAD_PARAM, *LPNET_DVR_DOWNLOAD_PARAM;

typedef void (CALLBACK *DATADOWNLOAD)(LONG nDownloadHandle, DWORD dwDataType, void* pBuffer, DWORD dwBufSize, void *pUser);
typedef struct tagNET_DVR_ALARMHOST_DOWNLOAD_PARAM
{
    DWORD         dwSize;
    BYTE        byDownType;
    BYTE        byDataType;
    BYTE        byDataNum;
    BYTE        byRes1;
    char        sFileName[260];
    DATADOWNLOAD lpDataCallBack;
    void*        pUserData;
    BYTE        byRes2[128];
}NET_DVR_ALARMHOST_DOWNLOAD_PARAM, *LPNET_DVR_ALARMHOST_DOWNLOAD_PARAM;

/*************************************SELF SERVICE BANK V2.0 begin***********************************/
typedef  struct tagNET_DVR_LED_SCREEN_CFG
{
    DWORD         dwSize;
    BYTE        sLEDName[NAME_LEN/*32*/];    // LED Screen name
    BYTE        byTransMode;                 //  1-seiral port communication
    BYTE        byProtocolType;                // protocol type\A3\ACLED factories
    BYTE        byLEDColor;                 // 1-one color\A3\AC 2-two-color\A3\AC 3-256 grayscale dual color\A3\AC 4- Full-color
    BYTE        byDataPolarity;                // Data polarity .0-Negative electrode\A3\AC1-positive electrode
    BYTE        byOEPolarity;                // 0-Active-low 1-Active-high
    BYTE        byScanMode;                 // 1-1/16,  2-1/8,  3-1/4,  4-1/2,  5-static
    BYTE        byRes1[2];
    //Minimum width and height is 16*16\A3\ACinterval is 8 points
    WORD        wLEDWidth;                     // 16~2048
    WORD         wLEDHeight;                    // 16~2048
    BYTE        byRes2[64];
}NET_DVR_LED_SCREEN_CFG, *LPNET_DVR_LED_SCREEN_CFG;


#define  MAX_CONTENT_LEN  512
typedef  struct tagNET_DVR_LED_CONTENT_CFG
{
    DWORD         dwSize;
    BYTE        sLEDContent[MAX_CONTENT_LEN];    // LED content
    BYTE        byContentAct;                    // 1-static\A3\AC2-Quick play\A3\AC3-Move to the left\A3\AC4-Move to the right\A3\AC 5-Move up\A3\AC 6-Move down
    BYTE        byContentSpeed;                    // 1-24\A3\A81-The fastest\A3\AC24-The slowest\A3\A9
    BYTE        byContentStayTime;                 // 0-127.5s(Accuracy 0.5s\A3\AC SDK will Multiply 2 when transmission
    BYTE        byRes[33];
}NET_DVR_LED_CONTENT_CFG, *LPNET_DVR_LED_CONTENT_CFG;

#define     LED_TIMER_NUM             3            // LED time which use for turn on and turn off
#define        TIME_SEGMENT_A_DAY        48            // segment in a day , every half hour is a segment

typedef struct tagNET_DVR_SWITCH_TIME
{
    BYTE    byValid;                // enable or disable, time is use in a time-group
    BYTE    byRes[3];
    NET_DVR_TIME_EX struTimeOn;     // time of turn on
    NET_DVR_TIME_EX struTimeOff;     // time of turn off
}NET_DVR_SWITCH_TIME, *LPNET_DVR_SWITCH_TIME;


typedef struct tagNET_DVR_LED_SWITCH_TIME
{
    DWORD        dwSize;//time of Timer switch,the  parameter byHour and byMinute is valid, the other parameters is invalid. boot time should earlier than off time
    NET_DVR_SWITCH_TIME      struTimer[LED_TIMER_NUM /*3*/];
    BYTE        byRes[64];
}NET_DVR_LED_SWITCH_TIME, *LPNET_DVR_LED_SWITCH_TIME;

typedef struct tagNET_DVR_LED_BRIGHTNESS_STEP
{
    DWORD         dwSize;
    BYTE        byValid;        //use for Time-sharing brightness adjustment
    BYTE        byRes1[3];
    BYTE         byBrightnessStep[TIME_SEGMENT_A_DAY /*48*/];     //total levels is 16\A3\AC0~15
    BYTE        byRes2[48];
}NET_DVR_LED_BRIGHTNESS_STEP, *LPNET_DVR_LED_BRIGHTNESS_STEP;

typedef struct tagNET_DVR_LED_STATUS
{
    DWORD    dwSize;
    BYTE    bySwitchState;        //1-status of turn on 2-status of turn off
    BYTE    byBrightness;        //brightness\A3\AC0-15
    BYTE    byRes[62];
}NET_DVR_LED_STATUS, *LPNET_DVR_LED_STATUS;

/*************************************SELF SERVICE BANK V2.0 end***********************************/
/************************************************************************/
/*********************************9000 2.0 begin***************************************/

//Mode A
typedef struct tagNET_DVR_HOLIDATE_MODEA
{
    BYTE    byStartMonth;    // Start month, starting from 1
    BYTE    byStartDay;        // Start day, starting from 1
    BYTE    byEndMonth;        // End month
    BYTE    byEndDay;        // End day
    BYTE    byRes[4];        // Reserved
}NET_DVR_HOLIDATE_MODEA, *LPNET_DVR_HOLIDATE_MODEA;

typedef struct tagNET_DVR_HOLIDATE_MODEB
{
    BYTE    byStartMonth;    // Start month, starting from 1
    BYTE    byStartWeekNum;    // Start week, starting from 1
    BYTE    byStartWeekday;    // Day of the week
    BYTE    byEndMonth;        // End month, starting from 1
    BYTE    byEndWeekNum;    // End week, starting from 1
    BYTE    byEndWeekday;    // Day of the week
    BYTE    byRes[2];        // Reserved
}NET_DVR_HOLIDATE_MODEB, *LPNET_DVR_HOLIDATE_MODEB;

typedef struct tagNET_DVR_HOLIDATE_MODEC
{
    WORD    wStartYear;        // Year
    BYTE    byStartMon;        // Month
    BYTE    byStartDay;        // Day
    WORD    wEndYear;        // Year
    BYTE    byEndMon;        // Month
    BYTE    byEndDay;        // Day
}NET_DVR_HOLIDATE_MODEC, *LPNET_DVR_HOLIDATE_MODEC;

typedef union tagNET_DVR_HOLIDATE_UNION
{
    // Union size: 12 bytes
    DWORD                    dwSize[3];
    NET_DVR_HOLIDATE_MODEA    struModeA;    // Mode A
    NET_DVR_HOLIDATE_MODEB    struModeB;    // Mode B
    NET_DVR_HOLIDATE_MODEC    struModeC;    // Mode C
}NET_DVR_HOLIDATE_UNION, *LPNET_DVR_HOLIDATE_UNION;

typedef enum tagHOLI_DATE_MODE
{
    HOLIDATE_MODEA = 0,
    HOLIDATE_MODEB,
    HOLIDATE_MODEC
}HOLI_DATE_MODE;

typedef struct tagNET_DVR_HOLIDAY_PARAM
{
    BYTE    byEnable;            // Enable or not
    BYTE    byDateMode;            // Date mode: 0- mode A, 1- mode B, 2- mode C
    BYTE    byRes1[2];            // Reserved
    NET_DVR_HOLIDATE_UNION uHolidate;    // Holiday date
    BYTE    byName[NAME_LEN];    // Holiday name
    BYTE    byRes2[20];            // Reserved
}NET_DVR_HOLIDAY_PARAM, *LPNET_DVR_HOLIDAY_PARAM;

#define  MAX_HOLIDAY_NUM    32

typedef struct tagNET_DVR_HOLIDAY_PARAM_CFG
{
    DWORD    dwSize;            //Structure size
    NET_DVR_HOLIDAY_PARAM struHolidayParam[MAX_HOLIDAY_NUM];    //Holiday parameter
    DWORD    byRes[40];        // Reserved
}NET_DVR_HOLIDAY_PARAM_CFG, *LPNET_DVR_HOLIDAY_PARAM_CFG;

//Holiday alarm handling mode
typedef struct tagNET_DVR_HOLIDAY_HANDLE
{
    DWORD    dwSize;                //Structure size
    NET_DVR_SCHEDTIME              struAlarmTime[MAX_TIMESEGMENT_V30];    //Arming schedule
    BYTE    byRes2[240];        // Reserved
}NET_DVR_HOLIDAY_HANDLE, *LPNET_DVR_HOLIDAY_HANDLE;

typedef struct tagNET_DVR_HOLIDAY_HANDLE_COND
{
    DWORD    dwSize;
    DWORD    dwChannel;
    DWORD    dwSMDHandleType;
    BYTE     byRes2[32];
}NET_DVR_HOLIDAY_HANDLE_COND, *LPNET_DVR_HOLIDAY_HANDLE_COND;

typedef struct tagNET_DVR_HOLIDAY_RECORD
{
    DWORD                 dwSize;
    NET_DVR_RECORDDAY     struRecDay;     // Record parameter
    NET_DVR_RECORDSCHED   struRecordSched[MAX_TIMESEGMENT_V30]; // Record schedule
    BYTE                  byRes[20];      //  Reserved
}NET_DVR_HOLIDAY_RECORD, *LPNET_DVR_HOLIDAY_RECORD;

#define  MAX_LINK_V30  128

typedef struct tagNET_DVR_ONE_LINK
{
    NET_DVR_IPADDR  struIP;     // Client IP
    LONG            lChannel;   // Channel number
    BYTE            byRes[32];  // Reserved
}NET_DVR_ONE_LINK, *LPNET_DVR_ONE_LINK;

typedef struct tagNET_DVR_LINK_STATUS
{
    DWORD   dwSize;      //Structure size
    WORD    wLinkNum;    //Total number of connections
    BYTE    byRes1[2];   // Reserved
    NET_DVR_ONE_LINK struOneLink[MAX_LINK_V30];   //Information of the client connecting to the device
    BYTE    byRes[32];   // Reserved
}NET_DVR_LINK_STATUS, *LPNET_DVR_LINK_STATUS;

#define MAX_BOND_NUM  2

typedef struct tagNET_DVR_ONE_BONDING
{
    BYTE    byMode;                //Work mode: 0 - network fault tolerance, 1 - load balancing
    BYTE    byUseDhcp;            //Enable dhcp or not
    BYTE    byMasterCard;        //Assign which network card to be master card
    BYTE    byStatus;           //BONDING status: 0 - exception, 1- normal. It is read only, and it is not supported to modify
    BYTE	byBond[MAX_NETWORK_CARD];//byBond[0]== 1 means to use eh0, byBond[0]== 0 means not to use eh0
    NET_DVR_ETHERNET_V30	struEtherNet; //Ethernet parameter
    NET_DVR_IPADDR	struGatewayIpAddr;    //IP address of Gateway
    BYTE  byEnableDNS; //DNS Enabled, 0-close\A3\AC1-open
    BYTE	byRes[19];      // res
}NET_DVR_ONE_BONDING, *LPNET_DVR_ONE_BONDING;

typedef struct tagNET_DVR_NETWORK_BONDING
{
    DWORD   dwSize;         //Structure size
    BYTE    byEnable;       //Enable bonding or not
    BYTE    byNum;          //The number of bonding network cards
    BYTE    byRes1[2];      //Reserved
    NET_DVR_ONE_BONDING struOneBond[MAX_BOND_NUM];
    BYTE    byRes2[40];        //Reserved
}NET_DVR_NETWORK_BONDING, *LPNET_DVR_NETWORK_BONDING;


//Disk quota
typedef struct tagNET_DVR_DISK_QUOTA
{
    BYTE    byQuotaType;     //Disk quota: 1- by capacity of disk 2-by Ratio 3-by Time
    BYTE    byRes1[5];       //Reserved
    WORD    wStoragePeriod;  //Video storage period, the unit day, by the time when the quota is valid type
    DWORD   dwHCapacity;     //High 32 bits of the allocated disk capacity, unit:MB
    DWORD   dwLCapacity;     //Low 32 bits of the allocated disk capacity, unit:MB
    DWORD   dwHUsedSpace;    //High 32 bits of used disk capacity, unit:MB
    DWORD   dwLUsedSpace;    //Low 32 bits of used disk capacity, unit:MB
    BYTE    byQuotaRatio;    //The proportion of the allocated disk, unit:%
    BYTE    byRes2[21];      //Reserved
}NET_DVR_DISK_QUOTA, *LPNET_DVR_DISK_QUOTA;

typedef struct tagNET_DVR_DISK_QUOTA_CFG
{
    DWORD   dwSize;         //Structure size
    NET_DVR_DISK_QUOTA    struPicQuota;       //Picture quota
    NET_DVR_DISK_QUOTA    struRecordQuota;    //Record quota
    NET_DVR_DISK_QUOTA    struAddInfoQuota; //  Add Info Quota
    BYTE    byRes[12];      //Reserved
}NET_DVR_DISK_QUOTA_CFG, *LPNET_DVR_DISK_QUOTA_CFG;


typedef struct tagNET_DVR_TIMING_CAPTURE
{
    NET_DVR_JPEGPARA  struJpegPara;   //Picture quality of timing capture
    DWORD      dwPicInterval;         //Interval of timing capture, unit: s
    BYTE       byRes[12];             //Reserved
}NET_DVR_TIMING_CAPTURE, *LPNET_DVR_TIMING_CAPTURE;

typedef struct tagNET_DVR_REL_CAPTURE_CHAN
{
    BYTE    byChan[16];    //Indicated by bit
    BYTE    byRes[20];     //Reserved
}NET_DVR_REL_CAPTURE_CHAN, *LPNET_DVR_REL_CAPTURE_CHAN;

#define MAX_PIC_EVENT_NUM  32
#define MAX_ALARMIN_CAPTURE   16

typedef struct  tagNET_DVR_REL_CAPTURE_CHAN_V40
{
    DWORD   dwMaxRelCaptureChanNum;  //Associated channel number maximum can trigger (read-only  )
    DWORD   dwChanNo[MAX_CHANNUM_V40]; //Capture trigger associated channel number, according to the values, the compact arrangement, 0xFFFFFFFF said the following invalid
    BYTE     byRes[32];
}NET_DVR_REL_CAPTURE_CHAN_V40, *LPNET_DVR_REL_CAPTURE_CHAN_V40;

typedef struct tagNET_DVR_EVENT_CAPTURE_V40
{
    NET_DVR_JPEGPARA  struJpegPara;   //Picture quality of event capture
    DWORD   dwPicInterval;   //Interval of event capture, unit: s
    NET_DVR_REL_CAPTURE_CHAN_V40 struRelCaptureChan[MAX_PIC_EVENT_NUM];   ///hat array subscript = 0 means motion detection triggering capture, array subscript = 1 means video tampering triggering capture,2-video lost capture,3-PIR alarm capture,4-wireless alarm capture,5-callhelp alarm capture,6-VCA capture,7- face detetct
    NET_DVR_REL_CAPTURE_CHAN_V40 struAlarmInCapture[MAX_ALARMIN_CAPTURE];    //Alarm in triggering capture. That array subscript = 0 means the NO.1 alarm in, and so forth

    DWORD   dwMaxGroupNum;  //The maximum number of alarm input device support, each group of 16 alarm input
    BYTE      byCapTimes; //capture times
    BYTE      byRes[59];
}NET_DVR_EVENT_CAPTURE_V40, *LPNET_DVR_EVENT_CAPTURE_V40;

typedef struct tagNET_DVR_EVENT_CAPTURE
{
    NET_DVR_JPEGPARA  struJpegPara;   //Picture quality of event capture
    DWORD       dwPicInterval;        //Interval of event capture, unit: s
    NET_DVR_REL_CAPTURE_CHAN struRelCaptureChan[MAX_PIC_EVENT_NUM]; //That array subscript = 0 means motion detection triggering capture, array subscript = 1 means video tampering triggering capture,2-video lost capture,3-PIR alarm capture,4-wireless alarm capture,5-callhelp alarm capture,6-VCA capture,7- face detetct
    NET_DVR_REL_CAPTURE_CHAN struAlarmInCapture[MAX_ALARMIN_CAPTURE];    //Alarm in triggering capture. That array subscript = 0 means the NO.1 alarm in, and so forth
    BYTE       byCapTimes; //capture times
    BYTE       byRes[59];
}NET_DVR_EVENT_CAPTURE, *LPNET_DVR_EVENT_CAPTURE;

typedef struct tagNET_DVR_JPEG_CAPTURE_CFG
{
    DWORD      dwSize;         //Structure size
    NET_DVR_TIMING_CAPTURE struTimingCapture;
    NET_DVR_EVENT_CAPTURE struEventCapture;
    BYTE       byStreamType;
    BYTE       byRes3[19];     // Reserved
}NET_DVR_JPEG_CAPTURE_CFG, *LPNET_DVR_JPEG_CAPTURE_CFG;

typedef struct tagNET_DVR_JPEG_CAPTURE_CFG_V40
{
    DWORD                             dwSize;
    NET_DVR_TIMING_CAPTURE        struTimingCapture;
    NET_DVR_EVENT_CAPTURE_V40    struEventCapture;
    BYTE       byStreamType;
    BYTE       byRes3[19];
}NET_DVR_JPEG_CAPTURE_CFG_V40, *LPNET_DVR_JPEG_CAPTURE_CFG_V40;

typedef struct tagNET_DVR_CAPTURE_DAY
{
    BYTE    byAllDayCapture;    //Enable all-day capture or not
    BYTE    byCaptureType;        //Capture type: 0- scheduled capture, 1- motion detection capture, 2- alarm capture, 3- motion detection | alarm capture, 4- motion detection & alarm capture, 6- intelligent alarm capture
    BYTE    byRes[2];
}NET_DVR_CAPTURE_DAY, *LPNET_DVR_CAPTURE_DAY;

typedef struct tagNET_DVR_CAPTURE_SCHED
{
    NET_DVR_SCHEDTIME struCaptureTime;  //Time segment
    BYTE        byCaptureType;          //Capture type: 0- scheduled capture, 1- motion detection capture, 2- alarm capture, 3- motion detection | alarm capture, 4- motion detection & alarm capture, 6- intelligent alarm capture
    BYTE        byRes[3];               //Reserved
}NET_DVR_CAPTURE_SCHED, *LPNET_DVR_CAPTURE_SCHED;

// Channel capture scheme
typedef struct tagNET_DVR_SCHED_CAPTURECFG
{
    DWORD  dwSize;     //Structure size
    BYTE    byEnable;    //Capture or not
    BYTE    byRes1[3];    // Reserved
    NET_DVR_CAPTURE_DAY    struCaptureDay[MAX_DAYS];    //All-day capture
    NET_DVR_CAPTURE_SCHED    struCaptureSched[MAX_DAYS][MAX_TIMESEGMENT_V30];    //Capture schedule
    NET_DVR_CAPTURE_DAY    struCaptureHoliday;            //Holiday capture schedule
    NET_DVR_CAPTURE_SCHED    struHolidaySched[MAX_TIMESEGMENT_V30];    //Holiday schedule
    DWORD    dwRecorderDuration;    //Max keeping time for captured pictures, unit: day. 0xffffffff means the value is invalid
    BYTE    byRes[40];            // Reserved
}NET_DVR_SCHED_CAPTURECFG, *LPNET_DVR_SCHED_CAPTURECFG;

typedef struct tagNET_DVR_FLOW_TEST_PARAM
{
    DWORD  dwSize;             //Structure size
    LONG   lCardIndex;         //NIC index
    DWORD  dwInterval;         //Uploading time interval, unit: 100 ms
    BYTE   byRes[8];           //Reserved
}NET_DVR_FLOW_TEST_PARAM, *LPNET_DVR_FLOW_TEST_PARAM;

typedef struct tagNET_DVR_FLOW_INFO
{
    DWORD  dwSize;             //Structure size
    DWORD  dwSendFlowSize;     //Size of sending flow, unit: kbps
    DWORD  dwRecvFlowSize;     //Size of receiving flow, unit: kbps
    BYTE   byRes[20];          //Reserved
}NET_DVR_FLOW_INFO, *LPNET_DVR_FLOW_INFO;

//Record label
#define LABEL_NAME_LEN 40
typedef struct tagNET_DVR_RECORD_LABEL
{
    DWORD  dwSize;                        //Structure size
    NET_DVR_TIME  struTimeLabel;        //Label time
    BYTE    byQuickAdd;                    //Whether quickly add label. Label name is invalid when quickly adding
    BYTE    byRes1[3];                    //Reserved
    BYTE    sLabelName[LABEL_NAME_LEN];    //Label name. Its length is 40 bytes
    BYTE    byRes2[40];                    //Reserved
}NET_DVR_RECORD_LABEL, *LPNET_DVR_RECORD_LABEL;

#define  LABEL_IDENTIFY_LEN     64
typedef struct tagNET_DVR_LABEL_IDENTIFY
{
    BYTE    sLabelIdentify[LABEL_IDENTIFY_LEN];    // 64 bytes identify
    BYTE    byRes[8];               // Reserved
}NET_DVR_LABEL_IDENTIFY, *LPNET_DVR_LABEL_IDENTIFY;

#define MAX_DEL_LABEL_IDENTIFY  20// Max number of label identifies to be deleted

typedef struct tagNET_DVR_DEL_LABEL_PARAM
{
    DWORD   dwSize;       //Structure size
    BYTE    byMode;          //Expressed by bit, 0x01 means deleting by identify
    BYTE    byRes1;
    WORD    wLabelNum;      //Total number of labels
    NET_DVR_LABEL_IDENTIFY struIndentify[MAX_DEL_LABEL_IDENTIFY]; //Label identify
    BYTE    byRes2[160];   //Reserved
}NET_DVR_DEL_LABEL_PARAM, *LPNET_DVR_DEL_LABEL_PARAM;

typedef struct tagNET_DVR_MOD_LABEL_PARAM
{
    NET_DVR_LABEL_IDENTIFY struIndentify; //Label identify to be modified
    BYTE byRes1[24];
    BYTE sLabelName[LABEL_NAME_LEN];    //Modified label name
    BYTE byRes2[40];
}NET_DVR_MOD_LABEL_PARAM, *LPNET_DVR_MOD_LABEL_PARAM;

//Record label searching structure
typedef struct tagNET_DVR_FIND_LABEL
{
    DWORD       dwSize;                     //Structure size
    LONG        lChannel;                    //Searching channel
    NET_DVR_TIME    struStartTime;           //Start time
    NET_DVR_TIME    struStopTime;            //End time
    BYTE        sLabelName[LABEL_NAME_LEN];    //Record label name. If the name is NULL, it will search all labels in the set period
    BYTE        byDrawFrame;        //0:not draw frame\A3\AC1\A3\BAdraw frame
    BYTE        byRes[39];                    //Reserved
}NET_DVR_FIND_LABEL, *LPNET_DVR_FIND_LABEL;

//Label information structure
typedef struct tagNET_DVR_FINDLABEL_DATA
{
    BYTE    sLabelName[LABEL_NAME_LEN];          //Label name
    NET_DVR_TIME struTimeLabel;                  //Label time
    NET_DVR_LABEL_IDENTIFY struLabelIdentify; //Label identify
    BYTE    byRes1[32];                          //Reserved
}NET_DVR_FINDLABEL_DATA, *LPNET_DVR_FINDLABEL_DATA;

#define CARDNUM_LEN_V30 40
//country enum
typedef enum _COUNTRY_INDEX_
{
    COUNTRY_NONSUPPORT = 0,   //0-not support
    /*235 */
    /*48*/
            COUNTRY_CZE = 1, //Czech Republic
    COUNTRY_FRA = 2, //France
    COUNTRY_DEU = 3, //Germany
    COUNTRY_ESP = 4, //Spain
    COUNTRY_ITA = 5, //Italy
    COUNTRY_NLD = 6, //Netherlands
    COUNTRY_POL = 7, //Poland
    COUNTRY_SVK = 8, //Slovakia
    COUNTRY_BLR = 9, //Belarus
    COUNTRY_MDA = 10, //Moldova
    COUNTRY_RUS = 11, //Russia
    COUNTRY_UKR = 12, //Ukraine
    COUNTRY_BEL = 13, //Belgium
    COUNTRY_BGR = 14, //Bulgaria
    COUNTRY_DNK = 15, //Denmark
    COUNTRY_FIN = 16, //Finland
    COUNTRY_GBR = 17, //Great Britain
    COUNTRY_GRC = 18, //Greece
    COUNTRY_HRV = 19, //Croatia
    COUNTRY_HUN = 20, //Hungary
    COUNTRY_ISR = 21, //Israel
    COUNTRY_LUX = 22, //Luxembourg
    COUNTRY_MKD = 23, //Macedonia
    COUNTRY_NOR = 24, //Norway
    COUNTRY_PRT = 25, //Portuga
    COUNTRY_ROU = 26, //Romania
    COUNTRY_SRB = 27, //Serbia
    COUNTRY_AZE = 28, //Azerbaijan
    COUNTRY_GEO = 29, //Georgia
    COUNTRY_KAZ = 30, //Kazakhstan
    COUNTRY_LTU = 31, //Lithuania
    COUNTRY_TKM = 32, //Turkmenistan
    COUNTRY_UZB = 33, //Uzbekistan
    COUNTRY_LVA = 34, //Latvia
    COUNTRY_EST = 35, //Estonia
    COUNTRY_ALB = 36, //Albania
    COUNTRY_AUT = 37, //Austria
    COUNTRY_BIH = 38, //Bosnia and Herzegovina
    COUNTRY_IRL = 39, //Ireland
    COUNTRY_ISL = 40, //Iceland
    COUNTRY_VAT = 41, //Vatican
    COUNTRY_MLT = 42, //Malta
    COUNTRY_SWE = 43, //Sweden
    COUNTRY_CHE = 44, //Switzerland
    COUNTRY_CYP = 45, //Cyprus
    COUNTRY_TUR = 46, //Turkey
    COUNTRY_SVN = 47, //Slovenia
    COUNTRY_MTG = 48, //Montenegro
    COUNTRY_KOV = 49, //Kosovo
    COUNTRY_ADR = 50, //Andorra
    COUNTRY_ARM = 51, //Armenia
    COUNTRY_MON = 52, //Monaco
    COUNTRY_LIE = 53, //Liechtenstein
    COUNTRY_SMO = 54, //San Marino
    COUNTRY_RES1 = 55, //Res
    COUNTRY_RES2 = 56, //Res
    COUNTRY_RES3 = 57, //Res
    COUNTRY_RES4 = 58, //Res

    /*48*/
            COUNTRY_CHI = 59, //China
    COUNTRY_IBN = 60, //In bahrain
    COUNTRY_SKR = 61, //South Korea
    COUNTRY_LEB = 62, //Lebanon
    COUNTRY_NEP = 63, //Nepal
    COUNTRY_THA = 64, //Thailand
    COUNTRY_PAK = 65, //Pakistan
    COUNTRY_EMI = 66, //The united Arab emirates
    COUNTRY_BHU = 67, //Bhutan
    COUNTRY_OMA = 68, //Oman
    COUNTRY_KOR = 69, //North Korea
    COUNTRY_PHI = 70, //The Philippines
    COUNTRY_CAM = 71, //Cambodia
    COUNTRY_QAT = 72, //Qatar
    COUNTRY_KYR = 73, //Kyrgyzstan
    COUNTRY_MAL = 74, //The maldives
    COUNTRY_MLY = 75, //Malaysia
    COUNTRY_MOG = 76, //Mongolia
    COUNTRY_ARA = 77, //Saudi Arabia
    COUNTRY_BRU = 78, //brunei
    COUNTRY_LAO = 79, //Laos
    COUNTRY_JAP = 80, //Japan
    COUNTRY_RES19 = 81, //Res
    COUNTRY_PAS = 82, //Palestinian state
    COUNTRY_TAJ = 83, //Tajikistan
    COUNTRY_KUW = 84, //Kuwait
    COUNTRY_SYR = 85, //Syria
    COUNTRY_IND = 86, //India
    COUNTRY_ISA = 87, //Indonesia
    COUNTRY_AFG = 88, //Afghanistan
    COUNTRY_LAN = 89, //Sri Lanka
    COUNTRY_IRQ = 90, //Iraq
    COUNTRY_VIE = 91, //Vietnam
    COUNTRY_IRA = 92, //Iran
    COUNTRY_YEM = 93, //yemen
    COUNTRY_JOR = 94, //Jordan
    COUNTRY_BUR = 95, //Burma
    COUNTRY_SIK = 96, //Sikkim
    COUNTRY_BAN = 97, //Bangladesh
    COUNTRY_SGA = 98, //Singapore
    COUNTRY_EAT = 99, //East timor
    COUNTRY_RES5 = 100, //Res
    COUNTRY_RES6 = 101, //Res
    COUNTRY_RES7 = 102, //Res
    COUNTRY_RES8 = 103, //Res

    /*60*/
            COUNTRY_EGT = 104, //Egypt
    COUNTRY_LIY = 105, //Libya
    COUNTRY_SUA = 106, //Sudan
    COUNTRY_TUN = 107, //Tunisia
    COUNTRY_ALG = 108, //Algeria
    COUNTRY_MCC = 109, //Morocco
    COUNTRY_ETH = 110, //Ethiopia
    COUNTRY_ERI = 111, //Eritrea
    COUNTRY_SDE = 112, //Somalia Democratic
    COUNTRY_DJI = 113, //Djibouti
    COUNTRY_KEN = 114, //Kenya
    COUNTRY_TAI = 115, //Tanzania
    COUNTRY_UGA = 116, //Uganda
    COUNTRY_RWA = 117, //Rwanda
    COUNTRY_BUD = 118, //Burundi
    COUNTRY_SEY = 119, //Seychelles
    COUNTRY_CHA = 120, //Chad
    COUNTRY_CEA = 121, //Central African
    COUNTRY_CON = 122, //Cameroon
    COUNTRY_EQG = 123, //Equatorial Guinea
    COUNTRY_GAB = 124, //Gabon
    COUNTRY_TCO = 125, //the Congo
    COUNTRY_DRC = 126, //Democratic Republic of the Congo
    COUNTRY_STP = 127, //Sao Tome and Principe
    COUNTRY_MAN = 128, //Mauritania
    COUNTRY_WSA = 129, //Western Sahara
    COUNTRY_SEL = 130, //Senegal
    COUNTRY_TGA = 131, //the Gambia
    COUNTRY_MAI = 132, //Mali
    COUNTRY_BUF = 133, //Burkina Faso
    COUNTRY_GUI = 134, //Guinea
    COUNTRY_GUB = 135, //Guinea-Bissau
    COUNTRY_CAV = 136, //Cape Verde
    COUNTRY_SLE = 137, //Sierra Leone
    COUNTRY_LIR = 138, //Liberia
    COUNTRY_IVC = 139, //Ivory Coast
    COUNTRY_GHA = 140, //Ghana
    COUNTRY_TGO = 141, //Togo
    COUNTRY_BEN = 142, //Benin
    COUNTRY_NIG = 143, //Niger
    COUNTRY_ZAB = 144, //Zambia
    COUNTRY_ANG = 145, //Angola
    COUNTRY_ZBE = 146, //Zimbabwe
    COUNTRY_MAW = 147, //Malawi
    COUNTRY_MOQ = 148, //Mozambique
    COUNTRY_BOT = 149, //Botswana
    COUNTRY_NAM = 150, //Namibia
    COUNTRY_SAF = 151, //South Africa
    COUNTRY_SWD = 152, //Swaziland
    COUNTRY_LES = 153, //Lesotho
    COUNTRY_MAG = 154, //Madagasca
    COUNTRY_UOC = 155, //Union of Comoros
    COUNTRY_MAT = 156, //Mauritius
    COUNTRY_NGE = 157, //Nigeria
    COUNTRY_SSD = 158, //South Sudan
    COUNTRY_SAH = 159, //Saint Helena
    COUNTRY_MYT = 160, //Mayotte
    COUNTRY_REN = 161, //Reunion
    COUNTRY_CAI = 162, //Canary
    COUNTRY_AZO = 163, //AZORES
    COUNTRY_MAD = 164, //Madeira
    COUNTRY_RES9 = 165, //Res
    COUNTRY_RES10 = 166, //Res
    COUNTRY_RES11 = 167, //Res
    COUNTRY_RES12 = 168, //Res

    /*55*/
            COUNTRY_CAD = 169, //Canada
    COUNTRY_GRE = 170, //Greenland Nuuk
    COUNTRY_PIE = 171, //Pierre and Miquelon
    COUNTRY_USA = 172, //United States
    COUNTRY_BER = 173, //Bermuda
    COUNTRY_MEX = 174, //Mexico
    COUNTRY_GUA = 175, //Guatemala
    COUNTRY_BLI = 176, //Belize
    COUNTRY_SAR = 177, //El Salvador
    COUNTRY_HOR = 178, //Honduras
    COUNTRY_NIC = 179, //Nicaragua
    COUNTRY_COR = 180, //Costa Rica
    COUNTRY_PAN = 181, //Panama
    COUNTRY_TBM = 182, //The Bahamas
    COUNTRY_TCI = 183, //The Turks and Caicos Islands
    COUNTRY_CUB = 184, //Cuba
    COUNTRY_JAM = 185, //Jamaica
    COUNTRY_CAY = 186, //Cayman Islands
    COUNTRY_HAT = 187, //Haiti
    COUNTRY_TDO = 188, //The Dominican
    COUNTRY_PUR = 189, //Puerto Rico
    COUNTRY_VIL = 190, //The United States Virgin Islands
    COUNTRY_BVI = 191, //The British Virgin Islands
    COUNTRY_ATV = 192, //Anguilla The Valley
    COUNTRY_ANB = 193, //Antigua and Barbuda
    COUNTRY_CSM = 194, //Collectivit\A8\A6 de Saint-Martin
    COUNTRY_ACY = 195, //Autonomous country
    COUNTRY_SBY = 196, //Saint-Barth\A8\A6lemy
    COUNTRY_SKN = 197, //Saint Kitts and Nevis
    COUNTRY_MOT = 198, //Montserrat
    COUNTRY_GLP = 199, //Guadeloupe
    COUNTRY_DOM = 200, //Dominica
    COUNTRY_MTE = 201, //Martinique
    COUNTRY_LUC = 202, //St. Lucia
    COUNTRY_SVG = 203, //Saint Vincent and the Grenadines
    COUNTRY_GRD = 204, //Grenada
    COUNTRY_BAR = 205, //Barbados
    COUNTRY_TRT = 206, //Trinidad and Tobago
    COUNTRY_CUR = 207, //Curacao
    COUNTRY_ARB = 208, //Aruba
    COUNTRY_NEA = 209, //Netherlands Antilles
    COUNTRY_COL = 210, //Colombia
    COUNTRY_VEN = 211, //Venezuela
    COUNTRY_GUY = 212, //Guyana
    COUNTRY_SUR = 213, //Suriname
    COUNTRY_FRN = 214, //Guyane Francaise
    COUNTRY_ECU = 215, //Ecuador
    COUNTRY_PER = 216, //Peru
    COUNTRY_BOL = 217, //Bolivia
    COUNTRY_PAR = 218, //Paraguay
    COUNTRY_CLE = 219, //Chile
    COUNTRY_BRA = 220, //Brazil
    COUNTRY_UGY = 221, //Uruguay
    COUNTRY_ARG = 222, //Argentina
    COUNTRY_RES13 = 223, //Res
    COUNTRY_RES14 = 224, //Res
    COUNTRY_RES15 = 225, //Res
    COUNTRY_RES16 = 226, //Res

    /*25*/
            COUNTRY_ATN = 227, //Australien
    COUNTRY_NED = 228, //Neuseeland
    COUNTRY_PNG = 229, //Papua New Guinea
    COUNTRY_SAN = 230, //Salomonen
    COUNTRY_VAU = 231, //Vanuatu
    COUNTRY_NCN = 232, //New Caledonia
    COUNTRY_PAU = 233, //Palau
    COUNTRY_FSM = 234, //Federated States of Micronesia
    COUNTRY_MRI = 235, //Marshall Island
    COUNTRY_CNM = 236, //Commonwealth of the Northern Mariana Islands
    COUNTRY_TEG = 237, //The Territory of Guahan
    COUNTRY_NUR = 238, //Nauru
    COUNTRY_KIB = 239, //Kiribati
    COUNTRY_FID = 240, //Fidschi
    COUNTRY_TNG = 241, //Tonga
    COUNTRY_TUV = 242, //Tuvalu
    COUNTRY_WEF = 243, //Wallis et Futuna
    COUNTRY_TIS = 244, //The Independent State of Samoa
    COUNTRY_EAS = 245, //Eastern Samoa
    COUNTRY_TOE = 246, //Tokelau
    COUNTRY_NUE = 247, //Niue
    COUNTRY_TCD = 248, //The Cook Islands
    COUNTRY_PFP = 249, //Polyn\A8\A6sie francaiseFrench Polynesia
    COUNTRY_PID = 250, //Pitcairn Islands
    COUNTRY_HAW = 251, //Hawaii State
    COUNTRY_RES17 = 252, //Res
    COUNTRY_RES18 = 253, //Res
    COUNTRY_UNRECOGNIZED = 0xfe, //Unrecognized
    COUNTRY_ALL = 0xff, //ALL
}COUNTRY_INDEX;
typedef struct tagNET_DVR_FIND_PICTURE_PARAM
{
    DWORD  dwSize;         //Structure size
    LONG   lChannel;       //Channel number
    BYTE   byFileType;     //Image type to search: 0- scheduled capture, 1- motion detection capture, 2- alarm capture, 3- motion detection or alarm capture, 3-motion detection and alarm capture, 6- manual capture, 9-VCA, 0x0d facedetect\A3\AC0xe NULL\A3\ACOxf field detection\A3\AC0x25-face snap,0xff- all types
    BYTE   byNeedCard;     //Whether need card number
    BYTE   byProvince;     //Province
    BYTE   byRes;
    BYTE   sCardNum[CARDNUM_LEN_V30];     //Card number
    NET_DVR_TIME  struStartTime;//Start time of image search
    NET_DVR_TIME  struStopTime;//End time of image search
    //ITC3.7 Newly added
    DWORD    dwTrafficType; //Image retrieval; Reference  VCA_OPERATE _TYPE
    DWORD    dwVehicleType; //Vehicle Type; Reference VCA_VEHICLE_TYPE
    //Illegal Type; Reference VCA_ILLEGAL_TYPE ;Not support check
    DWORD    dwIllegalType;
    BYTE     byLaneNo;  //Lane No. (1~99)
    BYTE     bySubHvtType ;//0- retention, 1- vehiclem, 2- Non-Motor Vehicle, 3- Pedestrians
    BYTE     byRes2[2];
    char     sLicense[MAX_LICENSE_LEN/*16*/];    //License No
    BYTE     byRegion;     //Region index value, 0 reserved, 1 Europe, 2 Russia(Russian regions), 3-EU&&CIS,0xff- all
    BYTE     byCountry;     // Country INdex ,Reference\A3\BACOUNTRY_INDEX
    BYTE     byRes3[6];
}NET_DVR_FIND_PICTURE_PARAM, *LPNET_DVR_FIND_PICTURE_PARAM;

#define PICTURE_NAME_LEN 64

typedef struct
{
    char    sFileName[PICTURE_NAME_LEN];//Picture name
    NET_DVR_TIME struTime;              //Time of picture capture
    DWORD dwFileSize;                   //Picture size
    char    sCardNum[CARDNUM_LEN_V30];    //Card number
    BYTE   byPlateColor ;               //Reference  VCA_PLATE_COLOR
    BYTE   byVehicleLogo;               //Reference  VLR_VEHICLE_CLASS
    BYTE   byEventSearchStatus; //0-back without pic info,1-next with pic info
    BYTE   byRecogResult ;//Recog RESULT
    char   sLicense[MAX_LICENSE_LEN/*16*/];    //Car Liscense
    BYTE   byRes[12];
}NET_DVR_FIND_PICTURE,*LPNET_DVR_FIND_PICTURE;

#define MAX_RECORD_PICTURE_NUM  50      //  Max number of backup pictures

typedef struct tagNET_DVR_BACKUP_PICTURE_PARAM
{
    DWORD  dwSize;         //Structure size
    DWORD  dwPicNum;
    NET_DVR_FIND_PICTURE struPicture[MAX_RECORD_PICTURE_NUM];
    BYTE   byDiskDes[DESC_LEN_32];
    BYTE   byWithPlayer;
    BYTE   byContinue;    /*Whether continue to backup or not: 0-no, 1-yes*/
    BYTE   byRes[34];
}NET_DVR_BACKUP_PICTURE_PARAM, *LPNET_DVR_BACKUP_PICTURE_PARAM;

typedef struct
{
    DWORD dwSize;           //Structure size
    DWORD dwChannel;        //Channel number
    BYTE  byCompressType;   //Compression type to be got: 1- main stream, 2- sub stream, 3- event
    BYTE  byRes[15];        //Reserved
    NET_DVR_COMPRESSIONCFG_V30  struCurrentCfg; //Current compression configuration
}NET_DVR_COMPRESSION_LIMIT, *LPNET_DVR_COMPRESSION_LIMIT;

#define   STEP_READY       0    //Ready to upgrade
#define   STEP_RECV_DATA   1    //Receive upgrade package data
#define   STEP_UPGRADE     2    //Upgrade system
#define   STEP_BACKUP      3    //Backup system
#define   STEP_SEARCH      255  //Search upgrade file

typedef struct tagNET_DVR_VIDEO_EFFECT
{
    DWORD dwBrightValue;      //Brightness value[0,255]
    DWORD dwContrastValue;    //Contrast value[0,255]
    DWORD dwSaturationValue;  //Saturation value[0,255]
    DWORD dwHueValue;         //Hue value[0,255]
    DWORD dwSharpness;          //Sharpness[0,255]
    DWORD dwDenoising;          //Denoising[0,255]
    BYTE  byRes[12];
}NET_DVR_VIDEO_EFFECT, *LPNET_DVR_VIDEO_EFFECT;

typedef struct tagNET_DVR_VIDEO_INPUT_EFFECT
{
    DWORD                    dwSize;             //Structure size
    WORD                    wEffectMode;        //Mode: 0-Standard, 1-In door,  2-Dim light, 3-Out door,  255-customized
    BYTE                    byRes1[146];        //Reserved
    NET_DVR_VIDEO_EFFECT    struVideoEffect;    //Video effect
    BYTE                    byRes2[60];         //Reserved
}NET_DVR_VIDEO_INPUT_EFFECT, *LPNET_DVR_VIDEO_INPUT_EFFECT;

typedef struct tagNET_DVR_VIDEOPARA_V40
{
    DWORD    dwChannel;            // Channel number
    DWORD    dwVideoParamType;      // Video param type 0-bright 1-contrast 2-saturation 3-hue 4-sharpness 5-denoising
    DWORD    dwVideoParamValue;  // Video param value
    BYTE     byRes[12];
}NET_DVR_VIDEOPARA_V40, *LPNET_DVR_VIDEOPARA_V40;

typedef struct tagNET_DVR_DEFAULT_VIDEO_COND
{
    DWORD    dwSize;
    DWORD    dwChannel;
    DWORD    dwVideoMode;
    BYTE    byRes[32];
}NET_DVR_DEFAULT_VIDEO_COND, *LPNET_DVR_DEFAULT_VIDEO_COND;

/*********************************9000 2.0 end***************************************/

typedef struct tagNET_DVR_ENCODE_JOINT_PARAM
{
    DWORD    dwSize;            //Structure size
    BYTE    byJointed;        //0- not associated  1- associated
    BYTE    byDevType;        //Associated device type, 1- intelligent device
    BYTE    byRes1[2];        //Reserved
    NET_DVR_IPADDR    struIP;    //IP address of associated device to be taken stream
    WORD    wPort;            //Port of associated device to be taken stream
    WORD    wChannel;        //Associated device channel to be taken stream
    BYTE    byRes2[20];        //Reserved
}NET_DVR_ENCODE_JOINT_PARAM, *LPNET_DVR_ENCODE_JOINT_PARAM;

typedef struct tagNET_DVR_VCA_CHAN_WORKSTATUS
{
    BYTE    byJointed;                //0- not associated  1- associated
    BYTE    byRes1[3];
    NET_DVR_IPADDR    struIP;            //IP address of associated device to take stream
    WORD    wPort;                    //Port of associated device to take stream
    WORD    wChannel;                //Associated device channel to take stream
    BYTE    byVcaChanStatus;        //0 - disable, 1 - enable
    BYTE    byRes2[19];                //Reserved
}NET_DVR_VCA_CHAN_WORKSTATUS, *LPNET_DVR_VCA_CHAN_WORKSTATUS;

typedef struct tagNET_DVR_VCA_DEV_WORKSTATUS
{
    DWORD    dwSize;            //Structure size
    BYTE    byDeviceStatus;    //Device status: 0- normal, 1- abnormal
    BYTE    byCpuLoad;        //CPU usage: 0-100 means percentage
    NET_DVR_VCA_CHAN_WORKSTATUS struVcaChanStatus[MAX_VCA_CHAN];
    DWORD    dwRes[40];        // Reserved
}NET_DVR_VCA_DEV_WORKSTATUS, *LPNET_DVR_VCA_DEV_WORKSTATUS;

/*****************************65dvs**************************************/
typedef struct tagNET_DVR_HISTORICDATACFG
{
    DWORD dwSize;
    DWORD dwTotalNum;  //History data total number
    BYTE byRes[16];
}NET_DVR_HISTORICDATACFG, *LPNET_DVR_HISTORICDATACFG;
/************************************************************************/

/********************************Thermal Imager********************************/
typedef struct tagNET_DVR_CORRECT_DEADPIXEL_PARAM
{
    DWORD dwSize;
    DWORD dwCommand; //Command: 0- enter bad point  mode, 1- add bad point, 2- save bad point, 3- exit bad point
    DWORD dwDeadPixelX; //X coordinate of bad point
    DWORD dwDeadPixelY; //Y coordinate of bad point
    BYTE byRes[12]; //Reserved
}NET_DVR_CORRECT_DEADPIXEL_PARAM, *LPNET_DVR_CORRECT_DEADPIXEL_PARAM;

#define MAX_REDAREA_NUM   6

typedef struct tagNET_DVR_CORRECT_PARAMS
{
    BYTE byYellowIntervalTime;
    BYTE byDigTrafficLight;
    BYTE byRes[2];
}NET_DVR_CORRECT_PARAMS,*LPNET_DVR_CORRECT_PARAMS;

typedef struct tagNET_DVR_REDAREACFG
{
    DWORD dwSize;
    DWORD dwCorrectEnable;
    DWORD dwCorrectLevel;
    DWORD dwAreaNum;
    NET_VCA_RECT struLaneRect[MAX_REDAREA_NUM];
    NET_DVR_CORRECT_PARAMS struCorrectParam[MAX_REDAREA_NUM/*6*/];
    BYTE   byRes2[8];
}NET_DVR_REDAREACFG, *LPNET_DVR_REDAREACFG;

/********************************Thermal Imager end****************************/

/***********************************81 Inquest DVR*****************************/
#define INQUEST_MESSAGE_LEN     44    //Length of inquest key tag message
#define INQUEST_MAX_ROOM_NUM    2     //Max number of inquest rooms
#define MAX_RESUME_SEGMENT      2     //Number of segments supported to resume simultaneously

typedef struct tagNET_DVR_INQUEST_ROOM
{
    BYTE        byRoomIndex;     //Inquest room index
    BYTE        byFileType;
    BYTE        byRes[22];       //Reserved
}NET_DVR_INQUEST_ROOM, *LPNET_DVR_INQUEST_ROOM;

typedef struct tagNET_DVR_INQUEST_MESSAGE
{
    char     sMessage[INQUEST_MESSAGE_LEN]; //Key marker information
    BYTE    byRes[46];                     //Reserved
}NET_DVR_INQUEST_MESSAGE, *LPNET_DVR_INQUEST_MESSAGE;

typedef struct tagNET_DVR_INQUEST_SENSOR_DEVICE
{
    WORD    wDeviceType;    //Data collection device type: 1: Mera, 2:Leicai, 3:Leicai
    WORD    wDeviceAddr;    //Data collection device address
    BYTE     byRes[28];        //Reserved
}NET_DVR_INQUEST_SENSOR_DEVICE, *LPNET_DVR_INQUEST_SENSOR_DEVICE;

typedef struct tagNET_DVR_INQUEST_SENSOR_INFO
{
    NET_DVR_INQUEST_SENSOR_DEVICE struSensorDevice[INQUEST_MAX_ROOM_NUM];
    DWORD   dwSupportPro;      //Supported protocol type, described by bit
    //0x1:Mera, 0x2:Leicai, 0x4:Youli
    BYTE    byRes[120];        //Reserved
}NET_DVR_INQUEST_SENSOR_INFO, *LPNET_DVR_INQUEST_SENSOR_INFO;

typedef struct tagNET_DVR_INQUEST_ROOM_INFO
{
    char        szCDName[NAME_LEN];    //cd name
    union
    {
        BYTE     byBitRate;
        BYTE    byInquestTime;
    }uCalcMode;
    BYTE        byCalcType;            //0-Bit 1-time
    BYTE        byAutoDelRecord;    // Auto del record 0-not del\A3\AC1-del
    BYTE        byAlarmThreshold;        // Alarm threshold
    BYTE        byInquestChannelResolution;     //0:720P,1:1080P,2:CIF,3:4CIF,4:WD1,5-VGA
    BYTE        byAutoOpenTray;        //Whether automatic open tray 0 - no, 1 - yes
    BYTE        byRes[10];
}NET_DVR_INQUEST_ROOM_INFO, *LPNET_DVR_INQUEST_ROOM_INFO;

typedef struct tagNET_DVR_INQUEST_SYSTEM_INFO
{
    DWORD    dwRecordMode;         //Burning mode: 1 Single room and double burned mode, 2- Single room and round burned mode, 3- double room and double burned mode
    DWORD    dwWorkMode;           //Working mode: 0- standard mode, 1- general mode
    DWORD    dwResolutionMode;     //Device resolution, 0: standard definition 1:D1 2:720P 3:1080P
    NET_DVR_INQUEST_SENSOR_INFO struSensorInfo;  //Temperature and humidity sensor configuration
    NET_DVR_INQUEST_ROOM_INFO     struInquestRoomInfo[INQUEST_MAX_ROOM_NUM];
    BYTE    byEnableHashCheck;        //enable HASH check or not, 0-invalid\A3\AC1-disable\A3\AC2-enable
    BYTE    byEnableInitCD;        //enable initial disk or not, 0-invalid\A3\AC1-disable\A3\AC2-enable
    BYTE    byRes[22];             //Reserved
}NET_DVR_INQUEST_SYSTEM_INFO, *LPNET_DVR_INQUEST_SYSTEM_INFO;

typedef struct tagNET_DVR_INQUEST_RESUME_SEGMENT
{
    NET_DVR_TIME  struStartTime; //Start time of event
    NET_DVR_TIME  struStopTime;  //End time of event
    BYTE    byRoomIndex;         //Inquest room index, start from 1
    BYTE    byDriveIndex;        //Burner index, start from 1
    WORD    wSegmetSize;         //Segment size, unit:M
    DWORD   dwSegmentNo;         //Segment number of this inquest event, start from 1
    BYTE    byRes[24];           //Reserved
}NET_DVR_INQUEST_RESUME_SEGMENT, *LPNET_DVR_INQUEST_RESUME_SEGMENT;

typedef struct _NET_DVR_TRAY_ABNORMAL_ALARM_
{
    DWORD dwSize;
    DWORD dwAlarmType;    /*Alarm type 0-tray full 1-tray error*/
    BYTE byTrayNo;     /*Tray No.*/
    BYTE byRes[255];
}NET_DVR_INQUEST_ALARM, *LPNET_DVR_TRAY_ABNORMAL_ALARM;

typedef struct tagNET_DVR_INQUEST_RESUME_EVENT
{
    DWORD   dwResumeNum;       //Number of events requiring to be resumed
    NET_DVR_INQUEST_RESUME_SEGMENT struResumeSegment[MAX_RESUME_SEGMENT];
    BYTE    byResumeMode;
    BYTE    byRes[199];        //Reserved
}NET_DVR_INQUEST_RESUME_EVENT, *LPNET_DVR_INQUEST_RESUME_EVENT;

typedef struct tagNET_DVR_INQUEST_DEVICE_VERSION
{
    BYTE  byMainVersion;         /* Baseline major version
                                   0 : unknown
                                   1 : 8000 inquest DVR
                                       minor version: 1 : 8000HD-S
                                   2 : 8100 inquest DVR
                                       minor version: 1 : inquest 81SNL
                                                      2 : inquest 81SH
                                                      3 : inquest 81SFH
                                   3 : 8608 NVR
                                       minor version: 1 : DS-8608SN-SP
                                                      2 : DS-8608SN-ST
                                 */
    BYTE  bySubVersion;          //Baseline minor version
    BYTE  byUpgradeVersion;      //Upgrade version, it is 0 if have not upgraded
    BYTE  byCustomizeVersion;    //Customized version, it is 0 if the device is not customized
    BYTE  byRes[60];             //Reserved
}NET_DVR_INQUEST_DEVICE_VERSION, *LPNET_DVR_INQUEST_DEVICE_VERSION;

/***********************************81 Inquest DVR*****************************/


typedef struct tagNET_DVR_DISK_RAID_INFO
{
    DWORD dwSize;       //Structure length
    BYTE byEnable;      //Is enbale of disk raid.
    BYTE bySleepStatus;
    BYTE byRes[34];     //reserved
}NET_DVR_DISK_RAID_INFO, *LPNET_DVR_DISK_RAID_INFO;

typedef struct tagNET_DVR_SYNCHRONOUS_IPC
{
    DWORD dwSize;    //Structure length
    BYTE  byEnable;  //Do synchronize IPC.
    BYTE  byRes[7];  //reserved
}NET_DVR_SYNCHRONOUS_IPC, *LPNET_DVR_SYNCHRONOUS_IPC;

typedef struct tagNET_DVR_IPC_PASSWD
{
    DWORD dwSize;    //Structure length
    char sOldPasswd[PASSWD_LEN];  //the old passward of IPC.
    char sNewPasswd[PASSWD_LEN];  //the new passward of IPC
    BYTE byRes[32];               //reserved
}NET_DVR_IPC_PASSWD, *LPNET_DVR_IPC_PASSWD;

//Get the using information of device net. (bps)
typedef struct tagNET_DEVICE_NET_USING_INFO
{
    DWORD dwSize;      //Structure length
    DWORD dwPreview;   //preview
    DWORD dwPlayback;  //playback
    DWORD dwIPCModule; //IPC
    DWORD dwNetDiskRW; //net disk reading or writing.
    BYTE res[32];      //reserved
}NET_DVR_DEVICE_NET_USING_INFO, *LPNET_DVR_DEVICE_NET_USING_INFO;

//Set the IP of IPC.
typedef struct tagNET_DVR_IPC_NETCFG
{
    DWORD dwSize;           //Structure length
    NET_DVR_IPADDR struIP;  //IP
    WORD wPort;             //Port
    char res[126];          //reserved
}NET_DVR_IPC_NETCFG, *LPNET_DVR_IPC_NETCFG;

//lock by time
typedef struct tagNET_DVR_TIME_LOCK
{
    DWORD dwSize;      //size
    NET_DVR_TIME strBeginTime;
    NET_DVR_TIME strEndTime;
    DWORD   dwChannel;        //channel no., 0xff: all channel
    DWORD   dwRecordType;     //record type
    DWORD   dwLockDuration;   //duration time, 0xffffffff: always lock
    NET_DVR_TIME_EX strUnlockTimePoint;
    BYTE    byRes[4];
}NET_DVR_TIME_LOCK, *LPNET_DVR_TIME_LOCK;

typedef struct tagNET_DVR_LOCK_RETURN
{
    DWORD dwSize;      //size
    NET_DVR_TIME strBeginTime;
    NET_DVR_TIME strEndTime;
    BYTE    byRes[20];
}NET_DVR_LOCK_RETURN, *LPNET_DVR_LOCK_RETURN;

//***channel record state*****//
typedef struct tagNET_DVR_CHANS_RECORD_STATUS
{
    BYTE byValid;       //Enable
    BYTE byRecord;      //(only read)record type:0: not recording; 1: recording
    WORD wChannelNO;    //Channel NO.
    DWORD dwRelatedHD;  //Disk NO.
    BYTE    byOffLineRecord;  // 0-off 1-on
    BYTE byRes[7];      //Reserved
}NET_DVR_CHANS_RECORD_STATUS, *LPNET_DVR_CHANS_RECORD_STATUS;


typedef struct tagNET_DVR_CHAN_GROUP_RECORD_STATUS
{
    DWORD dwSize; //Structure size
    NET_DVR_CHANS_RECORD_STATUS struChanStatus[MAX_CHANNUM_V30]; //One group has 64 channel
}NET_DVR_CHAN_GROUP_RECORD_STATUS, *LPNET_DVR_CHAN_GROUP_RECORD_STATUS;

typedef struct tagNET_DVR_RECTCFG
{
    WORD wXCoordinate; //X Coordinate of upper left corner point in rectangle
    WORD wYCoordinate; //Y Coordinate of upper left corner point in rectangle
    WORD wWidth;       //width of rectangle
    WORD wHeight;      //height of rectangle
}NET_DVR_RECTCFG, *LPNET_DVR_RECTCFG;
typedef struct tagNET_DVR_WINCFG
{
    DWORD dwSize;
    BYTE  byVaild;
    BYTE  byInputIdx;
    BYTE  byLayerIdx;
    BYTE  byTransparency;
    NET_DVR_RECTCFG  struWin;
    WORD wScreenHeight;
    WORD wScreenWidth;
    BYTE  byRes[20];
}NET_DVR_WINCFG, *LPNET_DVR_WINCFG;

#define  MAX_LAYERNUMS    32

typedef struct tagNET_DVR_ALLWINCFG
{
    DWORD dwSize;
    NET_DVR_WINCFG struWinCfg[MAX_LAYERNUMS];
    BYTE  byRes2[24];
}NET_DVR_ALLWINCFG, *LPNET_DVR_ALLWINCFG;

/********************************Intelligent Face Recognition****************************/
//Face snapshot rule(single)
typedef struct tagNET_VCA_SINGLE_FACESNAPCFG
{
    BYTE byActive;       //Whether to activate the rule: 0- no, 1- yes
    /********* IPC5.1.7 parameters Begin 2014-03-21***********/
    //Automatic Face ROI Enables
    BYTE byAutoROIEnable;//0-Close,1-Open
    BYTE byRes[2];
    /********* IPC5.1.7 parameters End 2014-03-21***********/
    NET_VCA_SIZE_FILTER struSizeFilter;   //Size filter
    NET_VCA_POLYGON     struVcaPolygon;      //Face recognition region
}NET_VCA_SINGLE_FACESNAPCFG, *LPNET_VCA_SINGLE_FACESNAPCFG;

//Face snapshot rules
typedef struct tagNET_VCA_FACESNAPCFG
{
    DWORD dwSize;
    BYTE bySnapTime;                    //Total snapshot number of single target face: 0-10
    BYTE bySnapInterval;                //Snapshot interval, unit: frame
    BYTE bySnapThreshold;               //Snapshot threshold: 0-100
    BYTE byGenerateRate;                 //Target generation speed, value range: [1, 5]
    BYTE bySensitive;                    //Target detection sensitivity, value range: [1, 5]
    BYTE byReferenceBright; //2012-3-27Reference bright[0,100]
    BYTE byMatchType;         //2012-5-3match alarm type,0-target disappear alarm,1-real time alarm
    BYTE byMatchThreshold;  //2012-5-3real time match threshold,0~100
    NET_DVR_JPEGPARA  struPictureParam; //JPEG picture specification structure
    NET_VCA_SINGLE_FACESNAPCFG struRule[MAX_RULE_NUM]; //Face snapshot rule
    //Face exposure shortest duration
    WORD wFaceExposureMinDuration;//(1~3600s\A3\AC Default 60)Effective in automatic mode
    //Face exposure Mode
    BYTE byFaceExposureMode;//1-Close\A3\AC2-Open\A3\AC0-automatic
    BYTE byBackgroundPic;//Back Ground Pic Upload Enable 0-open\A3\AC1-close
    DWORD dwValidFaceTime;    //Effective face the shortest duration, unit: second
    DWORD dwUploadInterval; //Face capture statistical data upload time interval, the unit: seconds, the default 900 seconds
    DWORD dwFaceFilteringTime;//0-100s
    BYTE byRes2[84];
}NET_VCA_FACESNAPCFG, *LPNET_VCA_FACESNAPCFG;

typedef struct tagNET_DVR_FIRMWARE_VERSION_IFNO
{
    DWORD       dwSize;
    char        szFirmwareVersion[LEN_PROPERTY/*128*/];
    BYTE        byRes2[128];
}NET_DVR_FIRMWARE_VERSION_IFNO, *LPNET_DVR_FIRMWARE_VERSION_IFNO;

//Age Group
typedef enum tagHUMAN_AGE_GROUP_ENUM
{
    ENUM_AGE_GROUP_INFANT      = 1,   //Infant
    ENUM_AGE_GROUP_CHILD       = 2,   //Children
    ENUM_AGE_GROUP_YOUNGSTER   = 3,   //Youngster
    ENUM_AGE_GROUP_ADOLESCENT  = 4,   //Adolescent
    ENUM_AGE_GROUP_YOUTH       = 5,   //Youth
    ENUM_AGE_GROUP_PRIME       = 6,   //Prime
    ENUM_AGE_GROUP_MIDLIFE     = 7,   //Midlife
    ENUM_AGE_GROUP_MIDAGE      = 8,   //Midage
    ENUM_AGE_GROUP_OLD         = 9    //Old
} HUMAN_AGE_GROUP_ENUM;



//Face snapshot result
typedef struct tagNET_VCA_FACESNAP_RESULT
{
    DWORD   dwSize;             //Structure size
    DWORD     dwRelativeTime;     //Relative time
    DWORD    dwAbsTime;            //Absolute time
    DWORD   dwFacePicID;        //Face picture ID
    DWORD   dwFaceScore;        //Face score: 0-100
    NET_VCA_TARGET_INFO  struTargetInfo;    //Alarm target information
    NET_VCA_RECT         struRect;          //Face subgraph area
    NET_VCA_DEV_INFO       struDevInfo;        //Front-end device information
    DWORD   dwFacePicLen;        //The length of face subgraph: 0- no picture, larger than 0- there is related picture
    DWORD   dwBackgroundPicLen; //The length of background picture: 0- no picture, larger than 0- there is related picture(reserved)
    BYTE    bySmart;//IDS Return 0(default),Smart Return 1
    BYTE    byAlarmEndMark;//Alarm End Mark;0-Retain\A3\AC1-Alarm End Mark
    BYTE    byRepeatTimes;
    BYTE    byRes;
    NET_VCA_HUMAN_FEATURE   struFeature;  //Human attributes
    float   fStayDuration; //Stay in the picture time (unit: s)
    char    sStorageIP[16];
    WORD    wStoragePort;
    WORD    wDevInfoIvmsChannelEx;     //NET_VCA_DEV_INFO->byIvmsChannel
    BYTE    byRes1[16];
    BYTE*   pBuffer1;           //Picture data of face subgraph
    BYTE*   pBuffer2;           //Picture data of background picture(reserved)
    //(can be got by the API of searching background picture--NET_DVR_FindBackgroundPic)
}NET_VCA_FACESNAP_RESULT, *LPNET_VCA_FACESNAP_RESULT;

typedef struct tagNET_DVR_FACE_DETECTION
{
    DWORD      dwSize;
    DWORD        dwRelativeTime; //Relative Time
    DWORD       dwAbsTime; //Abs Time
    DWORD      dwBackgroundPicLen; //Background Pictrue Len
    NET_VCA_DEV_INFO  struDevInfo;   //Device Info
    NET_VCA_RECT   struFacePic[MAX_FACE_PIC_NUM/*30*/];//Face Pictrue
    BYTE   byFacePicNum;//Pictru NUm
    BYTE   byRes1;
    WORD   wDevInfoIvmsChannelEx; //NET_VCA_DEV_INFO->byIvmsChannel
    BYTE   byRes[252];
    BYTE*  pBackgroundPicpBuffer; //Background Pictrue Buffer
}NET_DVR_FACE_DETECTION,*LPNET_DVR_FACE_DETECTION;

//defous result
typedef struct  tagNET_DVR_DEFOCUS_ALARM
{
    DWORD   dwSize;     //Structure size
    NET_VCA_DEV_INFO       struDevInfo;    //Front-end device information
    WORD    wDevInfoIvmsChannelEx;     //NET_VCA_DEV_INFO->byIvmsChannel
    DWORD  dwRelativeTime; //relative
    DWORD	 dwAbsTime; //absolute
    BYTE    byRes[54];    //Reserved
}NET_DVR_DEFOCUS_ALARM, *LPNET_DVR_DEFOCUS_ALARM;

//dense fog result
typedef struct  tagNET_DVR_DENSEFOGDETECTION_ALARM
{
    DWORD   dwSize;     //Structure size
    NET_VCA_DEV_INFO       struDevInfo; //device information
    DWORD  dwRelativeTime; //relative
    DWORD	 dwAbsTime; //absolute
    BYTE    byFogLevel; //fog level\A3\AC0-none-mist \A3\AC1-mist\A3\AC 2-dense fog, 3-thick fog
    BYTE    byRes[259];
}NET_DVR_DENSEFOGDETECTION_ALARM, *LPNET_DVR_DENSEFOGDETECTION_ALARM;

typedef struct  tagNET_DVR_AUDIOEXCEPTION_ALARM
{
    DWORD      dwSize;     //Structure size
    BYTE  byAlarmType;//alarmType\A3\AC1-audio input exception\A3\AC2-audio input changed\A3\AC3-audio steep fall \A3\AC4-audio Loss
    BYTE  byRes1;
    WORD wAudioDecibel;//the voice (for audio input changed)
    NET_VCA_DEV_INFO       struDevInfo;//Structure info
    WORD    wDevInfoIvmsChannelEx;     //NET_VCA_DEV_INFO->byIvmsChannel
    BYTE    byRes[62];        //Reserved
}NET_DVR_AUDIOEXCEPTION_ALARM, *LPNET_DVR_AUDIOEXCEPTION_ALARM;

typedef struct tagNET_VCA_FD_IMAGE_CFG
{
    DWORD   dwWidth;                  //Width of gray image data
    DWORD   dwHeight;                 //Heigth of gray image
    DWORD   dwImageLen;  //Length of gray image data
    BYTE     byRes[20];  //Reserved
    BYTE     *pImage;    //Gray image data
}NET_VCA_FD_IMAGE_CFG, *LPNET_VCA_FD_IMAGE_CFG;

typedef struct tagNET_VCA_FD_PROCIMG_CFG
{
    DWORD    dwSize;           //Structure size
    BYTE     byEnable;         //Whether to activate the rule
    BYTE     bySensitivity;    //Detection sensitivity, value range: [0,5]
    BYTE     byRes1[22];       //Reserved
    NET_VCA_SIZE_FILTER  struSizeFilter;  //Size filter
    NET_VCA_POLYGON   struPolygon;        //Polygon
    NET_VCA_FD_IMAGE_CFG struFDImage;     //Image information
    BYTE     byRes2[20];       //Reserved
}NET_VCA_FD_PROCIMG_CFG, *LPNET_VCA_FD_PROCIMG_CFG;

typedef struct tagNET_VCA_SUB_PROCIMG
{
    DWORD dwImageLen;         //Length of image data
    DWORD dwFaceScore;          //Face score, value range: 0-100
    NET_VCA_RECT struVcaRect; //Face subgraph area
    BYTE  byRes[20];          //Reserved
    BYTE  *pImage;            //Image data
}NET_VCA_SUB_PROCIMG, *LPNET_VCA_SUB_PROCIMG;

typedef struct tagNET_VCA_SUB_PROCIMG_V50
{
    DWORD dwImageLen;
    DWORD dwFaceScore;
    NET_VCA_RECT struVcaRect;
    NET_VCA_POINT struLeftEyePoint;
    NET_VCA_POINT struRightEyePoint;
    BYTE       byDistance;
    BYTE       bySex;
    BYTE       byAgeGroup;
    BYTE       byEyeGlass;
    NET_VCA_RECT struPosRect;
    BYTE       byRes[20];
    BYTE       *pImage;
}NET_VCA_SUB_PROCIMG_V50, *LPNET_VCA_SUB_PROCIMG_V50;

typedef struct tagNET_VCA_FD_PROCIMG_RESULT
{
    DWORD dwSize;             //Structure size
    DWORD dwImageId;          //Large picture ID
    BYTE byRes[20];           //Reserved
    DWORD dwSubImageNum;      //The total number of face subgraphs
    NET_VCA_SUB_PROCIMG  struProcImg[MAX_TARGET_NUM];  //Single face subgraph information
}NET_VCA_FD_PROCIMG_RESULT, *LPNET_VCA_FD_PROCIMG_RESULT;

typedef struct tagNET_VCA_FD_PROCIMG_RESULT_V50
{
    DWORD dwSize;
    DWORD dwImageId;
    BYTE byRes[20];
    DWORD dwSubImageNum;
    NET_VCA_SUB_PROCIMG_V50  struProcImg[MAX_TARGET_NUM];
}NET_VCA_FD_PROCIMG_RESULT_V50, *LPNET_VCA_FD_PROCIMG_RESULT_V50;

typedef struct tagNET_VCA_PICMODEL_RESULT
{
    DWORD dwImageLen;  //Length of image data
    DWORD dwModelLen;  //Length of model data
    BYTE  byRes[20];   //Reserved
    BYTE  *pImage;     //The pointer to face picture data
    BYTE  *pModel;     ///The pointer to model data
}NET_VCA_PICMODEL_RESULT, *LPNET_VCA_PICMODEL_RESULT;

typedef struct tagNET_VCA_REGISTER_PIC
{
    DWORD dwImageID; //Large picture ID
    DWORD dwFaceScore;        //Face score: 0-100
    NET_VCA_RECT struVcaRect;  //Face subgraph area
    BYTE  byRes[20];  //Reserved
}NET_VCA_REGISTER_PIC, *LPNET_VCA_REGISTER_PIC;

#define MAX_HUMAN_PICTURE_NUM   10   //The total number of pictures
#define MAX_HUMAN_BIRTHDATE_LEN 10   //The max length of birthday

typedef struct tagNET_DVR_AREAINFOCFG
{
    WORD wNationalityID; //Nationality
    WORD wProvinceID; //Province
    WORD wCityID; //City
    WORD wCountyID; //County
    BYTE byRes[4]; //Reserved
}NET_DVR_AREAINFOCFG, *LPNET_DVR_AREAINFOCFG;

typedef struct tagNET_VCA_HUMAN_ATTRIBUTE
{
    BYTE   bySex; //Gender: 0- man, 1- woman
    BYTE   byCertificateType; //Certificate type: 0- identity card,1- police certificate
    BYTE   byBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //Birthday, for example: 201106
    BYTE   byName[NAME_LEN]; //Name
    NET_DVR_AREAINFOCFG struNativePlace; //Birthplace parameter
    BYTE   byCertificateNumber[NAME_LEN];  //Certificate number
    BYTE   byRes2[20];
}NET_VCA_HUMAN_ATTRIBUTE, *LPNET_VCA_HUMAN_ATTRIBUTE;

typedef struct tagNET_VCA_HUMANATTRIBUTE_COND
{
    BYTE   bySex; //Gender: 0- disabled, 1- man, 2- woman
    BYTE   byCertificateType; //Certificate type: 0- disabled, 1- identity card, 2- police certificate
    BYTE   byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //Start birthday, for example: 201106
    BYTE   byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //End birthday, for example: 201106
    BYTE   byName[NAME_LEN]; //Name
    NET_DVR_AREAINFOCFG struNativePlace; //Birthplace parameter
    BYTE   byCertificateNumber[NAME_LEN];  //Certificate number
    BYTE   byRes[20];
}NET_VCA_HUMANATTRIBUTE_COND, *LPNET_VCA_HUMANATTRIBUTE_COND;


typedef struct tagNET_VCA_BLACKLIST_INFO
{
    DWORD  dwSize;   //Structure size
    DWORD  dwRegisterID;  //Register ID (read-only)
    DWORD  dwGroupNo; //Group number
    BYTE   byType; //Black and white list flag: 0- all, 1- white list, 2- black list
    BYTE   byLevel; //Black list level: 0- all, 1- low, 2- middle, 3- high
    BYTE   byRes1[2];  //Reserved
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //Personnel information
    BYTE   byRemark[NAME_LEN]; //Remark information
    BYTE   byRes2[20];
}NET_VCA_BLACKLIST_INFO, *LPNET_VCA_BLACKLIST_INFO;

typedef struct tagNET_VCA_BLACKLIST_PARA
{
    DWORD dwSize;   //Structure size
    NET_VCA_BLACKLIST_INFO struBlackListInfo;  //Black list information
    DWORD dwRegisterPicNum;  //The total number of blacklist pictures
    NET_VCA_PICMODEL_RESULT struRegisterPic[MAX_HUMAN_PICTURE_NUM];  //blacklist picture information
    BYTE  byRes[40]; //Reserved
}NET_VCA_BLACKLIST_PARA, *LPNET_VCA_BLACKLIST_PARA;

typedef struct tagNET_VCA_BLACKLIST_COND
{
    LONG  lChannel; //Channel number
    DWORD dwGroupNo; //Group number
    BYTE  byType; //Black and white list flag: 0- all, 1- white list, 2- black list
    BYTE  byLevel; //Black list level: 0- all, 1- low, 2- middle, 3- high
    BYTE  byRes1[2];  //Reserved
    NET_VCA_HUMAN_ATTRIBUTE struAttribute; //Personnel information
    BYTE  byRes[20];
}NET_VCA_BLACKLIST_COND, *LPNET_VCA_BLACKLIST_COND;

typedef struct tagNET_VCA_BLACKLIST_PIC
{
    DWORD dwSize;   //Structure size
    DWORD dwFacePicNum;  //Face picture number
    BYTE  byRes[20]; //Reserved
    NET_VCA_PICMODEL_RESULT  struBlackListPic[MAX_HUMAN_PICTURE_NUM];  //Single picture information
}NET_VCA_BLACKLIST_PIC, *LPNET_VCA_BLACKLIST_PIC;

typedef struct tagNET_VCA_FIND_PICTURECOND
{
    LONG lChannel;//Channel number
    NET_DVR_TIME struStartTime;//Start time
    NET_DVR_TIME struStopTime;//End time
    BYTE byRes[12]; //Reserved
}NET_VCA_FIND_PICTURECOND, *LPNET_VCA_FIND_PICTURECOND;

#define MAX_FACE_PIC_LEN   6144   //The max length of face picture data
typedef struct tagNET_VCA_SUB_SNAPPIC_DATA
{
    DWORD dwFacePicID; //Face picture ID
    DWORD dwFacePicLen;  //Length of face picture data
    NET_DVR_TIME struSnapTime;  //Snapshot time
    DWORD dwSimilarity; //Similarity
    BYTE  byRes[16];  //Reserved
    char  sPicBuf[MAX_FACE_PIC_LEN];  //Picture data
}NET_VCA_SUB_SNAPPIC_DATA, *LPNET_VCA_SUB_SNAPPIC_DATA;

typedef struct tagNET_VCA_ADVANCE_FIND
{
    DWORD dwFacePicID; //Face picture ID
    BYTE  byRes[36];
}NET_VCA_ADVANCE_FIND, *LPNET_VCA_ADVANCE_FIND;

typedef struct tagNET_VCA_NORMAL_FIND
{
    DWORD dwImageID; //Large picture ID
    DWORD dwFaceScore;  //Face score
    NET_VCA_RECT struVcaRect; //Face subgraph area
    BYTE byRes[20];
}NET_VCA_NORMAL_FIND, *LPNET_VCA_NORMAL_FIND;

typedef union tagNET_VCA_FIND_SNAPPIC_UNION
{
    NET_VCA_NORMAL_FIND  struNormalFind; //Common search
    NET_VCA_ADVANCE_FIND struAdvanceFind; //Advanced search
}NET_VCA_FIND_SNAPPIC_UNION, *LPNET_VCA_FIND_SNAPPIC_UNION;

typedef enum _VCA_FIND_SNAPPIC_TYPE_
{
    VCA_NORMAL_FIND   = 0x00000000,   //Common search
    VCA_ADVANCE_FIND  = 0x00000001    //Advanced search
}VCA_FIND_SNAPPIC_TYPE;

typedef struct tagNET_VCA_FIND_PICTURECOND_ADVANCE
{
    LONG lChannel;//Channel number
    NET_DVR_TIME struStartTime;//Start time
    NET_DVR_TIME struStopTime;//End time
    BYTE byThreshold;  //Threshold: 0-100
    BYTE byRes[23]; //Reserved
    VCA_FIND_SNAPPIC_TYPE dwFindType;//Retrieving type, see to VCA_FIND_SNAPPIC_TYPE
    NET_VCA_FIND_SNAPPIC_UNION uFindParam; //Retrieving parameter
}NET_VCA_FIND_PICTURECOND_ADVANCE, *LPNET_VCA_FIND_PICTURECOND_ADVANCE;

typedef struct tagNET_VCA_FACESNAP_INFO_ALARM
{
    DWORD dwRelativeTime;       //Relative time
    DWORD dwAbsTime;            //Absolute time
    DWORD dwSnapFacePicID;      //Snapshot face picture ID
    DWORD dwSnapFacePicLen;        //Length of face subgraph: 0- no picture, larger than 0- there is related picture
    NET_VCA_DEV_INFO struDevInfo;        //Front-end device information
    BYTE  byRes[20];              // Reserved
    BYTE  *pBuffer1;  //Snapshot face subgraph data
}NET_VCA_FACESNAP_INFO_ALARM, *LPNET_VCA_FACESNAP_INFO_ALARM;

typedef struct tagNET_VCA_BLACKLIST_INFO_ALARM
{
    NET_VCA_BLACKLIST_INFO struBlackListInfo; //Blacklist basic information
    DWORD dwBlackListPicLen;       //Length of blacklist face subgraph: 0- no picture, larger than 0- there is related picture
    BYTE  byRes[20];              // Reserved
    BYTE  *pBuffer1;  //Blacklist face subgraph data
}NET_VCA_BLACKLIST_INFO_ALARM, *LPNET_VCA_BLACKLIST_INFO_ALARM;

typedef struct tagNET_VCA_FACESNAP_MATCH_ALARM
{
    DWORD dwSize;             //Structure size
    float fSimilarity; //Similarity, value range: [0.001,1]
    NET_VCA_FACESNAP_INFO_ALARM  struSnapInfo; //Snapshot information
    NET_VCA_BLACKLIST_INFO_ALARM struBlackListInfo; //Blacklist information
    char         sStorageIP[16];
    WORD   wStoragePort;
    BYTE     byRes[42];
}NET_VCA_FACESNAP_MATCH_ALARM, *LPNET_VCA_FACESNAP_MATCH_ALARM;


typedef struct tagNET_VCA_BLACKLIST_INFO_ALARM_LOG
{
    NET_VCA_BLACKLIST_INFO struBlackListInfo; //Blacklist basic information
    DWORD dwBlackListPicID;       //Blacklist face subgraph ID, used to search pictures
    BYTE  byRes[20];              //Reserved
}NET_VCA_BLACKLIST_INFO_ALARM_LOG, *LPNET_VCA_BLACKLIST_INFO_ALARM_LOG;

typedef struct tagNET_VCA_FACESNAP_INFO_ALARM_LOG
{
    DWORD dwRelativeTime;        //Relative time
    DWORD dwAbsTime;             //Absolute time
    DWORD dwSnapFacePicID;       //Snapshot face picture ID
    NET_VCA_DEV_INFO       struDevInfo;        //Front-end device information
    BYTE  byRes[20];              // Reserved
}NET_VCA_FACESNAP_INFO_ALARM_LOG, *LPNET_VCA_FACESNAP_INFO_ALARM_LOG;

typedef struct tagNET_VCA_FACESNAP_MATCH_ALARM_LOG
{
    DWORD dwSize;             //Structure size
    float fSimilarity;      //Similarity, value range: [0.001,1]
    NET_VCA_FACESNAP_INFO_ALARM_LOG  struSnapInfoLog; //Snapshot information
    NET_VCA_BLACKLIST_INFO_ALARM_LOG struBlackListInfoLog; //Blacklist information
    BYTE  byRes[60];              // Reserved
}NET_VCA_FACESNAP_MATCH_ALARM_LOG, *LPNET_VCA_FACESNAP_MATCH_ALARM_LOG;

typedef struct tagNET_VCA_FACEMATCH_PICCOND
{
    DWORD dwSize;             // Structure size
    DWORD dwSnapFaceID; //Blacklist face subgraph ID
    DWORD dwBlackListID; //Matched blacklist ID
    DWORD dwBlackListFaceID; //Compared blacklist face subgraph ID
    BYTE  byRes[20];              // Reserved
}NET_VCA_FACEMATCH_PICCOND, *LPNET_VCA_FACEMATCH_PICCOND;

typedef struct tagNET_VCA_FACEMATCH_PICTURE
{
    DWORD dwSize;             //Structure size
    DWORD dwSnapFaceLen; //Length of face subgraph
    DWORD dwBlackListFaceLen; //Length of compared blacklist face subgraph
    BYTE  byRes[20];              //Reserved
    BYTE *pSnapFace;  //Picture data of face subgraph
    BYTE *pBlackListFace;  //Picture data of compared blacklist face subgraph
}NET_VCA_FACEMATCH_PICTURE, *LPNET_VCA_FACEMATCH_PICTURE;

typedef struct tagNET_VCA_BLACKLIST_FASTREGISTER_PARA
{
    DWORD dwSize;   //Structure size
    NET_VCA_BLACKLIST_INFO struBlackListInfo;  //Blacklist information
    DWORD dwImageLen;  //Length of image data
    BYTE  byRes[124];  //Reserved
    BYTE  *pImage;    //Image data
}NET_VCA_BLACKLIST_FASTREGISTER_PARA, *LPNET_VCA_BLACKLIST_FASTREGISTER_PARA;

//Single partition configuration
typedef struct tagNET_VCA_SINGLE_PATH
{
    BYTE  byActive;  //Whether it is available: 0- no, 1- yes
    BYTE  byType;    //0- save snapshot, 1- save blacklist comparison alarm, 2- save snapshot and blacklist comparison alarm\A3\AC0xff-invalid
    BYTE  bySaveAlarmPic; //save alarm picture,0-no,1-yes
    BYTE  byRes1[5]; //Reserved
    DWORD dwDiskDriver;   //Disk sign, start from 0
    DWORD dwLeftSpace;   //Reserved capacity (unit:G)
    BYTE  byRes2[8]; //Reserved
}NET_VCA_SINGLE_PATH, *LPNET_VCA_SINGLE_PATH;

//Set saving path
typedef struct tagNET_VCA_SAVE_PATH_CFG
{
    DWORD dwSize;   //Structure size
    NET_VCA_SINGLE_PATH  struPathInfo[MAX_DISKNUM_V30]; //Single partition
    BYTE  byRes[40]; //Reserved
}NET_VCA_SAVE_PATH_CFG, *LPNET_VCA_SAVE_PATH_CFG;

typedef struct tagNET_DVR_DEV_ACCESS_CFG
{
    DWORD   dwSize;
    NET_DVR_IPADDR     struIP;        //access device ip
    WORD     wDevicePort;                 //port
    BYTE    byEnable;                 //enable,0-no,1-yes
    BYTE     byRes1;                //
    BYTE    sUserName[NAME_LEN];    //access user name
    BYTE    sPassword[PASSWD_LEN];    //access password
    BYTE    byRes2[60];
}NET_DVR_DEV_ACCESS_CFG,*LPNET_DVR_DEV_ACCESS_CFG;

/********************************Intelligent Face Recognition end****************************/

typedef struct tagNET_DVR_IP_ALARM_GROUP_NUM
{
    DWORD dwSize;
    DWORD dwIPAlarmInGroup;
    DWORD dwIPAlarmInNum;
    DWORD dwIPAlarmOutGroup;
    DWORD dwIPAlarmOutNum;
    BYTE byRes[64];
}NET_DVR_IP_ALARM_GROUP_NUM, *LPNET_DVR_IP_ALARM_GROUP_NUM;
//****NVR end***//

typedef struct tagNET_DVR_ACCESS_CAMERA_INFO
{
    DWORD dwSize;                // Structure length
    char  sCameraInfo[32];        // Access camera info
    BYTE  byInterfaceType;        // Access camer type 1:VGA, 2:HDMI, 3:YPbPr 4:SDI 5:FC
    BYTE  byRes1[3];
    DWORD dwChannel;
    BYTE  byRes[24];
}NET_DVR_ACCESS_CAMERA_INFO, *LPNET_DVR_ACCESS_CAMERA_INFO;

typedef struct tagNET_DVR_AUDIO_INPUT_PARAM
{
    BYTE  byAudioInputType;  //Audio in type,0-mic in,1-line in
    BYTE  byVolume; //volume,[0-100]
    BYTE  byEnableNoiseFilter;
    BYTE  byres[5];
}NET_DVR_AUDIO_INPUT_PARAM, *LPNET_DVR_AUDIO_INPUT_PARAM;

typedef struct tagNET_DVR_CAMERA_DEHAZE_CFG
{
    DWORD dwSize;
    BYTE byDehazeMode; //0-disenable,1-auto mode,2-enable
    BYTE byLevel; //level,0-100
    BYTE byRes[6];
}NET_DVR_CAMERA_DEHAZE_CFG, *LPNET_DVR_CAMERA_DEHAZE_CFG;

typedef struct tagNET_DVR_VGA_DISP_CHAN_CFG_V40
{
    DWORD    dwSize;
    BYTE   byAudio;            /*Whether the audio is enabled*/
    BYTE   byAudioWindowIdx;      /*Sub window index to enable audio*/
    BYTE     byVgaResolution;      /*Resolution, got from ability set*/
    BYTE    byVedioFormat;         /*1:NTSC,2:PAL,0-NULL*/
    DWORD    dwWindowMode;        /*Screen mode, got from ability set*/
    BYTE      byJoinDecChan[MAX_WINDOWS];/*The decode channel joined with each sub-window*/
    BYTE    byEnlargeStatus;          /*Whether enlarge the window: 0- no, 1- yes*/
    BYTE    byEnlargeSubWindowIndex;//Enlarged sub window index
    BYTE    byScale; /*Display mode: 0--real display\A3\AC1--scaling display (for BNC)*/
    /*Distinguish between the union: 0- display channel configuration of the decoder inner video integrated platform,
    1- display channel configuration of other decoder*/
    BYTE    byUnionType;
    union
    {
        BYTE byRes[160];
        struct
        {
            /*Decode sub-system slot number corresponded to the decode channel joined with each sub-window(valid for decode sub-system in video integrated platform)*/
            BYTE    byJoinDecoderId[MAX_WINDOWS];
            //Video resolution of display window: 1- D1, 2- 720P, 3- 1080P,
            //Device set decode channel according to the resolution. For example, if 1 screen is configured to 1080P, the device will set 4 decode channels
            //to the display channel
            BYTE    byDecResolution;
            BYTE    byRes[143];
        }struVideoPlatform;
        struct
        {
            BYTE    byRes[160];
        }struNotVideoPlatform;
    }struDiff;
    BYTE    byRes[120];
}NET_DVR_VGA_DISP_CHAN_CFG_V40,*LPNET_DVR_VGA_DISP_CHAN_CFG_V40;


typedef struct tagNET_DVR_V6SUBSYSTEMPARAM
{
    BYTE        bySerialTrans;//Serial Transport\A3\AC0-no\A3\AC1-yes
    BYTE        byRes[35];
}NET_DVR_V6SUBSYSTEMPARAM, *LPNET_DVR_V6SUBSYSTEMPARAM;

// long config status

// pull disk status
#define PULL_DISK_SUCCESS        1
#define PULL_DISK_FAIL            2
#define PULL_DISK_PROCESSING    3
#define PULL_DISK_NO_ARRAY         4
#define PULL_DISK_NOT_SUPPORT    5

// scan raid state
#define SCAN_RAID_SUC            1
#define SCAN_RAID_FAIL            2
#define SCAN_RAID_PROCESSING    3
#define SCAN_RAID_NOT_SUPPORT    4

// set access camera type status
#define SET_CAMERA_TYPE_SUCCESS            1
#define SET_CAMERA_TYPE_FAIL            2
#define SET_CAMERA_TYPE_PROCESSING        3


//9000 2.2
typedef struct tagNET_DVR_RECORD_TIME_SPAN_INQUIRY
{
    DWORD    dwSize;    //Structure size
    BYTE    byType;    //0- normal audio and video recording, 1- picture channel recording,
    //2- ANR channel recording, 3- frame extracting channel recording
    BYTE     byRes[63]; //Reserved
}NET_DVR_RECORD_TIME_SPAN_INQUIRY, *LPNET_DVR_RECORD_TIME_SPAN_INQUIRY;

typedef struct tagNET_DVR_RECORD_TIME_SPAN
{
    DWORD          dwSize;        //Structure size
    NET_DVR_TIME  strBeginTime;  //Start time
    NET_DVR_TIME  strEndTime;    //End time
    BYTE          byType;        //0- normal audio and video recording, 1- picture channel recording,
    //2- ANR channel recording, 3- frame extracting channel recording
    BYTE           byRes[35];     //Reserved
}NET_DVR_RECORD_TIME_SPAN, *LPNET_DVR_RECORD_TIME_SPAN;

typedef struct tagNET_DVR_DRAWFRAME_DISK_QUOTA_CFG
{
    DWORD    dwSize;                    //Structure size
    BYTE     byPicQuota;                //Picture percentage                    [0%,  30%]
    BYTE     byRecordQuota;                //Record percentage                        [20%, 40%]
    BYTE     byDrawFrameRecordQuota;    //Frame extracting record percentage    [30%, 80%]
    BYTE     byRes[61];                //Reserved
}NET_DVR_DRAWFRAME_DISK_QUOTA_CFG, *LPNET_DVR_DRAWFRAME_DISK_QUOTA_CFG;

typedef struct tagNET_DVR_NAT_PORT
{
    WORD wEnable;         //Whether the port is enabled to be mapped
    WORD wExtPort;        //External port
    BYTE byRes[12];       //Reserved
}NET_DVR_NAT_PORT, *LPNET_DVR_NAT_PORT;

typedef struct  tagNET_DVR_NAT_CFG
{
    DWORD dwSize;          //Structure size
    WORD wEnableUpnp;     //Whether to enable UPNP
    WORD wEnableNat;        //Whether to enable UPNP port mapping(NAT) function(same as wEnableUpnp)
    NET_DVR_IPADDR  struIpAddr;      //LAN IP address of NAT router
    NET_DVR_NAT_PORT    struHttpPort;   //mapping configuration of web server http port
    NET_DVR_NAT_PORT    struCmdPort; //mapping configuration of command port
    NET_DVR_NAT_PORT    struRtspPort;  //mapping configuration of rtsp port
    BYTE byFriendName[64]; //Friend name
    BYTE byNatType; //UPNP NAT type,0-manual,1-auto
    BYTE                 byRes1[3];    //Reserved
    NET_DVR_NAT_PORT    struHttpsPort; //mapping configuration of  httpsport
    BYTE                 byres[76];    //Reserved
}NET_DVR_NAT_CFG, *LPNET_DVR_NAT_CFG;

typedef struct
{
    DWORD  dwEnabled;               //Whether enable the port to be mapped
    WORD   wInternalPort;           //internal port
    WORD   wExternalPort;           //External port
    DWORD  dwStatus;                 /*Port mapping state:
                                     0 Not effective
                                     1 Not effective: mapped source port should be same with destination port
                                     2 Not effective: mapped port has been used
                                     3 Effect
                                    */
    NET_DVR_IPADDR    struNatExternalIp;       //Mapped external IP address
    NET_DVR_IPADDR    struNatInternalIp;       //LAN IP address of NAT router
    BYTE   byRes[16];               //Reserved
}NET_DVR_UPNP_PORT_STATE, *LPNET_DVR_UPNP_PORT_STATE;

typedef struct
{
    NET_DVR_UPNP_PORT_STATE strUpnpPort[UPNP_PORT_NUM];     //Port mapping state, array 0- web server port, array 1- management port, array 2- rtsp port
    BYTE   byRes[200];              //Reserved
}NET_DVR_UPNP_NAT_STATE, *LPNET_DVR_UPNP_NAT_STATE;

typedef struct tagNET_DVR_PLAYCOND
{
    DWORD             dwChannel;
    NET_DVR_TIME     struStartTime;
    NET_DVR_TIME     struStopTime;
    BYTE             byDrawFrame;  //0- not extract frame, 1- extract frame
    BYTE             byStreamType ; //0-main 1-sub 2-three
    BYTE             byStreamID[STREAM_ID_LEN];  //Stream ID
    BYTE             byRes[30];    //Reserved
}NET_DVR_PLAYCOND, *LPNET_DVR_PLAYCOND;

typedef struct tagNET_DVR_ATMFINDINFO
{
    BYTE    byTransactionType;       //Trade Tye 0-All,1-Search, 2-Withdraw 3-Deposit, 4-Edit Password 5-Transfer,
    //6-No Card Withdraw 7-No Card Deposit 8-Swallow money 9-Swallow Card 10-seldefine
    BYTE    byRes[3] ;
    DWORD  dwTransationAmount ;     //trade money ;
} NET_DVR_ATMFINDINFO, *LPNET_DVR_ATMFINDINFO ;

typedef union  tagNET_DVR_SPECIAL_FINDINFO_UNION
{
    BYTE  byLenth[8] ;
    NET_DVR_ATMFINDINFO      struATMFindInfo;           //ATM Search
}NET_DVR_SPECIAL_FINDINFO_UNION, *LPNET_DVR_SPECIAL_FINDINFO_UNION;

typedef struct tagNET_DVR_FILECOND_V40
{
    LONG           lChannel;
    DWORD          dwFileType;
    DWORD          dwIsLocked;
    DWORD          dwUseCardNo;
    BYTE           sCardNumber[CARDNUM_LEN_OUT];
    NET_DVR_TIME   struStartTime;
    NET_DVR_TIME   struStopTime;
    BYTE           byDrawFrame; //0- not extract frame, 1- extract frame
    BYTE        byFindType;
    BYTE        byQuickSearch;
    BYTE        bySpecialFindInfoType ;    //special Find Info Type,     indicate NET_DVR_SPECIAL_FINDINFO_UNION 0-Invalid, 1-Find With ATM Cond
    DWORD       dwVolumeNum;
    BYTE        byWorkingDeviceGUID[GUID_LEN];
    NET_DVR_SPECIAL_FINDINFO_UNION uSpecialFindInfo ;   //special Find Info
    BYTE        byStreamType;
    BYTE        byAudioFile;
    BYTE        byRes2[30];
}NET_DVR_FILECOND_V40, *LPNET_DVR_FILECOND_V40;

typedef struct
{
    BYTE    sAESKey[16];        //Stream key
    BYTE    byRes[64];          //Reserved
}NET_DVR_AES_KEY_INFO, *LPNET_DVR_AES_KEY_INFO;

typedef struct
{
    NET_DVR_IPADDR struIP;     //IP address
    BYTE  byRes[128]; //Reserved
}NET_DVR_POE_CFG, *LPNET_DVR_POE_CFG;

#define MAX_PRO_PATH         256    //The max length of protocol path

typedef struct
{
    DWORD dwSize;              //Structure size
    DWORD dwEnabled;           //Whether enable the protocol: 0- no, 1- yes
    char  sProtocalName[DESC_LEN];   //Customized protocol name, 16 bits
    BYTE  byRes1[64];          //Reserved, used for extending protocol name
    DWORD dwEnableSubStream;   //Whether enable the sub stream: 0- no, 1- yes

    BYTE  byMainProType;        //Main stream protocol type: 1- RTSP
    BYTE  byMainTransType;       //Main stream transport type 0\A3\BAAuto 1\A3\BAudp 2\A3\BArtp over rtsp
    WORD  wMainPort;           //Main stream port
    char  sMainPath[MAX_PRO_PATH];  //Main stream path

    BYTE  bySubProType;         //Sub stream protocol type: 1- RTSP
    BYTE  bySubTransType;        //Main stream transport type 0\A3\BAAuto 1\A3\BAudp 2\A3\BArtp over rtsp
    WORD  wSubPort;             //Sub stream port
    char  sSubPath[MAX_PRO_PATH];   //Sub stream path

    BYTE  byRes2[200];          //Reserved
}NET_DVR_CUSTOM_PROTOCAL, *LPNET_DVR_CUSTOM_PROTOCAL;


typedef struct tagNET_DVR_VOD_PARA
{
    DWORD                dwSize;
    NET_DVR_STREAM_INFO struIDInfo;
    NET_DVR_TIME        struBeginTime;
    NET_DVR_TIME        struEndTime;
    HWND                hWnd;
    BYTE                byDrawFrame;
    BYTE                byVolumeType;  //0-common volume   1-backup volme
    BYTE                byVolumeNum;  //backup volme number
    BYTE                byStreamType;
    DWORD                   dwFileIndex;      //file index
    BYTE                byAudioFile;
    BYTE                byRes2[23];
}NET_DVR_VOD_PARA, *LPNET_DVR_VOD_PARA;

//B10 can support PSIA.
//cycle to wall
typedef struct
{
    DWORD dwEnable; //0-disable 1\A3\ADenable
    BYTE  byType;   //device type 0: DEV_SDK  1:DEV_DAHUA  2:DEV_EHOME    3:DEV_OTHERES
    BYTE byRes[3];  //reserved
    NET_DVR_STREAM_MEDIA_SERVER_CFG streamMediaServerCfg;
    NET_DVR_DEV_CHAN_INFO  struDevChanInfo; //the information of cycle decoding channel
    BYTE sRtspUrl[128]; //stream address
}NET_DVR_MATRIX_CHAN_INFO_EX,*LPNET_DVR_MATRIX_CHAN_INFO_EX;

typedef struct
{
    DWORD                    dwSize;
    DWORD                    dwPoolTime;        //the gap of cycle time
    NET_DVR_MATRIX_CHAN_INFO_EX        struchanConInfo[MAX_CYCLE_CHAN_V30];
    BYTE                   byRes[16];
}NET_DVR_MATRIX_LOOP_DECINFO_EX,*LPNET_DVR_MATRIX_LOOP_DECINFO_EX;

//realtime preview
typedef struct
{
    DWORD dwSize;
    BYTE byType;         //device type: 0: DEV_SDK  1:DEV_DAHUA  2:DEV_EHOME 3:DEV_OTHERES
    BYTE byRes[3];       //reserve
    NET_DVR_STREAM_MEDIA_SERVER_CFG struStreamMediaSvrCfg;
    NET_DVR_DEV_CHAN_INFO struDevChanInfo;
    BYTE sRtspUrl[128];  //stream address
}NET_DVR_PU_STREAM_CFG_EX,*LPNET_DVR_PU_STREAM_CFG_EX;
/////***********************************64-T decoder*************************************//////
//resolution
#define MAKE_RESOLUTION(_interlace_, _width_, _height_, _fps_) \
    (((_interlace_)<<28) \
    |((((_width_)>>3)&0x1ff)<<19)| \
    ((((_height_)>>1)&0x7ff)<<8)| \
((_fps_)&0xff))
#define GET_RES_INTERLACE(_res_) \
(((_res_)>>28)&0x1)
#define GET_RES_WIDTH(_res_) \
((((_res_)>>19)&0x1ff)<<3)
#define GET_RES_HEIGHT(_res_) \
((((_res_)>>8)&0x7ff)<<1)
#define GET_RES_FPS(_res_) \
((_res_)&0xff)

#define NOT_AVALIABLE    MAKE_RESOLUTION (0,0,0,0)
#define SVGA_60HZ         MAKE_RESOLUTION(0, 800, 600, 60)
#define SVGA_75HZ         MAKE_RESOLUTION(0, 800, 600, 75)
#define XGA_60HZ         MAKE_RESOLUTION(0, 1024, 768, 60)
#define XGA_75HZ         MAKE_RESOLUTION(0, 1024, 768, 75)
#define SXGA_60HZ          MAKE_RESOLUTION(0, 1280, 1024, 60)
#define SXGA2_60HZ      MAKE_RESOLUTION(0, 1280, 960, 60)
#define _720P_24HZ      MAKE_RESOLUTION(0, 1280, 720, 24)
#define _720P_25HZ      MAKE_RESOLUTION(0, 1280, 720, 25)
#define _720P_30HZ      MAKE_RESOLUTION(0, 1280, 720, 30)
#define _720P_60HZ      MAKE_RESOLUTION(0, 1280, 720, 60)
#define _720P_50HZ      MAKE_RESOLUTION(0, 1280, 720, 50)
#define _1080I_60HZ     MAKE_RESOLUTION(1, 1920, 1080, 60)
#define _1080I_50HZ      MAKE_RESOLUTION(1, 1920, 1080, 50)
#define _1080P_60HZ     MAKE_RESOLUTION(0, 1920, 1080, 60)
#define _1080P_50HZ     MAKE_RESOLUTION(0, 1920, 1080, 50)
#define _1080P_30HZ     MAKE_RESOLUTION(0, 1920, 1080, 30)
#define _1080P_25HZ     MAKE_RESOLUTION(0, 1920, 1080, 25)
#define _1080P_24HZ     MAKE_RESOLUTION(0, 1920, 1080, 24)
#define UXGA_60HZ          MAKE_RESOLUTION(0, 1600, 1200, 60)
#define UXGA_30HZ          MAKE_RESOLUTION(0, 1600, 1200, 30)
#define WSXGA_60HZ         MAKE_RESOLUTION(0, 1680, 1050, 60)
#define WUXGA_60HZ      MAKE_RESOLUTION(0, 1920, 1200, 60)
#define WUXGA_30HZ         MAKE_RESOLUTION(0, 1920, 1200, 30)
#define WXGA_60HZ          MAKE_RESOLUTION(0, 1360, 768, 60)
#define SXGA_PLUS_60HZ    MAKE_RESOLUTION(0, 1400, 1050, 60)
#define VGA_MODE_3840x2160_30HZ MAKE_RESOLUTION(0, 3840, 2160, 30)
#define VGA_MODE_3840x2160_60HZ MAKE_RESOLUTION(0, 3840, 2160, 60)

#define  MAX_WINDOWS_NUM 12        //number of menu partition mode
#define  MAX_SUPPORT_RES 32
#define  MAX_DISPNUM_V41 32
#define  MAX_SDI_RES     16     //
typedef struct tagNET_DVR_DISPWINDOWMODE
{
    BYTE byDispChanType;//Display channel type\A3\BA0-BNC, 1-VGA, 2-HDMI, 3-DVI
    BYTE byDispChanSeq;//sequence of display channel, if the byDispChanType is VGA, byDispChanSeq mean the sequence of VGA
    BYTE byRes[2];
    BYTE byDispMode[MAX_WINDOWS_NUM/*12*/];
}NET_DVR_DISPWINDOWMODE, *LPNET_DVR_DISPWINDOWMODE;


typedef struct tagNET_DVR_DISPINFO
{
    BYTE  byChanNums;//channel numbers
    BYTE  byStartChan;//start channel
    BYTE  byRes[2];
    DWORD    dwSupportResolution[MAX_SUPPORT_RES/*32*/];//support resolution
}NET_DVR_DISPINFO, *LPNET_DVR_DISPINFO;

typedef struct tagNET_DVR_SCREENINFO
{
    BYTE  bySupportBigScreenNums;//Max numbers of big screen
    BYTE  byStartBigScreenNum;//start index of screen
    BYTE  byMaxScreenX;//the mode of making up big screen
    BYTE  byMaxScreenY;
    BYTE  byRes[8];
}NET_DVR_SCREENINFO, *LPNET_DVR_SCREENINFO;

typedef struct tagNET_DVR_SDI_INFO
{
    BYTE  byChanNums;//
    BYTE  byStartChan;//
    BYTE  byRes[2];
    DWORD dwSupportResolution[MAX_SDI_RES/*16*/];//
}NET_DVR_SDI_INFO,*LPNET_DVR_SDI_INFO;

typedef struct tagNET_DVR_ACCELERATIONCFG
{
    DWORD    dwMaxXAcc;
    DWORD    dwMaxYAcc;
    DWORD    dwMaxZAcc;
    BYTE    byRes[4];
}NET_DVR_ACCELERATIONCFG,*LPNET_DVR_ACCERATIONCFG;

typedef struct tagNET_DVR_GSENSORPARA
{
    DWORD dwSize;
    NET_DVR_ACCELERATIONCFG struAccelerationCfg;
    BYTE  byModuleSelect;/*module select\A3\BA0 inside/1 outside*/
    BYTE  byRes1[3];
    NET_DVR_HANDLEEXCEPTION_V30 struHandleException;
    BYTE  byRes2[24];
}NET_DVR_GSENSORPARA, *LPNET_DVR_GSENSORPARA;

typedef struct tagNET_DVR_MB_POWERCTRLPARA
{
    DWORD    dwSize;
    DWORD     dwHaltDelay; /* shutdown delay time(min) */
    NET_DVR_MB_AUTOWORKPARA  struAutoWorkPara;/*start control parm set*/
    BYTE       byEnableUnderVoltProtect;   /*enable under volt proctect*/
    BYTE       byUnderVoltPercent;   /*under volt percent\A3\AC(85\A1\A290\A1\A295) */
    BYTE       byRes[34];
}NET_DVR_MB_POWERCTRLPARA, *LPNET_DVR_MB_POWERCTRLPARA;

//auto Backup
typedef struct tagNET_DVR_MB_AUTOBACKUPPARA
{
    DWORD dwSize;
    BYTE  byEnableAutoBackup; /* enable auto backup or not 0 stop \A3\AC1 start */
    BYTE  byRes1[3];
    BYTE  byBackupChannel[MAX_CHANNUM_V30];     /*the channel to auto backup*/
    BYTE  byBackupDays[MAX_CHANNUM_V30];/*the days to backup*/
    /* the file type to backup
    {0,ALL_RECORD_TYPE,all type},
    {1,TIMING_REC,Schedule},
    {2,MOTION_DETECT_REC,Motion Detection  },
    {3,ALARM_REC,alarm },
    {4,MANUAL_REC,Manual Recording}*/
    BYTE  byBackupFileType[MAX_CHANNUM_V30];
    NET_DVR_SCHEDTIME struBackupTime[MAX_CHANNUM_V30][2];    /* the shedule for auto backup*/
    BYTE  byRes2[36];                        /* res*/
}NET_DVR_MB_AUTOBACKUPPARA, *LPNET_DVR_MB_AUTOBACKUPPARA;

typedef struct tagNET_DVR_MB_GPSPARA
{
    DWORD dwSize;
    BYTE  byEnableGPS;	/*enable GPS or not*/
    BYTE  byGpsInterface;/*gps receive interface 0-rs232, 1-rs485, 2-frontpanel, 3-lcd */
    BYTE  bySpeedUnit;  /*speed unit\A3\AC0\A3\BAkm/h\A3\AC1 mile/h*/
    BYTE  byEnableRetrieve; /* dead zone retrieve(1enable\A3\AC0disable) */
    int	  iAdjustTime;/*time zone*/
    BYTE  byEnableAdjustTime;/*enable GPS Time Synchronization\A3\AC 1-enable, 0-disable*/
    BYTE  byRes1[5];
    WORD  wGpsUploadInterval;	/* GPS upload interval, second*/
    BYTE  byGpsOsdChannel[MAX_CHANNUM_V30];/*OSD display\A3\AC */
    DWORD dwSpeedLimit;	/* speed limit alarm*/
    NET_DVR_HANDLEEXCEPTION_V30  struGpsAlarm;
    BYTE  byRes2[36];
}NET_DVR_MB_GPSPARA, *LPNET_DVR_MB_GPSPARA;

#define         SENSOR_IN_NUMBER          8
typedef struct tagNET_DVR_MB_SENSORINPARA
{
    DWORD dwSize;
    BYTE  byTriggerType[SENSOR_IN_NUMBER];/*trigger type\A3\ACthe last four type is valid\A3\ACrepresenting brake\A1\A2turn left\A1\A2turn right\A1\A2reverse\A3\AC0-high level\A3\AC1-low level*/
    BYTE  byTriggerChannel [SENSOR_IN_NUMBER];
    BYTE  byOsdDisplay [MAX_CHANNUM_V30];/*OSD display*/
    BYTE  byRes[32];
}NET_DVR_MB_SENSORINPARA, *LPNET_DVR_MB_SENSORINPARA;

typedef struct tagNET_DVR_MB_DOWNLOADSVRPARA
{
    DWORD dwSize;
    NET_DVR_IPADDR    struDownloadSvrIp;        /* auto load server address */
    BYTE  byRes[64];
}NET_DVR_MB_DOWNLOADSVRPARA,*LPNET_DVR_MB_DOWNLOADSVRPARA;

typedef struct tagNET_DVR_MATRIX_ABILITY_V41
{
    DWORD dwSize;
    BYTE  byDspNums;//DSP numbers
    BYTE  byDecChanNums;//decoder channel numbers
    BYTE  byStartChan;//the start index of decoder channels
    BYTE  byRes1[5];
    NET_DVR_DISPINFO struVgaInfo;//information of VGA channels
    NET_DVR_DISPINFO struBncInfo;//information of BNC channels
    NET_DVR_DISPINFO struHdmiInfo;//information of HDMI channels
    NET_DVR_DISPINFO struDviInfo;//information of DVI channels
    NET_DVR_DISPWINDOWMODE struDispMode[MAX_DISPNUM_V41/*32*/];
    NET_DVR_SCREENINFO struBigScreenInfo;
    BYTE  bySupportAutoReboot; //auto reboot:0-not support\A3\AC1-support
    BYTE  byRes2[3];
    NET_DVR_SDI_INFO struSDIInfo;//SDI display channel information
    BYTE  byRes3[48];
} NET_DVR_MATRIX_ABILITY_V41, *LPNET_DVR_MATRIX_ABILITY_V41;

#define  MAX_WINDOWS                16
#define  MAX_WINDOWS_V41            36

#define  STARTDISPCHAN_VGA            1
#define  STARTDISPCHAN_BNC            9
#define  STARTDISPCHAN_HDMI            25
#define  STARTDISPCHAN_DVI            29



typedef union tagNET_DVR_VIDEO_PLATFORM
{
    BYTE byRes[160];
    struct
    {
        BYTE    byJoinDecoderId[MAX_WINDOWS_V41];
        BYTE    byDecResolution[MAX_WINDOWS_V41];
        NET_DVR_RECTCFG struPosition; //Display channel position in TV wall
        BYTE    byRes[80];
    }struVideoPlatform;
    struct
    {
        BYTE    byRes[160];
    }struNotVideoPlatform;
}NET_DVR_VIDEO_PLATFORM, LPNET_DVR_VIDEO_PLATFORM;


typedef struct tagNET_DVR_MATRIX_VOUTCFG
{
    DWORD    dwSize;
    BYTE    byAudio;            //is audio value
    BYTE    byAudioWindowIdx;      /*audio window Index*/
    BYTE    byDispChanType;      /*display channel type\A3\BA0-BNC\A3\AC1-VGA\A3\AC2-HDMI\A3\AC3-DVI\A3\AC4-YPbPr(DECODER_SERVER device used)*/
    BYTE    byVedioFormat;         /*1:NTSC,2:PAL\A3\AC0-NULL*/
    DWORD    dwResolution;
    DWORD    dwWindowMode;        /*the max value get from ability*/
    BYTE    byJoinDecChan[MAX_WINDOWS_V41];/*the decoder channel of every window conjunction*/
    BYTE    byEnlargeStatus;          /*0\A3\BAzoom in \A3\AC1\A3\BAzoom out*/
    BYTE    byEnlargeSubWindowIndex;//the index of window which is zoom in
    BYTE    byScale; /*0---realty  show\A3\AC1---zoom show( BNC )*/
    BYTE    byUnionType;/*0-use for the display channels of decoder in video platform\A3\AC1-use for the other disp channels of decoders*/
    NET_DVR_VIDEO_PLATFORM        struDiff;
    DWORD   dwDispChanNum; //Display channel N0.,only valid for getting all display channels' configure
    WORD     wLEDWidth;     //LED resolution width, 0 means invaild
    WORD     wLEDHeight;    //LED resolution height, 0 means invaild
    BYTE      byEnableVideoEffect;  //
    BYTE      byRes[3];  //
    NET_DVR_VIDEOEFFECT struVideoEffect;   //
}NET_DVR_MATRIX_VOUTCFG,*LPNET_DVR_MATRIX_VOUTCFG;

typedef struct tagNET_DVR_DISP_CHAN_STATUS_V41
{
    BYTE  byDispStatus;      /*0\A3\BAunshow\A3\AC1\A3\BAshow*/
    BYTE  byBVGA;              /*0-BNC\A3\AC1-VGA\A3\AC 2-HDMI\A3\AC3-DVI\A3\AC0xff-invalid*/
    BYTE  byVideoFormat;     /*1:NTSC,2:PAL,0-NON*/
    BYTE  byWindowMode;
    BYTE  byJoinDecChan[MAX_WINDOWS_V41];   /*the decoder channel of every window conjunction*/
    BYTE  byFpsDisp[MAX_WINDOWS_V41];        /*rate of frame*/
    BYTE  byScreenMode;        /*screen mode 0-normal 1-big screen*/
    BYTE  byRes1[3];
    DWORD  dwDispChan; /*only valid for getting all*/
    BYTE  byRes2[24];
}NET_DVR_DISP_CHAN_STATUS_V41, *LPNET_DVR_DISP_CHAN_STATUS_V41;

typedef struct tagNET_DVR_DECODER_WORK_STATUS_V41
{
    DWORD dwSize;
    NET_DVR_MATRIX_CHAN_STATUS struDecChanStatus[32];     /*status of decoder channels*/
    NET_DVR_DISP_CHAN_STATUS_V41   struDispChanStatus[MAX_DISPNUM_V41/*32*/];   /*status of disp channels*/
    BYTE byAlarmInStatus[32];         /*status of alarm in*/
    BYTE byAlarmOutStatus[32];       /*status of alarm out*/
    BYTE byAudioInChanStatus;          /*status of audio in*/
    BYTE byRes[127];
}NET_DVR_DECODER_WORK_STATUS_V41,*LPNET_DVR_DECODER_WORK_STATUS_V41;

typedef struct tagNET_DVR_MATRIX_DEC_REMOTE_PLAY_V41
{
    DWORD    dwSize;
    NET_DVR_IPADDR    struIP;        /* DVR IP*/
    WORD    wDVRPort;            /* port*/
    BYTE    byChannel;            /* channels */
    BYTE     byReserve;
    BYTE    sUserName[NAME_LEN];
    BYTE    sPassword[PASSWD_LEN];
    DWORD    dwPlayMode;       /* 0\A3\ADplay by file name 1\A3\ADplay by time*/
    NET_DVR_TIME StartTime;
    NET_DVR_TIME StopTime;
    char    sFileName[128];
    BYTE    byRes[64];
}NET_DVR_MATRIX_DEC_REMOTE_PLAY_V41, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_V41;

#define        MAX_BIGSCREENNUM    100// Max Screen number

typedef struct tagNET_DVR_SINGLESCREENCFG
{
    BYTE    byScreenSeq;//screen sequence, 0xff means doesn't use this screen\A3\ACthe first screen is main screen
    BYTE    bySubSystemNum;//slot index in subsystem of decode, this value is unuseful in 64-T decoder
    BYTE    byDispNum;//display channel index in subsystem of decode
    BYTE    byRes[9];
}NET_DVR_SINGLESCREENCFG, *LPNET_DVR_SINGLESCREENCFG;

typedef struct tagNET_DVR_BIGSCREENCFG
{
    DWORD   dwSize;
    BYTE    byEnable;                // 0-Enable\A3\AC1-Unable
    BYTE    byModeX;                // splice mode :x
    BYTE    byModeY;                // splice mode :y
    BYTE    byMainDecodeSystem;        // slot index of main screen in video platform, decode channel number in 64-T decoder
    BYTE    byMainDecoderDispChan;    // display of main screen\A3\AC1.1netra decoder has two display channels, each of them can be used as main screen, this value is unuseful in 64-T decoder
    BYTE    byVideoStandard;        // the format of every single screen is same1:NTSC,2:PAL
    BYTE    byRes1[2];
    DWORD  dwResolution;            // the resolution of every single screen is same
    NET_DVR_SINGLESCREENCFG struFollowSingleScreen[MAX_BIGSCREENNUM];
    WORD    wBigScreenX; //Big screen X coordinate
    WORD    wBigScreenY; //Big screem Y coordinate
    BYTE    byRes2[12];
}NET_DVR_BIGSCREENCFG, *LPNET_DVR_BIGSCREENCFG;
/////***********************************64-Tdecoder end*************************************//////


/********************************video platform scene begin*******************************/
#define  MAX_BIGSCREENNUM_SCENE 100
#define  MAX_LAYERNUMS    32


typedef struct tagNET_DVR_RECTCFG_SCENE
{
    WORD wXCoordinate; // x Coordinate of the upper left corner
    WORD wYCoordinate; // y Coordinate of the upper left corner
    WORD wWidth;       // width of the box
    WORD wHeight;      // height of the box
}NET_DVR_RECTCFG_SCENE, *LPNET_DVR_RECTCFGSCENE;

typedef struct tagNET_DVR_SCENEDISPCFG
{
    BYTE    byEnable;                // 0-not used\A3\AC1-used
    BYTE    bySoltNum;                // slot number
    BYTE    byRes1[2];
    BYTE    byDispChanNum;
    BYTE    byAudio;                // 0-close\A3\AC1-open
    BYTE    byAudioWindowIdx;       // the index of window which open the audio
    BYTE    byVedioFormat;          // 1:NTSC,2:PAL,0-NULL
    BYTE    byWindowMode;            // window mode\A3\ACget from the ability
    BYTE    byEnlargeStatus;        // enlarge status, 0: does not enlarge, 1: enlarge
    BYTE    byEnlargeSubWindowIndex;// index of sub window which enlarge
    BYTE    byScale;                // display mode\A3\AC0-the real show\A3\AC1-zoom display(BNC)
    DWORD   dwResolution;            // resolution
    BYTE    byJoinDecChan[MAX_WINDOWS_V41];     // join decoder channel of the sub window
    BYTE    byJoinDecoderId[MAX_WINDOWS_V41];// decoder slot
    //resolution 1-D1,2-720P,3-1080P\A3\ACthe device alloc the decode channel according to this parameter
    BYTE    byDecResolution[MAX_WINDOWS_V41];
    BYTE    byRow;                    // row of the screen in the whole screen wall
    BYTE    byColumn;                // column of the screen in the whole screen wall
    BYTE    byRes2[5];
    NET_DVR_RECTCFG struDisp;        // location of screen wall
} NET_DVR_SCENEDISPCFG,*LPNET_DVR_SCENEDISPCFG;

typedef struct tagDEV_CHAN_INFO_SCENE
{
    NET_DVR_IPADDR struIP;            // IP address
    WORD     wDVRPort;                 // port
    BYTE     byChannel;                // channel index\A3\ACthe index start from 33 if the device use ip channel as 9000 dvr
    BYTE    byTransProtocol;        // trans protocol 0-TCP\A3\AC1-UDP \A3\AC2-MCAST\A3\AC3-RTP
    BYTE    byTransMode;            // trans mode 0\A3\ADmain stream 1\A3\ADsub stream
    BYTE    byFactoryType;            // factory type
    BYTE    byDeviceType;            // device type 1-IPC\A3\AC2- ENCODER
    BYTE    byRes[5];
    BYTE    sUserName[NAME_LEN];    // user name of the monitor
    BYTE    sPassword[PASSWD_LEN];    // password of the monitor
} NET_DVR_DEV_CHAN_INFO_SCENE,*LPNET_DVR_DEV_CHAN_INFO_SCENE;

typedef struct tagSTREAM_MEDIA_SERVER_CFG_SCENE
{
    BYTE    byValid;            // 1-use stream media 0-does not use stream media
    BYTE    byRes1[3];
    NET_DVR_IPADDR struDevIP;    // ip of stream media server
    WORD    wDevPort;            // port of stream media server
    BYTE    byTransmitType;        // transmit type 0-TCP\A3\AC1-UDP
    BYTE    byRes2[5];
}NET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE,*LPNET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE;

typedef struct tagPU_STREAM_CFG_SCENE
{
    NET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE    streamMediaServerCfg;
    NET_DVR_DEV_CHAN_INFO_SCENE                struDevChanInfo;
}NET_DVR_PU_STREAM_CFG_SCENE,*LPNET_DVR_PU_STREAM_CFG_SCENE;

typedef struct  tagNET_DVR_CYC_SUR_CHAN_ELE_SCENE
{
    BYTE                            byEnable;                //enable status: 0\A3\ADdisable 1-enable
    BYTE                            byRes[3];
    NET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE    struStreamMediaSvrCfg;
    NET_DVR_DEV_CHAN_INFO_SCENE            struDecChanInfo;    //decoder channel information
}NET_DVR_CYC_SUR_CHAN_ELE_SCENE,*LPNET_DVR_CYC_SUR_CHAN_ELE_SCENE;

//loop decode
typedef struct  tagNET_DVR_MATRIX_LOOP_DECINFO_SCENE
{
    WORD    wPoolTime;        //time interval of loop
    BYTE    byRes1[2];
    NET_DVR_CYC_SUR_CHAN_ELE_SCENE    struChanArray[MAX_CYCLE_CHAN/*16*/];
    BYTE    byRes2[4];
} NET_DVR_MATRIX_LOOP_DECINFO_SCENE,*LPNET_DVR_MATRIX_LOOP_DECINFO_SCENE;

//single decode channel information
typedef struct tagNET_DVR_DECODECHANCFG_SCENE/*struct size : 2064*/
{
    BYTE    byDecodeEnable; //decode mark\A3\AC0-stop\A3\AC1-use dynamic decode\A3\AC2-use loop decode
    BYTE    bySlotNum;        //slot index
    BYTE    byDecChan;        //decoder channel index
    BYTE    byRes[5];
    union
    {
        NET_DVR_PU_STREAM_CFG_SCENE struSceneDynamicDecCfg;        //dynamic decode
        NET_DVR_MATRIX_LOOP_DECINFO_SCENE struSceneCycDecCfg;    //cycle    decode
    } struDecCfg;
}NET_DVR_DECODECHANCFG_SCENE,*LPNET_DVR_DECODECHANCFG_SCENE;

typedef struct tagNET_DVR_BIGSCREENCFG_SCENE
{
    BYTE byAllValid;            //roam status: 0:disable 1-enable
    BYTE byAssociateBaseMap;    //base map index\A3\AC0:does not associate
    BYTE byEnableSpartan;//enable spartan\A3\AC1-enable\A3\AC0-disable
    BYTE byRes;
    NET_DVR_WINCFG struWinCfg[MAX_LAYERNUMS];
    NET_DVR_BIGSCREENCFG struBigScreen;
}NET_DVR_BIGSCREENCFG_SCENE, *LPNET_DVR_BIGSCREENCFG_SCENE;

typedef struct tagNET_DVR_MATRIX_SCENECFG
{
    DWORD dwSize;
    BYTE  sSceneName[NAME_LEN];
    BYTE  byBigScreenNums;    //big screen numbers, the max number should get from the ability
    BYTE  byRes1[3];
    WORD  wDecChanNums;        //decode channel numbers
    WORD  wDispChanNums;    //display channel numbers
    BYTE  byRes2[12];
    BYTE  *pBigScreenBuffer;//buffer store big screen struct, byBigScreenNums\A1\C1sizeof(NET_DVR_BIGSCREENCFG_SCENE)
    BYTE  *pDecChanBuffer;    //buffer store decode channel, wDecChanNums\A1\C1sizeof(NET_DVR_DECODECHANCFG_SCENE)
    BYTE  *pDispChanBuffer;    //buffer store display channel, wDispChanNums\A1\C1sizeof(NET_DVR_SCENEDISPCFG)
}NET_DVR_MATRIX_SCENECFG, *LPNET_DVR_MATRIX_SCENECFG;

/********************************video platform scene end*******************************/

/********************************NetAlarmHost begin*******************************/
//////////subsystem config/////////////
#define MAX_ALARMHOSTKEYBOARD 64 //max keyboards of alarmhost
typedef struct tagNET_DVR_PUBLIC_SUB_SYSTEM
{
    //bit0- associate first subsystem.
    DWORD    dwJointSubSystem;
    BYTE    byRes[16];
}NET_DVR_PUBLIC_SUB_SYSTEM, *LPNET_DVR_PUBLIC_SUB_SYSTEM;

typedef struct tagNET_DVR_NOAMAL_SUB_SYSTEM
{
    //bit0 \A3\ACbe associated by the first public subsystem
    DWORD	dwBeJoinedSubSystem;
    BYTE	byRes[16];
}NET_DVR_NOAMAL_SUB_SYSTEM, *LPNET_DVR_NOAMAL_SUB_SYSTEM;

typedef union tagNET_DVR_JOINT_SUB_SYSTEM
{
    // use this parameter while byPublicAttributeEnable is 0
    NET_DVR_NOAMAL_SUB_SYSTEM     struNormalSubSystem;
    //use this parameter while byPublicAttributeEnable is 1
    NET_DVR_PUBLIC_SUB_SYSTEM        struPublicSubSystem;
    BYTE    byRes[20];
}NET_DVR_JOINT_SUB_SYSTEM,*LPNET_DVR_JOINT_SUB_SYSTEM;

//////////GPRS parameter config/////////////
#define    ACCOUNTNUM_LEN             6
#define ACCOUNTNUM_LEN_32       32
#define ACCOUNTNUM_LEN_V40      9
#define    APN_NAME_LEN            32
#define    APN_USERNAME_LEN        24
#define    APN_USERPASSWORD_LEN    16

#define MAX_SUBSYSTEM_ID_LEN 16

typedef struct tagNET_DVR_ALARMSUBSYSTEMPARAM
{
    DWORD   dwSize;
    WORD    wEnterDelay;//enter delay  uint:s
    WORD    wExitDelay;//exit delay :s
    BYTE    byHostageReport;//hostage report\A3\AC0-disable 1-enable
    BYTE        bySubsystemEnable; //subsystem enable
    BYTE        byKeyToneOfArmOrDisarm;// keyboard warn while send arm or disarm report successful\A3\AC0-no 1-yes
    BYTE        byKeyToneOfManualTestReport;    //keyboard warn while send test report successful\A3\AC0-no 1-yes
    WORD        wDelayTime;                        //delay time of siren
    BYTE        byEnableAlarmInDelay;//0--disable,1--enable
    BYTE         byPublicAttributeEnable;            //public subsystem enable
    NET_DVR_JOINT_SUB_SYSTEM struJointSubSystem;
    BYTE        byKeyZoneArm;        //arm subsystem by key switch
    BYTE        byKeyZoneArmReport;    //send report while key switch arm subsystem
    BYTE        byKeyZoneDisarm;    //disarm subsystem by key switch
    BYTE        byKeyZoneDisarmReport;    //send report while key switch disarm subsystem
    BYTE        bySubSystemID[MAX_SUBSYSTEM_ID_LEN];    //subsystem ID
    BYTE        byKeyZoneArmReportEnable;    //0--disable,1--enable
    BYTE      byKeyZoneArmEnable;    //0--disable,1--enable
    BYTE       byOneKeySetupAlarmEnable;          //0--disable,1--enable
    BYTE       bySingleZoneSetupAlarmEnable;       //0--disable,1--enable
    BYTE    byCenterType;                    //0-invalid, 1-center account(length-6), 2-center account(length-9)
    BYTE    sCenterAccount[ACCOUNTNUM_LEN/*6*/];    //center account
    BYTE    sCenterAccountV40[ACCOUNTNUM_LEN_32/*32*/];    //center account V40, sCenterAccount invalid when using it
    BYTE         byRes2[565];
}NET_DVR_ALARMSUBSYSTEMPARAM, *LPNET_DVR_ALARMSUBSYSTEMPARAM;

typedef struct  tagNET_DVR_REMIND_TIME//8
{
    BYTE byEnable;// 0-disable\A3\AC1-enable
    BYTE byHour;//0~24
    BYTE byMinute;//0~60
    BYTE bySecond;//0~60
}NET_DVR_REMIND_TIME,*LPNET_DVR_REMIND_TIME;

#define    MAX_KEYBOARD_USER_NUM    256
typedef struct tagNET_DVR_SUBSYSTEM_PARAM_EX
{
    DWORD     dwSize;
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS/*7*/][MAX_TIMESEGMENT_V30/*8*/]; //time of arm or disarm
    BYTE    byAlarmInAdvance;            // warn time of advance 0~45
    BYTE    byRes1[3];
    BYTE     byJointAlarmIn[MAX_ALARMHOST_ALARMIN_NUM / 8];//subsystem joint alarm in 0-no, 1-yes
    BYTE     byJointKeyboard[MAX_ALARMHOSTKEYBOARD/*64*/ / 8];//subsystem joint keyboard 0-no, 1-yes
    BYTE    byJointOpetaterUser[MAX_KEYBOARD_USER_NUM/8];//subsystem joint keyboard user 0-no, 1-yes
    NET_DVR_REMIND_TIME    struAlarmRemindTime[MAX_DAYS/*7*/][MAX_TIMESEGMENT_V30/*8*/];
    BYTE             byRes2[288];
}NET_DVR_SUBSYSTEM_PARAM_EX, *LPNET_DVR_SUBSYSTEM_PARAM_EX;

typedef struct tagNET_DVR_REGISTER_RS485CFG
{
    DWORD   dwSize;
    WORD    wDeviceProtocol;        // device protocol
    BYTE    byRes[2];
    DWORD   dwBaudRate;             //band rate(bps),0-50,1-75,2-110,3-150,4-300,5-600,6-1200,7-2400,8-4800,9-9600,10-19200,11-38400,12-57600,13-76800,14-115.2k
    BYTE    byRes1[124];              // res
}NET_DVR_REGISTER_RS485CFG, *LPNET_DVR_REGISTER_RS485CFG;

typedef struct tagNET_DVR_ALARMHOST_PRINTER_CFG
{
    DWORD 	dwSize;
    BYTE 	byPrinterEnable;		//printer enable
    BYTE	byPrintTime;			//print time
    BYTE 	byFaultDetect;			//check fault
    BYTE	byRes1;
    DWORD	dwAlarmInfo;			//alarm information\A3\ACevery bit means a alarm type\A1\A3bit0-zone alarm\A3\ACbit1-zone alarm restore\A3\ACbit2-emergency Keypad Alarms\A3\ACbit-3-duress alarm
    DWORD	dwDeviceInfo;			//device information\A3\ACevery bit means a alarm type\A1\A3bit0-AC loss\A1\A2bit1-AC loss restore\A3\ACbit2-System low battery\A1\A2bit3-System low battery restore\A3\ACbit4-PSTN Fault\A1\A2bit5-PSTN fault restore\A3\ACbit6-test report\A1\A2bit7-tamper alarm\A1\A2bit8-temper restore\A1\A2bit9-485 device fault\A1\A2bit10-485 device restore\A1\A2bit11-wireless network fault\A1\A2bit12-wireless network restore\A1\A2bit13-network fault\A1\A2bit14-network restore\A1\A2bit15-BUS Fault\A1\A2bit16-BUS restore\A1\A2bit17-hard disk faault\A1\A2bit18-hard disk restore\A1\A2bit19-keyboard locked
    DWORD	dwOperateInfo;			//operate information\A3\ACevery bit means a alarm type bit0-arm\A1\A2bit1-disarm\A1\A2bit2-clear alarm\A1\A2bit3-bypass\A1\A2bit4-bypass restore\A1\A2bit5-enter program\A1\A2bit6-exit program\A1\A2bit7-restart
    BYTE 	byRes2[256];
}NET_DVR_ALARMHOST_PRINTER_CFG, *LPNET_DVR_ALARMHOST_PRINTER_CFG;

typedef struct tagNET_DVR_ALARMHOST_NETPARAM
{
    DWORD dwSize;
    NET_DVR_IPADDR struIP;
    WORD    wPort;
    BYTE    byAddressType;    //0 - invalid, 1 - ipv4/ipv6 addres\A3\AC2 - domain name
    BYTE    byRes1[1];
    BYTE    byDomainName[MAX_DOMAIN_NAME/*64*/]; //domain name
    BYTE    byReportProtocol;        //1-private 2-NAL2300
    BYTE    byDevID[ACCOUNTNUM_LEN_32/*32*/]; //it is valid while the protocol is NAL2300
    BYTE    byRes2[7];
}NET_DVR_ALARMHOST_NETPARAM,  *LPNET_DVR_ALARMHOST_NETPARAM;

typedef struct tagNET_DVR_ALARMHOST_WIRELESS_NETWORK_CFG
{
    DWORD    dwSize;
    NET_DVR_ALARMHOST_NETPARAM struNetCenter[MAX_CENTERNUM]; //center parameters
    BYTE     byAPNName[APN_NAME_LEN/*32*/];
    BYTE    byAPNUserName[APN_USERNAME_LEN/*24*/];
    BYTE    byAPNPassWord[APN_USERPASSWORD_LEN/*16*/];
    BYTE    byReconnTime;    //Reconnect time, it is started when connecting is failed, unit: 10s range:(1-30)
    BYTE    byOverTime;        //Overtime, if there is no valid data in the OverTime\A3\ACreconnect range: 1-254\A3\ACunit :30s
    BYTE    byDetectLinkTime;    // range 1-30\A3\ACunit:10s
    BYTE    byRes1;
    BYTE    bySIMNum[NAME_LEN/*32*/]; //SIM number
    NET_DVR_IPADDR    struSIMIP;      //Get only
    BYTE    byRes2[64];
}NET_DVR_ALARMHOST_WIRELESS_NETWORK_CFG, *LPNET_DVR_ALARMHOST_WIRELESS_NETWORK_CFG;


//////////net parameter config/////////////
typedef struct tagNET_DVR_ALARMHOST_NETCFG
{
    DWORD dwSize;
    NET_DVR_ALARMHOST_NETPARAM     struNetCenter[MAX_CENTERNUM];
    BYTE    byRes1[32];
}NET_DVR_ALARMHOST_NETCFG,  *LPNET_DVR_ALARMHOST_NETCFG;

//////////report mode/////////////
#define    MAX_REPORTCHAN_NUM        4
#define    MAX_CENTERGROUP_NUM        16
typedef struct tagNET_DVR_ALARMHOST_REPORTCENTER_CFG
{
    DWORD    dwSize;
    BYTE    byValid;
    BYTE    byRes[3];
    BYTE    byChanAlarmMode[MAX_REPORTCHAN_NUM/*4*/];    //alarm channels\A3\AC 1-T1\A1\A22-T2\A1\A2 3-N1\A1\A2 4-N2\A1\A25-G1\A1\A2 6-G2
    BYTE    byDealFailCenter[MAX_CENTERGROUP_NUM/*16*/]; //send to these centers while send faile 0-not choose\A1\A21-choose
    BYTE    byDataType;    //1-alarm date 2-not alarm data 3-all data
    BYTE    byRes2[15];    //
}NET_DVR_ALARMHOST_REPORTCENTER_CFG, *LPNET_DVR_ALARMHOST_REPORTCENTER_CFG;

/********************************NetAlarmHost end*********************************/

#define MAX_EVENT_NUM 32// max event number
typedef struct tagNET_DVR_ALARMHOST_REPORT_CENTER_CFG_V40
{
    DWORD        dwSize;
    BYTE        byValid;
    BYTE        byDataType;            //1-All alarm data 2-not alarm data 3-all data\A3\AC4-zone report\A3\AC5-not zone report
    BYTE        byRes[2];
    BYTE        byChanAlarmMode[MAX_REPORTCHAN_NUM/*4*/];//alarm channels\A3\AC 1-T1\A1\A22-T2\A1\A2 3-N1\A1\A2 4-N2\A1\A25-G1\A1\A2 6-G2
    BYTE        byDealFailCenter[MAX_CENTERGROUP_NUM/*16*/]; //send to these centers while send faile 0-not choose\A1\A21-choose
    BYTE         byZoneReport[MAX_ALARMHOST_ALARMIN_NUM];    //zone report type\A3\AC0-not upload\A3\AC1-upload
    BYTE        byNonZoneReport[MAX_EVENT_NUM]; //not zone report, 0-not upload\A3\AC1-upload byNonZoneReport[0]-soft zone report byNonZoneReport[1]-system status report byNonZoneReport[2]-cancel report byNonZoneReport[3]-test report byNonZoneReport[4]-arm report byNonZoneReport[5]-disarm report byNonZoneReport[6]-duress report byNonZoneReport[7]-alarm recovery report byNonZoneReport[8]-bypass report byNonZoneReport[9]-bypass restore report,byNonZoneReport[10]-detector connect status report\A3\A8online/offline\A3\A9,byNonZoneReport[11]-detector power status report\A3\A8normal/low\A3\A9
    BYTE        byRes2[256];
}NET_DVR_ALARMHOST_REPORT_CENTER_CFG_V40, *LPNET_DVR_ALARMHOST_REPORT_CENTER_CFG_V40;

// Stream record status
typedef struct tagNET_DVR_STREAM_RECORD_STATUS
{
    DWORD          dwSize;
    BYTE            byRecord;         //(Read only)record type, 0\A3\BAnot record 1\A3\BArecording
    BYTE            byOffLineRecord;  // 0-off 1-on
    BYTE            byRes1[2];
    DWORD            dwRelatedHD;      //Related hard disk
    BYTE            byRes2[8];
}NET_DVR_STREAM_RECORD_STATUS, *LPNET_DVR_STREAM_RECORD_STATUS;

#define  CHAN_NO_LEN   24
typedef struct tagNET_DVR_DIRECT_CONNECT_CHAN_INFO
{
    BYTE        byEnable;                    //Enable or not
    BYTE        byProType;                    //Protocol type 0-Hik(default), need ability to get
    BYTE          byZeroChan;                    //Is zero channel ,0-no\A3\AC1-yes
    BYTE        byPriority;                //priority
    BYTE        sUserName[NAME_LEN];        //User name
    BYTE        sPassword[PASSWD_LEN];        //password
    BYTE        byDomain[MAX_DOMAIN_NAME];    //Domain
    NET_DVR_IPADDR  struIP;                        //IP adrress
    WORD        wDVRPort;                     //Port
    BYTE        byStreamType;               //Stream type 0:Main stream 1: Sub stream
    BYTE        byOnline;                    //Read only\A3\AC0-offline 1-online
    DWORD        dwChannel;                  //Channel number
    BYTE        byTransProtocol;            //Transmition protocol\A3\AC0-TCP\A3\AC1-UDP\A3\AC2-multicast
    BYTE        byLocalBackUp;
    WORD        wDirectLastTime;            //direct last time
    BYTE        byChanNo[CHAN_NO_LEN];     //Chan No
}NET_DVR_DIRECT_CONNECT_CHAN_INFO, *LPNET_DVR_DIRECT_CONNECT_CHAN_INFO;


typedef struct tagNET_DVR_DIRECT_CONNECT_CHAN_INFO_V40
{
    BYTE        byEnable;                    //Enable or not
    BYTE        byProType;                    //Protocol type 0-private(default), need ability to get
    BYTE          byZeroChan;                    //Is zero channel ,0-no\A3\AC1-yes
    BYTE        byRes1;
    BYTE        sUserName[NAME_LEN];        //User name
    BYTE        sPassword[PASSWD_LEN];        //password
    BYTE        byAddress[MAX_DOMAIN_NAME];    //Domain
    WORD        wDVRPort;                     //Port
    BYTE        byStreamType;               //Stream type 0:Main stream 1: Sub stream
    BYTE        byOnline;                    //Read only\A3\AC0-offline 1-online
    DWORD        dwChannel;                  //Channel number
    BYTE        byTransProtocol;            //Transmition protocol\A3\AC0-TCP\A3\AC1-UDP\A3\AC2-multicast
    BYTE        byLocalBackUp;
    BYTE        byRes3[2];
    BYTE        byVAGChanNo[MAX_VAG_CHANNO_LEN];
    BYTE        byRes[340];
}NET_DVR_DIRECT_CONNECT_CHAN_INFO_V40, *LPNET_DVR_DIRECT_CONNECT_CHAN_INFO_V40;


typedef struct tagNET_DVR_PU_STREAM_URL_CFG
{
    BYTE    byEnable;
    BYTE    byRes[3];
    BYTE    byStreamMediaIP[64];
    WORD    wStreamMediaPort;
    BYTE    byTransmitType;
    BYTE    byRes1[33];
    BYTE    byDevIP[64];
    WORD    wDevPort;
    BYTE    byChannel;
    BYTE    byTransMode; // 0-main 1- sub
    BYTE    byProType;
    BYTE    byTransProtocol; //0-TCP,  1-UDP,  2-MultiCast,  3-RTP
    BYTE    byRes3[2];
    BYTE    sUserName[NAME_LEN];
    BYTE    sPassWord[PASSWD_LEN];
    BYTE    byRes2[28];
}NET_DVR_PU_STREAM_URL_CFG, *LPNET_DVR_PU_STREAM_URL_CFG;

typedef struct tagNET_DVR_PU_STREAM_URL_CFG_V40
{
    BYTE    byEnable;
    BYTE    byRes[3];
    BYTE    byStreamMediaIP[64];
    WORD    wStreamMediaPort;
    BYTE    byTransmitType; //Transmit Type  0- TCP  1- UDP
    BYTE    byRes1;
    BYTE    byDevIP[64];
    WORD    wDevPort;
    BYTE    byChannel;
    BYTE    byTransMode; // 0-main 1- sub
    BYTE    byProType;
    BYTE    byTransProtocol; //0-TCP,  1-UDP,  2-MultiCast,  3-RTP
    BYTE    byRes3[2];
    BYTE    sUserName[NAME_LEN];
    BYTE    sPassWord[PASSWD_LEN];
    BYTE    byRes2[308];
}NET_DVR_PU_STREAM_URL_CFG_V40, *LPNET_DVR_PU_STREAM_URL_CFG_V40;

typedef struct tagNET_DVR_STREAM_URL_V40
{
    BYTE    byEnable;
    BYTE    byStreamType;
    BYTE    byLocalBackUp;
    BYTE     byRes;
    BYTE    strURL[URL_LEN_V40];
    DWORD   dwProtocalType;
    BYTE    sUserName[NAME_LEN];
    BYTE    sPassWord[PASSWD_LEN];
    BYTE    byAddress[MAX_DOMAIN_NAME];
    WORD    wIPPort;
    WORD    wChanNo;
    BYTE    byVAGChanNo[MAX_VAG_CHANNO_LEN];
    BYTE     byRes1[88];
}NET_DVR_STREAM_URL_V40, *LPNET_DVR_STREAM_URL_V40;

typedef union tagNET_DVR_STREAM_TYPE_UNION
{
    NET_DVR_DIRECT_CONNECT_CHAN_INFO    struChanInfo;          //IP Channel information
    NET_DVR_PU_STREAM_URL                struStreamUrl;        //Stream url
    NET_DVR_PU_STREAM_URL_CFG           struStreamUrlCfg;     //Get Stream for vqd 6
}NET_DVR_STREAM_TYPE_UNION, *LPNET_DVR_STREAM_TYPE_UNION;

typedef union tagNET_DVR_STREAM_TYPE_V40_UNION
{
    NET_DVR_DIRECT_CONNECT_CHAN_INFO_V40    struChanInfo;     //IP Channel information 0
    NET_DVR_PU_STREAM_URL struPuStreamUrl;        //Stream url- 4
    NET_DVR_PU_STREAM_URL_CFG_V40   struStreamUrlCfg; //Get Stream for vqd 6
    NET_DVR_RTSP_PROTOCAL_CFG struRtspCfg;        //Get Stream by RTSP 7
    NET_DVR_STREAM_URL_V40  struStreamUrlV40;  // By streaming sources to take the stream flow (supports cascade) 8
}NET_DVR_STREAM_TYPE_V40_UNION, *LPNET_DVR_STREAM_TYPE_V40_UNION;


typedef struct tagNET_DVR_STREAM_MODE_TYPE
{
    BYTE                    byGetStreamType;    //Stream type 0-direct get stream from device\A3\AC1-from stream media\A1\A22-From IPServer to device ip to get stream, 3.From IPServer find device\A3\ACthen get stream by stream media 4-From stream media by URL
    BYTE                    byRes[3];
    NET_DVR_STREAM_TYPE_UNION    uGetStream;
}NET_DVR_STREAM_MODE_TYPE, *LPNET_DVR_STREAM_MODE_TYPE;

// Stream source information
typedef struct tagNET_DVR_STREAM_SRC_INFO
{
    DWORD                    dwSize;
    NET_DVR_STREAM_MODE_TYPE    struStreamSrcInfo;
}NET_DVR_STREAM_SRC_INFO,*LPNET_DVR_STREAM_SRC_INFO;

typedef struct tagNET_DVR_STREAM_SRC_INFO_V40
{
    DWORD                    dwSize;
    BYTE                    byGetStreamType;    //Stream type 0-direct get stream from device,
    //1-from stream media\A1\A22-From IPServer to device ip to get stream, 3.From IPServer find device\A3\ACthen get stream by stream media
    //4-From stream media by URL 7-RTSP  8-By streaming sources to take the stream flow (supports cascade)
    BYTE                    byRes1[3];
    NET_DVR_STREAM_TYPE_V40_UNION    uGetStream;
    BYTE                    byRes[512];
}NET_DVR_STREAM_SRC_INFO_V40,*LPNET_DVR_STREAM_SRC_INFO_V40;


// Stream record information
typedef struct
{
    DWORD            dwSize;
    NET_DVR_RECORD_V30    struRecordInfo;
}NET_DVR_STREAM_RECORD_INFO, *LPNET_DVR_STREAM_RECORD_INFO;

//  lock record by time and stream id
typedef struct tagNET_DVR_STREAM_TIME_LOCK
{
    DWORD            dwSize;
    NET_DVR_TIME        strBeginTime;
    NET_DVR_TIME        strEndTime;
    NET_DVR_STREAM_INFO struStreamInfo;        // Stream info
    DWORD            dwRecordType;
    DWORD            dwLockDuration;      // 0xffffffff: always lock
    NET_DVR_TIME_EX        strUnlockTimePoint;
    BYTE                byRes[4];
}NET_DVR_STREAM_TIME_LOCK, *LPNET_DVR_STREAM_TIME_LOCK;


typedef struct tagNET_DVR_VOD_DRAWFRAME_PARA
{
    NET_DVR_TIME_EX struTime;
    /*
    dwDrawType
    0\A3\BAI
    1\A3\BAdrop1/2 P\A3\A8only svc code stream support\A3\A9
    2\A3\BAdrop3/4P  \A3\A8only svc code stream support\A3\A9
    3\A3\BAsend1/2 I
    4\A3\BAsend1/4 I
    5\A3\BAsend1/8 I
    */
    DWORD  dwDrawType;
    BYTE   byRes[128];
}NET_DVR_VOD_DRAWFRAME_PARA, *LPNET_DVR_VOD_DRAWFRAME_PARA;

typedef struct tagNET_DVR_MANUAL_RECORD_PARA
{
    NET_DVR_STREAM_INFO struStreamInfo;
    DWORD            lRecordType;
    BYTE            byRes[32];
}NET_DVR_MANUAL_RECORD_PARA, *LPNET_DVR_MANUAL_RECORD_PARA;

typedef struct tagNET_DVR_BIGSCREENASSOCIATECFG
{
    DWORD dwSize;
    BYTE  byEnableBaseMap;
    BYTE  byAssociateBaseMap;
    BYTE  byEnableSpartan;
    BYTE  byRes[21];
} NET_DVR_BIGSCREENASSOCIATECFG, *LPNET_DVR_BIGSCREENASSOCIATECFG;
/*******************************config screen window*******************************/
#define MAX_WIN_COUNT  224 //maximum of windows

typedef struct tagNET_DVR_SCREEN_WINCFG
{
    DWORD    dwSize;
    BYTE    byVaild;
    BYTE    byInputType;        //CAM_MDOE
    WORD    wInputIdx;            //index of input
    DWORD    dwLayerIdx;            //index of layer, 0- layer is on the bottom
    NET_DVR_RECTCFG  struWin;    //window location, relativity to the display wall
    BYTE    byWndIndex;            //index of window
    BYTE    byCBD;                //0-NULL\A3\AC1-has background\A3\AC2-no background
    BYTE    bySubWnd;            //0-yes\A3\AC1-no
    BYTE    byRes1;
    DWORD   dwDeviceIndex;//device index
    BYTE    byRes2[16];
}NET_DVR_SCREEN_WINCFG, *LPNET_DVR_SCREEN_WINCFG;

typedef struct tagNET_DVR_WINLIST
{
    DWORD    dwSize;
    WORD    wScreenSeq;    //index of screen
    BYTE    byRes[10];
    DWORD    dwWinNum;    //window numbers
    BYTE    *pBuffer;    //buffer used for window information, maximum length is 224*sizeof(NET_DVR_WINCFG)
    DWORD   dwBufLen;    //length of buffer
}NET_DVR_WINLIST,*LPNET_DVR_WINLIST;

/*******************************Config layout*******************************/

#define MAX_LAYOUT_COUNT 16        //maximun of layout
typedef struct tagNET_DVR_LAYOUTCFG
{
    DWORD dwSize;
    BYTE  byValid;                                //is the layout valid.  0-not valid , 1-valid
    BYTE  byRes1[3];
    BYTE  byLayoutName[NAME_LEN/*32*/];            //name of layout
    NET_DVR_SCREEN_WINCFG struWinCfg[MAX_WIN_COUNT/*224*/];    //window parameter in the plan
    BYTE  byRes2[16];
}NET_DVR_LAYOUTCFG, *LPNET_DVR_LAYOUTCFG;

typedef struct tagNET_DVR_LAYOUT_LIST
{
    DWORD dwSize;
    NET_DVR_LAYOUTCFG struLayoutInfo[MAX_LAYOUT_COUNT/*16*/];
    BYTE byRes[4];
}NET_DVR_LAYOUT_LIST, *LPNET_DVR_LAYOUT_LIST;

/*******************************Config signal source of input******************************/
#define MAX_CAM_COUNT  224

typedef enum tagNET_DVR_CAM_MODE
{
    NET_DVR_UNKNOW  = 0,
    NET_DVR_CAM_BNC,
    NET_DVR_CAM_VGA,
    NET_DVR_CAM_DVI,
    NET_DVR_CAM_HDMI,
    NET_DVR_CAM_IP,
    NET_DVR_CAM_RGB,
    NET_DVR_CAM_DECODER,
    NET_DVR_CAM_MATRIX,
    NET_DVR_CAM_YPBPR,
    NET_DVR_CAM_USB,
    NET_DVR_CAM_SDI,
    NET_DVR_CAM_HDI,
    NET_DVR_CAM_DP,
    NET_DVR_CAM_HDTVI,
    NET_DVR_CAM_JOINT,
    NET_DVR_CAM_HDBASET,
    NET_DVR_CAM_DVIT,
    NET_DVR_CAM_FUSION,
    NET_DVR_CAM_VSCREEN,
    NET_DVR_CAM_FIBER,
    NET_DVR_CAM_3GSDI, //3G-SDI
}NET_DVR_CAM_MODE;

typedef struct tagNET_DVR_INPUTSTREAMCFG
{
    DWORD    dwSize ;
    BYTE    byValid ;
    BYTE    byCamMode;                        //the type of signal source
    WORD    wInputNo;                        //the index of signal source0-224
    BYTE    sCamName[NAME_LEN] ;            //the name of signal source
    NET_DVR_VIDEOEFFECT struVideoEffect;    //video parameter
    NET_DVR_PU_STREAM_CFG    struPuStream;    //stream media parameter
    WORD    wBoardNum ;                        //index of board which has this signal source
    WORD    wInputIdxOnBoard;                //station of signal source in the board
    DWORD   dwResolution;//resolution
    BYTE    byVideoFormat;//video format(VIDEO_STANDARD)
    BYTE    byStatus;    //signal source status, 0-invaild 1-has signal 2-no signal 3-exception
    BYTE    sGroupName[NAME_LEN/*32*/];        //group name of net signal
    BYTE    byJointMatrix;                    // Joint matrix
    BYTE    byRes;
}NET_DVR_INPUTSTREAMCFG, *LPNET_DVR_INPUTSTREAMCFG;

typedef struct tagNET_DVR_INPUTSTREAM_LIST
{
    DWORD dwSize;
    NET_DVR_INPUTSTREAMCFG struInputStreamInfo[MAX_CAM_COUNT];
    BYTE byRes[4];
}NET_DVR_INPUTSTREAM_LIST, *LPNET_DVR_INPUTSTREAM_LIST;

/*******************************config output channels*******************************/
typedef struct tagNET_DVR_OUTPUTPARAM
{
    DWORD  dwSize;
    BYTE   byMonMode;        //output mode,1-BNC,2-VGA,3-DVI,4-HDMI
    BYTE   byRes1[3];
    DWORD  dwResolution;    //resolution;
    NET_DVR_VIDEOEFFECT  struVideoEffect;    //video parameter
    BYTE    byRes2[32];
}NET_DVR_OUTPUTPARAM, *LPNET_DVR_OUTPUTPARAM;

typedef struct tagNET_DVR_OUTPUTCFG
{
    DWORD dwSize;
    BYTE byScreenLayX;                        //maximum screen numbers in x coordinate of the layout
    BYTE byScreenLayY;                        //maximum screen numbers in x coordinate of the layout
    WORD wOutputChanNum;                    //output channel numbers\A3\AC0-maximum numbers of the device support\A3\ACthe other value means the output channel numbers
    BYTE byRes1[4];
    NET_DVR_OUTPUTPARAM  struOutputParam;    //video parameter of output channels
    BYTE    sWallName[16];                    //wall name
    BYTE    byRes2[8];
}NET_DVR_OUTPUTCFG, *LPNET_DVR_OUTPUTCFG;

/*******************************ability*******************************/
#define SCREEN_PROTOCOL_NUM      20    //maximum numbers of screen controller's protocol
//ability of screen server
typedef struct tagNET_DVR_SCREENSERVER_ABILITY
{
    DWORD dwSize;
    BYTE byIsSupportScreenNum; //support numbers of screen
    BYTE bySerialNums;            //serial numbers
    BYTE byMaxInputNums;
    BYTE byMaxLayoutNums;
    BYTE byMaxWinNums;
    BYTE byRes1[19];
    BYTE byMaxScreenLayX;//maximum screen numbers in x coordinate of the layout
    BYTE byMaxScreenLayY;//maximum screen numbers in x coordinate of the layout
    WORD wMatrixProtoNum; //protocol numbers of matrix
    NET_DVR_PROTO_TYPE struScreenProto[SCREEN_PROTOCOL_NUM];// maximum protocol lists of screen
    BYTE byRes2[24];
}NET_DVR_SCREENSERVER_ABILITY, *LPNET_DVR_SCREENSERVER_ABILITY;

//ability of screen controller

typedef struct tagNET_DVR_SCREENCONTROL_ABILITY
{
    DWORD dwSize;
    BYTE byLayoutNum;         // numbers of layout
    BYTE byWinNum;             // numbers of window
    BYTE byOsdNum;          //numbers of OSD
    BYTE byLogoNum;         //numbers of Logo
    BYTE byInputStreamNum;  //numbers of input source (local input + net signal)
    BYTE byOutputChanNum;    //numbers of output channel
    BYTE byCamGroupNum;        //numbers of camera group
    BYTE byPlanNum;            //numbers of plan
    BYTE byRes1[5];
    BYTE byIsSupportPlayBack;  //0-not support playback 1-support playback
    BYTE byMatrixInputNum;  //maximum numbers of matrix
    BYTE byMatrixOutputNum; //maximum numbers of output
    NET_DVR_DISPINFO struVgaInfo;//VGA information
    NET_DVR_DISPINFO struBncInfo;//BNC information
    NET_DVR_DISPINFO struHdmiInfo;//HDMI information
    NET_DVR_DISPINFO struDviInfo;//DVI information
    BYTE byMaxUserNums;        //numbers of user
    BYTE byPicSpan;            //span of the picture\A3\ACmax screen numbers of one basemap overlapped
    WORD wDVCSDevNum;        //numbers of sub device
    WORD wNetSignalNum;        //numbers of net signals
    WORD wBaseCoordinateX;    //base coordinate
    WORD wBaseCoordinateY;
    BYTE byExternalMatrixNum;    //max matrix number
    BYTE byRes2[49];
}NET_DVR_SCREENCONTROL_ABILITY, *LPNET_DVR_SCREENCONTROL_ABILITY;

/*******************************status of input source*******************************/
typedef struct tagNET_DVR_ANALOGINPUTSTATUS
{
    DWORD    dwLostFrame;        //the number of lost frames
    BYTE    byHaveSignal;        //is there signal? 0-no 1-yes
    BYTE    byVideoFormat;        //video format\A3\AC1\A3\BANTSC,2\A3\BAPAL,0\A3\BAnull
    BYTE    byRes[46];
} NET_DVR_ANALOGINPUTSTATUS, *LPNET_DVR_ANALOGINPUTSTATUS;

typedef union tagNET_DVR_INPUTSTATUS_UNION
{
    NET_DVR_MATRIX_CHAN_STATUS struIpInputStatus;
    NET_DVR_ANALOGINPUTSTATUS struAnalogInputStatus;
} NET_DVR_INPUTSTATUS_UNION, *LPNET_DVR_INPUTSTATUS_UNION;

typedef struct tagNET_DVR_INPUTSTATUS
{
    WORD    wInputNo;        //index of source
    BYTE    byInputType;    //CAM_MODE
    BYTE    byRes1[9];
    NET_DVR_INPUTSTATUS_UNION struStatusUnion;
    BYTE    byRes2[16];
} NET_DVR_INPUTSTATUS, *LPNET_DVR_INPUTSTATUS;

typedef struct tagNET_DVR_SCREENINPUTSTATUS
{
    DWORD    dwSize;
    BYTE    byRes[12];
    DWORD    dwNums;        //the numbers of input source states
    BYTE    *pBuffer;    //buffer
    DWORD   dwBufLen;    //the len of buffer
}NET_DVR_SCREENINPUTSTATUS,*LPNET_DVR_SCREENINPUTSTATUS;

/*******************************alarm of screen*******************************/
typedef struct tagNET_DVR_SCREENALARMCFG
{
    DWORD    dwSize;
    BYTE    byAlarmType;    //alarm type\A3\AC1-subboard pull out\A3\AC2-Insert subboard\A3\AC3-subsystem abnormal\A3\AC4-subsystem restoration 5-input source abnormal   6-alarm of temperature 7-FPGA version mismatch 8-begin plan 9-plan over 10-decoder net broken 11-decoder ip confilct\A3\AC12-fan abnormal
    BYTE    byBoardType;    // 1-input board 2-output board 3-back board 4-main board
    BYTE    bySubException;    //sub exception when input exception occur 1- change resolution normal 2-change interface 3-resolution error 4-resolution change, lead to alloc resource error 5-resolution change, lead to window size is not in the normal range 6-resolution return to normal,7-resolution change, lead to output board data overflow\A1\A3
    BYTE    byRes1;
    WORD    wStartInputNum; // input source exception , starting point
    WORD    wEndInputNum;    // input source exception , stopping point
    BYTE    byRes2[16];
}NET_DVR_SCREENALARMCFG, *LPNET_DVR_SCREENALARMCFG;

/*******************************config the screen server*******************************/
typedef struct tagNET_DVR_MATRIX_CFG
{
    BYTE  byValid;                //is the analog platform valid; 0- not valid,  1-valid
    BYTE  byCommandProtocol;    //the command of platform , 1-MATRIX_COMMAND_V1\A3\AC 2-MATRIX_COMMAND_V2, 3-MATRIX_COMMAND_V3, 4-MATRIX_COMMAND_V4
    BYTE  byScreenType;
    BYTE  byRes1;
    BYTE  byScreenToMatrix[32];    //relation between screen and analog
    BYTE  byRes2[4];
}NET_DVR_MATRIX_CFG, *LPNET_DVR_MATRIX_CFG;

typedef struct tagNET_DVR_DIGITALSCREEN
{
    NET_DVR_IPADDR  struAddress;//IP if the device is a digital device
    WORD            wPort;        //port
    BYTE            byRes[26];  //
}NET_DVR_DIGITALSCREEN, *LPNET_DVR_DIGITALSCREEN;
typedef struct tagNET_DVR_ANALOGSCREEN
{
    BYTE    byDevSerPortNum;   //serial port numbers
    BYTE    byScreenSerPort;  // the index of serial port
    BYTE    byRes[130];
    NET_DVR_MATRIX_CFG struMatrixCfg;
}NET_DVR_ANALOGSCREEN, *LPNET_DVR_ANALOGSCREEN;

typedef union tagNET_DVR_SCREEN_UNION
{
    NET_DVR_DIGITALSCREEN struDigitalScreen;
    NET_DVR_ANALOGSCREEN struAnalogScreen;
}NET_DVR_SCREEN_UNION, *LPNET_DVR_SCREEN_UNION;
typedef struct tagNET_DVR_SCREEN_SCREENINFO
{
    DWORD dwSize;
    BYTE byValid;                //Is the struct valid or not? 0-not valid,  1-valid
    BYTE nLinkMode;                //link mode\A3\AC0-serial work\A3\AC1-network
    BYTE byDeviceType;            //device type, get from ability
    BYTE byScreenLayX;            //lay of the screen , x coordinate
    BYTE byScreenLayY;            //lay of the screen, y coordinate
    BYTE byRes1[3];
    BYTE sUserName[NAME_LEN];    //User name
    BYTE sPassword[PASSWD_LEN]; //password
    BYTE sDevName[NAME_LEN];    //device name
    NET_DVR_SCREEN_UNION struScreenUnion;
    BYTE byInputNum;            // input source\A3\ACused for platform
    BYTE byOutputNum;            // output source , used for platform
    BYTE byCBDNum;                //CBD numbers
    BYTE byRes2[29];
} NET_DVR_SCREEN_SCREENINFO, *LPNET_DVR_SCREEN_SCREENINFO;

/*******************************upload background picture*******************************/
typedef struct tagNET_DVR_BASEMAP_CFG
{
    BYTE byScreenIndex;         //screen Index
    BYTE byMapNum;                //map numbers
    BYTE res[2];
    WORD wSourWidth;            //source picture width
    WORD wSourHeight;            //source picture height
}NET_DVR_BASEMAP_CFG, LPNET_DVR_BASEMAP_CFG;


typedef struct tagNET_DVR_PICCFG
{
    DWORD    dwSize;
    BYTE    byUseType;    //1use for background picture
    BYTE    bySequence; //picture index
    BYTE    byRes[2];
    NET_DVR_BASEMAP_CFG    struBasemapCfg;
    BYTE    sPicName[NAME_LEN];//Pic name
    DWORD   dwVideoWall;       //Wall No.
    BYTE    byRes2[28];
}NET_DVR_PICTURECFG, *LPNET_DVR_PICTURECFG;
/*******************************OSD*******************************/
#define MAX_OSDCHAR_NUM 256
typedef struct tagNET_DVR_OSDCFG
{
    DWORD   dwSize;
    BYTE    byValid;    /*0-invalid,  1-valid*/
    BYTE    byDispMode;  //Display mode \A3\AC1-transparent\A3\AC2-translucent\A3\AC3-cover
    BYTE    byFontColorY; /*Font colorY,0-255*/
    BYTE    byFontColorU; /*Font colorU,0-255*/
    BYTE    byFontColorV; /*Font colorV,0-255*/
    BYTE    byBackColorY; /**Back colorY,0-255*/
    BYTE    byBackColorU; /**Back colorU,0-255*/
    BYTE    byBackColorV; /**Back colorV,0-255*/
    WORD    wXCoordinate;   /*virtual LED point coordinate x*/
    WORD    wYCoordinate;   /*virtual LED point coordinate y*/
    WORD    wWidth;       /*virtual LED width*/
    WORD    wHeight;      /*virtual LED height*/
    DWORD   dwCharCnt;     /*virtual LED numbers*/
    WORD    wOSDChar[MAX_OSDCHAR_NUM]; /*virtual LED content*/
    BYTE    byRes[32];
}NET_DVR_OSDCFG, *LPNET_DVR_OSDCFG;
/*******************************Get Serial information*******************************/
typedef struct tagNET_DVR_SERIAL_CONTROL
{
    DWORD    dwSize ;
    BYTE    bySerialNum;        // serial numbers
    BYTE    byRes1[3];
    BYTE    bySerial[32];        //serial name;
    BYTE    byRes2[32];
}NET_DVR_SERIAL_CONTROL, *LPNET_DVR_SERIAL_CONTROL;

/*******************************control screen*******************************/
typedef enum tagINPUT_INTERFACE_TYPE
{
    INTERFACE_VGA = 0,
    INTERFACE_SVIDEO,    // 2046NL does not support\A3\AC2046NH support
    INTERFACE_YPBPR,
    INTERFACE_DVI ,
    INTERFACE_BNC ,
    INTERFACE_DVI_LOOP,    // (loop through) 2046NH not support\A3\AC2046NL support
    INTERFACE_BNC_LOOP, // (loop through) 2046NH not support\A3\AC2046NL.support
    INTERFACE_HDMI,
    INTERFACE_IP,
    INTERFACE_USB,
    INTERFACE_SDI,
    INTERFACE_DP,
    INTERFACE_HDBASET
}INPUT_INTERFACE_TYPE;

typedef struct tagNET_DVR_INPUT_INTERFACE_CTRL
{
    BYTE    byInputSourceType;    //see the struct INPUT_INTERFACE_TYPE
    BYTE    byRes[15];
}NET_DVR_INPUT_INTERFACE_CTRL, *LPNET_DVR_INPUT_INTERFACE_CTRL;
//control color
typedef struct tagNET_DVR_DISPLAY_COLOR_CTRL
{
    BYTE    byColorType;        //1-brightness 2-contrast 3-saturation 4-definition
    char    byScale;            //-1 \A1\A20\A1\A2+1
    BYTE    byRes[14];
}NET_DVR_DISPLAY_COLOR_CTRL, *LPNET_DVR_DISPLAY_COLOR_CTRL;
//control position
typedef struct tagNET_DVR_DISPLAY_POSITION_CTRL
{
    BYTE    byPositionType;        //1-horizontal position 2-vertical position
    char    byScale;            //-1 \A1\A20\A1\A2+1
    BYTE    byRes[14];
}NET_DVR_DISPLAY_POSITION_CTRL, *LPNET_DVR_DISPLAY_POSITION_CTRL;



/*******************************Screen Control V41*******************************/
typedef struct tagNET_DVR_RECTCFG_EX
{
    DWORD dwXCoordinate; /*X coordinate*/
    DWORD dwYCoordinate; /*Y coordinate*/
    DWORD dwWidth;       /*width*/
    DWORD dwHeight;      /*height*/
    BYTE  byRes[4];
}NET_DVR_RECTCFG_EX, *LPNET_DVR_RECTCFG_EX;

/*******************************plan manage*******************************/
#define        MAX_PLAN_ACTION_NUM     32     //plan action number
#define        DAYS_A_WEEK                7    //7 days a week
#define        MAX_PLAN_COUNT            16    //plan count

typedef enum
{
    NET_DVR_SWITCH_LAYOUT = 1,         // switch layout
    NET_DVR_SCREEN_POWER_OFF,          // turn off screen
    NET_DVR_SCREEN_POWER_ON,           // turn on screen
    NET_DVR_SWITCH_BASEMAP            //base map switch
}NET_DVR_PLAN_OPERATE_TYPE;

typedef struct  tagNET_DVR_PLAN_INFO
{
    BYTE  	byValid;      	// is the plan valid
    BYTE  	byType;       	// NET_DVR_PLAN_OPERATE_TYPE
    WORD  	wLayoutNo;  	// layout number
    BYTE	byScreenStyle;    //the type of screen\A3\AC1-low bright\A3\AC2-high bright
    BYTE  byBaseMapType;  //base map type, 1 - picture base map, 2 - UHD base map, valid when byType is NET_DVR_SWITCH_BASEMAP
    BYTE  byRes1[2];
    DWORD  	dwDelayTime;  	// plan delay time, unit /s
    DWORD   dwSerialNo;		//serial No.,valid for screen control
    DWORD  dwBaseMapWndNo; //base map window number, valid when byType is NET_DVR_SWITCH_BASEMAP
    DWORD  dwBaseMapNo;  //base map number, valid when byType is NET_DVR_SWITCH_BASEMAP; when base map type is 1, it is picture number; when base map type is 2, it is UHD subsystem input channel number.
    BYTE	byRes2[20];
} NET_DVR_PLAN_INFO, *LPNET_DVR_PLAN_INFO;
typedef struct tagNET_DVR_CYCLE_TIME
{
    BYTE    byValid;
    BYTE    byRes[3];
    NET_DVR_TIME_EX struTime;
}NET_DVR_CYCLE_TIME, *LPNET_DVR_CYCLE_TIME;
/*plan manage*/
typedef struct tagNET_DVR_PLAN_CFG
{
    DWORD     dwSize;
    BYTE      byValid;          // is the plan valid
    BYTE      byWorkMode;      // the plan work mode 1-manual\A3\AC2-auto\A3\AC3-cycle
    BYTE    byWallNo;        // wall no.\A3\ACstart from 1
    BYTE    byRes1;
    BYTE      byPlanName[NAME_LEN/*32*/]; //plan name
    NET_DVR_TIME_EX struTime; // time when the work mode is auto
    NET_DVR_CYCLE_TIME struTimeCycle[DAYS_A_WEEK/*7*/]; /*cycle time*/
    DWORD     dwWorkCount;      // plan work count\A3\AC0-keep working else-count
    NET_DVR_PLAN_INFO strPlanEntry[MAX_PLAN_ACTION_NUM/*32*/];  // plan information
    BYTE    byRes2[64];
}NET_DVR_PLAN_CFG, *LPNET_DVR_PLAN_CFG;

typedef struct tagNET_DVR_PLAN_LIST
{
    DWORD        dwSize;
    DWORD        dwPlanNums;            //input signal numbers
    BYTE          *pBuffer;            //buffer
    BYTE        byWallNo;            //wall no.\A3\ACstart from 1
    BYTE        byRes1[2];
    DWORD         dwBufLen;            //buffer size
    BYTE        byRes2[64];
} NET_DVR_PLAN_LIST,*LPNET_DVR_PLAN_LIST;

/*******************************plan control*******************************/
typedef struct tagNET_DVR_CONTROL_PARAM
{
    DWORD    dwSize;
    BYTE    sDeviceID[NAME_LEN]; //device ID
    WORD    wChan;                 //channel
    BYTE    byIndex;
    BYTE    byRes1;
    DWORD    dwControlParam;
    BYTE    byMandatoryAlarm;    //1-enable  0-disable
    BYTE      byRes3;
    WORD     wZoneIndex;
    BYTE      byOperatorCode[16];
    BYTE      byRes2[12];
}NET_DVR_CONTROL_PARAM, *LPNET_DVR_CONTROL_PARAM;

/*******************************GET DEVICE STATUS*******************************/
typedef struct tagNET_DVR_DEVICE_RUN_STATUS
{
    DWORD     dwSize;
    DWORD    dwMemoryTotal;        //Total Memory Unit: KByte
    DWORD    dwMemoryUsage;        //Memory Used Unit: KByte
    BYTE    byCPUUsage;            //CPU Used 0-100
    BYTE    byMainFrameTemp;    //Main frame temperature, unit: Celcius
    BYTE    byBackPanelTemp;    //Back panel temperature, unit: Celcius
    BYTE    byRes1[1];
    BYTE    byLeftDecResource[32];   //left resource of each decode board, oxff-invalid
    float    fNetworkFlow;    //network flow,KB/s\A3\ACeg:1200.00KB/s
    BYTE    byRes[88];
}NET_DVR_DEVICE_RUN_STATUS, *LPNET_DVR_DEVICE_RUN_STATUS;

/*******************************Picture Preview*******************************/

/******************************GET INPUT SIGNAL LIST*******************************/
typedef struct tagNET_DVR_INPUT_SIGNAL_LIST
{
    DWORD        dwSize;
    DWORD        dwInputSignalNums;    //input signal numbers
    BYTE          *pBuffer;            //buffer
    BYTE        byRes1[3];
    DWORD         dwBufLen;            //buffer size
    BYTE        byRes2[64];
} NET_DVR_INPUT_SIGNAL_LIST,*LPNET_DVR_INPUT_SIGNAL_LIST;
/********************************Screen Controller end****************************/

/********************************ATM Safety Cabin begin *********************************/
typedef  struct tagNET_DVR_ALARMHOST_SAFETYCABINSTATE
{
    DWORD    dwSize;
    BYTE    byEnterButton;    //enter button state 0-the button is not pushed down;  1-the button is pushed down
    BYTE    byExitButton;    //exit button state 0-the button is not pushed down;  1-the button is pushed down
    BYTE    byDoorState;    //door state    0-close  1-open
    BYTE    byLockState;    //locker state 0-locked    1-unlocked
    BYTE    byUrgencyButton;//Urgency Button state    0-the button is not pushed down;  1-the button is pushed down
    BYTE    byManState;     //man state     0-there is no one in the cabin; 1-there is someone in the cabin
    BYTE    byAbnormal;     //abnormal state  0-normal 1-abnormal
    BYTE    byLightState;   //light state,0-close,1-open
    BYTE    byFanState;     //fan state 0-close,1-open
    BYTE    byRes[63];
}NET_DVR_ALARMHOST_SAFETYCABINSTATE,*LPNET_DVR_ALARMHOST_SAFETYCABINSTATE;

typedef  struct tagNET_DVR_ALARMHOST_ALARMOUTSTATUS
{
    DWORD    dwSize;
    BYTE    byName[32];        //the name of Alarm output or siren
    BYTE    byAlarmType;    //1-Alarm output status, 2-SirenStatus
    WORD    wChan;            //if the byAlarmType is alarm output status, this value is 0-511\A3\BBelse if the byAlarmType is siren status, this value is 1-8 (there is only one siren in SAFETYCABIN)
    BYTE    byAlarmStatus; //Alarm status,   0-no alarm 1-alarm
    BYTE    byRes[32];
}NET_DVR_ALARMHOST_ALARMOUTSTATUS,*LPNET_DVR_ALARMHOST_ALARMOUTSTATUS;

//////////audio upload and download/////////////
typedef struct tagNET_DVR_AUDIO_PARAM
{
    DWORD        dwSize;
    BYTE        byAudioFormat;      //audio format\A3\AC1-G711\A3\AC2-G722
    BYTE        byRes1;
    WORD        wChannels;          // number of channels (i.e. mono, stereo...)
    DWORD        dwSamplesPerSec;    //samples per second
    BYTE        byRes2[20];
    DWORD        dwAudioSize;        //length of audio file
}NET_DVR_AUDIO_PARAM,*LPNET_DVR_AUDIO_PARAM;
/********************************DS_19SXX begin *********************************/

typedef struct tagNET_DVR_TRIGGER_EVENT
{
    DWORD    dwSize;
    DWORD    dwOverallEventTriggerAlarmoutOn;    //overall event cause alarmout on \A3\ACbit0-AC outage\A3\ACbit1-low voltage of battery\A3\ACbit2-telephone off_line\A3\ACbit3-network abnormal\A3\ACbit4-Wireless network abnormal\A3\ACbit5-HD error\A3\ACbit6-3G/4G signal abnormal\A3\ACbit7-third host offline
    DWORD    dwOverallEventTriggerAlarmoutOff;    //overall event cause alarmout off\A3\ACbit0-AC outage\A3\ACbit1-low voltage of battery\A3\ACbit2-telephone off_line\A3\ACbit3-network abnormal\A3\ACbit4-Wireless network abnormal\A3\ACbit5-HD error
    DWORD    dwSubSystemEventTriggerAlarmoutOn[MAX_ALARMHOST_SUBSYSTEM/*32*/]; //subsystem event cause alarmout on,dwSubSystemEvent[0] is subsystem 1\A3\ACdwSubSystemEvent[2] is subsystem 1\A3\ACevery bit is a subsystem event\A3\ACbit0-enter delay time\A3\ACbit1-exit delay time\A3\ACbit2-arm\A3\ACbit3-disarm\A3\ACbit4-alarm\A3\AC bit5-clear alarm, bit6-alarm restore
    DWORD    dwSubSystemEventTriggerAlarmoutOff[MAX_ALARMHOST_SUBSYSTEM/*32*/]; //subsystem event cause alarmout off,wSubSystemEvent[0] is subsystem 1\A3\ACdwSubSystemEvent[2] is subsystem 2\A3\ACevery bit is a subsystem event\A3\ACbit0-enter delay time\A3\ACbit1-exit delay time\A3\ACbit2-arm\A3\ACbit3-disarm\A3\ACbit4-alarm\A3\AC bit5-clear alarm, bit6-alarm restore
    BYTE    byRes[128];
}NET_DVR_TRIGGER_EVENT, *LPNET_DVR_TRIGGER_EVENT;

typedef struct  tagNET_DVR_ALARMHOST_FAULT_CFG
{
    DWORD     dwSize;
    DWORD    dwCheckFault;    //Check fault\A3\ACbit0-AC outage\A3\ACbit1-low voltage of battery\A3\ACbit2-device prevent disassemble\A3\ACbit3-telephone off_line\A3\ACbit4-485 device abnormal\A3\ACbit5-network abnormal\A3\ACbit6-wireless abnormal\A3\ACbit7-expand bus abnormal\A3\ACbit8-hard disk abnormal,bit9-FPGA abnornmal,bit10-analog quantity abnornmal,bit11-Zone expand Board Abnormal,bit12-Wifi abnornmal,bit13-RF signal abnornmal
    DWORD    dwOverallFaultJointLED;        //fault cause overall keyboard led turn on, bit0-AC outage\A3\ACbit1-low voltage of battery\A3\ACbit2-device prevent disassemble\A3\ACbit3-telephone off_line\A3\ACbit4-485 device abnormal\A3\ACbit5-network abnormal\A3\ACbit6-wireless abnormal\A3\ACbit7-expand bus abnormal\A3\ACbit8-hard disk abnormalCID_MODULE_FAIL = 913
    DWORD    dwOverallFaultJointSound;    //fault cause overall keyboard sound turn on, bit0-AC outage\A3\ACbit1-low voltage of battery\A3\ACbit2-device prevent disassemble\A3\ACbit3-telephone off_line\A3\ACbit4-485 device abnormal\A3\ACbit5-network abnormal\A3\ACbit6-wireless abnormal\A3\ACbit7-expand bus abnormal\A3\ACbit8-hard disk abnormal
    DWORD    dwSubSystemFaultJointLED[MAX_ALARMHOST_SUBSYSTEM]; /*fault cause subsystem keyboard led turn on\A3\ACdwSubSystemFaultJointLED[0] associate to first subsystem\A1\A3every bit means one fault of subsystem in dwSubSystemFaultJointLED[0]\A3\ACbit0-AC outage\A3\ACbit1-low voltage of battery\A3\ACbit2-device prevent disassemble\A3\ACbit3-telephone off_line\A3\ACbit4-485 device abnormal\A3\ACbit5-network abnormal\A3\ACbit6-wireless abnormal\A3\ACbit7-expand bus abnormal\A3\ACbit8-hard disk abnormal*/
    DWORD    dwSubSystemFaultJointSound[MAX_ALARMHOST_SUBSYSTEM];/*fault cause subsystem keyboard sound turn on, dwSubSystemFaultJointLED[0]associate to first subsystem\A1\A3every bit means one fault of subsystem in dwSubSystemFaultJointSound\A3\ACbit0-AC outage\A3\ACbit1-low voltage of battery\A3\ACbit2-device prevent disassemble\A3\ACbit3-telephone off_line\A3\ACbit4-485 device abnormal\A3\ACbit5-network abnormal\A3\ACbit6-wireless abnormal\A3\ACbit7-expand bus abnormal\A3\ACbit8-hard disk abnormal*/
    DWORD    dwFaultJointFaultLight;//fault joint LED
    BYTE    byRes[60];
}NET_DVR_ALARMHOST_FAULT_CFG, *LPNET_DVR_ALARMHOST_FAULT_CFG;

typedef struct tagNET_DVR_LIST_INFO
{
    DWORD    dwSize;
    BYTE    byIndex;
    BYTE       byRes[63];
}NET_DVR_LIST_INFO, *LPNET_DVR_LIST_INFO;

#define CID_CODE_LEN 4
typedef enum tagNET_DVR_ALARMHOST_REPORT_TYPE
{
    NET_DVR_DEFENCE_ALARM = 1,            //Zone alarm
    NET_DVR_VIDEO_ALARM,            //video alarm
    NET_DVR_VIRTUAL_DEFENCE_ALARM,    //virtual Zone alarm
    NET_DVR_HOSTAGE_ALARM,            //hostage alarm
    NET_DVR_KNOCK_DOWN_ALARM,        //knock down alarm
    NET_DVR_OPERATE_ALARM,            //operate alarm
    NET_DVR_OHTER_ABNORMAL_ALARM    //abnormal alarm
}NET_DVR_ALARMHOST_REPORT_TYPE;


typedef enum tagNET_DVR_ALARMHOST_CID_MAIN_TYPE
{
    CID_ENTER = 1000,
    CID_EXIT = 3000
}NET_DVR_ALARMHOST_CID_MAIN_TYPE;


typedef enum tagNET_DVR_ALARMHOST_CID_MINOR_TYPE
{
    CID_ALARM = 103,
    CID_FIRE_ALARM = 110,
    CID_ABDUCT_REPORT = 121,
    CID_SILENT_24 = 122,
    CID_AUDIO_24 = 123,
    CID_AUXILIARY_24 = 124,
    CID_SHOCK_24 = 125,
    CID_PERIMETER_ALARM = 131,
    CID_INNET_ALARM = 132,
    CID_ENTER_EXIT = 134,
    CID_DEVICE_OPEN = 137,
    CID_ZONE_BUS_BREAK = 141,
    CID_ZONE_BUS_SHORT = 142,

    CID_AC_LOSS = 301,
    CID_LOW_BATT_VOL = 302,
    CID_DEV_RESET = 305,
    CID_MBUS_MODEL_FAULT = 333,
    CID_PRINTER_FAIL = 336,
    CID_LINE_LOSS = 354,
    CID_BUS_LOSS = 382,
    CID_DETECTOR_OPEN = 383,

    CID_GUARD = 401,
    CID_GUARD_AUTO = 403,
    CID_CANCEL_ARM = 406,
    CID_GUARD_IMME = 408,
    CID_KEY_ZONE_GUARD = 409,
    CID_GUARD_STAY = 441,
    CID_FORCED_ARM = 442,
    CID_AUTOCTRL_TRIG = 443,
    CID_ONETOUCH_AWAY_ARMING = 444,
    CID_ONETOUCH_STAY_ARMING = 445,
    CID_CARD_ARMING_OR_DISARMING = 446,
    CID_AUTOGUARD_FAIL = 455,
    CID_AOPEN_TRIG_FAIL = 460,
    CID_ACLOSE_TRIG_FAIL = 461,
    CID_AUTOUNGUARD_FAIL = 462,

    CID_BYPASS = 570,
    CID_GROUP_BYPASS = 574,

    CID_MANUAL_TEST_RPT = 601,
    CID_AUTO_TEST_RPT = 602,
    CID_ENTER_PROG = 627,
    CID_EXIT_PROG = 628,

    CID_SOFT_INSTAND = 810,
    CID_SOFT_FIRE = 811,
    CID_SOFT_MOBS = 812,

    CID_KEY_FAIL = 910,
    CID_TRIGGER_FAIL = 911,
    CID_GPK_FAIL = 912,
    CID_MODULE_FAIL = 913,
    CID_WIRELESS_DETECTOR_FAIL = 914,
    CID_WIRELESS_DETECTOR_BATTERY_LOW = 915,
    CID_WRIE_LESS_NET = 920,
    CID_SIM_FAULT = 921,
    CID_WIFI_ABNORMAL = 922,
    CID_RF_ABNORMAL = 923,
    CID_IPADDR_CONFLICT = 930,
    CID_ETHERNET_BROKEN = 931,
    CID_GROUP_OUT_RP = 932,
    CID_GROUP_IN_RP = 933,
    CID_MOTION_DECTECT = 940,
    CID_MASK_ALARM = 941,
    CID_VI_LOST = 942,
    CID_VS_MISMATCH = 943,
    CID_VI_EXCEPTION = 944,
    CID_HD_FULL = 945,
    CID_HD_ERROR = 946,
    CID_PIC_SEND_FAILED = 947,
    CID_KEY_LOCKED = 948,
    CID_ZONE_BUS_SEARCH = 970,
    CID_ZONE_BUS_REGIST = 971,
    CID_GUARD_DELAY_OP = 972,
    CID_GUARD_SINGLE = 973,
    CID_ZONE_ASSOCIATED_DETECTOR = 975,
}NET_DVR_ALARMHOST_CID_MINOR_TYPE;

typedef struct tagNET_DVR_CID_ALARM
{
    DWORD    dwSize;
    BYTE    sCIDCode[CID_CODE_LEN/*4*/];    //CID CODE
    BYTE    sCIDDescribe[NAME_LEN/*32*/];    //CID name
    NET_DVR_TIME_EX struTriggerTime;            // time of trigger alarm
    NET_DVR_TIME_EX struUploadTime;                // time of uploading alarm
    BYTE    sCenterAccount[ACCOUNTNUM_LEN/*6*/];    //center account
    BYTE    byReportType;                    // see NET_DVR_ALARMHOST_REPORT_TYPE
    BYTE    byUserType;                        //User type\A3\AC0-net user 1-keyboard user 2-cellphone user,3-system user
    BYTE    sUserName[NAME_LEN/*32*/];        //user name of net user
    WORD    wKeyUserNo;                        //keyboard user no.    0xFFFF means Invalid
    BYTE    byKeypadNo;                        //keyboard no.        0xFF means Invalid
    BYTE    bySubSysNo;                        //subsystem no.        0xFF means Invalid
    WORD    wDefenceNo;                        //Zone no.        0xFFFF means Invalid
    BYTE    byVideoChanNo;                    //video channel no.    0xFF means Invalid
    BYTE    byDiskNo;                        //disk no.        0xFF means Invalid
    WORD    wModuleAddr;                    //module address    0xFFFF means Invalid
    BYTE    byCenterType;                    //0-invalid, 1-old center account(length is 6),2-new center account(length is 9)
    BYTE    byRes1;
    BYTE    sCenterAccountV40[ACCOUNTNUM_LEN_32/*32*/];    //center account V40
    BYTE    byRes2[28];
}NET_DVR_CID_ALARM, *LPNET_DVR_CID_ALARM;

#define MODULE_INFO_LEN            32
#define VERSION_INFO_LEN        32

typedef struct tagNET_DVR_ALARMHOST_MODULE_CFG
{
    DWORD    dwSize;
    BYTE    byModuleType;    //1-zone\A3\AC2-trigger
    BYTE    byZoneType;        //zone type\A3\AC1-local zone\A3\AC2-single zone\A3\AC3-double zone\A3\AC4-8 zone\A3\AC5-8 sensor zone 0xff-invalid
    BYTE    byTriggerType;    //trigger type\A3\AC1-local trigger, 1-local trigger\A3\AC 2-4-way trigger \A3\AC3 8-way trigger ,0xff-invalid
    BYTE    byRes1[1];
    char    sModelInfo[MODULE_INFO_LEN];                //module info
    char    sDeviceVersionInfo[VERSION_INFO_LEN];                /* version info*/
    BYTE    byRes[188];
} NET_DVR_ALARMHOST_MODULE_CFG, *LPNET_DVR_ALARMHOST_MODULE_CFG;
/********************************DS_19SXX end *********************************/


/********************************ATM Safety Cabin begin *********************************/


typedef struct tagNET_DVR_STREAM_CABAC
{
    DWORD        dwSize;
    BYTE         byCabacEnable;           //0 enable 1 disable
    BYTE          byRes1[31];
}NET_DVR_STREAM_CABAC, *LPNET_DVR_STREAM_CABAC;

//2012-1-12
/********************************Intelligent HD IPC V3.1*********************************/
#define  MAX_IOSPEED_GROUP_NUM      4  //The total number of IO speed measuring groups
#define  MAX_IOOUT_NUM              4  //The total number of IO output ports
#define  MAX_IOIN_NUM               8  //The total number of IO input ports
#define  MAX_RELAY_NUM              12 //Maximum number of relay control equipment 2013-11-04
#define  MAX_VEHICLE_TYPE_NUM        8  //Vehicle Type Num 2013-11-04
#define  MAX_IOIN_NUMEX             10 //The total number of IO input ports(ex)
#define  MAX_ITC_LANE_NUM           6  //The total number of lanes
#define  MAX_LANEAREA_NUM           2  //The total number of single lane areas
#define  ITC_MAX_POLYGON_POINT_NUM    20 //The max number of polygon points supported by detection area
#define  MAX_ITC_SERIALCHECK_NUM    8  //The max number of serial verification types
#define  MAX_LIGHT_NUM              6  //Max light number
#define  MAX_VIDEO_INTERVAL_NUM     2  //Max video interval number
#define  MAX_VIDEO_DETECT_LIGHT_NUM  12 //maximum 12 region detection
#define  MAX_RS485_NUM  12 //rs485 max Number
#define  MAX_CALIB_RECOG_NUM        2  //Calib Recog Num
#define  MAX_MOBILE_POLYGON_NUM     3  //Mobile Recog Num
#define  MAX_MOBILE_DETECTLINE_NUM  3  //Mobile Detect Line Num
#define  MAX_IOOUT_K_NUM            8  //K The total number of IO output ports

//IO output parameter (v3.1 or later version)
typedef struct tagNET_ITC_IOOUT_PARAM
{
    DWORD    dwSize;
    BYTE     byDefaultStatus;//IO default status: 0- low level, 1- high level
    BYTE     byIOOutStatus;//The status when IO takes effect: 0- low level, 1- high level, 2- puls
    BYTE     byMode; //The flash works, bitwise 0 - work - not work the bit0-video, bit1-mount, bit2-illegal
    BYTE     byIOWorkMode;//The IO output port mode: 0- flashlight, 1- polarizer,  2-BrightLight
    DWORD    dwTimeDelay;//IO valid duration, unit: us
    WORD     wAheadTime;//Ahead time of output IO, unit: us
    BYTE     byFreqMulti;        //Multi-frequency, range [1,15]
    BYTE     byDutyRate;        //Duty rate, [0,40%]
    BYTE     byDetectBrightness;//Whether auto detect brightness enable flash light or not: 0- not detect, 1- detect
    BYTE     byBrightnessThreld;//Brightness threshold of enable flash light, value range: [0,100], flash when the value higher than the threshold
    BYTE     byFlashLightEnable;    //Enable flash light or not: 0- close, 1- open
    BYTE     byStartHour;        //Starting time, hour, value range: 0-23
    BYTE     byStartMinute;        //Starting time, minute, value range: 0-59
    BYTE     byEndHour;            //End time, hour, value range: 0-23
    BYTE     byEndMinute;        //End time, minute, value range: 0-59
    BYTE     byAutoPlateBrightness;//The license plate automatic brightness enable flash 0- not enable 1- enabled
    BYTE     byIncrBrightEnable;
    BYTE     byIncrBrightPercent;//Incr Bright Percent 0~100%
    WORD     wIncrBrightTime;
    BYTE     byBrightness;//Brightness\A3\BB0~100
    BYTE     byEnvironBright;//Environment bright:0~100
    WORD     wDelayCaptureTime;//Delay Capture Time,1~1000ms
}NET_ITC_IOOUT_PARAM, *LPNET_ITC_IOOUT_PARAM;

typedef enum _ITC_TRIGGERMODE_TYPE_
{
    ITC_POST_IOSPEED_TYPE              = 0x1,  //IO speed measuring (traffic gate)
    ITC_POST_SINGLEIO_TYPE             = 0x2,  //Single IO triggering (traffic gate)
    ITC_POST_RS485_TYPE                = 0x4,  //RS485 magnetic vehicle detector triggering (traffic gate)
    ITC_POST_RS485_RADAR_TYPE          = 0x8,  //RS485 radar triggering (traffic gate)
    ITC_POST_VIRTUALCOIL_TYPE          = 0x10,   //Virtual coil triggering (traffic gate)
    ITC_POST_HVT_TYPE_V50               = 0x20,    //Mixed bayonet video trigger V50
    ITC_POST_MPR_TYPE                  = 0x40,   //MPR Type(Ver3.7)
    ITC_POST_PRS_TYPE                  = 0x80,   //PRS Type
    ITC_EPOLICE_IO_TRAFFICLIGHTS_TYPE  = 0x100,  //IO traffic lights (electronic police)
    ITC_EPOLICE_RS485_TYPE             = 0x200,  //RS485 magnetic vehicle detector triggering (electronic police)
    ITC_POST_HVT_TYPE                   = 0x400,    //Mixed bayonet video trigger (bayonet)
    ITC_PE_RS485_TYPE                  = 0x10000,  //RS485 magnetic vehicle detector triggering(electronic police of traffic gate mode)
    ITC_VIDEO_EPOLICE_TYPE             = 0x20000,  //Video triggering (electronic police of traffic gate mode)
    ITC_VIA_VIRTUALCOIL_TYPE           = 0x40000,  //VIA Trigger configuration
    ITC_POST_IMT_TYPE                   = 0x80000,   //IMT Trigger configuration
    IPC_POST_HVT_TYPE                   = 0x100000,    //IPC HVT Trigger configuration
    ITC_POST_MOBILE_TYPE               = 0x200000, //Mobile Trigger Configuration
    ITC_REDLIGHT_PEDESTRIAN_TYPE       = 0x400000,    //Red Light Pedestrian
    ITC_NOCOMITY_PEDESTRIAN_TYPE       = 0x800000    //Nocomity Pedestrian
}ITC_TRIGGERMODE_TYPE;

//Output parameter of capability set API, corresponding to pOutBuf
typedef struct tagNET_ITC_TRIGGERMODE_ABILITY
{
    DWORD dwSize;
    DWORD dwTriggerType; //Triggering type, indicated by bit, defining ITC_TRIGGERMODE_ABILITY.
    //The returned triggering type is different if input ability type is different.
    BYTE byRes[16];
}NET_ITC_TRIGGERMODE_ABILITY, *LPNET_ITC_TRIGGERMODE_ABILITY;

typedef struct tagNET_ITC_INTERVAL_PARAM
{
    BYTE byIntervalType;    //Interval type (default by time), 0- take effect by time, 1- take effect by distance
    BYTE byRes1[3];
    WORD wInterval[MAX_INTERVAL_NUM];//Continuous snapping interval time (unit: ms) or continuous snapping interval distance (unit: decimeter).
    //When byIntervalType is 0, it means interval time, when byIntervalType is 1, it means interval distance.
    BYTE byRes[8];
}NET_ITC_INTERVAL_PARAM, *LPNET_ITC_INTERVAL_PARAM;

//Plate recognition parameter
typedef struct tagNET_ITC_PLATE_RECOG_PARAM
{
    BYTE byDefaultCHN[MAX_CHJC_NUM]; //Shortening of province Chinese name
    BYTE byEnable;      //Whether enable plate recognition in this area: 0- no, 1- yes
    DWORD dwRecogMode;  /*Recognition type,
                        bit0-recognition direction: 0-from front,1-from back(back plate recognition);
                        bit1-Big plate of little plate: 0-little plate,1-Big plate;
                        bit2-Colour recognition: 0-disable colour recognition,1-Enable colour recognition;
                        bit3-Agricultural car recognition: 0-disable,1-enable;
                        bit4-Blur recognition: 0-disable,1-enable;
                        bit5-Frame location or scene location: 0-Frame location,1-Scene location;
                        bit6-Frame recognition or scene recognition: 0-Frame recognition,1-Scene recognition;
                        bit7-Day or night:0- day, 1- night
                        bit10-Small plate: 0- is not enabled, 1- enables small license plate recognition (60 ~ 80 pixels)
                        bit11-Safety belt detection: 0- disable, 1- enabled*/
    BYTE byVehicleLogoRecog;//Vehicle-logo recognition 0- is not enabled, 1- enabled
    BYTE byProvince;//Province
    BYTE byRegion;     //Region index value, 0- reserved, 1 -Europe, 2 -Russia 3-EU&CIS
    BYTE byRes1;
    WORD wPlatePixelWidthMin;//Plate Pixel Width min[130,500]
    WORD wPlatePixelWidthMax;//Plate Pixel Width max[130,500]
    BYTE byRes[24];
}NET_ITC_PLATE_RECOG_PARAM, *LPNET_ITC_PLATE_RECOG_PARAM;

//Polygon structure
typedef struct tagNET_ITC_POLYGON
{
    DWORD dwPointNum; //Valid point, >=3, if three points are on a straight line, or the lines cross, it is considered to invalid area
    NET_VCA_POINT  struPos[ITC_MAX_POLYGON_POINT_NUM]; //Polygon boundary point, the max number is 20
}NET_ITC_POLYGON, *LPNET_ITC_POLYGON;

typedef struct tagNET_ITC_PLATE_RECOG_REGION_PARAM
{
    BYTE byMode; //Area type: 0- rectangle, 1- polygon
    BYTE byRes1[3];
    union
    {
        NET_VCA_RECT struRect;  //Rectangle area
        NET_ITC_POLYGON struPolygon; //Polygon area
    }uRegion;
    BYTE  byRes[16];    //Reserved
}NET_ITC_PLATE_RECOG_REGION_PARAM, *LPNET_ITC_PLATE_RECOG_REGION_PARAM;

//Speed measuring parameter of single group IO
typedef struct tagNET_ITC_SINGLE_IOSPEED_PARAM
{
    BYTE byEnable; //Whether enable or not: 0- no, 1- yes
    BYTE byTrigCoil1; //The IO related with the first coil: 0- IO1, 1- IO2, 2- IO3, 3- IO4, 4- IO5, 5- IO6
    BYTE byCoil1IOStatus;//The input status of IO related with the first coil: 0- falling edge(default), 1- rising edge, 2- rising edge and falling edge,
    //3- high level, 4- low level
    BYTE byTrigCoil2; //The IO related with the second coil: 0- IO1, 1- IO2, 2- IO3, 3- IO4, 4- IO5, 5- IO6
    BYTE byCoil2IOStatus;//The input status of IO related with the second coil: 0- falling edge(default), 1- rising edge, 2- rising edge and falling edge,
    //3- high level, 4- low level
    BYTE byRelatedDriveWay;//Related lane number
    BYTE byTimeOut;//Timeout(default: 10), unit: s
    BYTE byRelatedIOOutEx;//Zeroth bits IO output port 1, and so on, 0- is not correlation, 1- correlation support related to the 8 (compatible with the byRelatedIOOut field)
    DWORD dwDistance;//Coil distance (default: 1000), unit: cm
    BYTE byCapSpeed;//Capturing speed (default: 30), unit: km/h
    BYTE bySpeedLimit;//Speed limit(default: 60), unit: km/h
    BYTE bySpeedCapEn; //Enable speed snap or not: 0- no, 1- yes
    BYTE bySnapTimes1; //Snapshot times of the first coil (default: not snap): 0- not snap, none 0- continuous times: max 5 times
    BYTE bySnapTimes2; //Snapshot times of the second coil(default: 1): 0- not snap, none 0- continuous times: max 5 times
    BYTE byBigCarSpeedLimit; //The speed limit value
    BYTE byBigCarSignSpeed;//Signs of speed limit (CART), unit km/h(3.7Ver)
    BYTE byIntervalType;    //Interval type(default: by time): 0- take effect by time, 1- take effect by distance
    WORD wInterval1[MAX_INTERVAL_NUM];//The first coil: continuous snapping interval time (unit: ms) or continuous snapping interval distance (unit:decimeter)
    //When byIntervalType is 0, it means interval time, when byIntervalType is 1, it means interval distance.
    WORD wInterval2[MAX_INTERVAL_NUM];//The second coil: continuous snapping interval time (unit: ms) or continuous snapping interval distance (unit:decimeter)
    //When byIntervalType is 0, it means interval time, when byIntervalType is 1, it means interval distance.
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //The related IO output port(can associate with multiple ports), array 0 means IO output no.1, array 1 means IO output no.2, and so forth.
    //The value: 0- not related, 1- related
    BYTE byFlashMode;   //Flash mode of flash light: 0- flash at the same time, 1- flash in turn
    BYTE byLaneType;   //Lane Type, 0- is not configured, 1- highway, 2- city expressway, 0xff- other road
    BYTE byCarSignSpeed;//speed limit sign, unit km/h(3.7Ver)
    BYTE byUseageType; //Lane Useage Type\A3\ACITC_LANE_USEAGE_TYPE
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //Plate recognition (there is one usable area, one area is reserved)
    BYTE byRelaLaneDirectionType;
    BYTE byLowSpeedLimit;
    BYTE byBigCarLowSpeedLimit;
    BYTE byLowSpeedCapEn;                 //Enable low speed snap or not: 0- no, 1- yes
    BYTE byEmergencyCapEn;                //Emergency Enable
    BYTE byRes[27];
}NET_ITC_SINGLE_IOSPEED_PARAM, *LPNET_ITC_SINGLE_IOSPEED_PARAM;

//IO velocimetry parameter of traffic gate
typedef struct tagNET_ITC_POST_IOSPEED_PARAM
{
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //License recognition parameter
    NET_ITC_SINGLE_IOSPEED_PARAM struSingleIOSpeed[MAX_IOSPEED_GROUP_NUM]; //Single IO velocimetry group parameter
    BYTE  byRes[32];
}NET_ITC_POST_IOSPEED_PARAM, *LPNET_ITC_POST_IOSPEED_PARAM;

//Single IO parameter
typedef struct tagNET_ITC_SINGLEIO_PARAM
{
    BYTE byDefaultStatus;//IO default triggering state: 0- low level, 1- high level
    BYTE byRelatedDriveWay;//Related traffic lane
    BYTE bySnapTimes; //Snapshot times (default: 1): 0- not snap, none 0- continuous times: max 5 times
    BYTE byRelatedIOOutEx;//Zeroth bits IO output port 1, and so on, 0- is not correlation, 1- correlation support related to the 8 (compatible with the byRelatedIOOut field)
    NET_ITC_INTERVAL_PARAM struInterval; //Snapshot interval
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //The related IO output port (can associate with multiple ports)
    BYTE byFlashMode;   //Flash mode of flash light: 0- flash at the same time, 1- flash in turn
    BYTE byEnable;//Single IO enable flag 0- is not enabled, 1- enabled (Remark: in the ability to return to support bySupport&0x20, said whether to support the single IO trigger interface IO enable configuration Shi Shengxiao)
    BYTE byUseageType; //Lane Useage Type\A3\ACITC_LANE_USEAGE_TYPE
    BYTE byEmergencyCapEn;                //Emergency Enable
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //Plate recognition parameter
    BYTE byRes[24];
}NET_ITC_SINGLEIO_PARAM, *LPNET_ITC_SINGLEIO_PARAM;

//Single IO triggering parameter
typedef struct tagNET_ITC_POST_SINGLEIO_PARAM
{
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //Plate recognition parameter
    NET_ITC_SINGLEIO_PARAM struSingleIO[MAX_IOIN_NUMEX]; //Single IO triggering parameter
}NET_ITC_POST_SINGLEIO_PARAM, *LPNET_ITC_POST_SINGLEIO_PARAM;

typedef struct tagNET_ITC_LANE_PARAM
{
    BYTE byEnable; //Enable the lane or not: 0- no, 1- yes
    BYTE byRelatedDriveWay;//Related lane
    WORD wDistance; //Coil distance, to calculate speed
    WORD wTrigDelayTime; //Triggering delay time (default: 200), unit: ms
    BYTE byTrigDelayDistance; //Triggering delay distance (default: 0), unit: decimeter
    BYTE bySpeedCapEn; //Whether enable speed snap:  0- no, 1- yes
    BYTE bySignSpeed;//Sign speed limit, unit: km/h
    BYTE bySpeedLimit;//Speed limit value, unit: km/h
    BYTE bySnapTimes; //The total snapshot times (default: 1), 0- not snap, none 0- continuous times: max 5 times
    BYTE byOverlayDriveWay; //OSD superimposed lane number
    NET_ITC_INTERVAL_PARAM struInterval; //Snapping interval parameter
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //The related IO output port (can associate with multiple ports)
    BYTE byFlashMode;   //Flash mode of flash light: 0- flash at the same time, 1- flash in turn
    BYTE byCartSignSpeed;//Signs speed limit (carts) in km / h
    BYTE byCartSpeedLimit;//Speed limit value (carts), in km / h
    BYTE byRelatedIOOutEx;//Zeroth bits IO output port 1, and so on, 0- is not correlation, 1- correlation support related to the 8 (compatible with the byRelatedIOOut field)
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //Lane plate recognition parameter
    BYTE byLaneType;   //Lane Type, 0- is not configured, 1- highway, 2- city expressway, 0xff- other road
    BYTE byUseageType; //Lane Useage Type,ITC_LANE_USEAGE_TYPE
    BYTE byRelaLaneDirectionType;
    BYTE byLowSpeedLimit;
    BYTE byBigCarLowSpeedLimit;
    BYTE byLowSpeedCapEn;                 //Whether enable low speed snap:  0- no, 1- yes
    BYTE byEmergencyCapEn;                //Emergency Enable
    BYTE byRes[9];
}NET_ITC_LANE_PARAM, *LPNET_ITC_LANE_PARAM;

//RS485 magnetic-vehicle-detector triggering parameter of traffic gate
typedef struct tagNET_ITC_POST_RS485_PARAM
{
    BYTE byRelatedLaneNum;//The total number of related lanes
    BYTE byTriggerSpareMode; //Trigger standby mode, 0 - default, 1 - bayonet virtual coil mode, 2-HVT mode
    BYTE byFaultToleranceTime;//Fault tolerance time (unit: minutes) for detecting vehicle inspection is normal maximum time
    BYTE byRes1;
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //Plate recognition parameter
    NET_ITC_LANE_PARAM struLane[MAX_ITC_LANE_NUM]; //Related lane parameter
    BYTE  byRes[32];
}NET_ITC_POST_RS485_PARAM, *LPNET_ITC_POST_RS485_PARAM;

typedef struct tagNET_ITC_RADAR_PARAM
{
    BYTE    byRadarType;    //Radar type: 0- no radar, 1- Andoray radar, 2- Olvia, 3- TransMicrowave, 0xff- other type
    BYTE    byLevelAngle;   //Angle to the horizontal, default: 25\A1\E3, value range: 0~90\A1\E3
    WORD    wRadarSensitivity; //Radar sensitivity
    WORD    wRadarSpeedValidTime;//Radar speed effective time (0~2000] MS, 0 did not support
    BYTE    byRes1[2];
    float      fLineCorrectParam;//Linear correction parameters of [0.0~2.0]
    int      iConstCorrectParam;//Constant correction parameters of [-100~100]
    BYTE    byRes2[8];
}NET_ITC_RADAR_PARAM, *LPNET_ITC_RADAR_PARAM;

typedef struct tagNET_ITC_RS485_ACCESS_INFO_COND
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwTriggerModeType;
    BYTE  byAssociateRS485No;
    BYTE  byRes[15];
}NET_ITC_RS485_ACCESS_INFO_COND,*LPNET_ITC_RS485_ACCESS_INFO_COND;

typedef struct tagNET_ITC_RADAR_INFO_PARAM
{
    NET_ITC_RADAR_PARAM  struRadarParam;
    BYTE  byAssociateLaneNo;//Association of the lane numbers 1 to 99 (this value can be repeated at different RS485 port)
    BYTE  byRes[103];
}NET_ITC_RADAR_INFO_PARAM, *LPNET_ITC_RADAR_INFO_PARAM;

typedef union tagNET_ITC_ACCESS_DEVINFO_PARAM_UNION
{
    BYTE uLen[128];
    NET_ITC_RADAR_INFO_PARAM struRadarInfoParam;
}NET_ITC_ACCESS_DEVINFO_PARAM_UNION, *LPNET_ITC_ACCESS_DEVINFO_PARAM_UNION;

typedef struct tagNET_ITC_RS485_ACCESS_CFG
{
    DWORD dwSize;
    BYTE  byModeType;//0 to set aside, Bit1 radar, bit2 ~ bit3 ~ sensors, signal detector
    BYTE  byRes[3];
    NET_ITC_ACCESS_DEVINFO_PARAM_UNION uITCAccessDevinfoParam;
    BYTE  byRes1[12];
}NET_ITC_RS485_ACCESS_CFG,*LPNET_ITC_RS485_ACCESS_CFG;

typedef struct tagNET_ITC_RS485_ACCESS_INFO
{
    DWORD dwSize;
    NET_ITC_RADAR_PARAM  struRadar[MAX_ITC_LANE_NUM];
    BYTE  byRes[20];
}NET_ITC_RS485_ACCESS_INFO, *LPNET_ITC_RS485_ACCESS_INFO;


//RS485 radar triggering parameter of traffic gate
typedef struct tagNET_ITC_POST_RS485_RADAR_PARAM
{
    BYTE byRelatedLaneNum;//The total number of related lanes
    BYTE byRes1[3];
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //Plate recognition parameter
    NET_ITC_LANE_PARAM struLane[MAX_ITC_LANE_NUM]; //Related lane parameter
    NET_ITC_RADAR_PARAM struRadar;  //Radar parameter
    BYTE  byRes[32];
}NET_ITC_POST_RS485_RADAR_PARAM, *LPNET_ITC_POST_RS485_RADAR_PARAM;

typedef struct tagNET_ITC_VTLANE_PARAM
{
    BYTE byRelatedDriveWay;//Related lane index
    BYTE bySpeedCapEn; //Enable overspeed snapshot or not: 0-no, 1- yes
    BYTE bySignSpeed;  //Sign speed limit, unit: km/h
    BYTE bySpeedLimit; //Speed limit, unit: km/h
    BYTE bySnapTimes;  //Snapshot times (default: 1): 0- not snapshot, none 0- continuous times: max 5 times
    BYTE byBigCarSignSpeed;///*The cart flag speed, unit km/h*/
    BYTE byBigCarSpeedLimit;/*The speed limit value, unitkm/h*/
    BYTE byRelatedIOOutEx;//Zeroth bits IO output port 1, and so on, 0- is not correlation, 1- correlation support related to the 8 (compatible with the byRelatedIOOut field)
    NET_ITC_INTERVAL_PARAM struInterval; //Snapshot interval
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //The related IO output port (can associate with multiple ports)
    BYTE byFlashMode;   //Flash mode of flash light: 0- flash at the same time, 1- flash in turn
    BYTE byLowSpeedLimit;/*Low Speed Limit\A3\ACUnit km/h*/
    BYTE byBigCarLowSpeedLimit; /*Big Car Low Speed Limit\A3\ACUnit km/h*/
    BYTE byRelaLaneDirectionType;
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //Plate recognition parameter
    NET_VCA_LINE struLine;
}NET_ITC_VTLANE_PARAM, *LPNET_ITC_VTLANE_PARAM;

typedef struct tagNET_ITC_VTCOIL_INFO
{
    NET_VCA_RECT struLaneRect;  //Virtual coil region
    BYTE byTrigFlag;       //Triggering flag: : 0- triggered by vehicle head, 1- triggered by vehicle rear,2- triggered by vehicle head or rear
    BYTE byTrigSensitive;  //Triggering sensitivity, value range: 1-100
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //The related IO output port (can associate with multiple ports), array 0 means IO output no.1, array 1 means IO output no.1, and so forth.
    //The value: 0- not related, 1- related
    BYTE byFlashMode;   //Flash mode of flash light: 0- flash at the same time, 1- flash in turn
    BYTE byLaneType;   //Lane Type, 0- is not configured, 1- highway, 2- city expressway, 0xff- other road
    BYTE byEnableRadar; //Whether to enable the radar velocimetry: 0- no, 1- yes
    NET_ITC_VTLANE_PARAM struLane; //Related lane parameter
    //Lane uses type, see ITC_LANE_USEAGE_TYPE, 1 and 8 of two types (3.7Ver)
    BYTE byUseageType;
    //The direction of travel of the vehicle, see ITC_LANE_CAR_DRIVE_DIRECT (3.7Ver)
    BYTE byCarDriveDirect;
    BYTE byRes[30];
}NET_ITC_VTCOIL_INFO, *LPNET_ITC_VTCOIL_INFO;

//Virtual coil triggering parameter of traffic gate
typedef struct tagNET_ITC_POST_VTCOIL_PARAM
{
    BYTE byRelatedLaneNum;//The total number of related lanes
    BYTE byIsDisplay; //Whether to display virtual coil on the video: 0- no, 1- yes
    BYTE byLoopPos;   //Triggering coil bias at night, default: 10
    BYTE byPolarLenType; //Polarizer type, 0- without polarizer, 1- add Schneider polarizer
    BYTE byDayAuxLightMode; //Auxiliary lighting during the day mode, 0- no auxiliary lighting, 1- LED lighting, 2- flash lighting
    BYTE byVideoLaneNO; //Reference lane number of the video reference brightness
    BYTE byVideoLowTh;  //Low threshold initial value of the video reference brightness, default: 40
    BYTE byVideoHighTh; //High threshold initial value of the video reference brightness, default: 55
    BYTE byRecordMode;  //Recording flag: 0- not record, 1- record
    BYTE bySnapMode;//Capture mode:
    /*speed mode: 0- not speed, 0x1- radar, 0x2- video speed*/
    BYTE bySpeedDetector;
    BYTE byRes1;
    WORD wResolutionX;  //Width of device current definition
    WORD wResolutionY;  //Height of device current definition
    DWORD   dwDayInitExp; //The initial value of video day exposure time, default: 2000
    DWORD   dwDayMaxExp;  //The max value of video day exposure time, default: 20000
    DWORD   dwNightExp;   //The night video exposure time, default: 3000
    DWORD   dwSnapExp;    //Snapshot exposure time
    BYTE   byDayInitGain; //The initial value of video day gain, default: 200
    BYTE   byDayMaxGain;  //The max value of video day gain, default: 400
    BYTE   byNightGain;   //Night video gain
    BYTE   bySnapGain;    //Snapshot gain
    DWORD dwSceneMode;    //Scene mode, see to SCENE_MODE
    NET_DVR_GEOGLOCATION struGeogLocation; //Address location, default: Zhejiang
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //Plate recognition parameter
    NET_ITC_VTCOIL_INFO struVtCoil[MAX_VL_NUM]; //Virtual coil parameter
    NET_ITC_RADAR_PARAM struRadar;  //Radar parameter
    NET_VCA_LINE struLine; //Right lane
    //Violation detection type, said, see the ITC_VIOLATION_DETECT_TYPE bit by bit, 0- is not enabled, 1- enabled (3.7Ver)
    DWORD dwVioDetectType;
    BYTE  byDebugMode; /*Debug mode, 0- not enabled, 1- enabled*/
    BYTE  byRes[11];
}NET_ITC_POST_VTCOIL_PARAM, *LPNET_ITC_POST_VTCOIL_PARAM;

//IO traffic light parameter of single group
typedef struct tagNET_ITC_SINGLE_IOTL_PARAM
{
    BYTE byEnable;  //Whether to enable or not: 0- no, 1- yes
    BYTE byLightIO; //Traffic light IO, 0- IO1, 1- IO2, 2- IO3, 3- IO4, 4- IO5, 5- IO6
    BYTE byTrafficLight; //Traffic light valid status: 0- high-level voltage corresponding to red light, low-level voltage corresponding to green light,
    //1- high-level voltage corresponding to green light, low-level voltage corresponding to red light
    BYTE byTrigIO;  //Triggered IO number: 0- IO1, 1- IO2, 2- IO3, 3- IO4, 4- IO5, 5- IO6
    BYTE byTrigIOStatus;//The IO status: 0- falling edge(default), 1- rising edge, 2- rising edge and falling edge, 3- high level, 4- low level
    BYTE byRelatedDriveWay;//Related lane index
    BYTE byRecordEnable;//Recording flag of running red light: 0- not record, 1- record
    BYTE byRecordType;//Recording type of running red light: 0- pre-recording, 1- delay recording
    BYTE byPreRecordTime;//Pre-recording time of running red light, default: 0, unit: s
    BYTE byRecordDelayTime;//Recording delay time of running red light, default: 0, unit: s
    BYTE byRecordTimeOut;//Cycle recording timeout of running red light, unit: s
    BYTE byRedSnapTimes; //Red light snapshot times: 0- not snapshot, none 0- continuous times: max 5 times
    BYTE byGreenSnapTimes; //Green light snapshot times: 0- not snapshot, none 0- continuous times: max 5 times
    BYTE byRelatedIOOutEx;//Zeroth bits IO output port 1, and so on, 0- is not correlation, 1- correlation support related to the 8 (compatible with the byRelatedIOOut field)
    BYTE byRes1;
    BYTE byIntervalType;    //Interval type (default: by time): 0- take effect by time, 1- take effect by distance
    WORD wRedInterval[MAX_INTERVAL_NUM];//Red light continuous snapshot interval time (unit: ms) or continuous snapshot interval distance (unit: decimeter)
    //When byIntervalType is 0, it means interval time, when byIntervalType is 1, it means interval distance
    WORD wGreenInterval[MAX_INTERVAL_NUM];//Green light continuous snapshot interval time (unit: ms) or continuous snapshot interval distance (unit: decimeter)
    //When byIntervalType is 0, it means interval time, when byIntervalType is 1, it means interval distance
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //The related IO output port (can associate with multiple ports)
    BYTE byFlashMode;   //Flash mode of flash light: 0- flash at the same time, 1- flash in turn
    BYTE byRes2[3];
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //Plate recognition parameter
    BYTE  byRes[32];
}NET_ITC_SINGLE_IOTL_PARAM, *LPNET_ITC_SINGLE_IOTL_PARAM;

//IO traffic light parameter of electronic police
typedef struct tagNET_ITC_EPOLICE_IOTL_PARAM
{
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //Plate recognition parameter
    NET_ITC_SINGLE_IOTL_PARAM struSingleIOTL[MAX_IOSPEED_GROUP_NUM]; //IO traffic light parameter of single group
    BYTE  byRes[32];
}NET_ITC_EPOLICE_IOTL_PARAM, *LPNET_ITC_EPOLICE_IOTL_PARAM;

typedef enum _ITC_SERIAL_PROTOCOL_
{
    ITC_PROTOCOL_UNKNOW = 0, //Unknown
    ITC_SINGLE_COIL_PROTOCOL_MODE1 = 1, //Single-coil magnetic vehicle detector protocol (Dynamic display: arrival, departure, departure-delay snapshot, departure plate recognition)
    ITC_DOUBLE_COIL_PROTOCOL_MODE1 = 2, //Double-coil magnetic vehicle detector protocol mode no.1
    //(Dynamic display: arrival no.1, departure no.1, snapshot of departure-delay no.2, plate recognition of departure no.1)
            ITC_DOUBLE_COIL_PROTOCOL_MODE2 = 3, //Double-coil magnetic vehicle detector protocol mode no.2
    ////(Dynamic display: arrival no.1, departure no.2, snapshot of departure-delay no.2, plate recognition of departure no.1, default delay distance is 1m)
            ITC_DOUBLE_COIL_PROTOCOL_MODE3 = 4, //Double-coil magnetic vehicle detector protocol mode no.3
    //(Dynamic display: arrival no.2, departure no.1, snapshot of departure-delay no.2, plate recognition of departure no.1, default delay distance is 1m)
            ITC_DOUBLE_COIL_PROTOCOL_MODE4 = 5, /*The dual coil vehicle inspection protocol mode (display: double / triple _ into the 2_ out the 2_ extension 2_1) to reach the 2, left 2, left 2 delay capture, leave a card identification upload three vehicles picturelicense plate results*/
    ITC_DOUBLE_COIL_PROTOCOL_MODE5 = 6, /*The dual coil vehicle inspection protocol mode (display: double / triple _ Feed out 2_ 2_ extension 2_2) to reach the 2, left 2, leaving 2 delay capture, to reach 2, left 1 are brand knowledge, uploaded 3Zhang vehicle pictures and high confidence license plate results (default)*/
    ITC_DOUBLE_COIL_PROTOCOL_MODE6 = 7, /*The dual coil vehicle inspection protocol mode (display: dual / triple _ Feed the 1_ out the 2_ extension 2_2) to reach 1, left 2, left 2 delay capture, to reach a left are brand knowledge, uploaded 3the license plate of the vehicle pictures and high confidence in Zhang*/
    ITC_DOUBLE_COIL_PROTOCOL_MODE7 = 8, /*Double coil vehicle inspection protocol mode (displayed as: the double _ Feed 1_ out 1_ extension 2_1) to reach the 1, left 1, left 2 delay capture, leaving a brand identification, upload vehicle images the (bayonet leave 1, running red lights to reach 1, left 1, left delay) and license plate results*/
    ITC_DOUBLE_COIL_PROTOCOL_MODE8 = 9, /*Dual coil vehicle inspection protocol mode (display: into 1_ out double _ 1_ extension 2_2) to reach 1, left 1, left 2 delay capture, to reach 1, left 1 are brand knowledge, upload vehicle images (a bayonet left, running red lights to reach 1, left 1, leaving the delay), and high confidence license plates results (default)*/
    ITC_SINGLE_COIL_PROTOCOL_MODE2 = 10, /*Single coils vehicle inspection protocol mode (display: Single _ into 1_ out 1_ extension 1_2), arrived and left, leaving delay capture to reach the left are brand knowledge, upload vehicle images (bayonet left, running red lights to reach, left, leave the license plate of the delay), and high confidence results (default)*/
    ITC_OTHER_PROTOCOL = 0xff //Other protocol of magnetic vehicle detector
}ITC_SERIAL_PROTOCOL;

//Logic capture type normal a car
typedef enum _ITC_NORMAL_PASS_SERIAL_PROTOCOL_
{
    ITC_NORMAL_PASS_SERIAL_UNKNOW     =  0,   //Unknown
    ITC_NORMAL_PASS_PROTOCOL_MODE1  = 1,  //Single coil, leave capture card identification upload (default)
    ITC_NORMAL_PASS_PROTOCOL_MODE2 =2,  //Single coil, arrive, leave capture are brand knowledge, only upload to leave the license plate of the vehicle pictures and high confidence results
    ITC_NORMAL_PASS_PROTOCOL_MODE3 =3,  //Double coils, leave a snapshot, brand identification upload (default)
    ITC_NORMAL_PASS_PROTOCOL_MODE4 =4, //Dual coil arrival, leaving a snapshot are brand knowledge only upload to leave a picture of a vehicle license plate and high confidence results
    ITC_NORMAL_PASS_PROTOCOL_MODE5 =5, //Double coil to reach the 2, leaving 1 capture are brand knowledge only upload to leave a picture of a vehicle license plate and high confidence results
}ITC_NORMAL_PASS_SERIAL_PROTOCOL;

//Retrograde violations logic capture type
typedef enum _ITC_INVERSE_SERIAL_PROTOCOL_
{
    ITC_INVERSE_SERIAL_UNKNOW     =  0,   //Unknown
    ITC_INVERSE_PROTOCOL_MODE1  = 1,  //Does not capture
    ITC_INVERSE_PROTOCOL_MODE2 =2,  //To reach an even caught two, leaving 2 capture, to reach a two brand consciousness, upload pictures and high confidence in three vehicle license plate results
    ITC_INVERSE_PROTOCOL_MODE3 =3,  //Arrival, leaving 2 capture, to reach a licensing knowledge, upload two vehicle images and license plate results
}ITC_INVERSE_SERIAL_PROTOCOL;

//The speeding violation logical capture type
typedef enum _ITC_SPEED_SERIAL_PROTOCOL_
{
    ITC_SPEED_SERIAL_UNKNOW     =  0,   //Unknown
    ITC_SPEED_PROTOCOL_MODE1  = 1,  //Does not capture
    ITC_SPEED_PROTOCOL_MODE2 =2,  //Double / triple coil, left 1, left 2, left 2 delay capture, leaving a brand consciousness, upload vehicle images (bayonet left 1, speeding left 1, left 2, left delay) and license plate results
    ITC_SPEED_PROTOCOL_MODE3 =3,  //Double / triple coil, leave, leave 2 leave 2 delay capture, leaving a brand consciousness, upload vehicle images (bayonet left 1, speeding left 1, left 2) and license plate results
}ITC_SPEED_SERIAL_PROTOCOL;

//Magnetic vehicle detector parameter
typedef struct tagNET_ITC_SERIAL_INFO
{
    BYTE bySerialProtocol; //Protocol type of magnetic vehicle detector, see to ITC_SERIAL_PROTOCOL
    BYTE byIntervalType;    //Interval type (default: by time): 0- take effect by time, 1- take effect by distance
    WORD wInterval;//Continuous snapping interval time (unit: ms) or continuous snapping interval distance (unit: decimeter)
    //When byIntervalType is 0, it means interval time, when byIntervalType is 1, it means interval distance
    BYTE byNormalPassProtocol; //Normal over the car to capture the protocol type, see ITC_NORMAL_PASS_SERIAL_PROTOCOL
    BYTE byInverseProtocol; //Retrograde capture protocol type, see ITC_INVERSE_SERIAL_PROTOCOL
    BYTE bySpeedProtocol; //Overspeed protocol type, see ITC_SPEED_SERIAL_PROTOCOL
    BYTE byRes[9];
}NET_ITC_SERIAL_INFO, *LPNET_ITC_SERIAL_INFO;

typedef struct tagNET_ITC_EPOLICE_LANE_PARAM
{
    BYTE byEnable; //Whether enable this traffic lane: 0- no, 1- yes
    BYTE byRelatedDriveWay;//The related lane number
    WORD wDistance; //Coil distance, unit: cm
    BYTE byRecordEnable;//Cycle recording sign of red light running behavior: 0- not record, 1- record
    BYTE byRecordType;//Recording type of red light running behavior: 0- pre-recording\A3\AC1- delay recording
    BYTE byPreRecordTime;//Pre-recording time of red light running behavior (default: 0), unit: s
    BYTE byRecordDelayTime;//Recording delay time of red light running behavior (default: 0), unit: s
    BYTE byRecordTimeOut;//Recording timeout time of red light running behavior, unit: s
    BYTE bySignSpeed;//Sign speed(Post epolice mode),km/h
    BYTE bySpeedLimit;//Speed limit(Post epolice mode), km/h
    BYTE byOverlayDriveWay; //OSD superimposed lane number
    NET_ITC_SERIAL_INFO struSerialInfo; //Magnetic vehicle detector parameter
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //Related IO output port, can associating with multiple ports
    BYTE byFlashMode;   //Flash flashing mode: 0- flash at the same time, 1- flash in turn
    BYTE bySerialType; //Type of vehicle inspection, 0 - private vehicle inspection, 1 - private OEM vehicle inspection - Other vehicle inspection
    BYTE byRelatedIOOutEx;//Zeroth bits IO output port 1, and so on, 0- is not correlation, 1- correlation support related to the 8 (compatible with the byRelatedIOOut field)
    BYTE bySnapPicPreRecord; //Capture images of pre recorded time points
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //Lane license plate recognition parameters
    BYTE byBigCarSignSpeed;    ///*The signs of speed limit\A3\ACunit km/h*/
    BYTE byBigCarSpeedLimit;/*The speed limit\A3\ACunit km/h*/
    BYTE byRedTrafficLightChan;//The red channel number: 1 ~ 16 (red light detector)
    BYTE byYellowTrafficLightChan;//The yellow light channel number: 1 ~ 16 (red light detector)
    BYTE byRelaLaneDirectionType;
    BYTE byRes3[11];
}NET_ITC_EPOLICE_LANE_PARAM, *LPNET_ITC_EPOLICE_LANE_PARAM;

//RS485 magnetic vehicle detector triggering parameter of electronic police or traffic-gate electronic police
typedef struct tagNET_ITC_EPOLICE_RS485_PARAM
{
    BYTE byRelatedLaneNum;//The total number of related lanes
    BYTE byTrafficLightSignalSrc;//The traffic light signal from 0 ~ 1 to red light detector sensors
    BYTE byRes1[2];
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //Plate recognition parameter
    NET_ITC_EPOLICE_LANE_PARAM struLane[MAX_ITC_LANE_NUM]; //Related lane parameter
    BYTE  byRes[32];
}NET_ITC_EPOLICE_RS485_PARAM, *LPNET_ITC_EPOLICE_RS485_PARAM;

typedef struct tagNET_ITC_LANE_LOGIC_PARAM
{
    BYTE byUseageType; //Lane use types, see ITC_LANE_USEAGE_TYPE
    BYTE byDirectionType; //Lane direction types, see ITC_LANE_DIRECTION_TYPE
    BYTE byCarDriveDirect; //Drive direction,see ITC_LANE_CAR_DRIVE_DIRECT
    BYTE byRes[33];
}NET_ITC_LANE_LOGIC_PARAM, *LPNET_ITC_LANE_LOGIC_PARAM;

typedef struct tagNET_ITC_LINE
{
    NET_VCA_LINE struLine; //Line parameters
    BYTE byLineType; //Line type, see ITC_LINE_TYPE
    BYTE byRes[7];
}NET_ITC_LINE, *LPNET_ITC_LINE;

typedef struct tagNET_ITC_SNAPMODE_PARAM
{
    BYTE     byVehicleCapMode;//Motor vehicle to capture mode\A3\AC0-Strobe mode\A3\BB1-Flash mode
    BYTE     byNoVehicleCapMode;//Non-motor vehicle snap mode\A3\AC0-Strobe mode\A3\BB1-Flash mode
    BYTE     byPasserCapMode;//Pedestrian snap mode\A3\AC0-Strobe mode\A3\BB1-Flash mode
    BYTE     byRes[29];
}NET_ITC_SNAPMODE_PARAM, *LPNET_ITC_SNAPMODE_PARAM;

typedef struct tagNET_ITC_HVT_EC_PARAM
{
    DWORD         dwCapShutter;            //capShutter 0~65535
    WORD         wCapGain;            //capGain 0\A1\AB100
    BYTE          byRes[2];
    DWORD         dwDayTimeVideoShutter;    //The maximum exposure time of day
    WORD         wDayTimeVideoGain;        //The maximum gain of day
    WORD         wNightVideoGain;        //the maximum gain of night
    DWORD         wNightVideoShutter;        //the time maximum exposure of night
    BYTE          byRes1[108];
}NET_ITC_HVT_EC_PARAM, *LPNET_ITC_HVT_EC_PARAM;

typedef struct tagNET_ITC_LANE_HVT_PARAM
{
    BYTE byLaneNO; //The associated Lane No. 1~255 (used for stacking and upload)
    BYTE bySignSpeed;    //Signs of speed limit, the unit km/h 0 ~ 255   70
    BYTE bySpeedLimit;    //Signs of speed limit, the unit km/h
    BYTE byBigCarSignSpeed;///*The signs of speed limit, the unit km/h*/
    BYTE byBigCarSpeedLimit;/*The speed limit, the unit km/h*/
    BYTE bySpeedCapEn; //SpeedCapEn\A3\AC0-no enable\A3\AC1-enable
    BYTE byCaptureCount;//cap number 1\A1\AB5(normal)
    BYTE byRelatedIOOut;    /*The associated IO output port (can simultaneously to multiple), according to a IO output port, zeroth IO output port 1, and so on, 0- is not correlation, 1- correlation*/
    BYTE byFlashMode;        /*Flash mode, 0- flash, 1 flash in turn*/
    BYTE byEnableRadar; //Whether to enable the radar\A3\AC0-no enable\A3\AC1- enable
    BYTE byRes2[2];
    DWORD dwCapTarget;    //Snap type bit0 said Bit1 bit2 said the non-motor vehicle pedestrian 0 ~ 1 ~ said that do not
    NET_ITC_INTERVAL_PARAM struInterval; //capture the interval parameter
    BYTE byRes3[24];
    NET_ITC_LANE_LOGIC_PARAM struLane; //Lane attributes, using byUseageType and byCarDriveDirect
    NET_ITC_LINE struLeftLaneLine;          //The left lane line, line type is dotted, solid yellow line, single and double yellow line
    NET_ITC_LINE struRightLaneLine;          //The right lane line, line type is dotted, solid yellow line, single and double yellow line
    NET_ITC_POLYGON struPlateRecog;         //Brand recognition of regional parameters
    NET_ITC_POLYGON struTraceArea;          //Video trigger focus area
    NET_VCA_LINE  struForwardTrigLine;      //Positive trigger line: a line segment, concerned about the endpoint position, currently only supports the level of configuration, interface is saved in two ends segment. (general configuration for the optimal trigger position forward vehicle)
    NET_VCA_LINE  struBackwardTrigLine;     //Back to the trigger line: a line segment, concerned about the endpoint position, currently only supports the level of configuration, interface is saved in two ends segment (generally configured to back to the optimal trigger position of vehicle)
    NET_VCA_LINE  struLeftTrigLine;          //The left trigger line: a line segment, concerned about the endpoint position, currently only supports the vertical configuration, interface is saved in two ends segment (general configuration for the optimal trigger position from the left into the vehicle)
    NET_VCA_LINE  struRightTrigLine;//The right trigger line: a line segment, concerned about the endpoint position, currently only supports the vertical configuration, interface is saved in two ends segment (general configuration for the optimal trigger position from the right into the vehicle)
    BYTE byRes4[60];
}NET_ITC_LANE_HVT_PARAM, *LPNET_ITC_LANE_HVT_PARAM;

typedef struct tagNET_ITC_POST_HVT_PARAM
{
    BYTE byLaneNum;//The number of lanes of identification, 1-6
    BYTE bySceneMode;//Road 0- unknown 1- city 2- District entrance;
    BYTE byRoadExpBright;//Pavement desired brightness (video exposure parameter adjustment based on. In the absence of a motor vehicle, according to the luminance expectations, adjust the video exposure parameters)
    BYTE byPlateExpBright;//The desired brightness (video license plate exposure parameter adjustment based on. In a motor vehicle by and recognition to the license plates, based on the expected value of brightness, adjust the video exposure parameters)
    NET_ITC_POLYGON struDetectArea;//Video detection area
    NET_ITC_SNAPMODE_PARAM  struCapMode;//Capture mode
    NET_ITC_HVT_EC_PARAM struEcParam;    //The exposure control parameters
    NET_ITC_LANE_HVT_PARAM struLaneParam[MAX_ITC_LANE_NUM]; //Road cycling property
    NET_ITC_PLATE_RECOG_PARAM  struPlateRecog;    //Brand identification parameters
    NET_DVR_GEOGLOCATION struGeogLocation;    //Address (default location in Zhejiang)
    BYTE byRes[324];
}NET_ITC_POST_HVT_PARAM, *LPNET_ITC_POST_HVT_PARAM;

/*************************MPR begin 2013-12-07****************/
typedef struct tagNET_ITC_LANE_MPR_PARAM
{
    BYTE byLaneNO;
    union
    {
        BYTE  uLen[4];
        struct
        {
            BYTE  byIONo;//IO[1, byIoInNum+1] (NET_DVR_SNAP_ABILITY.byIoInNum)
            BYTE  byTriggerType;//0-falling\A3\AC1-rising
            BYTE  byRes1[2];
        }struIO;//IO mode effect
        struct
        {
            BYTE  byRelateChan;//Correlation detectors channel number[1,16]
            BYTE  byRes2[3];
        }struRS485;
    }uTssParamInfo;
    BYTE byCarDriveDirect; // ITC_LANE_CAR_DRIVE_DIRECT
    BYTE byRes[58];
    NET_ITC_LINE struLaneLine;//Lane Line
    NET_ITC_POLYGON struPlateRecog;//Plate Recog
    BYTE byRelaLaneDirectionType;
    BYTE byRes1[255];
}NET_ITC_LANE_MPR_PARAM,*LPNET_ITC_LANE_MPR_PARAM;

typedef struct tagNET_ITC_POST_MPR_PARAM
{
    BYTE byEnable;
    BYTE byLaneNum;
    BYTE bySourceType;//0-MPR,1-IO,2-RS485
    BYTE byPicUploadType;//Picture Upload Type
    BYTE byRoadType;//Mode selection 0 - the entrance, 1 - city road, 2 - custom ,3-Alarm Input
    BYTE byRes2;
    WORD wCustomDelayTime;//Custom capture delay time (in byRoadType effect for the "custom"), in the range [0150] ms
    BYTE byRes[56];
    NET_ITC_LINE struLaneBoundaryLine;//The lane boundary line
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog;//Plate Recog  40
    NET_ITC_LANE_MPR_PARAM struLaneParam[MAX_ITC_LANE_NUM/*6*/];
    char  szSceneName[NAME_LEN/*32*/]; //Scene Name
    NET_VCA_LINE struSnapLine;//Snap line, on the erection way as the side of the camera installed, configure the parameters take effect (i.e., 4.5 NET_DVR_CAMERA_SETUPCFG byErectMethod field in a structure to 1)
    BYTE byRes1[392];
}NET_ITC_POST_MPR_PARAM,*LPNET_ITC_POST_MPR_PARAM;
/*************************MPR end 2013-12-07****************/

typedef struct tagNET_DVR_VIA_LANE_PARAM
{
    BYTE byLaneNO;  //Associate lane number
    BYTE byRes[63]; //Reserved
    NET_ITC_LANE_LOGIC_PARAM  struLogicParam; //Lane logic param
    NET_ITC_LINE  struLaneLine;//Lane line
    NET_ITC_POLYGON  struPlateRecog;//Plate recog region
    BYTE byRes1[300]; //Reserved
} NET_DVR_VIA_LANE_PARAM,*LPNET_DVR_VIA_LANE_PARAM;

typedef struct tagNET_DVR_VIA_VTCOIL_PARAM
{
    BYTE byEnable;    //0-Disable 1-Enable
    BYTE byLaneNum; //Lane Num
    BYTE byRes[62]; //Reserved
    NET_ITC_LINE  struLaneBoundaryLine;//Lane boundary line,that is the Leftmost lane on the left boundary
    NET_DVR_VIA_LANE_PARAM  struLaneParam[MAX_ITC_LANE_NUM/*6*/]; //Lane param
    NET_ITC_PLATE_RECOG_PARAM  struPlateRecog;//Plate recog param
    BYTE byRes1[624];//Reserved
}NET_DVR_VIA_VTCOIL_PARAM,*LPNET_DVR_VIA_VTCOIL_PARAM;

typedef struct tagNET_DVR_TRIGGER_COND
{
    DWORD  dwSize;       //Structure size
    DWORD  dwChannel;    //Channel number
    DWORD  dwTriggerMode;//Trigger mode,refet to ITC_TRIGGERMODE_TYPE
    BYTE   byDetSceneID;//Scene ID[1,4]
    BYTE   byRes[63];    //Reserved
}NET_DVR_TRIGGER_COND,*LPNET_DVR_TRIGGER_COND;

typedef struct tagNET_ITC_LANE_IMT_PARAM
{
    BYTE byLaneNO;
    //ITC_RELA_LANE_DIRECTION_TYPE
    BYTE byRelaLaneDirectionType;
    BYTE byRes[146];
    NET_ITC_LINE struLaneLine;
    BYTE byRes1[256];
}NET_ITC_LANE_IMT_PARAM,*LPNET_ITC_LANE_IMT_PARAM;

typedef struct tagNET_ITC_POST_IMT_PARAM
{
    BYTE byEnable;
    BYTE byLaneNum;
    BYTE bySnapMode;
    BYTE byRes[61];
    NET_ITC_PLATE_RECOG_PARAM  struPlateRecog;
    NET_ITC_LINE struLaneBoundaryLine;
    NET_ITC_LANE_IMT_PARAM struLaneParam[MAX_ITC_LANE_NUM/*6*/];
    BYTE byRes1[1584];
}NET_ITC_POST_IMT_PARAM,*LPNET_ITC_POST_IMT_PARAM;

typedef struct tagNET_ITC_LANE_PRS_PARAM
{
    BYTE byLaneNO;
    union
    {
        BYTE  uLen[4];
        struct
        {
            BYTE  byIONo;//IO Number[1,4]
            BYTE  byTriggerType;//0-falling edge, 1-Rising edge
            BYTE  byRes1[2];
        }struIO;//IO mode effect
        struct
        {
            BYTE  byRelateChan;//Correlation detectors channel number[1,16]
            BYTE  byRes2[3];
        }struRS485;
    }uTssParamInfo;
    BYTE byRes[59];
    NET_ITC_LINE struLaneLine;//Lane Line
    NET_ITC_POLYGON struPlateRecog;//Plate Recog
    BYTE byRelaLaneDirectionType;
    BYTE byRes2[3];
    NET_ITC_LINE struTrigLine;
    BYTE byRes1[228];
}NET_ITC_LANE_PRS_PARAM,*LPNET_ITC_LANE_PRS_PARAM;


typedef struct tagNET_ITC_POST_PRS_PARAM
{
    BYTE byEnable;
    BYTE byLaneNum;
    BYTE bySourceType;//0-Video detection, 1- associated IO trigger (induction coil), trigger signal 2- Association RS485
    BYTE bySnapMode;//0- panorama, 1- panorama + close-up
    BYTE byCapMode;//Video detection mode effect\A3\AC0-Strobe mode, 1- flashing mode
    BYTE byNoPlatCarCap;
    BYTE bySceneMode;
    BYTE byRes[57];
    NET_ITC_LINE struLaneBoundaryLine;//The lane boundary line (the left most Lane left)
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog;//Plate Recog  40
    NET_ITC_LANE_PRS_PARAM struLaneParam[MAX_ITC_LANE_NUM/*6*/];
    BYTE byRes1[440];
}NET_ITC_POST_PRS_PARAM,*LPNET_ITC_POST_PRS_PARAM;

typedef struct tagNET_IPC_LANE_HVT_PARAM
{
    BYTE byLaneNO;
    BYTE byCarDriveDirect; //ITC_LANE_CAR_DRIVE_DIRECT
    BYTE byRes[62];
    NET_ITC_LINE struLaneLine;//Lane Line
    NET_ITC_POLYGON struPlateRecog;//Plate Recog
    BYTE byRes1[256];
} NET_IPC_LANE_HVT_PARAM,*LPNET_IPC_LANE_HVT_PARAM;

typedef struct tagNET_IPC_POST_HVT_PARAM
{
    BYTE  byEnable;
    BYTE  byLaneNum;
    BYTE  byRes[62];
    NET_ITC_LINE struLaneBoundaryLine;//The lane boundary line (the left most Lane left)
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog;//Plate Recog  40
    NET_IPC_LANE_HVT_PARAM struLaneParam[MAX_ITC_LANE_NUM/*6*/];
    char  szSceneName[NAME_LEN/*32*/]; //Scene Name
    NET_VCA_LINE struSnapLine;//Snap line, on the erection way as the side of the camera installed, configure the parameters take effect (i.e., 4.5 NET_DVR_CAMERA_SETUPCFG byErectMethod field in a structure to 1)
    BYTE byRes1[392];
} NET_IPC_POST_HVT_PARAM,*LPNET_IPC_POST_HVT_PARAM;

//Snap 4.0 add
typedef struct tagNET_ITC_LANE_HVT_PARAM_V50
{
    BYTE byLaneNO;        //Lane No. 1\A1\AB255
    BYTE byFlashMode;    //Flash Mode
    BYTE bySignSpeed;    //Sign Speed Unit:km/h
    BYTE bySpeedLimit;    //Speed Limit\A3\ACUnit:km/h
    BYTE bySignLowSpeed;    //Sign Low Speed\A3\ACUnit:km/h
    BYTE byLowSpeedLimit;    //Low Speed Limit\A3\ACUnit:km/h
    BYTE byBigCarSignSpeed;    //Big Car Sign Speed\A3\ACUnit:km/h
    BYTE byBigCarSpeedLimit;    //Big Car Speed Limit\A3\ACUnit:km/h
    BYTE byBigCarSignLowSpeed;    //Big Car Sign Low Speed\A3\ACUnit:km/h
    BYTE byBigCarLowSpeedLimit;    //Big Car Low Speed Limit\A3\ACUnit:km/h
    BYTE bySnapTimes;    //Snap Times\A3\AC1~3
    BYTE  byDriveLineSnapTime;// Drive Line Snap Times 1~3
    BYTE  byHighSpeedSnapTime;// High Speed Snap Times 1~3
    BYTE  byLowSpeedSnapTime;// Low Speed Snap Time 1~3
    BYTE  byBanSnapTime;// Ban Snap Time  1~3
    BYTE  byReverseSnapTime;//Reverse Snap Time  1~3
    BYTE  byRelatedDriveWay;//Lane No.
    BYTE  byLaneType;   //Lane Type
    //RelaLane Direction Type
    BYTE   byRelaLaneDirectionType;
    BYTE   byRes1[29];
    DWORD  dwVioDetectType; // ITC_VIOLATION_DETECT_TYPE
    DWORD  dwRelatedIOOut;  //Related IO Out
    NET_ITC_LINE struTrigLine; //Trigger Line
    NET_ITC_LINE struLineLeft;                //Left Line
    NET_ITC_POLYGON struPlateRecog;       //Plate Recog
    NET_ITC_LANE_LOGIC_PARAM struLane;   //Lane CFG
    NET_ITC_INTERVAL_PARAM struInterval;//Interval CFG\A3\A820byte\A3\A9
    BYTE byRes2[280];
}NET_ITC_LANE_HVT_PARAM_V50, *LPNET_ITC_LANE_HVT_PARAM_V50;

typedef struct tagNET_ITC_POST_HVT_PARAM_V50
{
    BYTE byLaneNum;    //Lane Num\A3\AC1-6
    BYTE byCapType;        //Capture Type
    BYTE byCapMode;    //Capture Mode
    BYTE bySecneMode;    //Secne Mode
    BYTE bySpeedMode;  //Speed Mode
    BYTE byLineRuleEffect; //Line Rule Effect
    BYTE byRes1[78];
    NET_ITC_LINE struLeftTrigLine;    //Left Trigger Line
    NET_ITC_LINE struRigtTrigLine;    //Right Trigger Line
    NET_ITC_LINE struLaneBoundaryLine;        //Lane Boundary Line
    NET_ITC_POLYGON struDetectArea;    //Detect Area
    NET_DVR_GEOGLOCATION struGeogLocation; //Recognition Location
    NET_ITC_LANE_HVT_PARAM_V50 struLaneParam[MAX_ITC_LANE_NUM/*6*/]; //Lane Param
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog;    //Plate Recognition
    BYTE byRes2[260];
} NET_ITC_POST_HVT_PARAM_V50, *LPNET_ITC_POST_HVT_PARAM_V50;


typedef struct tagNET_ITC_LANE_NOCOMITY_PEDESTRIAN_PARAM
{
    BYTE byRelatedDriveWay;//Related DriveWay
    BYTE byRelaLaneDirectionType;//RelaLane Direction Type
    BYTE byPedestriansNum;//Pedestrians Num
    BYTE byVehicleSpeed;//Vehicle Speed
    DWORD dwVehicleInterval; //Vehicle Interval
    BYTE byPedesDetRule; //Pedestrians Detction Rule
    BYTE byRes[3];
    NET_ITC_LINE struLaneLine;//Lane Line
    NET_ITC_LINE struStopLine;//Stop Line
    NET_ITC_POLYGON struPlateRecog; //Plate Recog
    BYTE byRes1[280];
} NET_ITC_LANE_NOCOMITY_PEDESTRIAN_PARAM,
        *LPNET_ITC_LANE_NOCOMITY_PEDESTRIAN_PARAM;


typedef struct tagNET_ITC_NOCOMITY_PEDESTRIAN_PARAM
{
    BYTE byEnable;
    BYTE byLaneNum;//Lane Num
    BYTE byRes[74];
    NET_ITC_LINE struLaneBoundaryLine;//Lane Boundary Line
    NET_ITC_LINE struTriggerLine;//Trigger Line
    NET_ITC_POLYGON struPedesDetRecog;//Pedestrians Detction Recog
    NET_ITC_LANE_NOCOMITY_PEDESTRIAN_PARAM struLaneParam[MAX_ITC_LANE_NUM/*6*/];    //Lane Param
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //Plate Recog
    BYTE byRes1[400];
}NET_ITC_NOCOMITY_PEDESTRIAN_PARAM,
        *LPNET_ITC_NOCOMITY_PEDESTRIAN_PARAM;

//Single IO light access parameter
typedef struct tagNET_ITC_SINGLE_IO_LIGHT_PARAM
{
    BYTE byLightType; //Light type,0-left,1-straight,2-right
    BYTE byRelatedIO; //Related IO
    BYTE byRedLightState; //Red light state,0-high level,1-low level
    BYTE byRes[17];
}NET_ITC_SINGLE_IO_LIGHT_PARAM, *LPNET_ITC_SINGLE_IO_LIGHT_PARAM;

//IO light access parameter
typedef struct tagNET_ITC_IO_LIGHT_PARAM
{
    NET_ITC_SINGLE_IO_LIGHT_PARAM struIOLight[MAX_LIGHT_NUM]; //Single IO light access parameter
    BYTE byRes[8];
}NET_ITC_IO_LIGHT_PARAM, *LPNET_ITC_IO_LIGHT_PARAM;

//Single RS485 access light
typedef struct tagNET_ITC_SINGLE_RS485_LIGHT_PARAM
{
    BYTE byLightType; //Light type,0-left,1-straight,2-right
    BYTE byRelatedLightChan; //Related light channel
    BYTE byInputLight;    //input light type,0-red light,1-green
    BYTE byRelatedYLightChan; //The yellow light detector channel number Association
    BYTE byRes[16];
}NET_ITC_SINGLE_RS485_LIGHT_PARAM, *LPNET_ITC_SINGLE_RS485_LIGHT_PARAM;

//RS485 access light
typedef struct tagNET_ITC_RS485_LIGHT_PARAM
{
    NET_ITC_SINGLE_RS485_LIGHT_PARAM struRS485Light[MAX_LIGHT_NUM]; //
    BYTE byRes[8];
}NET_ITC_RS485_LIGHT_PARAM, *LPNET_ITC_RS485_LIGHT_PARAM;

typedef struct tagNET_POS_PARAM
{
    WORD wLeft;
    WORD wTop;
    WORD wRight;
    WORD wBottom;
}NET_POS_PARAM, *LPNET_POS_PARAM;

//Video detection of a single set of traffic lights parameter structure
typedef struct tagNET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM
{
    BYTE byLightNum; //Number of traffic lights
    BYTE byStraightLight; //Whether there straight flag lights 0 - No 1 -yes
    BYTE byLeftLight; //Whether there turn left marker lamps 0 - No 1 -yes
    BYTE byRightLight; //Whether there is a right turn marker lamps 0 - No 1 -yes
    BYTE byRedLight;//Whether there is a red light, 0 - No, 1 -yes
    BYTE byGreenLight; //Whether there is a green light, 0 - No, 1 -yes
    BYTE byYellowLight; //Whether yellow, 0 - No, 1 -yes
    BYTE byYellowLightTime;//Range (0 ~ 10s)\A3\A8ITC3.7Ver\A3\A9
    NET_POS_PARAM struLightRect; //Traffic light area
    BYTE byRes[24];
}NET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM, *LPNET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM;


//The video detection traffic lights parameters structure (maximum 12 region detection, 488 bytes)
typedef struct tagNET_ITC_VIDEO_DETECT_LIGHT_PARAM
{
    NET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM struTrafficLight[MAX_VIDEO_DETECT_LIGHT_NUM]; //Single video detection lights parameters
    BYTE byRes[8];
}NET_ITC_VIDEO_DETECT_LIGHT_PARAM, *LPNET_ITC_VIDEO_DETECT_LIGHT_PARAM;

//Light access parameter
typedef union tagNET_ITC_LIGHT_ACCESSPARAM_UNION
{
    DWORD uLen[122];
    NET_ITC_IO_LIGHT_PARAM struIOLight; //IO access light
    NET_ITC_RS485_LIGHT_PARAM struRS485Light; //485 access light
    NET_ITC_VIDEO_DETECT_LIGHT_PARAM struVideoDelectLight; //The video detection signal lights parameters
}NET_ITC_LIGHT_ACCESSPARAM_UNION, *LPNET_ITC_LIGHT_ACCESSPARAM_UNION;

//Traffic light parameter
typedef struct tagNET_ITC_TRAFFIC_LIGHT_PARAM
{
    BYTE bySource; //light source,0-IO access,1-RS485 access
    BYTE byRes1[3];
    NET_ITC_LIGHT_ACCESSPARAM_UNION struLightAccess;//light access parameter
    BYTE byRes[32];
}NET_ITC_TRAFFIC_LIGHT_PARAM, *LPNET_ITC_TRAFFIC_LIGHT_PARAM;

//Violation detect line
typedef struct tagNET_ITC_VIOLATION_DETECT_LINE
{
    NET_ITC_LINE  struLaneLine; //Lane line
    NET_ITC_LINE  struStopLine; //Stop line
    NET_ITC_LINE  struRedLightLine; //Red light line
    NET_ITC_LINE  struCancelLine; //Cancel line
    NET_ITC_LINE  struWaitLine; //Wait line
    NET_ITC_LINE  struRes[8];
}NET_ITC_VIOLATION_DETECT_LINE, *LPNET_ITC_VIOLATION_DETECT_LINE;

//Redlight Pedestrian Param
typedef struct tagNET_ITC_REDLIGHT_PEDESTRIAN_PARAM
{
    BYTE byEnable;
    BYTE bySnapNumTimes; //Snap Num Times
    BYTE byPedesDir; //Pedestrians Dir
    BYTE byDelayTime; //Delay Time
    BYTE byStackTargetEnble;//Stack Target Enble
    BYTE byCalibRecogCtrl;//Calib Recog Ctrl
    BYTE byRes1[2];
    NET_ITC_TRAFFIC_LIGHT_PARAM struTrafficLight; //Traffic Light
    NET_ITC_LINE struStopLine;//Stop Line
    NET_ITC_POLYGON struCalibRecog[MAX_CALIB_RECOG_NUM/*2*/];//Calib Recog
    BYTE byRes[440];
}NET_ITC_REDLIGHT_PEDESTRIAN_PARAM,
        *LPNET_ITC_REDLIGHT_PEDESTRIAN_PARAM;

typedef struct tagNET_ITC_POST_MOBILE_PARAM
{
    BYTE  byEnable;
    BYTE  bySceneMode;//Scene mode, 0- highway, 1- city expressway
    WORD  wExpressWayCapType;//highway capture type
    WORD  wUrbanRoadCapType;//city expressway
    BYTE  byCapNum;//capture number [2,3]
    BYTE  byRecordEnable;//record enable, 0-off 1-om
    DWORD dwPreRecordTime;//prerecord time(s)
    DWORD dwOverRecordTime;//overrecord time(s)
    NET_ITC_LANE_LOGIC_PARAM struLane;   //Lane Param
    NET_ITC_POLYGON struPolygon[MAX_MOBILE_POLYGON_NUM/*3*/]; //Plate Recog
    NET_ITC_VIOLATION_DETECT_LINE struLine[MAX_MOBILE_DETECTLINE_NUM/*3*/]; //Violation Detect Line
    NET_ITC_LINE struLaneBoundaryLine;        //Lane Boundary Line
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //Plate Recog Param
    NET_ITC_INTERVAL_PARAM struInterval;//Interval
    BYTE  byRes[256];
}NET_ITC_POST_MOBILE_PARAM,*LPNET_ITC_POST_MOBILE_PARAM;

typedef union tagNET_ITC_TRIGGER_PARAM_UNION
{
    DWORD  uLen[1070];            // Parameter
    NET_ITC_POST_IOSPEED_PARAM    struIOSpeed; //(traffic gate) IO velocimetry parameter
    NET_ITC_POST_SINGLEIO_PARAM   struSingleIO; //(traffic gate) single IO parameter
    NET_ITC_POST_RS485_PARAM       struPostRs485; //(traffic gate) RS485 vehicle checker
    NET_ITC_POST_RS485_RADAR_PARAM  struPostRadar; //(traffic gate) RS485 Radar parameters
    NET_ITC_POST_VTCOIL_PARAM     struVtCoil; //(traffic gate) Virtual coil
    NET_ITC_POST_HVT_PARAM          struHvt;    /*(bayonet) mixed bayonet parameters*/
    NET_ITC_EPOLICE_IOTL_PARAM     struIOTL;        //(electronic police) IO traffic light parameters
    NET_ITC_EPOLICE_RS485_PARAM    struEpoliceRs485; //(electronic police) RS485 magnetic vehicle detector triggering parameter
    NET_ITC_EPOLICE_RS485_PARAM  struPERs485;    //(traffic-gate electronic police) RS485 magnetic vehicle detector triggering parameter
    NET_ITC_POST_MPR_PARAM       struPostMpr; //MPR Detection Trigger parameter 2013-12-07
    NET_DVR_VIA_VTCOIL_PARAM        struViaVtCoil;  //(VIA)Trigger parameter
    NET_ITC_POST_IMT_PARAM          struPostImt;//(IMT)Trigger parameter
    NET_ITC_POST_PRS_PARAM           struPostPrs;//PRS Trigger parameter
    NET_IPC_POST_HVT_PARAM          struIpcHvt;//(IPC) HVT
    NET_ITC_POST_HVT_PARAM_V50      struHvtV50;  /*(bayonet) mixed bayonet parameters V50*/
    NET_ITC_POST_MOBILE_PARAM       struPostMobile;// Mobie Trigger Parameter
    NET_ITC_NOCOMITY_PEDESTRIAN_PARAM struNoComityPed;//Nocomity Pedestrian Param
    NET_ITC_REDLIGHT_PEDESTRIAN_PARAM struRedLightPed;//RedLight Pedestrian Param
}NET_ITC_TRIGGER_PARAM_UNION, *LPNET_ITC_TRIGGER_PARAM_UNION;

//Single triggering parameter structure
typedef struct tagNET_ITC_SINGLE_TRIGGERCFG
{
    BYTE  byEnable;    //Enable the triggering mode: 1- yes, 0- no
    BYTE  byRes1[3];
    DWORD dwTriggerType; //Triggering type, see to ITC_TRIGGERMODE_TYPE
    NET_ITC_TRIGGER_PARAM_UNION uTriggerParam; //Triggering parameter
    BYTE  byRes[64];
}NET_ITC_SINGLE_TRIGGERCFG, *LPNET_ITC_SINGLE_TRIGGERCFG;

//Triggering parameter structure
typedef struct tagNET_ITC_TRIGGERCFG
{
    DWORD   dwSize;            //Structure size
    NET_ITC_SINGLE_TRIGGERCFG  struTriggerParam;  //Single triggering parameter
    BYTE    byRes[32];
}NET_ITC_TRIGGERCFG, *LPNET_ITC_TRIGGERCFG;


//violation detect type
typedef enum _ITC_VIOLATION_DETECT_TYPE_
{
    ITC_VIOLATION_POST = 0x01, //post
    ITC_VIOLATION_DRIVELINE = 0x02,//drive line
    ITC_VIOLATION_REVERSE = 0x04,//reverse
    ITC_VIOLATION_REDLIGHT = 0x08,//red light
    ITC_VIOLATION_DIRECTION = 0x10,//direction
    ITC_VIOLATION_INTERSECTION_CONGEST = 0x20,//intersection congest
    ITC_VIOLATION_NONDRIVEWAY = 0x40,  //non-driveway
    ITC_VIOLATION_CHANGELANE = 0x80, //Illegal lane change
    ITC_VIOLATION_BAN = 0x100, //Illegal ban
    ITC_VIOLATION_INTERSECTION_PARK=0x200,//intersection park
    ITC_VIOLATION_GREEN_PARK=0x400,//green park
    ITC_VIOLATION_HIGH_SPEED = 0x800,
    ITC_VIOLATION_LOW_SPEED = 0x1000,
    ITC_VIOLATION_EMERGENCY = 0x2000,
    ITC_VIOLATION_TURN_AROUND = 0x8000,/*Illegal Turn*/
    ITC_VIOLATION_CONGESTION = 0x10000 /*congestion*/
}ITC_VIOLATION_DETECT_TYPE;

//Violation detect parameter
typedef struct tagNET_ITC_VIOLATION_DETECT_PARAM
{
    DWORD dwVioDetectType; //violation detect type, bit, see ITC_VIOLATION_DETECT_TYPE ,0-disenable,1-enable
    BYTE byDriveLineSnapTimes; //Pressure lane line to capture the number of sheets,2-3
    BYTE byReverseSnapTimes; //Retrograde capture,2-3
    WORD wStayTime; //Machines accounted for non-residence time (the time after capture), the unit s
    BYTE byNonDriveSnapTimes;//Machine for non capture a number 2-3
    BYTE byChangeLaneTimes;//Illegal lane change capture a number 2-3
    BYTE bybanTimes;//Illegal ban snapshot number 2-3
    BYTE byDriveLineSnapSen;// Drive Line Snap(0~100)(3.7Ver)
    WORD wSnapPosFixPixel; //Article 2,3 to capture the position of minimum deviation (violation of signal onset) (unit: pixel)
    BYTE bySpeedTimes;//Illegal speeding capture number 2-3(3.8Ver)
    BYTE byTurnAroundEnable;//Turn Around Enable
    BYTE byThirdPlateRecogTime;//Third Plate Recognition Time 0~180s
    BYTE byPostSnapTimes;//Post Snap Times,1~2
    BYTE byRes1[18];
    WORD wStopLineDis;  //Electric police the the two breaches pictures with the shortest distance to the stop line, [0,300] units (pixels)
    BYTE byRes[14];
}NET_ITC_VIOLATION_DETECT_PARAM, *LPNET_ITC_VIOLATION_DETECT_PARAM;

typedef enum _ITC_RELA_LANE_DIRECTION_TYPE_
{
    ITC_RELA_LANE_DIRECTION_UNKNOW      = 0,
    ITC_RELA_LANE_EAST_WEST               = 1,
    ITC_RELA_LANE_WEST_EAST               = 2,
    ITC_RELA_LANE_SOUTH_NORTH            = 3,
    ITC_RELA_LANE_NORTH_SOUTH            = 4,
    ITC_RELA_LANE_EASTSOUTH_WESTNORTH    = 5,
    ITC_RELA_LANE_WESTNORTH_EASTSOUTH  = 6,
    ITC_RELA_LANE_EASTNORTH_WESTSOUTH  = 7,
    ITC_RELA_LANE_WESTSOUTH_EASTNORTH  = 8
} ITC_RELA_LANE_DIRECTION_TYPE;


//Lane useage type
typedef enum _ITC_LANE_USEAGE_TYPE_
{
    ITC_LANE_USEAGE_UNKNOW     = 0,  //Unknow
    ITC_LANE_CARRIAGEWAY       = 1,   //car lane
    ITC_LANE_BUS               = 2,   //bus lane
    ITC_LANE_FAST               = 3,   //fast lane
    ITC_LANE_SLOW               = 4,   //slow lane
    ITC_LANE_MOTOR               = 5,   //motor lane
    ITC_LANE_NONMOTOR           = 6,    //non motor lane
    ITC_LANE_REVERSE_LANE      = 7, //reverse lane
    ITC_LANE_BAN_TRUCKS           = 8, // Prohibit trucks lane
    ITC_LANE_MIX = 9,
    ITC_LANE_EMERGENCY = 10,
    ITC_LANE_BAN_LEFT  = 11,
    ITC_LANE_BAN_RIGHT  = 12

}ITC_LANE_USEAGE_TYPE;

//Lane direction type
typedef enum _ITC_LANE_DIRECTION_TYPE_
{
    ITC_LANE_DIRECTION_UNKNOW     = 0, //Unknow
    ITC_LANE_LEFT                  = 1, //left
    ITC_LANE_STRAIGHT              = 2, //straight
    ITC_LANE_LEFT_STRAIGHT          = 3, //left+straight
    ITC_LANE_RIGHT                  = 4, //right
    ITC_LANE_LEFT_RIGHT              = 5, //left+right
    ITC_LANE_RIGHT_STRAIGHT          = 6, //right+straight
    ITC_LANE_LEFT_RIGHT_STRAIGHT  = 7, //left+right+straight
    ITC_LANE_LEFT_WAIT              = 9, //left wait
    ITC_LANE_STRAIGHT_WAIT          = 10, //straight wait
    ITC_LANE_FORWARD              = 11, //Moving forward
    ITC_LANE_BACKWARD              = 12, //Back to travel
    ITC_LANE_BOTHWAY              = 13, //Two-way traffic
    ITC_LANE_STRAIGHT_WAIT_RIGHT  = 14
}ITC_LANE_DIRECTION_TYPE;


//Drive direction
typedef enum _ITC_LANE_CAR_DRIVE_DIRECT_
{
    ITC_LANE_DRIVE_UNKNOW        = 0, //Unknown
    ITC_LANE_DRIVE_UP_TO_DOWN    = 1, //From up to down
    ITC_LANE_DRIVE_DOWN_TO_UP    = 2  //From down to up
}ITC_LANE_CAR_DRIVE_DIRECT;

//Line type
typedef enum _ITC_LINE_TYPE_
{
    ITC_LINT_UNKNOW        = 0,  //Unknow
    ITC_LINE_WHITE         = 1,  //Lane write line
    ITC_LINE_STOP          = 2,  //Lane stop line
    ITC_LINE_SINGLE_YELLOW = 3,  //Lane single yellow line
    ITC_LINE_DOUBLE_YELLOW = 4,  //Lane double yellow line
    ITC_LINE_GUARD_RAIL    = 5,  //Lane guard rail line
    ITC_LINE_NO_CROSS      = 6,   //Lane no cross line
    ITC_LINE_DOTTED = 7 //dotted
}ITC_LINE_TYPE;



//Single video epolice param
typedef struct tagNET_ITC_LANE_VIDEO_EPOLICE_PARAM
{
    BYTE byLaneNO; //Lane NO.
    BYTE bySensitivity; //Coil sensitivity\A3\AC[1,100]
    BYTE byEnableRadar;//Whether to enable the radar  0-no enable \A3\AC1- enable
    BYTE byRelaLaneDirectionType;
    NET_ITC_LANE_LOGIC_PARAM struLane; //Lane logic param
    NET_ITC_VIOLATION_DETECT_PARAM struVioDetect; //violation detect param
    NET_ITC_VIOLATION_DETECT_LINE struLine; //Violation detect line param
    NET_ITC_POLYGON struPlateRecog; //plate recog param
    BYTE byRecordEnable;//Running a red light cycle video flag, 0 - no video - Video
    BYTE byRecordType;//Through a red light video type, 0 - pre-recorded, 1 - Time-Lapse Recording
    BYTE byPreRecordTime;//Red light running pre-recorded video clips (default 0) unit: seconds
    BYTE byRecordDelayTime;//Red light running footage delay time (default 0) Unit: second
    BYTE byRecordTimeOut;//Running a red light cycle video timeout (in seconds)
    BYTE byCarSpeedLimit; //Car Limit Speed Unit:km/h
    BYTE byCarSignSpeed;//Sign Limit Speed Unit:km/h
    BYTE bySnapPicPreRecord; //snap Picture Record
    NET_ITC_INTERVAL_PARAM struInterval;//Interval
    BYTE byRes[36];
}NET_ITC_LANE_VIDEO_EPOLICE_PARAM, *LPNET_ITC_LANE_VIDEO_EPOLICE_PARAM;

//Video epolice param
typedef struct tagNET_ITC_VIDEO_EPOLICE_PARAM
{
    BYTE byEnable;    //enable,0-no,1-yes
    BYTE byLaneNum; //Lane number
    BYTE byLogicJudge;//Red light violations judgment logic, setting value: 0- according to the direction, 1- in the lane
    BYTE byRes1;
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //plate recog
    NET_ITC_TRAFFIC_LIGHT_PARAM struTrafficLight; //traffic light
    NET_ITC_LANE_VIDEO_EPOLICE_PARAM struLaneParam[MAX_ITC_LANE_NUM]; //single lane param
    NET_ITC_LINE  struLaneBoundaryLine; //Lane boundary line(the lane right boundary line
    NET_ITC_LINE  struLeftLine; //left line
    NET_ITC_LINE  struRightLine; //right line
    NET_ITC_LINE  struTopZebraLine; //top zebra line
    NET_ITC_LINE  struBotZebraLine; //bottom zebra line
    BYTE  byRes[32];
}NET_ITC_VIDEO_EPOLICE_PARAM, *LPNET_ITC_VIDEO_EPOLICE_PARAM;

typedef union tagNET_ITC_VIDEO_TRIGGER_PARAM_UNION
{
    DWORD  uLen[1150];
    NET_ITC_VIDEO_EPOLICE_PARAM struVideoEP; //Video epolice param
}NET_ITC_VIDEO_TRIGGER_PARAM_UNION, *LPNET_ITC_VIDEO_TRIGGER_PARAM_UNION;

typedef struct tagNET_ITC_VIDEO_TRIGGER_PARAM
{
    DWORD dwSize;
    DWORD dwMode; //trigger mode,see ITC_TRIGGERMODE_TYPE
    NET_ITC_VIDEO_TRIGGER_PARAM_UNION uVideoTrigger; //video trigger param
    BYTE  byRes[32];
}NET_ITC_VIDEO_TRIGGER_PARAM, *LPNET_ITC_VIDEO_TRIGGER_PARAM;

typedef struct tagNET_DVR_STATUS_DETECTCFG
{
    DWORD  dwSize;            //Structure size
    BYTE   byEnableTrigIODetect; //Enable the status detection of triggering IO: 1- yes, 0- no
    BYTE   byEnableFlashOutDetect; //Enable the status detection of synchronous output: 1- yes, 0- no
    BYTE   byEnableRS485Detect; //Enable the detection of RS485 receiving status: 1- yes, 0- no
    BYTE   byEnableTrafficLightDetect;//Open the traffic light state detection, 1-yes, 0- no
    BYTE   byRes[28];
}NET_DVR_STATUS_DETECTCFG, *LPNET_DVR_STATUS_DETECTCFG;

typedef enum _ITC_STATUS_DETECT_TYPE_
{
    ITC_STATUS_DETECT_NULL = 0,        //Unknown
    ITC_STATUS_DETECT_TRIGGERIO,    //Triggered IO port
    ITC_STATUS_DETECT_FLASHOUT,     //Synchronous output
    ITC_STATUS_DETECT_RS485, //RS485
    ITC_STATUS_DETECT_TRIGGERTYPE, //Triggering type(reserved)
    ITC_STATUS_DETECT_TRAFFICLIGHT_COLOR,  //The traffic light (color difference)
    ITC_STATUS_DETECT_TRAFFICLIGHT_TURN  //The traffic lights (distinguish steering)
}ITC_STATUS_DETECT_TYPE;

typedef struct tagNET_ITC_TRIGGERIO_INFO
{
    BYTE byTriggerIOIndex[MAX_IOIN_NUM]; //Triggered IO port
    BYTE byRes[40];
}NET_ITC_TRIGGERIO_INFO, *LPNET_ITC_TRIGGERIO_INFO;

typedef struct tagNET_ITC_FLASHOUT_INFO
{
    BYTE byFlashOutIndex[MAX_IOOUT_K_NUM]; //Synchronous output number
    BYTE byRes[40];
}NET_ITC_FLASHOUT_INFO, *LPNET_ITC_FLASHOUT_INFO;

typedef struct tagNET_ITC_SERIAL_CHECKINFO
{
    BYTE bySerialIndex[MAX_ITC_SERIALCHECK_NUM]; //RS485 verification result: 0- invalid, 1- valid,
    //bySerialIndex[0] means the correct head, bySerialIndex[1] means the correct rear
    BYTE byRes[40];
}NET_ITC_SERIAL_CHECKINFO, *LPNET_ITC_SERIAL_CHECKINFO;

typedef struct tagNET_ITC_TRIGGERTYPE_INFO
{
    BYTE byTrigTypeIndex; //Triggering type value
    BYTE byRes[47];
}NET_ITC_TRIGGERTYPE_INFO, *LPNET_ITC_TRIGGERTYPE_INFO;

typedef struct tagNET_ITC_TRAFFIC_LIGHT_COLOR
{
    BYTE  byLeftLight;//Turn left at the lights, 0 invalid, 1 to 2 red to green 3 yellow 4 lamp does not light
    BYTE  byRightLight; //Turn right at the lights, 0 invalid, 1 to 2 red to green 3 yellow 4 lamp does not light
    BYTE  byStraightLight; //straight lights, 0 invalid, 1 to 2 red to green 3 yellow 4 lamp does not light
    BYTE  byRes[45];
}NET_ITC_TRAFFIC_LIGHT_COLOR, *LPNET_ITC_TRAFFIC_LIGHT_COLOR;

typedef struct tagNET_ITC_TRAFFIC_LIGHT_TURN
{
    BYTE byLightType[MAX_ITC_LANE_NUM];// 0 invalid, 1 to 2 red to green 3 yellow 4 lamp does not light
    BYTE byRes[42];
} NET_ITC_TRAFFIC_LIGHT_TURN, *LPNET_ITC_TRAFFIC_LIGHT_TURN;

typedef union tagNET_ITC_STATUS_UNION
{
    BYTE   uLen[48];            //Parameter
    NET_ITC_TRIGGERIO_INFO struTrigIO; //Triggered IO port
    NET_ITC_FLASHOUT_INFO struFlashOut; //Synchronous output
    NET_ITC_SERIAL_CHECKINFO struSerial;  //Serial port
    NET_ITC_TRIGGERTYPE_INFO struTrigType; //Triggering type (reserved)
    NET_ITC_TRAFFIC_LIGHT_COLOR struTrafficLightColor; //The traffic light (color difference) corresponding types ITC_STATUS_DETECT_TRAFFICLIGHT_COLOR
    NET_ITC_TRAFFIC_LIGHT_TURN struTrafficLightTurn;//The traffic lights (distinguish steering) corresponding types ITC_STATUS_DETECT_TRAFFICLIGHT_TURN
}NET_ITC_STATUS_UNION, *LPNET_ITC_STATUS_UNION;

typedef struct tagNET_ITC_STATUS_DETECT_RESULT
{
    ITC_STATUS_DETECT_TYPE dwStatusType;//Status detection type, see to ITC_STATUS_DETECT_TYPE
    NET_ITC_STATUS_UNION uStatusParam; //Status detection result
    DWORD dwHoldTime; //Light holding time(reserved), unit: ms
    BYTE byRes[32];
}NET_ITC_STATUS_DETECT_RESULT, *LPNET_ITC_STATUS_DETECT_RESULT;

typedef struct tagNET_DVR_SETUPALARM_PARAM
{
    DWORD dwSize;
    BYTE  byLevel; //Arming priority: 0-high, 1-middle, 2-low
    BYTE  byAlarmInfoType;
    BYTE  byRetAlarmTypeV40; //0- Ret NET_DVR_ALARMINFO_V30 or Older, 1- if Device Support NET_DVR_ALARMINFO_V40,  Ret NET_DVR_ALARMINFO_V40, else Ret NET_DVR_ALARMINFO_V30 Or NET_DVR_ALARMINFO
    BYTE  byRetDevInfoVersion; //CVR alarm 0-COMM_ALARM_DEVICE\A3\AC 1-COMM_ALARM_DEVICE_V40
    BYTE  byRetVQDAlarmType; //Exptected VQD alarm type,0-upload NET_DVR_VQD_DIAGNOSE_INFO\A3\AC1-upload NET_DVR_VQD_ALARM
    //1-(INTER_FACE_DETECTION),0-(INTER_FACESNAP_RESULT)
    BYTE  byFaceAlarmDetection;
    //Bit0 - indicates whether the secondary protection to upload pictures: 0 - upload, 1 - do not upload
    //Bit1 - said open data upload confirmation mechanism; 0 - don't open, 1 - to open
    BYTE  bySupport;
    //broken Net Http
    //bit0-Vehicle Detection\A3\A8IPC\A3\A9 \A3\A80 - not continuingly, 1 - continuingly\A3\A9
    //bit1-PDC\A3\A8IPC\A3\A9  \A3\A80 - not continuingly, 1 - continuingly\A3\A9
    //bit2-HeatMap\A3\A8IPC\A3\A9  \A3\A80 - not continuingly, 1 - continuingly\A3\A9
    BYTE  byBrokenNetHttp;
    WORD  wTaskNo;//Tasking number and the (field dwTaskNo corresponding data upload NET_DVR_VEHICLE_RECOG_RESULT the same time issued a task structure NET_DVR_VEHICLE_RECOG_COND corresponding fields in dwTaskNo
    BYTE  byRes1[5];
    BYTE  byCustomCtrl;//Bit0- Support the copilot face picture upload: 0-Upload\A3\AC1-Do not upload
}NET_DVR_SETUPALARM_PARAM, *LPNET_DVR_SETUPALARM_PARAM;

typedef struct tagNET_ITC_VIDEO_TRIGGER_COND
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwTriggerMode; //video ep mode,see ITC_TRIGGERMODE_TYPE
    BYTE byRes[16];
}NET_ITC_VIDEO_TRIGGER_COND, *LPNET_ITC_VIDEO_TRIGGER_COND;

typedef struct tagNET_ITC_FTP_TYPE_COND
{
    DWORD dwChannel;
    BYTE    byWorkMode;  // 0-FTP1(main FTP)\A3\AC1-FTP2(sub FTP)
    BYTE    byRes[7];
}NET_ITC_FTP_TYPE_COND, *LPNET_ITC_FTP_TYPE_COND;


typedef struct tagNET_ITC_FTP_CFG
{
    DWORD            dwSize;
    BYTE			    byEnable;/*Do you want to start the FTP upload function, 0- no, 1- yes*/
    BYTE 				byAddressType;   //0- IPv4 IPv6 address 1- domain name
    // Control of unionServer is to use the actual address or domain name
    WORD				wFTPPort;
    union
    {
        struct
        {
            BYTE			szDomain[MAX_DOMAIN_NAME];
            BYTE			byRes1[80];
        }struDomain;
        struct
        {
            NET_DVR_IPADDR 	struIp;
        } struAddrIP;
    }unionServer;
    BYTE				szUserName[NAME_LEN];
    BYTE				szPassWORD[PASSWD_LEN];
    BYTE	            byRes4;  // 0-FTP1(main FTP)\A3\AC1-FTP2(sub FTP)
    BYTE				byDirLevel;	/*0 = do not use a directory structure, directly stored in the root directory,
									1 = 1 level directory, 2= uses 2 directory,
                                    3 = 3 level directory, 4= uses 4 directory*/
    BYTE 				byIsFilterCarPic;/*plate small map is uploaded, 0- upload, 1- do not upload*/
    BYTE   			    byUploadDataType;//All of the 0-, 1- mount, 2- violation (single FTP default select all, support the bayonet, double FTP violation choice)
    NET_DVR_PICTURE_NAME 	struPicNameRule;/* Picture naming rules */
    BYTE				byTopDirMode; /*Top Dir, 0x1 = use device name, 0x2 = use of equipment, equipment used,
									  0x3 = IP address, 0x4= monitoring, 0x5= uses time (month and year), the operation time of 0x6= (Nian Yueri),
									  0x7= type of violation, 0x8= direction, 0x9= sites, 0xa= channel, 0xb= channel, 0xc= lane, 0xff= custom*/
    BYTE				bySubDirMode; /*Sub Dir, 0x1 = use device name, 0x2 = use of equipment, equipment used,
									  0x3 = IP address, 0x4= monitoring, 0x5= uses time (month and year), the operation time of 0x6= (Nian Yueri),
									  0x7= type of violation, 0x8= direction, 0x9= sites, 0xa= channel, 0xb= channel, 0xc= lane, 0xff= custom*/
    BYTE				byThreeDirMode; /*Three Dir, 0x1 = use device name, 0x2 = use of equipment, equipment used,
									  0x3 = IP address, 0x4= monitoring, 0x5= uses time (month and year), the operation time of 0x6= (Nian Yueri),
									  0x7= type of violation, 0x8= direction, 0x9= sites, 0xa= channel, 0xb= channel, 0xc= lane, 0xff= custom*/
    BYTE				byFourDirMode; /*Four Dir, 0x1 = use device name, 0x2 = use of equipment, equipment used,
									  0x3 = IP address, 0x4= monitoring, 0x5= uses time (month and year), the operation time of 0x6= (Nian Yueri),
									  0x7= type of violation, 0x8= direction, 0x9= sites, 0xa= channel, 0xb= channel, 0xc= lane, 0xff= custom*/
    //Picture naming custom, When "PICNAME_ITEM_CUSTOM" Take effect
    BYTE                szPicNameCustom[MAX_CUSTOMDIR_LEN];// (3.7Ver Take effect)
    BYTE			    szTopCustomDir[MAX_CUSTOMDIR_LEN];
    BYTE				szSubCustomDir[MAX_CUSTOMDIR_LEN];
    BYTE				szThreeCustomDir[MAX_CUSTOMDIR_LEN];
    BYTE				szFourCustomDir[MAX_CUSTOMDIR_LEN];
    BYTE 				byRes3[900];
}NET_ITC_FTP_CFG, *LPNET_ITC_FTP_CFG;

typedef struct tagNET_DVR_LATITUDE_PARAM
{
    BYTE byDegree;//Degree[0,179]
    BYTE byMinute;//Minute[0,59]
    BYTE bySec;//Sec[0,59]
    BYTE byRes;
}NET_DVR_LATITUDE_PARAM, *LPNET_DVR_LATITUDE_PARAM;

typedef struct tagNET_DVR_LONGITUDE_PARAM
{
    BYTE byDegree;//Degree[0,179]
    BYTE byMinute;//Minute[0,59]
    BYTE bySec;//Sec[0,59]
    BYTE byRes;
}NET_DVR_LONGITUDE_PARAM, *LPNET_DVR_LONGITUDE_PARAM;

typedef struct tagNET_DVR_GPS_DATACFG
{
    DWORD     dwSize;
    BYTE byGpsDataMode;//GPS Get Date Mode: 0-auto\A3\AC1-manual
    BYTE byLongitudeType;//longitude  0-east\A3\AC1-west
    BYTE byLatitudeType;//latitude  0-South\A3\AC1-North
    BYTE byRes;
    NET_DVR_LATITUDE_PARAM    struLatitude;     /*longitude*/
    NET_DVR_LONGITUDE_PARAM    struLongitude; /*latitude*/
    BYTE byRes1[128];
}NET_DVR_GPS_DATACFG,*LPNET_DVR_GPS_DATACFG;

/********************************Intelligent HD IPC V3.1 end*********************************/

typedef    struct tagNET_DVR_LEDDISPLAYINFO
{
    DWORD            dwSize;
    BYTE              byAddressType;
    BYTE             byRes1[3];
    union
    {
        struct
        {
            BYTE            szDomain[MAX_DOMAIN_NAME/*64*/];
            BYTE            byRes1[80];
        }struDomain;
        struct
        {
            NET_DVR_IPADDR     struIp;
        } struAddrIP;
    }unionServer;
    char        szDisplayInfo[MAX_LEDDISPLAYINFO_LEN/*1024*/];
    BYTE        byRes[128];
}NET_DVR_LEDDISPLAYINFO,*LPNET_DVR_LEDDISPLAYINFO;


/********************************Face search*********************************/
typedef enum _VCA_DATABASE_TYPE_
{
    DATABASE_NULL = 0, //unknow
    DATABASE_SNAP,    //snap database
    DATABASE_FACE    //face database
}VCA_DATABASE_TYPE;

typedef struct tagNET_VCA_DATABASE_PARAM
{
    DWORD dwSize;
    DWORD dwDataBaseID; //database ID
    DWORD dwDataBaseType; //database type,see VCA_DATABASE_TYPE
    BYTE byDataBaseName[NAME_LEN]; //database name
    BYTE byAttribute[64]; //attirbute
    BYTE byRes[20];
}NET_VCA_DATABASE_PARAM, *LPNET_VCA_DATABASE_PARAM;

typedef struct tagNET_VCA_FIND_DATABASE_COND
{
    DWORD dwDataBaseType; //database type,see VCA_DATABASE_TYPE
    BYTE byRes[12];
}NET_VCA_FIND_DATABASE_COND, *LPNET_VCA_FIND_DATABASE_COND;

typedef struct tagNET_VCA_DELETE_DATABASE_COND
{
    DWORD dwSize;
    DWORD dwDataBaseType; //Database id, see VCA_DATABASE_TYPE
    DWORD dwDataBaseID; //database ID
    BYTE byRes[64];
}NET_VCA_DELETE_DATABASE_COND, *LPNET_VCA_DELETE_DATABASE_COND;

typedef struct tagNET_VCA_INQUIRE_SNAPDB_COND
{
    DWORD dwChannel;//channel NO.
    NET_DVR_TIME struStartTime;//start time
    NET_DVR_TIME struStopTime;//stop time
    BYTE bySex; //sex:0-non,1-man,2-woman
    BYTE byRes1[3];
    BYTE byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //start birthdate, for:201106
    BYTE byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //end birthdate,for:201106
    BYTE byAttribute1[NAME_LEN]; //Attribute1
    BYTE byAttribute2[NAME_LEN]; //Attribute2
    BYTE byRes[12];
}NET_VCA_INQUIRE_SNAPDB_COND, *LPNET_VCA_INQUIRE_SNAPDB_COND;

typedef struct tagNET_VCA_INQUIRE_SNAPRECORD_RESULT
{
    DWORD dwSize;
    DWORD dwDataBaseID;  //database ID
    DWORD dwRecordID; //record ID
    NET_DVR_TIME struSnapTime;  //Snap Time
    BYTE bySex; //sex:0-non,1-man,2-woman
    BYTE byRes1[3];
    BYTE byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //start birthdate, for:201106
    BYTE byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //end birthdate,for:201106
    BYTE byAttribute1[NAME_LEN]; //Attribute1
    BYTE byAttribute2[NAME_LEN]; //Attribute2
    DWORD dwFacePicID; //face picture ID
    DWORD dwFacePicLen;  //face picture length
    BYTE byRes[80];
    BYTE *pFacePic;    //face picture data
}NET_VCA_INQUIRE_SNAPRECORD_RESULT, *LPNET_VCA_INQUIRE_SNAPRECORD_RESULT;

typedef union tagNET_VCA_DELETE_SNAPRECORD_COND_UNION
{
    NET_VCA_INQUIRE_SNAPDB_COND struAttribute;  //information(bulk delete)
    DWORD dwRecordID; //record ID(single delete)
}NET_VCA_DELETE_SNAPRECORD_COND_UNION, *LPNET_VCA_DELETE_SNAPRECORD_COND_UNION;

typedef enum _VCA_DELETE_RECORD_TYPE_
{
    DELETE_RECORD_SINGLE = 0, //single delete
    DELETE_RECORD_BATCH    //bulk delete
}VCA_DELETE_RECORD_TYPE;

typedef struct tagNET_VCA_DELETE_SNAPRECORD_COND
{
    VCA_DELETE_RECORD_TYPE dwDeleteType; //delete type
    NET_VCA_DELETE_SNAPRECORD_COND_UNION uDeleteCond;  //delete condition
    BYTE  byRes[40];
}NET_VCA_DELETE_SNAPRECORD_COND, *LPNET_VCA_DELETE_SNAPRECORD_COND;

typedef enum _VCA_SEARCH_DATABASE_TYPE_
{
    VCA_NORMAL_SEARCH_DATABASE   = 0x00000000,   //normal search
    VCA_ADVANCE_SEARCH_DATABASE  = 0x00000001    //advance search
}VCA_SEARCH_DATABASE_TYPE;

typedef struct tagNET_VCA_ADVANCE_SEARCH_DATABASE_COND
{
    DWORD dwDataBaseType; //database type,see VCA_DATABASE_TYPE
    DWORD dwDataBaseID; //database ID
    DWORD dwFacePicID; //face picture ID
    BYTE byRes[36];
}NET_VCA_ADVANCE_SEARCH_DATABASE_COND, *LPNET_VCA_ADVANCE_SEARCH_DATABASE_COND;

typedef union tagNET_VCA_SEARCH_DATABASE_COND_UNION
{
    DWORD uLen[25];
    NET_VCA_REGISTER_PIC struNormalFind; //normal search
    NET_VCA_ADVANCE_SEARCH_DATABASE_COND struAdvanceFind; //advance search
}NET_VCA_SEARCH_DATABASE_COND_UNION, *LPNET_VCA_SEARCH_DATABASE_COND_UNION;

typedef struct tagNET_VCA_SEARCH_DATABASE_PARAM
{
    DWORD dwSearchType; //search type,see VCA_SEARCH_DATABASE_TYPE
    NET_VCA_SEARCH_DATABASE_COND_UNION uSearchCond; //search parameter
    BYTE byRes[16];
}NET_VCA_SEARCH_DATABASE_PARAM, *LPNET_VCA_SEARCH_DATABASE_PARAM;

typedef struct tagNET_VCA_SEARCH_SNAPDB_COND
{
    DWORD dwChannel; //channel NO.
    DWORD dwDataBaseID; //database ID
    NET_DVR_TIME struStartTime;//start time
    NET_DVR_TIME struStopTime;//stop time
    BYTE bySex; //sex:0-non,1-man,2-woman
    BYTE byRes1[3];
    BYTE byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //start birthdate, for:201106
    BYTE byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //end birthdate, for:201106
    BYTE byAttribute1[NAME_LEN]; //Attribute1
    BYTE byAttribute2[NAME_LEN]; //Attribute2
    NET_VCA_SEARCH_DATABASE_PARAM struSearchParam;  //Search parameter
    DWORD dwMaxSearchNum; //max seatch number
    WORD wThreshold;  //threshold,0-100
    BYTE  byRes[78];
}NET_VCA_SEARCH_SNAPDB_COND, *LPNET_VCA_SEARCH_SNAPDB_COND;

typedef struct tagNET_VCA_SEARCH_SNAPRECORD_RESULT
{
    DWORD dwSize;
    DWORD dwDataBaseID;  //database ID
    DWORD dwRecordID; //record ID
    NET_DVR_TIME struSnapTime;//snap time
    BYTE bySex; //sex:0-non,1-man,2-woman
    BYTE byRes1[3];
    BYTE byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //start birthdate, for:201106
    BYTE byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //end birthdate, for:201106
    BYTE byAttribute1[NAME_LEN]; //Attribute1
    BYTE byAttribute2[NAME_LEN]; //Attribute2
    float fSimilarity; //similarity,[0.001,1]
    DWORD dwFacePicID; //face picture ID
    DWORD dwFacePicLen;  //face picture length
    BYTE byRes[80];
    BYTE *pFacePic;    //face picture data
}NET_VCA_SEARCH_SNAPRECORD_RESULT, *LPNET_VCA_SEARCH_SNAPRECORD_RESULT;

typedef struct tagNET_VCA_DATARECORD_INFO
{
    DWORD dwSize;
    DWORD dwRecordID; //record ID, update record valid
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //human attribure
    NET_VCA_REGISTER_PIC struRegisterPic;  //human picture information
    BYTE  byRemark1[NAME_LEN]; //remark1
    BYTE  byRemark2[64]; //remark2
    BYTE  byRes[32]; //
}NET_VCA_DATARECORD_INFO, *LPNET_VCA_DATARECORD_INFO;

typedef struct tagNET_VCA_FAST_DATARECORD_INFO
{
    DWORD dwSize;
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //human attribure
    BYTE  byRemark1[NAME_LEN]; //remark1
    BYTE  byRemark2[64]; //remark2
    DWORD dwImageLen;  //image length
    BYTE  byRes[80];  //
    BYTE *pImage;    //image data
}NET_VCA_FAST_DATARECORD_INFO, *LPNET_VCA_FAST_DATARECORD_INFO;

typedef struct tagNET_VCA_INQUIRE_DATARECORD_RESULT
{
    DWORD dwSize; //
    DWORD dwDataBaseID;  //database ID
    DWORD dwRecordID; //record ID
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //human attribute
    BYTE  byRemark1[NAME_LEN]; //remark1
    BYTE  byRemark2[64]; //remark2
    DWORD dwFacePicID; //face picture ID
    DWORD dwFacePicLen;  //face picture length
    BYTE byRes[80];  //
    BYTE *pFacePic;    //face picture data
}NET_VCA_INQUIRE_DATARECORD_RESULT, *LPNET_VCA_INQUIRE_DATARECORD_RESULT;

typedef struct tagNET_VCA_SEARCH_DATARECORD_RESULT
{
    DWORD dwSize;
    DWORD dwDataBaseID;  //database ID
    DWORD dwRecordID; //record ID
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //human attribute
    BYTE  byRemark1[NAME_LEN]; //remark1
    BYTE  byRemark2[64]; //remark2
    float fSimilarity; //similarity,[0.001,1]
    DWORD dwFacePicID; //face picture ID
    DWORD dwFacePicLen;  //face picture length
    BYTE byRes[80];  //
    BYTE *pFacePic;    //face picture data
}NET_VCA_SEARCH_DATARECORD_RESULT, *LPNET_VCA_SEARCH_DATARECORD_RESULT;

typedef struct tagNET_VCA_DATARECORD_COND
{
    DWORD dwDataBaseID; //database ID
    NET_VCA_HUMANATTRIBUTE_COND struAttribute;  //human attribute
    BYTE byRes[80];  //
}NET_VCA_DATARECORD_COND, *LPNET_VCA_DATARECORD_COND;

typedef union tagNET_VCA_DELETE_RECORD_COND_UNION
{
    NET_VCA_HUMANATTRIBUTE_COND struAttribute;  //human attribute(batch delete)
    DWORD dwRecordID; //record ID(single delete)
}NET_VCA_DELETE_RECORD_COND_UNION, *LPNET_VCA_DELETE_RECORD_COND_UNION;

typedef struct tagNET_VCA_DELETE_RECORD_COND
{
    VCA_DELETE_RECORD_TYPE dwDeleteType; //delete type
    NET_VCA_DELETE_RECORD_COND_UNION uDeleteCond;  //delete parameter
    BYTE  byRes[40]; //
}NET_VCA_DELETE_RECORD_COND, *LPNET_VCA_DELETE_RECORD_COND;

typedef struct tagNET_VCA_SEARCH_FACEDB_COND
{
    DWORD dwDataBaseID; //Database ID
    NET_VCA_HUMANATTRIBUTE_COND struAttribute;  //Human attribute
    NET_VCA_SEARCH_DATABASE_PARAM struSearchParam;  //Search parameter
    DWORD dwMaxSearchNum; //Max search number
    WORD wThreshold;  //threshold, 0-100
    BYTE  byRes[78]; //
}NET_VCA_SEARCH_FACEDB_COND, *LPNET_VCA_SEARCH_FACEDB_COND;

typedef struct tagNET_VCA_FIND_MATCHPIC_COND
{
    DWORD dwSize;
    DWORD dwDataBaseType; //database ID, see VCA_DATABASE_TYPE
    DWORD dwDataBaseID; //database ID
    DWORD dwRecordID; //record ID
    BYTE byRes[64]; //
}NET_VCA_FIND_MATCHPIC_COND, *LPNET_VCA_FIND_MATCHPIC_COND;

typedef struct tagNET_VCA_FIND_MATCHPIC_RESULT
{
    DWORD dwSize;
    DWORD dwDataBaseType; //database ID, see VCA_DATABASE_TYPE
    DWORD dwDataBaseID; //databaseID
    DWORD dwRecordID; //record ID
    DWORD dwPicLen; //picture length
    BYTE byRes[64]; //
    BYTE *pPicBuffer; //picture data
}NET_VCA_FIND_MATCHPIC_RESULT, *LPNET_VCA_FIND_MATCHPIC_RESULT;

/********************************VCA face end*********************************/

/********************************IPC*************************/
typedef struct tagNET_DVR_REMOTECONTROL_ALARM_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //channel
    WORD wDealyTime; //delay time,unit:s
    BYTE  byRes[30];
}NET_DVR_REMOTECONTROL_ALARM_PARAM, *LPNET_DVR_REMOTECONTROL_ALARM_PARAM;

typedef struct tagNET_DVR_REMOTECONTROL_STUDY_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //channel
    BYTE  byRes[16];
}NET_DVR_REMOTECONTROL_STUDY_PARAM, *LPNET_DVR_REMOTECONTROL_STUDY_PARAM;

typedef struct tagNET_DVR_WIRELESS_ALARM_STUDY_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //channel
    BYTE  byIndex;  //wireless alarm ID,1-8
    BYTE  byRes[15];
}NET_DVR_WIRELESS_ALARM_STUDY_PARAM, *LPNET_DVR_WIRELESS_ALARM_STUDY_PARAM;

#define MAX_AUX_ALARM_NUM 8 //max aux alarm number
#define MAX_WIRELESS_ALARM_NUM 8 //max wireless alarm number
typedef enum _IPC_AUX_ALARM_TYPE_
{
    IPC_AUXALARM_UNKNOW   = 0, //Unknow
    IPC_AUXALARM_PIR      = 1, //PIR alarm
    IPC_AUXALARM_WIRELESS = 2,   //Wireless alarm
    IPC_AUXALARM_CALLHELP = 3  //Call help alarm
}IPC_AUX_ALARM_TYPE;

typedef struct tagNET_DVR_AUDIO_LIMIT_ALARM_CFG
{
    DWORD    dwSize;
    BYTE    byEnable;
    BYTE    byRes1[3];
    DWORD    dwDecibelLimit; //Decibel Limit
    NET_DVR_HANDLEEXCEPTION_V30    struHandleException;  //Exception handle
    BYTE    byRes2[24];
}NET_IPC_AUDIO_LIMIT_ALARM_CFG,*LPNET_IPC_AUDIO_LIMIT_ALARM_CFG;

typedef struct tagNET_DVR_BUTTON_DOWN_ALARM_CFG
{
    DWORD    dwSize;
    BYTE    byEnable;
    BYTE    byRes1[3];
    NET_DVR_HANDLEEXCEPTION_V30    struHandleException;  //Exception handle
    BYTE    byRes2[24];
}NET_IPC_BUTTON_DOWN_ALARM_CFG,*LPNET_IPC_BUTTON_DOWN_ALARM_CFG;

typedef struct tagNET_IPC_PIR_ALARMCFG
{
    BYTE byAlarmName[NAME_LEN];    /* Alarm name */
    BYTE byAlarmHandle;            /* Handle alarm, 0-disanble,1-enable*/
    BYTE byRes1[3];
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;    /* alarm handle type */
    BYTE byRelRecordChan[MAX_CHANNUM_V30]; //record channel, 1-enable
    BYTE byRes[64];
}NET_IPC_PIR_ALARMCFG, *LPNET_IPC_PIR_ALARMCFG;

typedef struct tagNET_IPC_PIR_ALARMCFG_EX
{
    BYTE byAlarmName[NAME_LEN];    /* Alarm name */
    BYTE byAlarmHandle;            /* Handle alarm, 0-disanble,1-enable*/
    BYTE byRes1[3];
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;    /* alarm handle type */
    BYTE byRelRecordChan[MAX_CHANNUM_V30]; //record channel, 1-enable
    NET_DVR_SCHEDTIME   struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];
    BYTE byRes[1464];
}NET_IPC_PIR_ALARMCFG_EX, *LPNET_IPC_PIR_ALARMCFG_EX;

typedef struct tagNET_IPC_CALLHELP_ALARMCFG
{
    BYTE byAlarmHandle;            /* Handle alarm, 0-disanble,1-enable*/
    BYTE byRes1[3];
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;    /* alarm handle type */
    BYTE byRelRecordChan[MAX_CHANNUM_V30]; //record channel, 1-enable
    BYTE byRes[64];
}NET_IPC_CALLHELP_ALARMCFG, *LPNET_IPC_CALLHELP_ALARMCFG;

typedef struct tagNET_IPC_SINGLE_WIRELESS_ALARMCFG
{
    BYTE byAlarmName[NAME_LEN];    /* Alarm name */
    BYTE byAlarmHandle;            /* Handle alarm, 0-disanble,1-enable*/
    BYTE byID; //Wireless alarm ID,1-8
    BYTE byRes1[2];
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;    /* alarm handle type */
    BYTE byRelRecordChan[MAX_CHANNUM_V30]; //record channel, 1-enable
    BYTE byRes[32];
}NET_IPC_SINGLE_WIRELESS_ALARMCFG, *LPNET_IPC_SINGLE_WIRELESS_ALARMCFG;

typedef struct tagNET_IPC_WIRELESS_ALARMCFG
{
    NET_IPC_SINGLE_WIRELESS_ALARMCFG struWirelessAlarm[MAX_WIRELESS_ALARM_NUM]; //Single Wireless alarm
    BYTE byRes[32];
}NET_IPC_WIRELESS_ALARMCFG, *LPNET_IPC_WIRELESS_ALARMCFG;

typedef union tagNET_IPC_AUX_ALARMCFG_UNION
{
    DWORD uLen[472];
    NET_IPC_PIR_ALARMCFG_EX struPIRAlarm; //PIR alarm
    NET_IPC_WIRELESS_ALARMCFG struWirelessAlarm; //Wireless alarm
    NET_IPC_CALLHELP_ALARMCFG struCallHelpAlarm; //call help alarm
}NET_IPC_AUX_ALARMCFG_UNION, *LPNET_IPC_AUX_ALARMCFG_UNION;

typedef struct tagNET_IPC_SINGLE_AUX_ALARMCFG
{
    BYTE byAlarmType;       //alarm type,see IPC_AUX_ALARM_TYPE
    BYTE byRes1[3];
    NET_IPC_AUX_ALARMCFG_UNION uAlarm; //alarm parameter
    BYTE byRes[16];
}NET_IPC_SINGLE_AUX_ALARMCFG, *LPNET_IPC_SINGLE_AUX_ALARMCFG;

typedef struct tagNET_IPC_AUX_ALARMCFG
{
    DWORD dwSize;
    NET_IPC_SINGLE_AUX_ALARMCFG struAlarm[MAX_AUX_ALARM_NUM]; //alarm
    BYTE byRes[64];
}NET_IPC_AUX_ALARMCFG, *LPNET_IPC_AUX_ALARMCFG;

typedef union tagNET_IPC_AUXALARM_UPLOAD_UNION
{
    DWORD uLen[66];
    NET_IPC_PIR_ALARMCFG struPIRAlarm; //PIR alarm
    NET_IPC_SINGLE_WIRELESS_ALARMCFG struWirelessAlarm; //wireless alarm
    NET_IPC_CALLHELP_ALARMCFG struCallHelpAlarm; //call help alarm
}NET_IPC_AUXALARM_UPLOAD_UNION, *LPNET_IPC_AUXALARM_UPLOAD_UNION;

typedef struct tagNET_IPC_AUXALARM_RESULT
{
    DWORD dwSize;
    DWORD dwChannel; //channel
    BYTE byAlarmType;       //alarm type,see IPC_AUX_ALARM_TYPE
    BYTE byRes1[3];
    NET_IPC_AUXALARM_UPLOAD_UNION struAuxAlarm; //alarm information
    BYTE byDeviceID[NAME_LEN];
    BYTE byRes[32];
}NET_IPC_AUXALARM_RESULT, *LPNET_IPC_AUXALARM_RESULT;

typedef struct tagNET_DVR_PREVIEW_DISPLAYCFG
{
    DWORD  dwSize;
    BYTE   byCorrectMode;     //Correction mode, 0 - software calibration, 1 - chip calibration
    BYTE   byMountType;       //Type of installation - Ceiling, 1 - Desktop 2 - wall
    /*
        0- mode 1: fisheye + panoramic +3PTZ (non real time mode with the original agreement);
        1- mode: +4PTZ (2 eye with the original real-time consistent mode);
        2- mode 3: fisheye (main) + fisheye (sub) +3PTZ;
        3- mode 4: Pan (Ma Liu and Ma Liu);
        4- mode 5\A3\BA4PTZ\A3\BB
        5- mode6\A3\BAfisheye\A3\BB
    */
    BYTE   byRealTimeOutput;  //Realtime output\A3\AC0 -disable\A3\AC1-enable
    BYTE   byRes[61];         //Reserved
}NET_DVR_PREVIEW_DISPLAYCFG, *LPNET_DVR_PREVIEW_DISPLAYCFG;

typedef struct tagNET_DVR_REMOTECONTROL_PTZ_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //Channel number
    DWORD dwPTZCommand; //PTZ control commands
    NET_VCA_POINT struVcaPoint; //Preview interface point coordinates
    DWORD dwSpeed; //Control the speed, range [0,7]
    DWORD dwStop; //Action to stop or start action: 0 - start; 1 - stop
    BYTE  byRes[32];
}NET_DVR_REMOTECONTROL_PTZ_PARAM, *LPNET_DVR_REMOTECONTROL_PTZ_PARAM;

typedef struct tagNET_DVR_PRESET_POINT_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //Channel number
    DWORD dwPTZPresetCmd; //Preset control commands
    NET_VCA_POINT struVcaPoint; //Preview interface point coordinates
    DWORD dwPresetIndex; //Preset number (1), supports up to 255 preset points
    WORD  wZoomCoordinate;
    BYTE  byRes[30];
}NET_DVR_PRESET_POINT_PARAM, *LPNET_DVR_PRESET_POINT_PARAM;

typedef struct tagNET_DVR_PTZ_CRUISE_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //Channel number
    DWORD dwPTZCruiseCmd; //Cruise control command
    NET_VCA_POINT struVcaPoint; //Preview interface point coordinates
    WORD wCruiseRoute; //Cruise path, supports up to 32 paths (serial number starting with 1)
    WORD wCruisePoint; //Cruise point supports up to 32 points (numbered from 1)
    WORD wInput; //Different cruise command value preset points (maximum 255), time (maximum 255), speed (maximum 40)
    WORD wZoomCoordinate;
    BYTE  byRes[32];
}NET_DVR_PTZ_CRUISE_PARAM, *LPNET_DVR_PTZ_CRUISE_PARAM;

typedef struct tagNET_DVR_WPS_PARAM
{
    DWORD dwSize;
    BYTE byEnableWps; //enable WPS,0-no,1-yes
    BYTE byRes[31];
}NET_DVR_WPS_PARAM, *LPNET_DVR_WPS_PARAM;

typedef struct tagNET_DVR_PIN_PARAM
{
    DWORD dwSize;
    BYTE byPIN[8]; //PIN
    BYTE byRes[32];
}NET_DVR_PIN_PARAM, *LPNET_DVR_PIN_PARAM;

typedef struct tagNET_DVR_WPS_CONNECT_PARAM_
{
    DWORD dwSize;
    BYTE byConnectType; //WPS connect type,0-PBC,1-AP PIN
    BYTE byRes1[3];
    BYTE byPIN[8]; //PIN(WPS connect type,AP PIN)
    BYTE byEssid[IW_ESSID_MAX_SIZE]; //essid(WPS connect type,AP PIN)
    BYTE byRes[32];
}NET_DVR_WPS_CONNECT_PARAM, *LPNET_DVR_WPS_CONNECT_PARAM;


#define UPLOAD_CERTIFICATE  1 //upload certificate

/********************************IPC end*************************/

/**********************pic preview of push mode***************************/
typedef struct tagNET_DVR_PIC_VIEW_PARAM
{
    DWORD    dwSize;
    NET_DVR_IPADDR    struCuIp;    // ip of CU
    WORD    wPort;                // port of CU
    BYTE    bySourceIndex;        // channel index of signal
    BYTE    byRes[29];
}NET_DVR_PIC_VIEW_PARAM, *LPNET_DVR_PIC_VIEW_PARAM;

#define DVCS_DEVICEID_LEN   16
//2012-03-13  picture preview message callback
typedef struct tagNET_DVR_PICVIEW_CALLBACKPARAM
{
    DWORD    dwUserID;
    BYTE   sDeviceID[DVCS_DEVICEID_LEN];
    LONG    nPicViewHandle; //picture view handle
    WORD    wSignalIndex;    //signal index
    WORD    wHeadLen;        //head len, the len of private stream is 40
    BYTE    byHeadBuf[100]; //stream head buffer
    BYTE    byRes2[32];
}NET_DVR_PICVIEW_CALLBACKPARAM, *LPNET_DVR_PICVIEW_CALLBACKPARAM;

/**********************get sub device list***************************/

typedef struct tagNET_DEVICEID_INFO
{
    DWORD        dwSize;
    DWORD        dwDeviceIndex;                    //device index
    BYTE        byWallNo;                        //wall no.\A3\ACstart from 1
    BYTE        byRes1[27];
    DWORD        dwChan;                            //channel index
    DWORD        dwInputSignalIndex;                //signal index\A3\ACused in DVCS
    BYTE        byRes[60];
}NET_DVR_DEVICEID_INFO, *LPNET_DVR_DEVICEID_INFO;

typedef struct tagNET_DVR_SINGLE_NETPARAM
{
    DWORD  dwSize;
    BYTE   byUseDhcp;                 //DHCP 0xff-INVALID 0-not used 1-used
    BYTE   byRes1[3];
    NET_DVR_IPADDR  struDevIP;       // ip address
    NET_DVR_IPADDR  struSubnetMask;  // mask
    NET_DVR_IPADDR  struGateway;     // gate way
    WORD    wDevPort;                 // port
    BYTE    byMACAddr[MACADDR_LEN];  // MAC address(get only)
    BYTE    byRes2[16];
} NET_DVR_SINGLE_NETPARAM, *LPNET_DVR_SINGLE_NETPARAM;

typedef struct tagNET_DVR_CHAN_INFO
{
    DWORD    dwSize;
    BYTE    byValid;                //0-invalid 1-valid
    BYTE    byRes1[3];
    BYTE    sChanName[NAME_LEN];    //channel name
    NET_DVR_COLOR struVideoColor;  //video color
    WORD    wResolutionX;        //current resolution---width
    WORD    wResolutionY;        //current resolution---high
    BYTE   byRes2[40];    ;
} NET_DVR_CHAN_INFO, *LPNET_DVR_CHAN_INFO;

//coder information
typedef struct tagNET_DVR_CODEDEV_INFO
{
    NET_DVR_CHAN_INFO struChanInfo[MAX_CHANNUM/*16*/];//channel information
} NET_DVR_CODEDEV_INFO, *LPNET_DVR_CODEDEV_INFO;

//decoder information
typedef struct tagNET_DVR_DECODEDEV_INFO
{
    BYTE    byRes[1408];
} NET_DVR_DECODEDEV_INFO, *LPNET_DVR_DECODEDEV_INFO;

//net signal information
typedef struct tagNET_DVR_NETSIGNAL_INFO
{
    DWORD    dwSize;
    BYTE    byDevName[NAME_LEN/*32*/];        // net signal name
    NET_DVR_PU_STREAM_CFG struPuStream;
    BYTE    byValid;                        // 0-invalid\A3\ACset 0 when delete signal, 1-valid\A3\ACset 1 when add or mod signal/
    BYTE     byRes1[3];                        // res
    BYTE    sGroupName[NAME_LEN/*32*/];        // group name of net signal
    WORD    wResolutionX;        //current resolution---width
    WORD    wResolutionY;        //current resolution---high
    BYTE    byRes2[24];
}NET_DVR_NETSIGNAL_INFO, *LPNET_DVR_NETSIGNAL_INFO;

typedef struct tagNET_DVR_NETSIGNALDEV_INFO
{
    NET_DVR_NETSIGNAL_INFO struDevInfo;
    BYTE    byRes1[816];
}NET_DVR_NETSIGNALDEV_INFO, *LPNET_DVR_NETSIGNALDEV_INFO;

typedef union tagNET_DVR_DIFFDEV_INFO
{
    NET_DVR_CODEDEV_INFO struCodeDevInfo;            //coder information
    NET_DVR_DECODEDEV_INFO struDecodeDevInfo;        //decoder information
    NET_DVR_NETSIGNALDEV_INFO struNetSignalInfo;    //net signal information
} NET_DVR_DIFFDEV_INFO, *LPNET_DVR_DIFFDEV_INFO;

typedef enum tagNET_DVCS_DEVICE_TYPE
{
    NET_DVR_BNC_PROC = 1,                   // BNC processor
    NET_DVR_RGB_PROC,                       // RGB processor
    NET_DVR_STP_PROC,                       // stream processor
    NET_DVR_DISP_PROC,                      // display processor
    NET_DVR_NETSIGNAL,                        // net signal
    NET_DVR_SDI_PROC,                       // SDI processor
    NET_DVR_BIW_PROC,                       // 8 channels BNC processor
    NET_DVR_DON_PROC,                       // display processor
    NET_DVR_TVI_PROC,                       // TVI processor
    NET_DVR_DI2_PROC                        // 2 channels DVI processor
}NET_DVCS_DEVICE_TYPE;

typedef struct  tagNET_DVR_SINGLE_DEV_INFO
{
    DWORD    dwSize;
    DWORD    dwSoftVersion;            // soft version, the highest 8 bits is main version, other 8bits is sub version. the last 16 bits is repair version
    DWORD    dwSoftwareBuildDate;     // version Build data, 0xYYYYMMDD
    BYTE    byUseInSys;                // 0-not used in system 1-used in the system
    BYTE    byDevStatus;            // device status\A3\AC0-offline\A3\AC1-online
    BYTE    byDeviceType;            // device type  describe in struct DEVICE_TYPE
    BYTE    byRes1[17];
    BYTE    sDevName[NAME_LEN];                            //device name
    NET_DVR_SINGLE_NETPARAM struEtherNet[MAX_ETHERNET]; //net param of device
    BYTE    sSerialNumber[SERIALNO_LEN];                //device serial
    NET_DVR_DIFFDEV_INFO  struSubDevInfo;                //device information
    DWORD    dwDeviceIndex;//devide index
    BYTE    byRes2[48];
} NET_DVR_SINGLE_DEV_INFO, *LPNET_DVR_SINGLE_DEV_INFO;

typedef struct tagNET_DVR_DEVLIST
{
    DWORD        dwSize;
    DWORD        dwDevNums;//sub device numbers
    BYTE          *pBuffer;
    BYTE        byRes1[3];
    DWORD         dwBufLen;//buffer len
    BYTE        byRes2[64];
} NET_DVR_DEVLIST,*LPNET_DVR_DEVLIST;

/********************************base information of sub device****************************/
typedef struct tagNET_DVR_DEV_BASE_INFO
{
    DWORD  dwSize;
    BYTE   byEnable;            // 0-not used in system 1-used in the system
    BYTE   byDeviceType;        // device type
    BYTE   byRes1[2];
    BYTE   sDevName[NAME_LEN];    // device name
    BYTE   byRes2[24];
} NET_DVR_DEV_BASE_INFO,*LPNET_DVR_DEV_BASE_INFO;

/********************************net information of sub device****************************/
typedef  struct tagNET_DVR_NETPARAM
{
    DWORD dwSize;
    NET_DVR_SINGLE_NETPARAM struEtherNet[MAX_ETHERNET];
    BYTE   byRes[64];
} NET_DVR_NETPARAM, *LPNET_DVR_NETPARAM;

/********************************config display unit****************************/
// Binding screen and device(16 bytes)
typedef struct tagNET_DVR_DISP_SCREEN
{
    DWORD    dwSize;
    WORD    wScreenID;    // screen ID, start from 1
    BYTE    byWallNo;    // wall no.
    BYTE    byRes1;
    DWORD    dwDeviceIndex;// id of output device
    BYTE    byRes2[16];
}NET_DVR_DISP_SCREEN, *LPNET_DVR_DISP_SCREEN;

// screen control
typedef struct tagNET_DVR_TEXTSHOW
{
    DWORD dwSize;
    BYTE  byShowText;//1-display text\A3\AC0-do not display text
    BYTE  byRes[35];
}NET_DVR_TEXTSHOW, *LPNET_DVR_TEXTSHOW;

typedef struct tagNET_DVR_SCREENLIST
{
    DWORD        dwSize;
    BYTE        byWallNo;
    BYTE        byRes[11];
    DWORD        dwScreenNums;//screen numbers
    BYTE          *pBuffer;
    DWORD         dwBufLen;//buffer length
} NET_DVR_SCREENLIST,*LPNET_DVR_SCREENLIST;

typedef struct tagNET_DVR_OPERATE_DEVICE
{
    DWORD    dwSize;
    DWORD    dwSubCommand;//1-start upgrade\A3\AC2-stop upgrade
    DWORD    dwDeviceIndex;//device index
    BYTE    byRes[44];
}NET_DVR_OPERATE_DEVICE, *LPNET_DVR_OPERATE_DEVICE;

//upgrade
typedef struct tagNET_DVR_UPGRADE_STATE
{
    DWORD    dwProgress; // 0-100
    BYTE     byState;  //1-upgrade finished 2-upgrading 3-upgrade failed
    BYTE    byRes2[31];
}NET_DVR_UPGRADE_STATE, *LPNET_DVR_UPGRADE_STATE;

//data type of picture preview, the data type is bmp picture in cvcs, the picture data is ps stream in dvcs
typedef enum
{
    NET_DVR_DATA_BMP = 0,
    NET_DVR_START_CALLBACK,
    NET_DVR_STREAM_SYSHEAD,
    NET_DVR_STREAM_DATA
}PIC_PREVIEW_DATATYPE;

typedef struct tagNET_DVR_START_PIC_VIEW_INFO
{
    DWORD    dwSize;
    DWORD    dwSignalIndex;                    // signal index\A3\ACused in cvcs
    DWORD    dwDeviceIndex;//device index
    BYTE    byRes1[12];
    BYTE    byChanIndex;                    // channel index
    BYTE    byRes2[3];

    DWORD   dwScreenNum; //big screen index,start from zero
    DWORD   dwLayer;     //layer No : start from zero
    DWORD   dwResolution;//resolution, 1-QCIF,2-CIF,3-D1
    BYTE    byFrame;//frame, unit: frame/second
    BYTE    bySupportStreamView; //client support stream view, 0-not support, 1-support
    BYTE    byRes3[14];
}NET_DVR_START_PIC_VIEW_INFO, *LPNET_DVR_START_PIC_VIEW_INFO;

typedef struct tagNET_DVR_DVCS_STATE_ALARM
{
    DWORD    dwSize;
    BYTE    byAlarmType;         //alarm type 1-device online\A3\AC2-device offline 3-server online 4-server offline, 5-manager logon,6-plan begin,7-plan end 8-resolution change\A3\AC9-cut picture failed\A3\AC10-not enough resource\A3\AC11-temperature abnormal
    BYTE    byDeviceType;        //device type ,see struct NET_DVCS_DEVICE_TYPE
    BYTE    byWallNo;            // wall no\A3\ACstart from 1
    BYTE    byDeviceChanIndex;     // device channle index\A3\AC0 means invalid\A3\ACthe other data means the channel index
    DWORD    dwDeviceIndex;        // device index
    WORD    wResolutionX;        //resolution-width
    WORD    wResolutionY;        //resolution-high
    WORD    wTemperature;       // device temperature
    BYTE    byRes[86];
}NET_DVR_DVCS_STATE_ALARM, *LPNET_DVR_DVCS_STATE_ALARM;

#define    DECODEPIC_LEFTADJUST            1        /*shift left*/
#define    DECODEPIC_RIGHTADJUST            2        /*shift right*/
#define    DECODEPIC_UPADJUST                3        /*shift upper*/
#define    DECODEPIC_DOWNADJUST            4        /*shift down*/
#define    DECODEPIC_REDUCEADJUST            5        /*zoom in*/
#define    DECODEPIC_FULL_SCREEN_ADJUST    6        /*full screen*/
#define    DECODEPIC_CANCEL_FULL_SCREEN_ADJUST    7        /*cancel full screen*/
#define DECODEPIC_AUTOADJUST            8       /* auto adjust */

typedef struct tagNET_DVR_PIC_ADJUST
{
    DWORD        dwSize;
    BYTE        bySubCommand;        //see struct DECODEPIC_LEFTADJUST
    BYTE        byScale;            //scale
    BYTE        byPictureProportion;    //picture proportion 1-4:3, 2-16:9
    BYTE        byRes[29];
}NET_DVR_PIC_ADJUST, *LPNET_DVR_PIC_ADJUST;

typedef struct tagNET_DVR_PICTURE_PARAM
{
    DWORD    dwSize;
    BYTE    byControlCommand;    //control command\A3\AC1-show\A3\AC2-hide\A3\AC3-delete all\A3\A8use when GIF\A3\A9
    BYTE    byUseType;            //pictrue type\A3\AC1-OSD 2-basemap\A3\AC3-GIF
    BYTE    byWallNo;            //wall no.start from 1
    BYTE    byPictureNo;        //picture no.
    BYTE    byRes[64];
}NET_DVR_PICTURE_PARAM, *LPNET_DVR_PICTURE_PARAM;
/********************************dvcs end****************************/

// 76SP device config POE channel add mode
typedef struct tagNET_DVR_POE_ADAPTER_TYPE
{
    DWORD        dwSize;
    BYTE         byAdapterType;             //Aapter type 0: inter adpter 1: LAN1
    BYTE          byRes1[127];
}NET_DVR_POE_ADAPTER_TYPE, *LPNET_DVR_POE_ADAPTER_TYPE;

// 76SP device config POE channel add mode
typedef struct tagNET_DVR_POE_CHANNEL_ADD_MODE
{
    DWORD        dwSize;
    BYTE         byAddMode;                 //0: UPNP 1: add by manual
    BYTE          byRes1[127];
}NET_DVR_POE_CHANNEL_ADD_MODE, *LPNET_DVR_POE_CHANNEL_ADD_MODE;

#define MAX_ESATA_NUM 16
#define MAX_MINISAS_NUM 96

typedef struct tagNET_DVR_ESATA_MINISAS_USAGE
{
    DWORD        dwSize;
    BYTE        byESATAUsage[MAX_ESATA_NUM];        // 0\A3\BAbackup 1\A3\BArecord
    BYTE        byMiniSASUsage[MAX_MINISAS_NUM];    // 0\A3\BAbackup 1\A3\BArecord
    BYTE         byRes[32];
}NET_DVR_ESATA_MINISAS_USAGE, *LPNET_DVR_ESATA_MINISAS_USAGE;

#define MAX_DISK_NUM 128

typedef struct tagNET_DVR_BACKUP_LOG_PARAM
{
    DWORD        dwSize;
    BYTE        byDiskDesc[DESC_LEN_32];
    BYTE        byHardDisk[MAX_DISK_NUM];
    BYTE        byBackupHardDiskNum;
    BYTE        byContinue;
    BYTE        byAllLogBackUp ;
    BYTE         byRes[29];
}NET_DVR_BACKUP_LOG_PARAM, *LPNET_DVR_BACKUP_LOG_PARAM;

typedef struct tagNET_DVR_DIGITAL_CHANNEL_STATE
{
    DWORD    dwSize;
    BYTE    byDigitalAudioChanTalkState[MAX_CHANNUM_V30];  //Digital audio talk state 0-not use\A3\AC1-using, 0xff, not valid
    BYTE    byDigitalChanState[MAX_CHANNUM_V30];
    BYTE    byDigitalAudioChanTalkStateEx[MAX_CHANNUM_V30*3];
    BYTE    byDigitalChanStateEx[MAX_CHANNUM_V30*3];
    BYTE    byAnalogChanState[MAX_ANALOG_CHANNUM];
    BYTE    byRes[32];
}NET_DVR_DIGITAL_CHANNEL_STATE, *LPNET_DVR_DIGITAL_CHANNEL_STATE;

typedef enum
{
    NET_SDK_DC_STATUS_CONNECTED = 1,
    NET_SDK_DC_STATUS_CONNECTING,
    NET_SDK_DC_STATUS_BAND_WIDTH_EXCEED,
    NET_SDK_DC_STATUS_DOMAIN_ERROR,
    NET_SDK_DC_STATUS_CHANNEL_ERROR,
    NET_SDK_DC_STATUS_ACCOUNT_ERROR,
    NET_SDK_DC_STATUS_STREAM_TYPE_NOT_SUPPORT,
    NET_SDK_DC_STATUS_CONFLICT_WITH_DVR,
    NET_SDK_DC_STATUS_CONFLICT_WITH_IPC,
    NET_SDK_DC_STATUS_NETWORK_UNREACHBALE,
    NET_SDK_DC_STATUS_IPC_NOT_EXIST,
    NET_SDK_DC_STATUS_IPC_EXCEPTION,
    NET_SDK_DC_STATUS_OTHER_ERROR,
    NET_SDK_DC_STATUS_RESOLUTION_NOT_SUPPORT,
    NET_SDK_DC_STATUS_IPC_LAN_ERR = 15,
    NET_SDK_DC_STATUS_USER_LOCKED = 16,
    NET_SDK_DC_STATUS_NOT_ACTIVATED = 17,
    NET_SDK_DC_STATUS_USER_NOT_EXIST = 18,
    NET_SDK_DC_STATUS_IPC_UNREGISTERED = 19,
    NET_SDK_DC_STATUS_POE_PORT_DETECTING = 20
}NET_SDK_DIGITAL_CHANNEL_STATUS;


/*************************************ITS****************************/
#define VERSION_LEN                 32 //Version length
#define    MAX_OVERLAP_ITEM_NUM        50 //Max character overlap number
#define    ITS_MAX_DEVICE_NUM            32 //Max device number

//Terminal basic information
typedef struct tagNET_ITS_BASEINFO
{
    DWORD   dwSize;
    BYTE    byMainVer[VERSION_LEN];    // Terminal Basic information
    BYTE    byMprVer[VERSION_LEN];    // Multiple frame recognize data version
    BYTE    byBvtVer[VERSION_LEN];    // Backward video library version
    BYTE    byLptVer[VERSION_LEN];    // Video tracking data version
    BYTE    byTvdVer[VERSION_LEN];    // Rule-break detection data version
    BYTE    byTldVer[VERSION_LEN];    // Signal light detection data version
    BYTE    byRes[252];        // Reserved
}NET_ITS_BASEINFO,*LPNET_ITS_BASEINFO;

//Photomontage parameters
typedef struct tagNET_ITS_IMGMERGE_CFG
{
    DWORD  dwSize;
    BYTE  byIsMerge;        //Merged needed or not (0:No 1:YES)
    BYTE   byCloseupProportion;   //Figure 1- the original resolution feature size, 2- width and height as the original resolution two times, and so on (1 ~ 8)
    BYTE   byRes1[2];
    DWORD  dwOneMergeType;    //Single captured picture merged method (close-up view might be cut out )
    DWORD  dwTwoMergeType;    //Two captured picture merged method
    DWORD  dwThreeMergeType;    //Three captured picture merged method
    DWORD  dwJpegQuality;      //Compression quality(0~100)
    DWORD  dwCloseupIndex;     //The number of close-up picture
    DWORD  dwMerageMaxSize;   //Top limit size of the merged pictures (300~10240KB)
    WORD   wCloseupDeviation; //Closeup deviation(50~picture height),unit:pixel
    BYTE   byRes[30];
    /************************************************************************/
    /* 201 merge the upper and the lower pictures, the width of the merged picture is one times, the height is doubled         */
    /* 202 merge the left and the right pictures, the width of the merged picture is doubled, the height is one times.         */
    /* 301 merge the top, the middle and the bottom pictures, the width of the merged picture is one times, the height is tripled */
    /* 302 merge the left, the middle and the right pictures, the width of the merged picture is tripled, the height is one times */
    /* 303 take a license plate from the three pictures as a close-up, and merge with the other three pictures into a 2*2 layout, make the license plate on the lower right. The width of the merged picture is doubled and the height is doubled.*/
    /* 304 take a license plate from the three pictures as a close-up, and merge with the other three pictures into a 2*2 layout, make the license plate on the lower right. The width of the merged picture is one times and the height is one times.*/
    /* 305 take a license plate from the three pictures as a close-up, and merge with the other three pictures into a 2*2 layout, make the license plate on the top left. The width of the merged picture is doubled and the height is doubled.*/
    /* 306 take a license plate from the three pictures as a close-up, and merge with the other three pictures into a 2*2 layout, make the license plate on the top left. Compress the resolution. The width of the merged picture is one times, and the height is one times.*/
    /* 307 merge the three pictures into a 1*2 layout */
    /* 308 merge the three pictures into a 2*1 layout */
    /* 309 take a license plate from the three pictures as a close-up, and merge with the other three pictures into a 2*2 layout, make the license plate on the lower left. The width of the merged picture is doubled and the height is doubled.*/
    /* 310 take a license plate from the three pictures as a close-up, and merge with the other three pictures into a 2*2 layout, make the license plate on the lower left. The width of the merged picture is one times and the height is one times.*/
    /* 311 take a license plate from the three pictures as a close-up, and merge with the other three pictures into a 2*2 layout, make the license plate on the top right. The width of the merged picture is doubled and the height is doubled.*/
    /* 312 take a license plate from the three pictures as a close-up, and merge with the other three pictures into a 2*2 layout, make the license plate on the top right. Compress the resolution. The width of the merged picture is one times, and the height is one times.*/
    /************************************************************************/
}NET_ITS_IMGMERGE_CFG,*LPNET_ITS_IMGMERGE_CFG;

//Transportation data host
typedef    struct    tagNET_ITS_TRAFFIC_DATA_HOST
{
    NET_DVR_IPADDR    struHostAddr;    // Remote host IP
    WORD            wHostPort;    // Remote host port
    BYTE            byRes1[2];
    DWORD            dwDataType;    // Upload the data type of the remote mainframe (see below definition), indicated by bit
    BYTE            bySuspendUpload;    //Suspend the data uploading or not: 0- upload, 1- suspend
    BYTE            byUploadStrategy;    //Upload strategy: 0- upload the latest data first, 1- upload the data in sequence
    WORD            wUploadInterval;    //The interval of the upload(ms, 1~2000), this parameter only works for historical data
    DWORD            dwUploadTimeOut; //Upload timed-out
    BYTE            byRes[24];
}NET_ITS_TRAFFIC_DATA_HOST,*LPNET_ITS_TRAFFIC_DATA_HOST;

//Data upload parameter
typedef  struct    tagNET_ITS_UPLOAD_CFG
{
    DWORD                  dwSize;
    NET_ITS_TRAFFIC_DATA_HOST    struRemoteDataHost1;       //Host 1 to receive transportation dat
    NET_ITS_TRAFFIC_DATA_HOST    struRemoteDataHost2;    //Host 2 to receive transportation data
}NET_ITS_UPLOAD_CFG,*LPNET_ITS_UPLOAD_CFG;

typedef struct tagNET_DVR_SYSTEM_TIME
{
    WORD  wYear;           //Year
    WORD  wMonth;          //Month
    WORD  wDay;            //Day
    WORD  wHour;           //Hour
    WORD  wMinute;      //Minute
    WORD  wSecond;      //Second
    WORD  wMilliSec;    //Millisecond
    BYTE  byRes[2];
}NET_DVR_SYSTEM_TIME, *LPNET_DVR_SYSTEM_TIME;

//The status of the transportation data host
typedef    struct tagNET_ITS_TRAFFIC_DATA_INFO
{
    DWORD    dwDataQuantity;      //Data amount
    DWORD    dwDataRsendQuantity;     //Undelivered data quantity (needs to be uploaded to the transportation data host)
    NET_DVR_SYSTEM_TIME      struStartTime;      //The earliest time of the undelivered data
    NET_DVR_SYSTEM_TIME      struEndTime;        //The most recent time of the undelivered data
    NET_DVR_IPADDR   struDataHost;    //Host of receiving transportation data
}NET_ITS_TRAFFIC_DATA_INFO, *LPNET_ITS_TRAFFIC_DATA_INFO;

//The terminal work status
typedef  struct tagNET_ITS_WORKSTATE
{
    DWORD      dwSize ;
    BYTE     byDevName[32];    // Device name
    DWORD  dwRunTime;        // System running time, Unit: second
    NET_ITS_TRAFFIC_DATA_INFO    struTrafficDataInfo[2]; //Tow hosts are supported(The data upload to the configuration hosts)
    DWORD  dwMemoryUsage;    // Memory usage (If the usage is 30%, enter 30 in this field)
    DWORD  dwCpuUsage;        // CPU usage (If the usage is 30%, enter 30 in this field)
    DWORD  dwDevTemperature;    // Temperature
    DWORD  dwDeviceStatic;     // Device status: 0-normal, 1-CPU usage is more than 85, 2-hardware error, e.g. serial port broken
    NET_DVR_DISKSTATE  struHardDiskStatic[MAX_DISKNUM_V30];   //Hardware status
    NET_DVR_CHANNELSTATE_V30 struChanStatic[MAX_CHANNUM_V30]; //Channel status
    BYTE  byAlarmInStatic[MAX_ALARMIN_V30];  //Alarm input status, 0- no alarm, 1- alarm
    BYTE  byAlarmOutStatic[MAX_ALARMOUT_V30]; //Alarm output status, 0- no alarm, 1- alarm
    DWORD dwLocalDisplay;            //Local view status, 0- normal, 1-abnormal
    BYTE  byAudioInChanStatus[8];      //Audio channel status, 0-not in use, 1- in use, array 0 means the no.1 voice channel
    BYTE  byRes[36];             //Reserved
}NET_ITS_WORKSTATE, *LPNET_ITS_WORKSTATE;

//Import and export traffic configuration to obtain parameters
typedef  struct tagNET_ITS_ECT_WORKSTATE_COMMAND
{
    DWORD    dwSize;
    DWORD  dwChannel;
    BYTE   byRes[256];
}NET_ITS_ECT_WORKSTATE_COMMAND, *LPNET_ITS_ECT_WORKSTATE_COMMAND;

typedef struct tagNET_ITS_ECTWORKSTATE
{
    DWORD      dwSize ;
    BYTE      byDevName[NAME_LEN];    // device name
    DWORD    dwRunTime;        // System uptime, unitss
    NET_ITS_TRAFFIC_DATA_INFO    struTrafficDataInfo[2]; //Support two hosts (data upload configuration host)
    DWORD    dwMemoryUsage;    // Memory usage (memory occupancy rate of 30%, where the fill 30)
    DWORD    dwCpuUsage;        // cpu usage (cpu occupancy rate of 30%, where the fill 30)
    DWORD    dwDevTemperature;    // The temperature of the machine
    DWORD    dwDeviceStatic;     // The status of the device, 0 - normal, 1-CPU occupancy rate is too high, more than 85%, 2 - hardware error, such as serial dead
    NET_DVR_DISKSTATE  struHardDiskStatic[MAX_DISKNUM_V30];   //Hard disk status
    BYTE     byAlarmInStatic[MAX_ALARMIN_V30];  //The status of the alarm input port, 0 - no alarm - alarm
    BYTE     byAlarmOutStatic[MAX_ALARMOUT_V30]; //The status of the alarm output port, 0 - no output, 1 - alarm output
    DWORD    dwLocalDisplay;//Local display state 0 - normal, 1 - normal
    BYTE     byRes[256];
}NET_ITS_ECTWORKSTATE, *LPNET_ITS_ECTWORKSTATE;

// Picture info
typedef struct tagNET_ITS_PICTURE_INFO
{
    DWORD   dwDataLen;            //Media data length
    BYTE    byType;                //0: license picture, 1: Scene picture, 2: Composite map, 3: stream
    BYTE    byDataType; // 0-Data Upload; 1-Cloud Storage Server
    BYTE    byCloseUpType;//Close Up Type
    BYTE    byPicRecogMode;  //Picture Recog Mode\A3\BB
    DWORD   dwRedLightTime;        //Time for passing the red traffic light (s)
    BYTE    byAbsTime[32];        //Absolute time, yyyymmddhhmmssxxx,e.g.20090810235959999, The last three numbers mean millisecond
    NET_VCA_RECT   struPlateRect;    //License plate location
    NET_VCA_RECT  struPlateRecgRect;   //License plate region coordinate
    BYTE        *pBuffer;    //Data pointer
    DWORD   dwUTCTime;//UTC Time
    BYTE    byCompatibleAblity; //Compatible Ablity
    BYTE    byRes2[7];           //Reserved
}NET_ITS_PICTURE_INFO, *LPNET_ITS_PICTURE_INFO;


typedef struct tagNET_ITS_ILLEGAL_INFO
{
    BYTE  byIllegalInfo[MAX_ILLEGAL_LEN/*64*/];// Illegal Info
    BYTE  byRes[256];
}NET_ITS_ILLEGAL_INFO,*LPNET_ITS_ILLEGAL_INFO;


//Detection result
typedef struct tagNET_ITS_PLATE_RESULT
{
    DWORD   dwSize;        //Structure size
    DWORD   dwMatchNo;  //Matched Serial Number. (consisting of the vehicle serial number, data type and lane number)
    BYTE    byGroupNum;    //Amount of the picture groups (the amount of pictures captured when one vehicle passing by. The data can be used for the Time Delay Matching.)
    BYTE    byPicNo;    //Continuous captured pictures serial number. (indicating the complete of the receiving.)
    BYTE    bySecondCam;    //Whether set the second camera to snapshot (e.g. prospect camera of far and near scene capture, rear camera of front and rear capture\A3\A9
    BYTE    byFeaturePicNo; //electric alarm of running red light, which picture taken to be close-up, 0xff- not take
    BYTE    byDriveChan;    //Triggering lane No.
    BYTE    byVehicleType;     //Vehicle type,refer to VTR_RESULT
    BYTE    byDetSceneID;//Detecting Scene ID[1,4],
    BYTE    byVehicleAttribute;// 0- no additional attributes, 1- standard yellow cars (banner), 2- dangerous goods vehicle
    WORD    wIllegalType;       //Rules broken type adopts the international standard definition
    BYTE    byIllegalSubType[8];   //Rules broken sub-type
    BYTE    byPostPicNo;    //The captured picture number to be traffic mount picture when the rule is broken,0xff- not take
    BYTE    byChanIndex;        //Camera No. (reserved)
    WORD    wSpeedLimit;        //Speed upper limit(valid when overspeed)
    BYTE    byChanIndexEx;      //byChanIndexEx*256+byChanIndex
    BYTE    byRes2;
    NET_DVR_PLATE_INFO  struPlateInfo;     //Plate info. structure
    NET_DVR_VEHICLE_INFO struVehicleInfo;    //Vehicle info
    BYTE    byMonitoringSiteID[48];        //Camera No.
    BYTE    byDeviceID[48];                //Device No.
    BYTE    byDir;            //Monitoring direction; 1- Up, 2- Down, 3- Bi-directional, 4- Westward, 5- Northward, 6-Eastward, 7-Southward, 8-Other directio
    BYTE    byDetectType;    //Detecting methods: 1- Triggered by induction coil, 2- Triggered by video, 3- Triggered by multi-frame detection, 4-Triggered by radar.
    BYTE    byRelaLaneDirectionType;//ITC_RELA_LANE_DIRECTION_TYPE
    BYTE    byCarDirectionType; //Car Direction Type
    DWORD   dwCustomIllegalType; //Custom Illegal Type
    BYTE*   pIllegalInfoBuf;    //Illegal Info Buf
    BYTE    byIllegalFromatType; //Illegal Fromat Type
    BYTE    byPendant;//  Pendant,0-Unknow, 1-No,2-Yes
    BYTE    byDataAnalysis;		    //0-Data Not Analysis, 1-Data Analysis
    BYTE    byYellowLabelCar;		//Yellow Label Car; 0-Unknow, 1-No,2-Yes
    BYTE    byDangerousVehicles;	//Dangerous Vehicles; 0-Unknow, 1-No,2-Yes
    BYTE    byPilotSafebelt;//Pilot Safe belt
    BYTE    byCopilotSafebelt;//Copilot Safe belt
    BYTE    byPilotSunVisor;//Pilot Sun Visor
    BYTE    byCopilotSunVisor;//Copilot Sun Visor
    BYTE    byPilotCall;// Pilot Call
    //The 0-open, 1-close(dedicated to the historical data based on black and white list matching, whether to open a sign of success)
    BYTE    byBarrierGateCtrlType;
    BYTE    byAlarmDataType;//0-RealTime Data\A3\AC1-Historical Data
    NET_DVR_TIME_V30  struSnapFirstPicTime;//End time (MS) (captured the first picture time.)
    DWORD   dwIllegalTime;//Illegal duration (MS) = captured the last picture time - to capture the first picture of the time
    DWORD   dwPicNum;        //The picture count (different with picGroupNum, represent the picture count attached by this information, picture info defined by struVehicleInfoEx
    NET_ITS_PICTURE_INFO struPicInfo[6];         //Picture info, check picture, at most 6 pictures at one time
}NET_ITS_PLATE_RESULT, *LPNET_ITS_PLATE_RESULT;

//Import and export vehicles to capture data upload
typedef struct tagNET_ITS_GATE_VEHICLE
{
    DWORD   dwSize;
    DWORD   dwMatchNo;    //Match the serial number, by default match code (vehicle ID, data type, lane number) 0
    BYTE    byGroupNum;    //Image data control the picture group number (a number of car camera several times to capture the total number of on behalf of a group of pictures for delay matching data) default capture type subsequently received delay operations
    BYTE    byPicNo;        //Continuous group of pictures upload pictures serial number (the number of received a group of pictures, which means that the reception is complete.
    //Receive time-out is less than the number of the group of pictures, according to the need to retain or delete)
    BYTE    bySecondCam;    //Rear camera to capture whether the second camera to capture (such as distance views to capture the vision camera, or about special projects will be used) marked the front and rear camera to capture pictures
    BYTE    byRes;
    WORD    wLaneid;            //Lane number 1 to 32 (index lane number, you can jump)
    BYTE    byCamLaneId;    //The corresponding camera lane number from 1 to 16 (camera configuration lane number, you can jump, can be the same)
    BYTE    byRes1;
    BYTE    byAlarmReason[MAX_ALARMREASON_LEN]; //Custom alarm type defaults to Chinese
    WORD    wBackList;    //Marked as to whether the alarm data of 0 indicates normal-car data expressed blacklist
    WORD    wSpeedLimit;        //Speed limit upper limit (speeding) km / h
    DWORD   dwChanIndex;
    NET_DVR_PLATE_INFO    struPlateInfo;
    NET_DVR_VEHICLE_INFO  struVehicleInfo;
    BYTE    byMonitoringSiteID[MAX_ID_LEN];        //Monitoring points
    BYTE    byDeviceID[MAX_ID_LEN];                //Device number
    BYTE    byDir;            //Monitoring direction, 0 - 1 admission, 2 appearances
    BYTE    byDetectType;    //Detection, 0 - Other 1 - to feel fat, 2 - video trigger, 3 - Multi-frame identification, 4 - radar trigger
    BYTE    byRes2[2];
    BYTE    byCardNo[MAX_ID_LEN];
    DWORD   dwPicNum;        //Pictures (unlike picGroupNum, on behalf of this section with the number of pictures, image information defined by the struVehicleInfoEx
    NET_ITS_PICTURE_INFO struPicInfo[4];         //Picture message, a single callback, up to 4, by serial number distinguish
    //2013-11-19 add Parameters
    BYTE    bySwipeTime[MAX_TIME_LEN];//Swipe Time  Time Format:yyyymmddhh24missfff
    BYTE    byRes3[224];
}NET_ITS_GATE_VEHICLE, *LPNET_ITS_GATE_VEHICLE;

typedef  struct  tagNET_ITS_GATE_FACE
{
    DWORD   dwSize;
    BYTE    byGroupNum;    //Image group number of (a pedestrian cameras capture many times the number of the total number of on behalf of a group of pictures for the delay matching data)
    BYTE    byPicNo;        //Continuous picture serial number (the number of received a group of pictures, which means that the reception is complete.
    //Receive time-out is less than the number of the group of pictures, according to the need to retain or delete)
    BYTE    byFeaturePicNo; //Take a few pictures and even caught as a close-up view, 0xff-said they did not take
    BYTE    byRes;
    WORD    wLaneid;            //Lane number 1 to 32 (index lane number, you can jump)
    BYTE    byCamLaneId;    //The corresponding camera lane number from 1 to 16 (camera configuration lane number, you can jump, can be the same)
    BYTE    byDir;        //Monitoring direction, 0 - 1 admission, 2 appearances
    DWORD   dwChanIndex;
    BYTE    byMonitoringSiteID[MAX_ID_LEN];
    BYTE    byDeviceID[MAX_ID_LEN];
    NET_VCA_FACESNAP_RESULT     struFaceInfo;
    BYTE    byRes2[256];
}NET_ITS_GATE_FACE, *LPNET_ITS_GATE_FACE;

typedef struct _tagNET_ITS_PARK_VEHICLE_
{
    DWORD   dwSize;
    BYTE    byGroupNum; //The number of group of pictures (single polling snapshot pictures)
    BYTE    byPicNo; //Receive complete burst picture group upload pictures serial number (the number of received a group of pictures
    //Receive time-out is less than the number of the group of pictures, according to the need to retain or delete)
    BYTE    byLocationNum; //The number of parking spaces managed by a single picture
    BYTE    byParkError; //Parking abnormalities, 0 - Normal 1 exception
    BYTE    byParkingNo[MAX_PARKNO_LEN];
    BYTE    byLocationStatus; //Parking the vehicle state, 0 - no cars, car
    BYTE    bylogicalLaneNum;//Logical number of parking spaces, 0-3, a camera largest pipe 4 parking spaces (0 represents the left-most, 3 represents the far right)
    WORD    wUpLoadType;//Zero bit: 0 ~ rotational training upload, 1 to change to upload
    BYTE    byRes1[4];
    DWORD   dwChanIndex; //Channel number digital channels
    NET_DVR_PLATE_INFO   struPlateInfo;
    NET_DVR_VEHICLE_INFO struVehicleInfo;
    BYTE   byMonitoringSiteID[MAX_ID_LEN];
    BYTE   byDeviceID[MAX_ID_LEN];
    DWORD  dwPicNum; //Pictures (picGroupNum, on behalf of this information incidental to the number of pictures
    //\A3\ACThe picture by struVehicleInfoEx defined
    NET_ITS_PICTURE_INFO struPicInfo[2];  //Picture message, a single callback, up to 2 No. distinguish
    BYTE   byRes2[256];
}NET_ITS_PARK_VEHICLE, *LPNET_ITS_PARK_VEHICLE;

typedef enum _VTR_RESULT
{
    VTR_RESULT_OTHER   =  0,  //other
    VTR_RESULT_BUS      =  1,  //Bus
    VTR_RESULT_TRUCK    =  2,  //Truck
    VTR_RESULT_CAR      =  3,   //Car
    VTR_RESULT_MINIBUS  =  4,   //MiniBus
    VTR_RESULT_SMALLTRUCK = 5,    //SmallTruck
    VTR_RESULT_HUMAN      =  6,   //human
    VTR_RESULT_TUMBREL  =  7,   //Tumbrel
    VTR_RESULT_TRIKE  = 8,     //Trike
    VTR_RESULT_SUV_MPV    =  9,  //SUV/MPV
    VTR_RESULT_MEDIUM_BUS =  10,  //Medium Bus
    VTR_RESULT_MOTOR_VEHICLE = 11, //Motor Vehicle
    VTR_RESULT_NON_MOTOR_VEHICLE = 12,  //Non-Motor Vehicle
    VTR_RESULT_SMALLCAR   = 13,   //Small Car
    VTR_RESULT_MICROCAR   = 14,   //Micro Car
    VTR_RESULT_PICKUP     = 15    //Pick Up
}VTR_RESULT;

typedef struct tagNET_DVR_TFS_ALARM
{
    DWORD                   dwSize;                //Structure size
    DWORD                   dwRelativeTime;        //Relative time
    DWORD                   dwAbsTime;               //Absolute time
    DWORD                   dwIllegalType;         //Lawless types, using national standard definition, using byIllegalCode when dwIllegalType value of 0 XFFFFFFFF
    DWORD                   dwIllegalDuration;     //Illegal duration(second)
    BYTE                    byMonitoringSiteID[MONITORSITE_ID_LEN];//ID of monitoring point
    BYTE                    byDeviceID[DEVICE_ID_LEN];             //ID of the device
    NET_VCA_DEV_INFO        struDevInfo;           //Device info
    NET_DVR_SCENE_INFO      struSceneInfo;         //Scene info
    NET_DVR_TIME_EX         struBeginRecTime;      //Record begin time
    NET_DVR_TIME_EX         struEndRecTime;        //Record end time
    NET_DVR_AID_INFO        struAIDInfo;           //Traffic event info
    NET_DVR_PLATE_INFO      struPlateInfo;         //License plate information
    NET_DVR_VEHICLE_INFO    struVehicleInfo;       //Vehicle info
    DWORD                   dwPicNum;              //The number of pictures
    NET_ITS_PICTURE_INFO    struPicInfo[8];        //Picture information, up to 8 pitures
    BYTE                    bySpecificVehicleType;     //The specific vehicle type recognition result types reference  VTR_RESULT
    BYTE                    byLaneNo;  //Relate Lane No
    BYTE                    byRes1[2];
    NET_DVR_TIME_V30        struTime;//Time
    DWORD                   dwSerialNo;//Serial No.
    BYTE                    byVehicleAttribute;// 0- no additional attributes, 1- standard yellow cars (banner), 2- dangerous goods vehicle
    BYTE                    byPilotSafebelt;//Pilot Safe belt
    BYTE                    byCopilotSafebelt;//Copilot Safe belt
    BYTE                    byPilotSunVisor;//Pilot Sun Visor
    BYTE                    byCopilotSunVisor;//Copilot Sun Visor
    BYTE                    byPilotCall;// Pilot Call
    BYTE                    byRes2[2]; //Res
    BYTE                    byIllegalCode[ILLEGAL_LEN/*32*/];//Illegal code extension, when dwIllegalType value is 0 XFFFFFFFF; Use this value
    BYTE                    byRes[68]; //Res
}NET_DVR_TFS_ALARM,*LPNET_DVR_TFS_ALARM;

typedef struct tagNET_DVR_SOFTWARE_SERVICE_CFG
{
    DWORD       dwSize;
    BYTE        byThirdStreamEnabled;  //Whether open three yards flow configuration: 0 - no, 1 - is
    BYTE        byRes[255];
}NET_DVR_SOFTWARE_SERVICE_CFG, *LPNET_DVR_SOFTWARE_SERVICE_CFG;

typedef struct _tagNET_ITS_ECT_BLACKLIST_
{
    DWORD dwSize;
    DWORD dwChannel;
    BYTE  bylogicalLaneNo;
    BYTE  byRes1[3];
    BYTE  byLaneName[NAME_LEN];
    NET_DVR_PLATE_INFO  struPlateInfo;
    BYTE  byRes2[256];
}NET_ITS_ECT_BLACKLIST, *LPNET_ITS_ECT_BLACKLIST;

//IPC channel configuration
typedef    struct     tagNET_ITS_IPC_CHAN_CFG
{
    DWORD        dwSize;
    BYTE        byCameraType;        //Camera type, 0- surveillance camera, 1- coil triggering camera, 2- camera for video analysis, 3- zoom camera
    BYTE        byRes1[3];           //Reserved
    BYTE        byMonitoringSiteID[48];        //Camera No.
    BYTE        byDeviceID[48];                //Device No.
    BYTE        byDirectionNo;         //Monitoring direction; 1-Up, 2-Down, 3-Bi-directional, 4- Westward, 5- Northward, 6-Eastward, 7-Southward, 8-Other direction
    BYTE        byMonitorInfo[48];      //Camera information description
    BYTE        byRes2[15];        //Reserved
}NET_ITS_IPC_CHAN_CFG, *LPNET_ITS_IPC_CHAN_CFG;

//Single device info
typedef struct tagNET_ITS_SINGLE_DEVICE_INFO
{
    DWORD  dwDeviceType;          //Device Type, 0- end, 1- camera, 2- compensation light, 3- car checking machine
    DWORD  dwDirID;               //Direction No.
    DWORD  dwLaneID;             //Lane No.
    DWORD  dwDeviceState;         //Device status; 0:normal, others: abnormal
    BYTE     byDeviceName[32];     //Device name
    BYTE       byDeviceID[48];    //Device No., normally it should be the serial number and for the car checking machine, address should be used.
    NET_DVR_TIME_V30  struTriggerTime;//triggering time ;
    BYTE   byRelateChan; //Relate Channel
    BYTE   byRes[3];
}NET_ITS_SINGLE_DEVICE_INFO,*LPNET_ITS_SINGLE_DEVICE_INFO;

//Road junction information
typedef struct tagNET_ITS_ROADINFO
{
    DWORD     dwSize;
    DWORD     dwChannel;          //Channel No., 0xffffffff means terminal, other value mean the corresponding camera
    BYTE     byTriggerMode;    //0: Triggered  by loop; 1: Triggered by video
    BYTE     byRes1[3];
    DWORD   dwDeviceNum;       //Actual device count
    BYTE      byMonitoringSiteID[48];    //Camera No.
    BYTE       byRoadInfo[48];       //Camera info
    NET_ITS_SINGLE_DEVICE_INFO        struSingleDevice[ITS_MAX_DEVICE_NUM];
    BYTE byRes[16];
}NET_ITS_ROADINFO,*LPNET_ITS_ROADINFO;

typedef struct tagNET_ITS_TRAFFIC_DRIVE_CHAN
{
    BYTE   byDriveChan;        //Drive channel
    BYTE   byRes1[3];            //
    WORD   wCarFlux;            //Car flux
    WORD   wPasserbyFlux;        //Passerby flux
    WORD   wShayFlux;        //Shay flux
    float  fAverOccpancy;       //Average occpancy
    WORD   wAverSpeed;         //Average speed(km/h)
    WORD   wAverCarDis;        //Average car distance()
    BYTE   byRes2[16];            //
}NET_ITS_TRAFFIC_DRIVE_CHAN,*LPNET_ITS_TRAFFIC_DRIVE_CHAN;

typedef struct tagNET_ITS_TRAFFIC_COLLECT
{
    DWORD  dwSize;        //
    BYTE   byMonitoringSiteID[48];        //Monitor ID
    BYTE   byDeviceID[48];                //Device ID
    BYTE   byLaneNum;    //Lane number
    BYTE   byDir;        //Direction
    BYTE   byDetectType;    //Detect type 1-coil 2-video trigger 3-Multi frame identification 4-radar trigger
    BYTE   byRes1;           //
    DWORD  dwChannel; //channel number
    NET_DVR_SYSTEM_TIME     struStartTime;        //Starttime
    DWORD  dwSamplePeriod;    //Sample period,second
    NET_ITS_TRAFFIC_DRIVE_CHAN    struDriveChan[6];         //Drive channel data
    BYTE   byRes2[24];     //
}NET_ITS_TRAFFIC_COLLECT,*LPNET_ITS_TRAFFIC_COLLECT;

typedef struct tagNET_ITS_OVERLAPCFG_COND
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwConfigMode; //Configuration mode, 0- terminal, 1-front end(Directly connect to front-end or terminal connect to the front end)
    BYTE  byPicModeType;//0-Said Small map\A3\AC1-Said Big map
    /*
    0 MPR Mode
    1 Hvt Mode
    */
    BYTE  byRelateType;
    BYTE  byRes[14];
}NET_ITS_OVERLAPCFG_COND, *LPNET_ITS_OVERLAPCFG_COND;

typedef enum ITS_OVERLAP_ITEM_TYPE
{
    OVERLAP_ITEM_NULL = 0,              //0-Unknown
    OVERLAP_ITEM_SITE,                //1-Location
    OVERLAP_ITEM_ROADNUM,             //2-Road Cross No.
    OVERLAP_ITEM_INSTRUMENTNUM,       //3-Device No.
    OVERLAP_ITEM_DIRECTION,           //4-Direction No.
    OVERLAP_ITEM_DIRECTIONDESC,       //5-Direction
    OVERLAP_ITEM_LANENUM,             //6-Lane No.
    OVERLAP_ITEM_LANEDES,             //7-Lane
    OVERLAP_ITEM_CAPTIME,             //8-Captured time(without ms)
    OVERLAP_ITEM_CAPTIME_MILLSECOND,  //9-Captured time(with ms)
    OVERLAP_ITEM_PLATENUM,            //10-License plate number
    OVERLAP_ITEM_CARCOLOR,            //11-Vehicle color
    OVERLAP_ITEM_CARTYPE,             //12-Vehicle type
    OVERLAP_ITEM_CARBRAND,            //13-Car brand
    OVERLAP_ITEM_CARSPEED,            //14-Speed
    OVERLAP_ITEM_SPEEDLIMIT,          //15-Speed limit sign
    OVERLAP_ITEM_CARLENGTH,           //16-Vehicle length: 1~99m
    OVERLAP_ITEM_ILLEGALNUM,          //17-Illegal code(generally it will be not used, it should overlay illegal information, such as normal, low speed, overspeed, retrograde, running red lights, lane and pressure the yellow line)
    OVERLAP_ITEM_MONITOR_INFO,        //18-Vehicle length
    OVERLAP_ITEM_ILLEGALDES,          //19-Illegal action
    OVERLAP_ITEM_OVERSPEED_PERCENT,      //20-Over-speed ratio
    OVERLAP_ITEM_RED_STARTTIME,       //21-Red light start time
    OVERLAP_ITEM_RED_STOPTIME,          //22-Red light stop time
    OVERLAP_ITEM_RED_DURATION,        //23-Red light on time
    OVERLAP_ITEM_SECUNITY_CODE,          //24-Anti-counterfeiting code
    OVERLAP_ITEM_CAP_CODE,              //25-Capture No.
    OVERLAP_ITEM_SEATBELT,              //26-SeatBelt
    OVERLAP_ITEM_MONITOR_ID,          //27-Monitor Id
    OVERLAP_ITEM_SUN_VISOR,           //28-Sun Visor
    OVERLAP_ITEM_LANE_DIRECTION,       //29-Lane Direction
    OVERLAP_ITEM_LICENSE_PLATE_COLOR,  //30-Plate Color
    OVERLAP_ITEM_SCENE_NUMBER,  //31-Scene Number
    OVERLAP_ITEM_SCENE_NAME,   //32-Scene Name
    OVERLAP_ITEM_YELLOW_SIGN_CAR,  //33-yellow Sign Car
    OVERLAP_ITEM_DANGEROUS_CAR,    //34-dangerous Car
    OVERLAP_ITEM_CAR_SUBBRAND,  //35-Car Sub Brand
    OVERLAP_ITEM_CAR_DIRECTION,  //36-Car Direction
    OVERLAP_ITEM_PENDANT,  //37-Pendant
    OVERLAP_ITEM_CALL  //38-Call
}ITS_OVERLAP_ITEM_TYPE;

//Single item of character overlay
typedef struct tagNET_ITS_OVERLAP_SINGLE_ITEM_PARAM
{
    BYTE byRes1[2];                 // String length for text overlaying
    BYTE byItemType;               //Item type, see to OVERLAP_ITEM_TYPE
    BYTE byChangeLineNum;           //Line numbers after overlay item[0-10](default: 0)
    BYTE bySpaceNum;                   //Line numbers after overlay item[0-255](default: 0)
    BYTE byRes2[2];
    BYTE byEnablePos;  //Enable Pos
    WORD wStartPosTop;    //Start Top Pos [0~2448]
    WORD wStartPosLeft;    //Start Left Pos [0~2448]
    BYTE byRes[8];
}NET_ITS_OVERLAP_SINGLE_ITEM_PARAM, *LPNET_ITS_OVERLAP_SINGLE_ITEM_PARAM;

typedef struct tagNET_ITS_OVERLAP_ITEM_PARAM
{
    NET_ITS_OVERLAP_SINGLE_ITEM_PARAM struSingleItem[MAX_OVERLAP_ITEM_NUM]; //Single string parameter
    DWORD dwLinePercent;  //Overlay percentage(0~100),(default: 100)
    DWORD dwItemsStlye;   //Overlay style: 0- horizontal,1- vertical, (default: horizontal)
    WORD wStartPosTop;    //The starting top coordinate, only effective for the internal overlay of picture[0~2448](default:0)
    WORD wStartPosLeft;   //The starting left coordinate,only effective for the internal overlay of picture[0~2448](default:0)
    WORD wCharStyle;    //Font type: 0- Times New Roman,1- (default)
    WORD wCharSize;     //Font size: 0--16x16,1--32x32,2-48x48,3--64x64 (default)
    WORD wCharInterval;    //Character spacing: [0\A1\AB16]\A3\ACunit: pixel(default)
    BYTE  byRes1[2];
    DWORD dwForeClorRGB; //foreground color RGB value: bit0-1:(B) bit2-3:(G) bit4-5:(G) (default: x00FFFFFF- white)
    DWORD dwBackClorRGB; //Background color RGB value, only effective for the extra overlay of picture: bit0-1:(B) bit2-3:(G) bit4-5:(G) (default: x00000000- black)
    BYTE  byColorAdapt;	 //Color self-adaption: 0- no, 1- yes
    //(Ver3.7 )
    // Param Fill Zero Enble 0-Fill Zero , 1-Not Fill Zero
    BYTE  byParamFillZeroEnble;
    BYTE  byPlateLeftCornerEnable;// Plate small overlay the upper left corner of the 0- don't stack, 1- stack
    BYTE  byRes2;
    WORD  wStartSPicPosTop; //Picture Start Top Pos [0~2448]
    WORD  wStartSPicPosLeft; //Picture Start Left Pos [0~2448]
    //OSD stack location 0- picture, 1- picture on the edge, 2- image edge (synthetic map of the special is the edge)\A3\A8V3.7\A3\A9
    BYTE       byOsdLocate;
    BYTE 		byRes[23];
}NET_ITS_OVERLAP_ITEM_PARAM, *LPNET_ITS_OVERLAP_ITEM_PARAM;

//Overlay specified info
typedef struct tagNET_ITS_OVERLAP_INFO_PARAM
{
    BYTE bySite[128];           //Location description
    BYTE byRoadNum[32];  //Road Cross No.
    BYTE byInstrumentNum[32];                //Device No.
    BYTE byDirection[32];        //Direction No.
    BYTE byDirectionDesc[32];    //Direction
    BYTE byLaneDes[32];        //Lane description
    BYTE byRes1[32];     //
    BYTE byMonitoringSite1[44];        //Camera 1 info
    BYTE byMonitoringSite2[32];        //Camera 2 info
    BYTE byRes[64];        //Reserved
}NET_ITS_OVERLAP_INFO_PARAM, *LPNET_ITS_OVERLAP_INFO_PARAM;

typedef struct tagNET_ITS_OVERLAP_CFG
{
    DWORD dwSize;
    BYTE byEnable; //Enable or not: 0- no, 1- yes
    BYTE byRes1[3];
    NET_ITS_OVERLAP_ITEM_PARAM        struOverLapItem; //String parameters
    NET_ITS_OVERLAP_INFO_PARAM     struOverLapInfo;  //String content info
    BYTE byRes[32];
}NET_ITS_OVERLAP_CFG, *LPNET_ITS_OVERLAP_CFG;

//Single item of character overlay
typedef struct tagNET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50
{
    BYTE byRes1[2];                 // String length for text overlaying
    BYTE byItemType;               //Item type, see to OVERLAP_ITEM_TYPE
    BYTE byChangeLineNum;           //Line numbers after overlay item[0-10](default: 0)
    BYTE bySpaceNum;                   //Line numbers after overlay item[0-255](default: 0)
    BYTE byRes2[2];
    BYTE byEnablePos;  //Enable Pos
    WORD wStartPosTop;    //Start Top Pos [0~2448]
    WORD wStartPosLeft;    //Start Left Pos [0~2448]
    BYTE byItemTypeCustom[32];   //Custom Item Type
    BYTE byRes[8];
}NET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50, *LPNET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50;

typedef struct tagNET_ITS_OVERLAP_ITEM_PARAM_V50
{
    NET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50 struSingleItem[MAX_OVERLAP_ITEM_NUM]; //Single string parameter
    DWORD dwLinePercent;  //Overlay percentage(0~100),(default: 100)
    DWORD dwItemsStlye;   //Overlay style: 0- horizontal,1- vertical, (default: horizontal)
    WORD wStartPosTop;    //The starting top coordinate, only effective for the internal overlay of picture[0~2448](default:0)
    WORD wStartPosLeft;   //The starting left coordinate,only effective for the internal overlay of picture[0~2448](default:0)
    WORD wCharStyle;    //Font type: 0- Times New Roman,1- (default)
    WORD wCharSize;     //Font size: 0--16x16,1--32x32,2-48x48,3--64x64 (default)
    WORD wCharInterval;    //Character spacing: [0\A1\AB16]\A3\ACunit: pixel(default)
    BYTE  byRes1[2];
    DWORD dwForeClorRGB; //foreground color RGB value: bit0-1:(B) bit2-3:(G) bit4-5:(G) (default: x00FFFFFF- white)
    DWORD dwBackClorRGB; //Background color RGB value, only effective for the extra overlay of picture: bit0-1:(B) bit2-3:(G) bit4-5:(G) (default: x00000000- black)
    BYTE  byColorAdapt;	 //Color self-adaption: 0- no, 1- yes
    //(Ver3.7 )
    // Param Fill Zero Enble 0-Fill Zero , 1-Not Fill Zero
    BYTE  byParamFillZeroEnble;
    BYTE  byPlateLeftCornerEnable;// Plate small overlay the upper left corner of the 0- don't stack, 1- stack
    BYTE  byRes2;
    WORD  wStartSPicPosTop; //Picture Start Top Pos [0~2448]
    WORD  wStartSPicPosLeft; //Picture Start Left Pos [0~2448]
    //OSD stack location 0- picture, 1- picture on the edge, 2- image edge (synthetic map of the special is the edge)\A3\A8V3.7\A3\A9
    BYTE       byOsdLocate;
    BYTE 		byRes[63];
}NET_ITS_OVERLAP_ITEM_PARAM_V50, *LPNET_ITS_OVERLAP_ITEM_PARAM_V50;

typedef struct tagNET_ITS_OVERLAP_CFG_V50
{
    DWORD dwSize;
    BYTE byEnable; //Enable or not: 0- no, 1- yes
    BYTE byRes1[3];
    NET_ITS_OVERLAP_ITEM_PARAM_V50        struOverLapItemV50; //String parameters
    NET_ITS_OVERLAP_INFO_PARAM             struOverLapInfo;  //String content info
    BYTE byRes[120];
}NET_ITS_OVERLAP_CFG_V50, *LPNET_ITS_OVERLAP_CFG_V50;


#define  MAX_PTZCRUISE_POINT_NUM   32   //Maximum support of 32 cruise points


typedef struct tagNET_DVR_PRESET_INFO
{
    DWORD dwSize;
    DWORD dwPresetNum;
    DWORD dwGroupNum;
    BYTE  byRes[8];
}NET_DVR_PRESET_INFO, *LPNET_DVR_PRESET_INFO;


typedef struct tagNET_DVR_PRESET_COND
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwGroupNO;
    BYTE byRes[8];
}NET_DVR_PRESET_COND, *LPNET_DVR_PRESET_COND;


typedef struct tagNET_DVR_PRESETCFG
{
    DWORD dwSize;
    DWORD dwPresetIndex;
    NET_VCA_POINT struVcaPoint;
    WORD wZoomCoordinate;
    BYTE  byRes[30];
}NET_DVR_PRESETCFG, *LPNET_DVR_PRESETCFG;

typedef struct tagNET_DVR_PTZCRUISE_INFO
{
    DWORD dwSize;
    DWORD dwPtzCruiseNum;
    DWORD dwGroupNum;
    BYTE byRes[8];
}NET_DVR_PTZCRUISE_INFO, *LPNET_DVR_PTZCRUISE_INFO;

typedef struct tagNET_DVR_PTZCRUISE_COND
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwGroupNO;
    BYTE byRes[8];
}NET_DVR_PTZCRUISE_COND, *LPNET_DVR_PTZCRUISE_COND;


typedef struct tagNET_DVR_PTZCRUISE_POINTCFG
{
    DWORD dwSize;
    DWORD dwPresetIndex;
    NET_VCA_POINT struVcaPoint;
    BYTE    byDwell;
    BYTE    bySpeed;
    WORD  wZoomCoordinate;
    BYTE   byRes[28];
}NET_DVR_PTZCRUISE_POINTCFG, *LPNET_DVR_PTZCRUISE_POINTCFG;

typedef struct tagNET_DVR_PTZCRUISECFG
{
    DWORD dwSize;
    DWORD dwCruiseRoute;
    NET_DVR_PTZCRUISE_POINTCFG struCruisePoint[MAX_PTZCRUISE_POINT_NUM];
    BYTE  byRes[32];
}NET_DVR_PTZCRUISECFG, *LPNET_DVR_PTZCRUISECFG;


typedef struct tagNET_DVR_MOTION_TRACK_CFG
{
    DWORD dwSize;
    BYTE byEnableTrack;
    BYTE byRes[63];
}NET_DVR_MOTION_TRACK_CFG, *LPNET_DVR_MOTION_TRACK_CFG;


typedef struct tagNET_DVR_DAY_SCHEDULE
{
    BYTE byWorkMode ;            //0-open all day\A3\AC1-close all day\A3\AC2-time
    BYTE byRes1[3] ;
    NET_DVR_SCHEDTIME struTime[MAX_TIMESEGMENT_V30/*8*/];
    BYTE byRes2[8];
}NET_DVR_DAY_SCHEDULE ,*LPNET_DVR_DAY_SCHEDULE;

typedef struct tagNET_DVR_SCHEDULE_AUTO_TRACK_CFG
{
    DWORD    dwSize;
    BYTE     byEnableTrack;            //0-disable\A3\AC1-enable
    BYTE    byRes1[3] ;
    NET_DVR_DAY_SCHEDULE struSchedule[MAX_DAYS/*7*/];
    BYTE    byRes2[128];
}NET_DVR_SCHEDULE_AUTO_TRACK_CFG,*LPNET_DVR_SCHEDULE_AUTO_TRACK_CFG;

typedef struct tagNET_DVR_I_FRAME
{
    DWORD    dwSize;
    BYTE    sStreamID[STREAM_ID_LEN/*32*/] ; //stream ID
    DWORD    dwChan;                     //channel no
    BYTE    byStreamType;             //0-main stream\A3\AC1-sub stream\A3\AC2-stream 3\A3\AC3-stream 4\A3\AC4-stream5
    BYTE    byRes[63];
} NET_DVR_I_FRAME, *LPNET_DVR_I_FRAME;


/*************************************ITS end****************************/

typedef struct tagNET_DVR_REBOOT_TIME
{
    BYTE byDate;   //date,1 to 7 represent Monday to Sunday
    BYTE byHour;   //hour
    BYTE byMinute; //minute
    BYTE byRes1;
    BYTE byRebootMode; //reboot mode, 0-by week\A3\AC1-by month(only for getting, cannot be set)
    BYTE byRes[11];
}NET_DVR_REBOOT_TIME,*LPNET_DVR_REBOOT_TIME;

typedef struct tagNET_DVR_AUTO_REBOOT_CFG
{
    DWORD dwSize;
    NET_DVR_REBOOT_TIME struRebootTime;
}NET_DVR_AUTO_REBOOT_CFG,*LPNET_DVR_AUTO_REBOOT_CFG;

/*************************************MVA 2.1 begin****************************/
#define NET_DVR_GPS_FINDING       0   //finding
#define NET_DVR_GPS_RECV          1   //receive data
#define NET_DVR_GPS_OVER          2   //finding finish
#define NET_DVR_GPS_EXCEPTION     3   //receive exception
typedef struct tagNET_DVR_MENU_OUTPUT_MODE
{
    DWORD        dwSize;
    BYTE        byMenuOutputMode; //menu output mode. not homologous device\A3\BA0-Auto 1-main CVBS 2-HDMI 3-VGA homologous device\A3\BA0-Auto 1-main CVBS 2-HDMI/VGA
    BYTE        byRes[63];
}NET_DVR_MENU_OUTPUT_MODE, *LPNET_DVR_MENU_OUTPUT_MODE;

typedef struct tagNET_DVR_MB_IPADDR
{
    NET_DVR_IPADDR   struIP;  //IP address
    WORD        wPort;   //port
    BYTE        byRes[2];
}NET_DVR_MB_IPADDR,*LPNET_DVR_MB_IPADDR;

typedef struct tagNET_DVR_MB_WVSPARA
{
    NET_DVR_MB_IPADDR struWVSAddr;
    BYTE byPuid[NAME_LEN];    //pu id
    BYTE byPassword[PASSWD_LEN];  //password
    BYTE byRes[8];
}NET_DVR_MB_WVSPARA, *LPNET_DVR_MB_WVSPARA;

typedef struct tagNET_DVR_MB_EHOMEPARA
{
    NET_DVR_MB_IPADDR struEHomeAddr;
    BYTE byPuid[NAME_LEN];   //pu id
}NET_DVR_MB_EHOMEPARA, *LPNET_DVR_MB_EHOMEPARA;

typedef struct tagNET_DVR_MB_PLATFORMPARA
{
    DWORD dwSize;
    BYTE byNetEnvironment;/*network,0-wireless,1-3G,2-wLan,3-lan*/
    BYTE byCurPlatForm;   /*current platform,0 - WVS, 1 - E home, 2 - CMS */
    BYTE byRes1[2];
    NET_DVR_MB_WVSPARA  struWVSPara; /*WVS platform parameter*/
    NET_DVR_MB_EHOMEPARA struMbEHpara;/*E home platform parameter */
    BYTE byRes2[64];
}NET_DVR_MB_PLATFORMPARA, *LPNET_DVR_MB_PLATFORMPARA;

typedef struct tagNET_DVR_MB_GPS_STATUS
{
    BYTE        byGPSModule;      /*gps module, 0: not exist, 1: normal*/
    BYTE        byPositionStatus;      /*gps position status, 0: fail, 1: success*/
    BYTE        bySignalStrength;    /*signal strength, 0: weak, 1: normal, 2: good*/
    BYTE        byres[5];
}NET_DVR_MB_GPS_STATUS, *LPNET_DVR_MB_GPS_STATUS;

typedef struct tagNET_DVR_MB_GSENSOR_STATUS
{
    BYTE        byGsensorModule;    /*g-sensor module, 0: not exist, 1 build-in: , 2: external*/
    BYTE        byCurAccX[10];     /*current acceleration of X*/
    BYTE        byCurAccY[10];    /*current acceleration of Y*/
    BYTE        byCurAccZ[10];    /*current acceleration of Z*/
    BYTE        byRefAccX[10];    /* reference acceleration of X*/
    BYTE        byRefAccY[10];    /* reference acceleration of Y*/
    BYTE        byRefAccZ[10];    /* reference acceleration of Z*/
    BYTE        byres[3];
}NET_DVR_MB_GSENSOR_STATUS, *LPNET_DVR_MB_GSENSOR_STATUS;

#define IP_ADDR_LEN         16
#define IW_ESSID_MAX_SIZE    32

typedef struct tagNET_DVR_MB_WIFI_STATUS
{
    BYTE        byEnableWiFi; /* WIFI, 0 off, 1 on */
    BYTE         byWiFiConnectStatus;  /* WIFI status, 0: fail to connect, 1: connect success 2: no module*/
    BYTE        bySignalStrength;             /* signal strength, 0 weak, 1 normal, 2 good */
    BYTE        byIPaddress[IP_ADDR_LEN];   /*WIFI device ip*/
    BYTE        byEssid[IW_ESSID_MAX_SIZE];  /*AP essid*/
    BYTE        byres[5];
}NET_DVR_MB_WIFI_STATUS,*LPNET_DVR_MB_WIFI_STATUS;

typedef struct tagNET_DVR_MB_PLATFORM_STATUS
{
    BYTE        byCurPlat;      /*current platform, 0: wvs, 1: ivms, 2: CMS*/
    BYTE        byLoginStatus;     /*login status, 0: login failed, 1: login success*/
    BYTE        byExceptionInfo;      /*exception*/
/*
WVS :exception info:
        0: fail to connect server
        1: logining
        2: user name or password error
        3: time out
        4: no heartbeat
        5: success
iVMS :exception info:
        0: not login
        1: logining
        2: fail to connect
        3: heart beat timeout
        4: connection break
        5: New registration
        6: max device number in CMS
        7: max channel number in CMS
        8: no configuration in web management center
        9: communication to CMS and WEB management center error
        10:login unknown error
        11:login success
CMS  :exception info:
        0: not login
        1: logining
        2: Duplicate registration
        3: connect fail
        4: server IP change
        5: login success
        6: logput
        7: heart beat timeout
*/
    BYTE        byres[5];
}NET_DVR_MB_PLATFORM_STATUS, *LPNET_DVR_MB_PLATFORM_STATUS;


typedef struct tagNET_DVR_MB_MOBILEDEV_STATUS
{
    DWORD        dwSize;
    union
    {
        NET_DVR_MB_GPS_STATUS struGPSStatus;
        NET_DVR_MB_GSENSOR_STATUS struGSensorStatus;
        NET_DVR_MB_WIFI_STATUS struWiFiStatus;
        NET_DVR_MB_PLATFORM_STATUS struPlatformStatus;
    }mobileStatus;
}NET_DVR_MB_MOBILEDEV_STATUS, *LPNET_DVR_MB_MOBILEDEV_STATUS;

#define NET_DVR_GPS_STATUS       0
#define NET_DVR_GSENSOR_STATUS   1
#define NET_DVR_WIFI_STATUS      2
#define NET_DVR_PLATFORM_STATUS  3


typedef struct tagNET_DVR_GPS_INFO
{
    BYTE    byDirection[2];        /*direction[0]0or1(east longitude/west longitude), direction[1]:0or1(North latitude/south latitude)  */
    BYTE    bySvs;         /* satellite vehicles\A3\BAEffective Satellite number */
    BYTE    byLocateMode;  /* location mode\A3\BAonly NMEA0183 3.00 version\A3\AC0=auto\A3\AC1=Differential\A3\AC2=Estimate\A3\AC3= Invalid data*/
    WORD    wHDOP;  /* horizontal accuracy\A3\AC0.5-99.9\A3\ACbelow 6 represent high accuracy\A3\ACabove 20 need to be abandoned\A3\ACthis value is multipled by 10 */
    WORD    wHeight;             /* height */
    DWORD   dwLatitude;     /*latitude = degree*3600*100+branch*60*100+second*100 */
    DWORD   dwLongitude; /*longitude =degree*3600*100+branch*60*100+second*100 */
    DWORD   dwVehicleSpeed;        /* mobile speed =speed*100000 kph*/
    DWORD    dwVehicleDirection;    /* mobile direction= actual direction*100\A3\ACcolockwise from North, uint:degree */
    BYTE    byRes[8];
}NET_DVR_GPS_INFO,*LPNET_DVR_GPS_INFO;

//GPS status upload
typedef  struct _NET_DVR_GPS_STATUS_ALARM_
{
    DWORD       dwSize;
    NET_DVR_TIME_V30   struGPSTime;      //GPS sampling time, use the local time
    NET_DVR_GPS_INFO   struGPSInfo;      //GPS coordinate point
    BYTE         byRetransFlag; //0 - this GPS real-time package; 1 - this GPS as heavy package
    BYTE         byNeedsResponse; //Response to tag, 0: does not need to respond to pack, 1: need to response to the package
    BYTE         byType;//Report type 0 - unmanned aerial vehicle (uav)
    BYTE         byBatteryRemaining;//Battery:-1 ~ 100; -1 said wrong
    int        iRollAngle;//Roll Angle, range - PI - + PI, the actual value * 100
    int        iPitchAngle;//Pitch Angle, range - PI - + PI, the actual value * 100
    WORD        wRelativeHeight;//Relative height, unit: cm
    WORD        wVerticalSpeed;//Vertical speed, unit: cm/h
    BYTE         byRes2[160];
}NET_DVR_GPS_STATUS_ALARM, *LPNET_DVR_GPS_STATUS_ALARM;

typedef struct tagNTE_DVR_GPS_DATA
{
    NET_DVR_GPS_INFO  struGPSInfo;      //GPS point
    NET_DVR_TIME      struTime;            //GPS point time
    BYTE        byRes[12];
}NET_DVR_GPS_DATA,*LPNET_DVR_GPS_DATA;


typedef struct tagNET_DVR_GET_GPS_DATA_PAPAM
{
    DWORD dwCmdType;              //0-find by time segment,1-find by time point
    union
    {
        struct
        {
            NET_DVR_TIME struBeginTime;               //start time
            NET_DVR_TIME struEndTime;                 //end time
            DWORD dwInterval;                  //interval,unit: second
            BYTE  byRes[76];
        }TimeSeg;
        struct
        {
            NET_DVR_TIME struTimePoint;              //time point
            BYTE  byRes[104];
        }TimePoint;
    }GpsDataParam;
}NET_DVR_GET_GPS_DATA_PARAM,*LPNET_DVR_GET_GPS_DATA_PARAM;
/*************************************MVA 2.1 end****************************/
typedef struct tagNET_DVR_SDKLOCAL_CFG
{
    BYTE    byEnableAbilityParse;    //use ability parse,0-not use,1-use,default 0
    BYTE    byVoiceComMode;          //Voice Intercom Mode \A3\AC1-Use Windows Api( linux ,mac not support),0-Use VoiceIntercom library(default);
    BYTE    byLoginWithSimXml;  //use simulate ability in login,0-not use,1-use,default 0
    BYTE    byCompatibleType;
    BYTE    byRes[380];
    BYTE    byProtectKey[128];    //default 0
}NET_DVR_SDKLOCAL_CFG, *LPNET_DVR_SDKLOCAL_CFG;


typedef struct tagNET_DVR_LOCAL_ABILITY_PARSE_CFG
{
    BYTE    byEnableAbilityParse;
    BYTE    byRes[127];
}NET_DVR_LOCAL_ABILITY_PARSE_CFG, *LPNET_DVR_LOCAL_ABILITY_PARSE_CFG;

typedef struct tagNET_DVR_LOCAL_TALK_MODE_CFG
{
    BYTE    byTalkMode;
    BYTE    byRes[127];
}NET_DVR_LOCAL_TALK_MODE_CFG, *LPNET_DVR_LOCAL_TALK_MODE_CFG;


typedef struct tagNET_DVR_LOCAL_PROTECT_KEY_CFG
{
    BYTE    byProtectKey[128];
    BYTE    byRes[128];
}NET_DVR_LOCAL_PROTECT_KEY_CFG, *LPNET_DVR_LOCAL_PROTECT_KEY_CFG;

typedef struct tagNET_DVR_SIMXML_LOGIN
{
    BYTE   byLoginWithSimXml;   //use simulate in login,0-no,1-yes
    BYTE   byRes[127];
}NET_DVR_SIMXML_LOGIN, *LPNET_DVR_SIMXML_LOGIN;

typedef enum tagNET_SDK_LOCAL_CFG_TYPE
{
    NET_SDK_LOCAL_CFG_TYPE_TCP_PORT_BIND = 0,        //NET_DVR_LOCAL_TCP_PORT_BIND_CFG
    NET_SDK_LOCAL_CFG_TYPE_UDP_PORT_BIND,            //NET_DVR_LOCAL_UDP_PORT_BIND_CFG
    NET_SDK_LOCAL_CFG_TYPE_MEM_POOL,                //NET_DVR_LOCAL_MEM_POOL_CFG
    NET_SDK_LOCAL_CFG_TYPE_MODULE_RECV_TIMEOUT,        //NET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG
    NET_SDK_LOCAL_CFG_TYPE_ABILITY_PARSE,            //NET_DVR_LOCAL_ABILITY_PARSE_CFG
    NET_SDK_LOCAL_CFG_TYPE_TALK_MODE,                //NET_DVR_LOCAL_TALK_MODE_CFG
    NET_SDK_LOCAL_CFG_TYPE_PROTECT_KEY,                //NET_DVR_LOCAL_PROTECT_KEY_CFG
    NET_SDK_LOCAL_CFG_TYPE_CFG_VERSION,              //configuration version. test device.
    NET_SDK_LOCAL_CFG_TYPE_RTSP_PARAMS,                //Rtsp params config, NET_DVR_RTSP_PARAMS_CFG
    NET_SDK_LOCAL_CFG_TYPE_SIMXML_LOGIN,            //NET_DVR_SIMXML_LOGIN
    NET_SDK_LOCAL_CFG_TYPE_CHECK_DEV,                //NET_SDK_LOCAL_CFG_TYPE_CHECK_DEV
    NET_SDK_LOCAL_CFG_TYPE_SECURITY,                  //local security config\A3\AC
    NET_SDK_LOCAL_CFG_TYPE_EZVIZLIB_PATH,            //EZVIZLIB path config
    NET_SDK_LOCAL_CFG_TYPE_CHAR_ENCODE,               //13.char encode type config
    NET_SDK_LOCAL_CFG_TYPE_PROXYS,                     //get the proxy server info
    NET_DVR_LOCAL_CFG_TYPE_LOG,                       //SDK Log Configuration
    NET_DVR_LOCAL_CFG_TYPE_STREAM_CALLBACK,           //Stream CallBack Configuration NET_DVR_LOCAL_STREAM_CALLBACK_CFG
    NET_DVR_LOCAL_CFG_TYPE_GENERAL,                   //NET_DVR_LOCAL_GENERAL_CFG
}NET_SDK_LOCAL_CFG_TYPE;

typedef enum tagNET_SDK_EXCEPTION_CALLBACK_TYPE
{
    NET_SDK_EXCEPTION_CALLBACK_BY_POOL = 0,         //callback by pool
    NET_SDK_EXCEPTION_CALLBACK_DIRECTLY = 1,        //callback directly
}NET_SDK_EXCEPTION_CALLBACK_TYPE;

typedef struct tagNET_DVR_LOCAL_GENERAL_CFG
{
    BYTE     byExceptionCbDirectly;    //0-callback by pool\A3\AC1-callback directly
    BYTE     byNotSplitRecordFile;     //0-split record\A3\AC1-not split
    BYTE byRes[6];
    UINT64 i64FileSize;      //file size:Byte
    BYTE byRes1[240];
}NET_DVR_LOCAL_GENERAL_CFG, *LPNET_DVR_LOCAL_GENERAL_CFG;

typedef struct tagNET_DVR_LOCAL_STREAM_CALLBACK_CFG
{
    BYTE     byPlayBackEndFlag;                         //0- Not CallBack PlayBack EndFlag\A3\AC1-CallBack PlayBack EndFlag
    BYTE     byRes[255];
}NET_DVR_LOCAL_STREAM_CALLBACK_CFG, *LPNET_DVR_LOCAL_STREAM_CALLBACK_CFG;

typedef struct tagNET_DVR_LOCAL_LOG_CFG
{
    WORD    wSDKLogNum;
    BYTE    byRes[254];
}NET_DVR_LOCAL_LOG_CFG, *LPNET_DVR_LOCAL_LOG_CFG;

typedef int(CALLBACK * CHAR_ENCODE_CONVERT)(char * pInput, DWORD dwInputLen, DWORD dwInEncodeType, char *pOutput, DWORD dwOutputLen, DWORD dwOutEncodeType);

typedef struct tagNET_DVR_LOCAL_BYTE_ENCODE_CONVERT
{
    CHAR_ENCODE_CONVERT  fnCharConvertCallBack;
    BYTE     byRes[256];
}NET_DVR_LOCAL_BYTE_ENCODE_CONVERT, *LPNET_DVR_LOCAL_BYTE_ENCODE_CONVERT;

typedef struct tagNET_DVR_LOCAL_SECURITY
{
    BYTE bySecurityLevel;       //communication mode\A3\AC //0-compatibility mode\A3\AC1-security mode \A3\A8MD5\A3\A92-security mode\A3\A8RSA\A3\A9
    BYTE byRes[255];
}NET_DVR_LOCAL_SECURITY, *LPNET_DVR_LOCAL_SECURITY;

typedef struct tagNET_DVR_LOCAL_TCP_PORT_BIND_CFG
{
    WORD    wLocalBindTcpMinPort;
    WORD    wLocalBindTcpMaxPort;
    BYTE    byRes[60];
}NET_DVR_LOCAL_TCP_PORT_BIND_CFG, *LPNET_DVR_LOCAL_TCP_PORT_BIND_CFG;


typedef struct tagNET_DVR_LOCAL_UDP_PORT_BIND_CFG
{
    WORD    wLocalBindUdpMinPort;
    WORD    wLocalBindUdpMaxPort;
    BYTE    byRes[60];
}NET_DVR_LOCAL_UDP_PORT_BIND_CFG, *LPNET_DVR_LOCAL_UDP_PORT_BIND_CFG;


typedef struct tagNET_DVR_LOCAL_MEM_POOL_CFG
{
    DWORD    dwAlarmMaxBlockNum;
    DWORD    dwAlarmReleaseInterval;
    DWORD   dwObjectReleaseInterval;
    BYTE    byRes[508];
}NET_DVR_LOCAL_MEM_POOL_CFG, *LPNET_DVR_LOCAL_MEM_POOL_CFG;

typedef  struct  tagNET_DVR_OPTICAL_CHANNEL_BIND
{
    WORD wChannelIndex;    //optical port num(0-7)
    WORD wSubChannel;      //sub optical channel\A3\ACget value range from ability set
    BYTE  byBind;      //0-not bind\A3\AC1-bind
    BYTE  byRes[3];
}NET_DVR_OPTICAL_CHANNEL_BIND,*LPNET_DVR_OPTICAL_CHANNEL_BIND;

typedef struct tagNET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG
{
    DWORD        dwPreviewTime;        //Preview module timeout
    DWORD        dwAlarmTime;            //alarm module timeout
    DWORD        dwVodTime;            //playback timeout
    DWORD        dwElse;                    //other module timeout
    BYTE        byRes[512];                            //res
}NET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG, *LPNET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG;

typedef struct tagNET_DVR_RTSP_PARAMS_CFG
{
    DWORD    dwMaxBuffRoomNum;    //max buffer num
    BYTE    byUseSort;    //rtp over udp sort\A3\AC 0-disable  1-enable
    BYTE    byRes[123];
}NET_DVR_RTSP_PARAMS_CFG, *LPNET_DVR_RTSP_PARAMS_CFG;

typedef struct tagNET_DVR_OPTICAL_CHANNEL_CFG
{
    DWORD dwSize;
    NET_DVR_OPTICAL_CHANNEL_BIND struBindVideo;//video binding configuration
    NET_DVR_OPTICAL_CHANNEL_BIND struBindAudio;//audio binding configuration
    BYTE  byRes[16];
}NET_DVR_OPTICAL_CHANNEL_CFG,*LPNET_DVR_OPTICAL_CHANNEL_CFG;

typedef struct tagNET_DVR_OPTICAL_INFO
{
    DWORD dwSize;
    BYTE  bySlotNum;//code subsystem slot num
    BYTE  byChannel; //code channel num
    BYTE  byRes[18];
}NET_DVR_OPTICAL_INFO,*LPNET_DVR_OPTICAL_INFO;

//audio switch
typedef struct tagNET_DVR_AUDIO_SURCHAN_CFG
{
    DWORD dwSize;
    BYTE  byStatus;       //audio status\A3\AC1-on\A3\AC0-off
    BYTE  byRes1[3];
    //byStatus == 1 valid
    DWORD dwSubWinNum; //related sub window number
    DWORD dwSurChanNum;             /*device channel number */
    NET_DVR_IPADDR struIpaddr;            /*device ip address */
    WORD   wPort;                          /*device port */
    BYTE   byRes2[14];
}NET_DVR_AUDIO_SURCHAN_CFG, *LPNET_DVR_AUDIO_SURCHAN_CFG;

//ethernet channel
#define MAX_ETHERNET_PORT_NUM       8//max port number in one link
typedef struct tagNET_DVR_ETHERNET_CHANNEL_INFO
{
    DWORD dwSize;
    BYTE byConverge[MAX_ETHERNET_PORT_NUM];
    //byConverge[i] = j represents add port i to link j,j's value range is 1-8,j = 0 means delete port i from the link
    BYTE byRes[32];
}NET_DVR_ETHERNET_CHANNEL_INFO,*LPNET_DVR_ETHERNET_CHANNEL_INFO;
//spartan
typedef struct tagNET_DVR_SPARTAN_INFO
{
    DWORD  dwSize;
    BYTE   bySpartanStatus; //0-off,1-on
    BYTE   byRes[31];
}NET_DVR_SPARTAN_INFO,*LPNET_DVR_SPARTAN_INFO;

typedef struct tagNET_DVR_IPADDR_FILTERCFG
{
    DWORD dwSize;
    BYTE byEnable; //enable,0-no,1-yes
    BYTE byFilterType; //filter type,0-forbit,1-permit
    BYTE byRes1[2];
    BYTE byRes[16];
    BYTE byIPAddr[1024];    //IP address,for 192.168.1.2;192.168.1.3
}NET_DVR_IPADDR_FILTERCFG, *LPNET_DVR_IPADDR_FILTERCFG;

typedef struct tagNET_DVR_LOGO_OVERLAYCFG
{
    DWORD dwSize;
    BYTE  byEnable; //enable,0-no,1-yes
    BYTE  byRes1[3];
    DWORD dwCoordinateX;    //X coordinate
    DWORD dwCoordinateY;    //Y coordinate
    WORD  wPicWidth; //width
    WORD  wPicHeight; //height
    BYTE  byRes[16];
}NET_DVR_LOGO_OVERLAYCFG,*LPNET_DVR_LOGO_OVERLAYCFG;


typedef struct tagNET_DVR_INVALID_DISK_PARAM
{
    NET_DVR_STRUCTHEAD    struStructHead;
    DWORD                dwDiskNo;            // Disk number
    BYTE                byDelAll;            // 0-Delete dwDiskNo  1-Delete all
    BYTE                 byres[31];
}NET_DVR_INVALID_DISK_PARAM, *LPNET_DVR_INVALID_DISK_PARAM;


typedef struct tagNET_DVR_INVALID_MOUNT_DISK_PARAM
{
    NET_DVR_STRUCTHEAD    struStructHead;
    DWORD                dwDiskNo;            // Disk number
    BYTE                 byres[32];
}NET_DVR_MOUNT_DISK_PARAM, *LPNET_DVR_MOUNT_DISK_PARAM;

typedef void (CALLBACK *fLoginResultCallBack) (LONG lUserID, DWORD dwResult, LPNET_DVR_DEVICEINFO_V30 lpDeviceInfo , void* pUser);

#define NET_DVR_DEV_ADDRESS_MAX_LEN 129
#define NET_DVR_LOGIN_USERNAME_MAX_LEN 64
#define NET_DVR_LOGIN_PASSWD_MAX_LEN 64

typedef struct
{
    char sDeviceAddress[NET_DVR_DEV_ADDRESS_MAX_LEN];
    BYTE byUseTransport;
    WORD wPort;
    char sUserName[NET_DVR_LOGIN_USERNAME_MAX_LEN];
    char sPassword[NET_DVR_LOGIN_PASSWD_MAX_LEN];
    fLoginResultCallBack cbLoginResult;
    void *pUser;
    BOOL bUseAsynLogin;
    BYTE byProxyType;
    BYTE byUseUTCTime;
    BYTE byRes2[2];
    LONG iProxyID;
    BYTE byRes3[120];
}NET_DVR_USER_LOGIN_INFO,*LPNET_DVR_USER_LOGIN_INFO;

// Long config callback type
typedef enum
{
    NET_SDK_CALLBACK_TYPE_STATUS = 0,        // Status
    NET_SDK_CALLBACK_TYPE_PROGRESS,            // Progress
    NET_SDK_CALLBACK_TYPE_DATA                // Data
}NET_SDK_CALLBACK_TYPE;


// Long config status value
typedef enum
{
    NET_SDK_CALLBACK_STATUS_SUCCESS = 1000,        // Success
    NET_SDK_CALLBACK_STATUS_PROCESSING,            // Processing
    NET_SDK_CALLBACK_STATUS_FAILED,                // Failed
    NET_SDK_CALLBACK_STATUS_EXCEPTION,            // Exception
    NET_SDK_CALLBACK_STATUS_LANGUAGE_MISMATCH,    // Language mismatch
    NET_SDK_CALLBACK_STATUS_DEV_TYPE_MISMATCH,    // Device type mismatch
    NET_DVR_CALLBACK_STATUS_SEND_WAIT,           // send wait
}NET_SDK_CALLBACK_STATUS_NORMAL;

//The following is a key configuration failure status code \A1\AA\A1\AApart1
#define NET_SDK_OKC_STATUS_SUCCESS                1000
#define NET_SDK_OKC_STATUS_FAILED                1002
#define NET_SDK_OKC_STATUS_START_CONFIG            1003
#define NET_SDK_OKC_CHECK_HD                    1004
#define NET_SDK_OKC_INIT_HD                        1005
#define NET_SDK_OKC_CREATE_RAID_OR_SINGLE_DISK    1006
#define NET_SDK_OKC_INIT_CVR_SERVICE            1007
#define NET_SDK_OKC_CREATE_RECORD_VOLUME        1008
#define NET_SDK_OKC_ERR_LOAD_CONF_FAILED              1009
#define NET_SDK_OKC_ERR_NOT_SUPPORT_RAID_LEVLE        1010
#define NET_SDK_OKC_ERR_CONFIGURATION_CONFLICT          1011
#define NET_SDK_OKC_ERR_GET_DISK_INFO_FAILED          1012
#define NET_SDK_OKC_ERR_CHECK_DISK_FAILED             1013
#define NET_SDK_OKC_ERR_INIT_DISK_FAILED              1014
#define NET_SDK_OKC_ERR_DISK_CAPACITY_SMALL           1015
#define NET_SDK_OKC_ERR_BOTH_SV_NS                    1016
#define NET_SDK_OKC_ERR_CREATE_RAID_FAILED            1017
#define NET_SDK_OKC_ERR_GET_RAID_FAILED               1018
#define NET_SDK_OKC_ERR_CREATE_SPARE_FAILED           1019
#define NET_SDK_OKC_ERR_CREATE_STORAGE_POOL_FAILED    1020
#define NET_SDK_OKC_ERR_GET_POOL_INFO_FAILED          1021
#define NET_SDK_OKC_ERR_CREATE_LUN_FAILED             1022
#define NET_SDK_OKC_ERR_GET_LUN_INFO_FAILED           1023
#define NET_SDK_OKC_ERR_CREATE_BACKUP_FAILED          1024
#define NET_SDK_OKC_ERR_GET_BACKUP_FAILED                1025
#define NET_SDK_OKC_ERR_CREATE_PRIVATE_LUN_FAILED        1026
#define NET_SDK_OKC_ERR_CREATE_RV_FAILED              1027
#define NET_SDK_OKC_ERR_CREATE_ARCH_RV_FAILED         1028
#define NET_SDK_OKC_ERR_START_CVR_SERVICE_FAILED      1029

//One key configuration state of SAN
#define NET_SDK_OKC_CREATING_ARRAY                    1030
#define NET_SDK_OKC_CREATING_STORAGE_POOL            1031
#define NET_SDK_OKC_CREATING_LUN_VOL                1032
#define NET_SDK_OKC_CREATING_ISCSI                    1033
#define NET_SDK_OKC_ERR_HOT_SPARE_CONFICT            1034
#define NET_SDK_OKC_ERR_STORAGE_POOL_CONFICT        1035

//The following is a key configuration failure status code \A1\AA\A1\AApart2
#define NET_SDK_OKC_ERR_SAPRE_NUM_EXCEED            1101    //Hot plate number too much
#define NET_SDK_OKC_ERR_CREATE_PIC_VOLUME_FAILED    1102    //Failed to create image volumes

typedef enum
{
    NET_SDK_GET_NEXT_STATUS_SUCCESS = 1000,    // Get data successfully, Call API NET_DVR_RemoteConfigGetNext after processing this data.
    NET_SDK_GET_NETX_STATUS_NEED_WAIT,        // Need wait, keep calling NET_DVR_RemoteConfigGetNext
    NET_SDK_GET_NEXT_STATUS_FINISH,            // Get data finish, call API NET_DVR_StopRemoteConfig
    NET_SDK_GET_NEXT_STATUS_FAILED,            // Get data failed, call API NET_DVR_StopRemoteConfig
}NET_SDK_GET_NEXT_STATUS;

typedef enum tagNET_SDK_IPC_CFG_FILE_ERR_CODE
{
    NET_SDK_IPC_CFG_FILE_NO_ERR = 0,
    NET_SDK_IPC_CFG_FILE_ERR_CODE_CHANNEL_INVALID = 1,
    NET_SDK_IPC_CFG_FILE_ERR_CODE_CHANNEL_DUPLICATE,
    NET_SDK_IPC_CFG_FILE_ERR_CODE_IP_INVALID,
    NET_SDK_IPC_CFG_FILE_ERR_CODE_IP_DUPLICATE,
    NET_SDK_IPC_CFG_FILE_ERR_CODE_IP_CONFLICT_WITH_LOCAL,
    NET_SDK_IPC_CFG_FILE_ERR_CODE_PROTOCOL_INVALID,
    NET_SDK_IPC_CFG_FILE_ERR_CODE_PORT_INVALID,
    NET_SDK_IPC_CFG_FILE_ERR_CODE_DEVICE_CHANNEL_ERR,
    NET_SDK_IPC_CFG_FILE_ERR_CODE_USER_NAME_ERR,
    NET_SDK_IPC_CFG_FILE_ERR_CODE_PASSWD_ERR,
    NET_SDK_IPC_CFG_FILE_ERR_CODE_TRANSPORT_PROTOCOL_INVALID
}NET_SDK_IPC_CFG_FILE_ERR_CODE;

typedef enum
{
    NET_SDK_UPGRADE_IPC_INVALID = 0,
    NET_SDK_UPGRADE_IPC_SUCCESS,
    NET_SDK_UPGRADE_IPC_OFFLINE,
    NET_SDK_UPGRADE_IPC_NOT_SUPPORT,
    NET_SDK_UPGRADE_IPC_LANGUAGE_MISMATCH,
    NET_SDK_UPGRADE_IPC_WRITE_FLASH_FAILED,
    NET_SDK_UPGRADE_IPC_OTHER_ERROR
}NET_SDK_UPGRADE_IPC_ERR_CODE;

typedef enum
{
    NET_SDK_REMOTE_CONFIG_STATUS_SUCCESS = 1001,
    NET_SDK_REMOTE_CONFIG_STATUS_FAILED,
    NET_SDK_REMOTE_CONFIG_STATUS_PROCESSING
}NET_SDK_REMOTE_CONFIG_STATUS;

/*************************************coder server start****************************/
#define MAX_CODE_CARD_SUPPORTDISPNUMS 8//max support display channel for one card
#define MAX_SUPPORT_RES 32

typedef enum _BOARD_TYPE
{
    DS4004HC_BOARD        =2,  //4004HC
    DS4008HC_BOARD        =3,  //4008HC
    DS4016HC_BOARD        =4,  //4016HC
    DS4001HF_BOARD        =5,  //4001HF
    DS4004HF_BOARD        =6,  //4004HF
    DS4002MD_BOARD        =7,  //4002MD
    DS4004MD_BOARD        =8,  //4004MD
    DS4016HCS_BOARD        =9,  //4016HCS
    DS4004HC_PLUS_BOARD    =13, //4004HC+
    DS4008HC_PLUS_BOARD    =14, //4008HC+
    DS4016HC_PLUS_BOARD    =15, //4016HC+
    DS4008HF_BOARD        =16, //4008HF
    DS4008MD_BOARD        =17, //4008MD
    DS4008HS_BOARD        =18, //4008HS
    DS4016HS_BOARD        =19, //4016HS

    DS4108HCV_BOARD        =20, //4108HCV
    DS4116HCV_BOARD        =21, //4116HCV
    DS5016HC_BOARD        =22, //5016HC

    DS4208HFV_BOARD        =23, //4208HFV
    DS4216HC_BOARD        =24, //4216HC
    DS4216HFV_BOARD        =25, //4216HFV

    DS5008HF_BOARD        =26, //5008HF
    DS5116HF_BOARD        =27, //5116HF

    DS5216HC_BOARD        =28, //5216HC
    DS5208HF_BOARD        =29, //5208HF
    DS5216HF_BOARD        =30, //5216HF

    DS4101HD_BOARD        =31, //4101HD
    DS4102HD_BOARD        =32, //4102HD
    DS4104HD_BOARD        =33, //4104HD

    DS4002MD_PLUS_BOARD =34, //4002MD+
    DS4004MD_PLUS_BOARD =35, //4004MD+

    DS4204HFV_BOARD        =36, //4204HFV
    DS4308HCV_BOARD        =37, //4308HCV
    DS4308HFV_BOARD        =38, //4308HFV
    DS4316HCV_BOARD        =39, //4316HCV
    DS4316HFV_BOARD        =40, //4316HFV
    DS4304HD_BOARD        =41, //4304HD
    DS4304HFH_BOARD     =42, //4304HFH
    DS4304HFV_BOARD     =43, //4304HFV
    DS4302HFH_BOARD     =44, //4302HFH
    DS5316HF_BOARD      =45, //5316HF
    DS4308HW_BOARD      =46, //4308HW
    DS4316HW_BOARD      =47, //4316HW
    DS4308MD_BOARD      =48, //4308MD
    UNKNOWN_BOARD_TYPE  =0xffffffff,
}BOARD_TYPE;

typedef struct tagNET_DVR_CODECARD_ABILITY
{
    BYTE byCardType;      //code card type(enum BOARD_TYPE)
    BYTE byCodeNums;      //code channel nummber
    BYTE byDispNums;      //display channel number
    BYTE byCodeStartIdx;     //fisrt code channel index in all code channels
    BYTE byDispStartIdx;     //first display channel index in all display channels
    BYTE byRes1[3];
    DWORD dwVgaSupportResolution[MAX_SUPPORT_RES/*32*/];//supported resolution of VGA
    DWORD dwHdmiSupportResolution[MAX_SUPPORT_RES/*32*/];//supported resolution of HDMI
    DWORD dwDviSupportResolution[MAX_SUPPORT_RES/*32*/];//supported resolution of DVI
    DWORD dwYpbprSupportResolution[MAX_SUPPORT_RES/*32*/];//supported resolution of Ypbpr
    BYTE byDispFormat[MAX_CODE_CARD_SUPPORTDISPNUMS];   //supported display format(enum HD_DISPLAY_FORMAT)
    BYTE byWindowMode[MAX_CODE_CARD_SUPPORTDISPNUMS][12]; //supported window mode(eg. 1,2,4,9,16))
    BYTE byRes2[36];
}NET_DVR_CODECARD_ABILITY,*LPNET_DVR_CODECARD_ABILITY;

#define        MAX_CODE_CARD_NUM            8   //max code card number
typedef struct tagNET_DVR_CODESVR_ABILITY
{
    DWORD dwSize;
    BYTE byCardNums;      /* code card number */
    BYTE byStartChan;     /* start channel number */
    BYTE byRes1[2];
    NET_DVR_CODECARD_ABILITY struCodeCardAbility[MAX_CODE_CARD_NUM];
    BYTE byRes2[64];
}NET_DVR_CODESVR_ABILITY, *LPNET_DVR_CODESVR_ABILITY;

typedef struct tagNET_DVR_CODER_SERVER_OUTPUT_CFG
{
    DWORD  dwSize;
    BYTE   byDispChanType;        /*display channel type\A3\BA0-BNC\A3\AC1-VGA\A3\AC2-HDMI\A3\AC3-DVI*/
    BYTE   byVedioFormat;      /*1:NTSC,2:PAL\A3\AC0-NULL*/
    BYTE   byRes1[2];
    DWORD  dwResolution;       //resolution
    DWORD  dwWindowMode;        /*window mode*/
    BYTE   byRes2[64];
}NET_DVR_CODER_SERVER_OUTPUT_CFG,*LPNET_DVR_CODER_SERVER_OUTPUT_CFG;

typedef struct tagNET_DVR_DISPLAY_START_INFO
{
    DWORD  dwSize;
    DWORD  dwDisplayChan; //display channel number
    DWORD  dwCodeChan; //code channel number
    DWORD  dwWinNum;   //window number
    BYTE   byEnableAudio; //enable video\A3\AC0-disable\A3\AC1-enable
    BYTE   byRes[31];
}NET_DVR_DISPLAY_START_INFO,*LPNET_DVR_DISPLAY_START_INFO;

typedef struct tagNET_DVR_CODER_WINDOW_INFO
{
    DWORD dwSize;
    DWORD dwDisplayChan;//display channel number
    DWORD dwWinNum;     //window number
    BYTE  byRes[16];
}NET_DVR_CODER_WINDOW_INFO,*LPNET_DVR_CODER_WINDOW_INFO;

typedef struct tagNET_DVR_WINDOW_STATUS
{
    DWORD  dwSize;
    DWORD  dwCodeChan;      /*code channel number*/
    BYTE   byDisplay;        /*enable output\A3\AC0-disable\A3\AC1-enable*/
    BYTE   byAudio;            /*enable video\A3\AC0-disable\A3\AC1-enable*/
    BYTE   byRes[30];
}NET_DVR_WINDOW_STATUS,*LPNET_DVR_WINDOW_STATUS;

/*************************************coder server end****************************/

typedef struct tagNET_DVR_RECORD_LOCK_PERCENTAGE
{
    DWORD     dwSize;
    BYTE     byPercentage;        //range [0,100]
    BYTE      byRes[31];          //
}NET_DVR_RECORD_LOCK_PERCENTAGE, *LPNET_DVR_RECORD_LOCK_PERCENTAGE;

typedef struct tagNET_DVR_UPDATE_RECORD_INFO
{
    DWORD             dwSize;
    NET_DVR_STREAM_INFO struStreasmInfo;     //Stream ID
    DWORD              dwBeginTime;    //record begin time
    DWORD             dwEndTime;        //record end time
    BYTE              byRes[32];
}NET_DVR_UPDATE_RECORD_INFO, *LPNET_DVR_UPDATE_RECORD_INFO;

typedef struct tagNET_DVR_CMD_TRIGGER_PERIOD_RECORD_PARA
{
    NET_DVR_STREAM_INFO        struStreamInfo;
    DWORD                    dwCmdType;                         //Command type
    DWORD                    dwRecordTimeLen;                //Record time\A3\ACsecond
    BYTE                    byEventID[MAX_EVENTID_LEN];        //Event ID
    BYTE                    byRes[128];
}NET_DVR_CMD_TRIGGER_PERIOD_RECORD_PARA, *LPNET_DVR_CMD_TRIGGER_PERIOD_RECORD_PARA;

typedef struct tagNET_DVR_LOCK_FILE_BY_NAME_PARA
{
    BYTE                byFileName[NAME_LEN];     // record file name
    DWORD                dwLockDuration;            // duration time
    BYTE                byRes[512];
}NET_DVR_LOCK_FILE_BY_NAME_PARA, *LPNET_DVR_LOCK_FILE_BY_NAME_PARA;



typedef struct tagNET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND
{
    DWORD                    dwSize;
    NET_DVR_STREAM_INFO        struStreamInfo;
    DWORD                    dwStreamType; //Stream type\A3\AC0-main stream\A3\AC1-sub stream\A3\AC2-event\A3\AC3-stream 3\A3\AC\A1\AD\A1\AD
    BYTE                    byRes[32];
}NET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND, *LPNET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND;


typedef struct tagNET_DVR_MULTI_STREAM_COMPRESSIONCFG
{
    DWORD                            dwSize;
    DWORD                            dwStreamType;        //Stream type\A3\AC0-main stream\A3\AC1-sub stream\A3\AC2-event\A3\AC3-stream 3\A3\AC\A1\AD\A1\AD
    NET_DVR_COMPRESSION_INFO_V30    struStreamPara;        //copress info
    BYTE                            byRes[80];
}NET_DVR_MULTI_STREAM_COMPRESSIONCFG, *LPNET_DVR_MULTI_STREAM_COMPRESSIONCFG;

typedef struct tagNET_DVR_PUSHALARMINFO_V40
{
    DWORD dwAlarmType; /*0- sensor alarm; 1- hard disk full; 2- video lost; 3- motion detection; 4- hard disk unformatted; 5- hard disk error; 6- tampering detection; 7- unmatched video output standard; 8- illegal operation; 9- video exception; 0xa- record exception
                        11- Vca scene change 12-Array exception 13 resolution dismatch*/
    union
    {
        BYTE byRes[300];
        struct
        {
            DWORD dwAlarmInputNumber;   /*Alarm input Port*/
            BYTE  byAlarmOutputNumber[MAX_ALARMOUT_V30];   /*State of Alarm output channel, 1- - Triggered*/
            BYTE  byAlarmRelateChannel[MAX_CHANNUM_V30];  /*channels triggered to record, 1- recording,  dwAlarmRelateChannel[0] is the first channel*/
            BYTE  byRes1[97];
            BYTE  byDeviceID[NAME_LEN]; /*Device ID*/
            BYTE  byRes2[7];
        }struIOAlarm;
        struct
        {
            BYTE byStreamID[STREAM_ID_LEN]; //Stream id
            BYTE byRes1[132];
            BYTE byChannel[MAX_CHANNUM_V30];             /*If the dwAlarmType is 2, 3 or 6, it stands for channel, dwChannel[0] is the first channel*/
            BYTE byRes2[33];
            BYTE byDeviceID[NAME_LEN]; /*Device ID*/
            BYTE byRes3[7];
        }struStreamIDorChannel;
        struct
        {
            BYTE byRes1[228];
            BYTE byDiskNumber[MAX_DISKNUM_V30];  /*When dwAlarmType is 1, 4 or 5,  it stands for Hard Disk,  dwDiskNumber[0] is the first disk*/
            BYTE byDeviceID[NAME_LEN]; /*Device ID*/
            BYTE byRes2[7];
        }struDiskAlarm;
    }uAlarmInfo;
}NET_DVR_PUSHALARMINFO_V40, *LPNET_DVR_PUSHALARMINFO_V40;
typedef struct tagNET_DVR_RECORD_PACK
{
    NET_DVR_STRUCTHEAD     struStruceHead;
    DWORD           dwPackageInterval;    // Packaged interval time     units: min
    BYTE              byRes[32];            // preserve
}NET_DVR_RECORD_PACK,*LPNET_DVR_RECORD_PACK;

/*****************************Netra 2.3***********************************/
//Netra 2.3 2012-10-9
#define NET_DVR_FIND_NAS_DIRECTORY          6161        //find NAS directory
#define NET_DVR_NAS_FINDING       0   //is finding
#define NET_DVR_NAS_RECV          1   // recv data
#define NET_DVR_NAS_OVER          2   // find over
#define NET_DVR_NAS_EXCEPTION     3   //Exception
typedef struct tagNET_DVR_NET_DISK_SERACH_PARAM
{
    NET_DVR_IPADDR              struIP;         // IP address
    WORD              wPort;      // IP port
    BYTE                byRes[10];  // preserve
}NET_DVR_NET_DISK_SERACH_PARAM, *LPNET_DVR_NET_DISK_SERACH_PARAM;


typedef struct tagNET_DVR_NET_DISK_SERACH_RET
{
    BYTE byDirectory[128];  // file directory
    BYTE byRes[20];
}NET_DVR_NET_DISK_SERACH_RET, *LPNET_DVR_NET_DISK_SERACH_RET;

typedef struct tagNET_DVR_HTTPS_CFG
{
    DWORD    dwSize;
    WORD    wHttpsPort;  // HTTPS ports
    BYTE    byEnable;    // enable 0\A3\BAclose 1\A3\BAopen
    BYTE    byRes[125];
}NET_DVR_HTTPS_CFG, *LPNET_DVR_HTTPS_CFG;

typedef struct tagNET_DVR_WD1_CFG
{
    NET_DVR_STRUCTHEAD     struStruceHead;
    BYTE              byWD1Enable;         //WD1 enable   0 close  1 open
    BYTE                 byRes[31];      //preserve
}NET_DVR_WD1_CFG, *LPNET_DVR_WD1_CFG;



/*****************************Netra 2.3***********************************/
//Netra 2.3 2012-10-9







typedef struct tagNET_DVR_FTPCFG_V40
{
    NET_DVR_STRUCTHEAD     struStruceHead;
    BYTE                byEnableFTP;        /* enable ftp , 0-No 1-yes */
    BYTE                byProtocolType;        /*Protocol type 0-FTP\A3\AC1-SFTP*/
    WORD                wFTPPort;            /*Port*/
    union
    {
        struct
        {
            BYTE            szDomain[64];      //domain name
            BYTE            byRes1[80];
        }struDomain;
        struct
        {
            NET_DVR_IPADDR     struIp;          /*IP Address*/
        }struAddrIP;
    }unionServer;  //IPv4 IPv6 server address or domain name

    BYTE                szUserName[32];        /*User name */
    BYTE                szPassWORD[16];        /*password*/
    BYTE                szTopCustomDir[64];    /*Custom top directory*/
    BYTE                szSubCustomDir[64];    /*Custom sub directory*/
    BYTE                byDirLevel;            /*0 = Do not use the directory structure directly stored in the root directory,
                                              1 = stored in the top directory,2=stored in the sub directory */
    BYTE                 byTopDirMode;        /* Top directory\A3\AC0x1 = use device name, 0x2 = use device No,0x3 = use device ip\A3\AC
                                               0x4=use Monitoring points ,0x5=Time (Date)  0x6-Using a custom , 0x7= type of violation, the direction of 0x8=, 0x9= location*/
    BYTE                 bySubDirMode;       /*Sub directory\A3\AC0x1=use channel name,0x2=use channel number
                                               0x3=use time (Date),0x4=use Lane number 0x5-Using a custom , 0x6= type of violation, the direction of 0x7=, 0x8= location*/
    BYTE                byType;                /* 0-Main server\A3\AC1-reserved server*/
    BYTE                byEnableAnony;      /*use anony 0-no 1-yes*/
    BYTE                byAddresType;        /*0 use IPV4\A1\A2IPV6  1- use Domain name*/
    /*******************2013-09-27 New parameters begin********************************/
    BYTE                byFTPPicType;        //0-preserve\A3\AC1-Parking lot to capture the picture naming rules
    BYTE                 byPicArchivingInterval; //Picture Archiving Interval[1~30]
    NET_DVR_PICTURE_NAME_EX     struPicNameRule;/* picture naming rules:
                                                byFTPPicType ==1,Parking lot to capture the picture naming rules*/
    BYTE                byPicNameRuleType;      //Picture Name Rule Type
    BYTE                 byRes[203];          /*preserve*/
    /*******************2013-09-27 New parameters end ********************************/
}NET_DVR_FTPCFG_V40, *LPNET_DVR_FTPCFG_V40;

typedef struct tagNET_DVR_FTP_TYPE
{
    BYTE    byType;  // 0-main server\A3\AC1-Spare server
    BYTE    byRes[3];
}NET_DVR_FTP_TYPE, *LPNET_DVR_FTP_TYPE;

typedef struct
{
    DWORD     dwSize;
    BYTE                byEnableFTP;        /*enable ftp , 0-No 1-yes */
    BYTE                byProtocolType;        /*Protocol type 0-FTP\A3\AC1-SFTP*/
    WORD                wFTPPort;            /*Port*/
    union
    {
        BYTE byRes[144];
        struct
        {
            BYTE    szDomain[MAX_DOMAIN_NAME];      /*domain name*/
            BYTE    byRes1[80];
        }struDomain;
        struct
        {
            NET_DVR_IPADDR     struIp;          /*IP Address*/
        }struAddrIP;
    }unionServer;  //IPv4 IPv6 server address or domain name

    BYTE    szUserName[NAME_LEN];        /*User name */
    BYTE    szPassWORD[PASSWD_LEN];        /*password*/
    BYTE    szTopCustomDir[MAX_CUSTOM_DIR];    /*Custom top directory*/
    BYTE    szSubCustomDir[MAX_CUSTOM_DIR];    /*Custom sub directory*/
    BYTE                byDirLevel;            /*0 = Do not use the directory structure directly stored in the root directory,
                                              1 = stored in the top directory,2=stored in the sub directory */
    BYTE                 byTopDirMode;        /* Top directory\A3\AC0x1 = use device name, 0x2 = use device No,0x3 = use device ip\A3\AC
                                               0x4=use Monitoring points ,0x5=Time (Date)  0x6-Using a custom , 0x7= type of violation, the direction of 0x8=, 0x9= location*/
    BYTE                 bySubDirMode;       /*Sub directory\A3\AC0x1=use channel name,0x2=use channel number
                                               0x3=use time (Date),0x4=use Lane number 0x5-Using a custom , 0x6= type of violation, the direction of 0x7=, 0x8= location*/
    BYTE                byType;                /* 0-Main server\A3\AC1-reserved server*/
    BYTE                byEnableAnony;      /*use anony 0-no 1-yes*/
    BYTE                byAddresType;        /*0 use IPV4\A1\A2IPV6  1- use Domain name*/

    BYTE    byRes2[198];
}NET_DVR_FTP_SERVER_TEST_PARA, *LPNET_DVR_FTP_SERVER_TEST_PARA;

typedef struct tagNET_DVR_SERVER_TEST_PARA
{
    DWORD    dwSize;
    union
    {
        BYTE byRes[740];
        struct
        {
            NET_DVR_NTPPARA    struNtpPara;                    /*NTP server test param 80 bytes*/
            BYTE    byRes1[660];
        }struNtpPara;
        struct
        {
            NET_DVR_SINGLE_NET_DISK_INFO_V40    struNasPara;   /*NAS server test param 480 bytes*/
            BYTE    byRes1[260];
        }struNasPara;
        struct
        {
            NET_DVR_FTP_SERVER_TEST_PARA    struFtpPara;   /*FTP server test param 528 bytes*/
            BYTE    byRes1[212];
        }struFtpPara;
        struct
        {
            NET_DVR_EMAILCFG_V30    struEmailPara;            /*Email server test param 660 bytes*/
            BYTE    byRes1[80];
        }struEmailPara;
        struct
        {
            NET_DVR_IPADDR    struIp;                            /*IP conflict test param 24 bytes*/
            BYTE    byRes1[716];
        }struIpPara;
        struct
        {
            NET_DVR_IPADDR  struIPAdder;
            WORD  wPort; //Port
            BYTE  byRes2[2];
            char  szUser[CLOUD_NAME_LEN/*48*/]; //User
            char  szPassword[CLOUD_PASSWD_LEN/*48*/];     // Passwor
            NET_DVR_POOLPARAM  struPoolInfo[16];//Array 0 bayonet video pool, an array of 1 said illegal video pool,  2 Vehicle detection\A3\A8IPC/D\A3\A9
            BYTE byRes1[490];
        }struCloudStoragePara;
        struct
        {
            BYTE byPhoneNum[MAX_PHONE_NUM/*32*/]; //Phone Num
            BYTE byRes1[708];
        }struPhoneNumPara;//Phone Num Test
    }unionServerPara;
    BYTE byRes2[800];
}NET_DVR_SERVER_TEST_PARA, *LPNET_DVR_SERVER_TEST_PARA;

typedef struct  tagNET_DVR_GOP_INFO
{
    DWORD      dwSize;          //struct size
    LONG      lChannel;
    NET_DVR_TIME_EX   struStartTime;
    NET_DVR_TIME_EX   struEndTime;
    BYTE                 byRes[256];
}NET_DVR_GOP_INFO, *LPNET_DVR_GOP_INFO;

typedef struct  tagNET_DVR_GOP_INFO_RET
{
    NET_DVR_TIME_V30   struGopTime;
    DWORD         dwDuration;
    DWORD         dwDataSize;
    BYTE          byRes[128];
    char* pBuf;
}NET_DVR_GOP_INFO_RET, *LPNET_DVR_GOP_INFO_RET;

typedef struct tagNET_DVR_GOP_INFO_PASSBACK
{
    DWORD       dwSize;
    NET_DVR_TIME_V30  struTime;
    DWORD       dwDuration;
    DWORD       dwMetaDataSize;
    DWORD       dwPicDataSize;
    char*        pMetaDataBuffer;
    char*       pPicDataBuf;
    BYTE        byRes[32];
}NET_DVR_GOP_INFO_PASSBACK, *LPNET_DVR_GOP_INFO_PASSBACK;
/****************************Netra 2.3 end ***************************************/

#define MAX_LOCAL_ADDR_LEN            96
#define    MAX_COUNTRY_NAME_LEN        4

typedef struct tagNET_DVR_BONJOUR_CFG
{
    DWORD    dwSize ;
    BYTE    byEnableBonjour;
    BYTE     byRes1[3];
    BYTE     byFriendlyName[MAX_DOMAIN_NAME];
    BYTE     byRes2[128];
}NET_DVR_BONJOUR_CFG, *LPNET_DVR_BONJOUR_CFG;

typedef struct tagNET_DVR_SOCKS_CFG
{
    DWORD            dwSize;
    BYTE            byEnableSocks;
    BYTE             byVersion;
    WORD            wProxyPort;
    BYTE            byProxyaddr[MAX_DOMAIN_NAME];
    BYTE             byUserName[MAX_DOMAIN_NAME];
    BYTE             byPassword[NAME_LEN];
    BYTE             byLocalAddr[MAX_LOCAL_ADDR_LEN];
    BYTE             byRes[128];
}NET_DVR_SOCKS_CFG, *LPNET_DVR_SOCKS_CFG;

typedef struct tagNET_DVR_QOS_CFG
{
    DWORD        dwSize;
    BYTE        byManageDscp;
    BYTE        byAlarmDscp;
    BYTE        byVideoDscp;
    BYTE        byAudioDscp;
    BYTE        byFlag;
    BYTE        byEnable;
    BYTE         byRes[126];
}NET_DVR_QOS_CFG, *LPNET_DVR_QOS_CFG;


//Cert Info
typedef struct tagNET_DVR_CERT_NAME
{
    BYTE    byCountry[MAX_COUNTRY_NAME_LEN];
    BYTE     byState[MAX_DOMAIN_NAME];
    BYTE     byLocality[MAX_DOMAIN_NAME];
    BYTE     byOrganization[MAX_DOMAIN_NAME];
    BYTE     byUnit[MAX_DOMAIN_NAME];
    BYTE     byCommonName[MAX_DOMAIN_NAME];
    BYTE     byEmail[MAX_DOMAIN_NAME];
    BYTE     byRes[128];
}NET_DVR_CERT_NAME, *LPNET_DVR_CERT_NAME ;

typedef struct tagNET_DVR_CERT_PARAM
{
    DWORD dwSize;
    WORD wCertFunc; //certificate type,0-802.1x,1-HTTPS
    WORD wCertType; //certificate type,0-CA\A3\AC1-Certificate,2-private
    BYTE byFileType; //certificate type,0-PEM,1-PFX
    BYTE byRes[35];
}NET_DVR_CERT_PARAM, *LPNET_DVR_CERT_PARAM;

typedef struct tagNET_DVR_CERT_INFO
{
    DWORD                 dwSize;
    NET_DVR_CERT_PARAM     struCertParam;
    DWORD                dwValidDays;
    BYTE                 byPasswd[NAME_LEN];
    NET_DVR_CERT_NAME     struCertName;
    NET_DVR_CERT_NAME     struIssuerName;
    NET_DVR_TIME_EX         struBeginTime;
    NET_DVR_TIME_EX         struEndTime;
    BYTE                 serialNumber[NAME_LEN];
    BYTE                 byVersion;
    BYTE                 byKeyAlgorithm;
    BYTE                  byKeyLen;
    BYTE                 bySignatureAlgorithm;
    BYTE                 byRes[128];
}NET_DVR_CERT_INFO, *LPNET_DVR_CERT_INFO;



typedef enum
{
    UPGRADE_CERT_FILE = 0,
    UPLOAD_CERT_FILE = 1 ,
    TRIAL_CERT_FILE = 2,
    CONFIGURATION_FILE = 3,
    UPLOAD_RECORD_FILE = 4,  //upload record file
    SCENE_CONFIGURATION_FILE = 5, //upload sence configure file
    UPLOAD_PICTURE_FILE = 6,  //upload pocture file
    UPLOAD_VIOLATION_FILE = 7,  //Upload Violation File
    UPLOAD_TG_FILE = 8,  //Upload TG File
    UPLOAD_DATA_TO_DB = 9,        //upload data to DB
    UPLOAD_BACKGROUND_PIC = 10, //Upload Background Picture
    UPLOAD_CALIBRATION_FILE = 11, //Upload Calibration file
    UPLOAD_TME_FILE = 12, //Tme File
    UPLOAD_VEHICLE_BLACKWHITELST_FILE = 13,
    UPLOAD_PICTURE_TO_CLOUD = 15, //upload picture to cloud storage
    UPLOAD_VIDEO_FILE = 16,  //upload video file
    UPLOAD_SCREEN_FILE = 17,    //upload screen server file
    UPLOAD_PUBLISH_MATERIAL = 18,    //upload info publish material file
    UPLOAD_PUBLISH_UPGRADE_FILE = 19,    //upload info upgrade file
    UPLOAD_RING_FILE = 20,   //upload ring file
    UPLOAD_ENCRYPT_CERT = 21,    //upload encrypt cert
    UPLOAD_THERMOMETRIC_FILE = 22,  //Upload Thermometric File
    UPLOAD_SUBBRAND_FILE = 23,  //Upload Sub Brand File
    UPLOAD_LED_CHECK_FILE = 24,    //upload LED check file
    BATCH_UPLOAD_PICTURE_FILE = 25,  //batch upload pictrue
    UPLOAD_EDID_CFG_FILE = 26, //upload EDID file
    UPLOAD_PANORAMIC_STITCH = 27,//Upload a panoramic stitching configuration file automatically
    UPLOAD_BINOCULAR_COUNTING = 28,//Upload the vertical flow correction table
    UPLOAD_AUDIO_FILE = 29,   //Upload Audio File
    UPLOAD_PUBLISH_THIRD_PARTY_FILE = 30  //upload third part file
}NET_SDK_UPLOAD_TYPE;

typedef enum
{
    NET_SDK_DOWNLOAD_CERT = 0,               //Download certificate file
    NET_SDK_DOWNLOAD_IPC_CFG_FILE = 1,         //Download ipc config file
    NET_SDK_DOWNLOAD_BASELINE_SCENE_PIC = 2, //Download baseline scene picture
    NET_SDK_DOWNLOAD_VQD_ALARM_PIC      = 3, //Download the lastest alarm picture of certain VQD event
    NET_SDK_DOWNLOAD_CONFIGURATION_FILE=4,   //Download configuration file
    NET_SDK_DOWNLOAD_SCENE_CONFIGURATION_FILE = 5, //Download scene configure file
    NET_SDK_DOWNLOAD_FILE_FORM_DB = 6,                //Download from DB
    NET_SDK_DOWNLOAD_TME_FILE = 7,  //TME File
    NET_SDK_DOWNLOAD_VEHICLE_BLACKWHITELST_FILE = 8, //Download black and white configure file
    NET_SDK_DOWNLOAD_GUID_FILE = 9, //Download GUID file
    NET_SDK_DOWNLOAD_FILE_FORM_CLOUD = 10,   //download picture from cloud storage
    NET_SDK_DOWNLOAD_PICTURE = 11, //download picture file
    NET_SDK_DOWNLOAD_VIDEO = 12, //download video file
    NET_DVR_DOWNLOAD_SCREEN_FILE = 13, //download screen server file
    NET_SDK_DOWNLOAD_PUBLISH_MATERIAL = 14,    //download info publish material
    NET_SDK_DOWNLOAD_THERMOMETRIC_FILE = 15,  //Download Thermometric File
    NET_SDK_DOWNLOAD_LED_CHECK_FILE = 16,        //download LED check file

}NET_SDK_DOWNLOAD_TYPE;

typedef enum
{
    NET_SDK_DOWNLOAD_STATUS_SUCCESS = 1,
    NET_SDK_DOWNLOAD_STATUS_PROCESSING,
    NET_SDK_DOWNLOAD_STATUS_FAILED,
    NET_SDK_DOWNLOAD_STATUS_UNKOWN_ERROR,
    NET_SDK_DOWNLOAD_STATUS_RESOURCE,
    NET_SDK_DOWNLOAD_STATUS_GUIDFILE_EXPORT_FAIL
}NET_SDK_DOWNLOAD_STATUS;

typedef enum tagNET_SDK_DOWNLOAD_CONTROL_TYPE_ENUM
{
    ENUM_DOWNLOAD_CONTROL_ERR = -1,
    ENUM_DOWNLOAD_CONTROL_QOS = 1
}NET_SDK_DOWNLOAD_CONTROL_TYPE_ENUM;


/********************************video wall begin*********************************/
typedef struct tagNET_DVR_PANORAMIC_STITCH_UPLOAD
{
    DWORD   dwSize;
    DWORD   dwChannel;
    BYTE    byRes[128];
}NET_DVR_PANORAMIC_STITCH_UPLOAD, *LPNET_DVR_PANORAMIC_STITCH_UPLOAD;

typedef struct tagNET_DVR_SINGLEWALLPARAM
{
    DWORD  dwSize;
    BYTE   byEnable;
    BYTE   byRes1[3];
    DWORD  dwWallNum;//output No.
    NET_DVR_RECTCFG struRectCfg;//screen position
    BYTE    byRes2[36];
}NET_DVR_SINGLEWALLPARAM, *LPNET_DVR_SINGLEWALLPARAM;

/*windows information*/
typedef struct tagNET_DVR_WALLWINCFG
{
    DWORD dwSize;
    BYTE  byEnable;
    BYTE  byRes1[7];
    DWORD dwWinNum;//window No.
    DWORD dwLayerIndex;//layer No.
    NET_DVR_RECTCFG struWinPosition;//window position
    DWORD dwDeviceIndex;//device index
    WORD  wInputIndex;//input index
    BYTE  byRes2[14];
}NET_DVR_WALLWINCFG, *LPNET_DVR_WALLWINCFG;

typedef struct tagNET_DVR_WALL_INDEX
{
    DWORD    dwSize;
    BYTE    byWallNo;    //wall no. start from 1
    BYTE    bySceneNo;    //scene no.
    BYTE    byRes1[2];
    DWORD    dwDeviceID;    //sub device index
    DWORD    dwWindowNo;    //window no./signal no.
    BYTE    byRes2[32];
}NET_DVR_WALL_INDEX, *LPNET_DVR_WALL_INDEX;

typedef struct tagNET_DVR_WALLWINPARAM
{
    DWORD dwSize;
    BYTE  byTransparency; //enable transparency\A3\AC0-disable, not 0-enable
    BYTE  byWinMode;//window mode
    BYTE  byEnableSpartan;//enable motion fluency\A3\AC0-disable\A3\AC1-enable
    BYTE  byDecResource;//decode resource alloc\A3\AC1-D1\A3\AC2-720P\A3\AC3-1080P
    BYTE  byWndShowMode;
    BYTE  byRes1[3];
    DWORD dwAmplifyingSubWndNo;
    BYTE  byRes[24];
}NET_DVR_WALLWINPARAM, *LPNET_DVR_WALLWINPARAM;

typedef struct tagNET_DVR_WALLSCENECFG
{
    DWORD dwSize;
    BYTE  sSceneName[NAME_LEN];//scene name
    BYTE    byEnable;        //0-invalid\A3\AC1-valid
    BYTE    bySceneIndex;     //scene index\A3\ACget only\A1\A3use this parameter when get all scene
    BYTE  byRes [78];
}NET_DVR_WALLSCENECFG, *LPNET_DVR_WALLSCENECFG;

typedef struct tagNET_DVR_WALLWIN_INFO
{
    DWORD dwSize;
    DWORD dwWinNum;   //window No.
    DWORD dwSubWinNum;//sub window No.
    DWORD dwWallNo;  //video wall No
    BYTE  byRes[12];
}NET_DVR_WALLWIN_INFO,*LPNET_DVR_WALLWIN_INFO;

typedef struct tagNET_DVR_WALL_WIN_STATUS
{
    DWORD dwSize ;
    BYTE  byDecodeStatus; /*corrent decode status:0:off,1 :on*/
    BYTE  byStreamType;    /*stream type*/
    BYTE  byPacketType;    /*packet type*/
    BYTE  byFpsDecV; /*video decode frame rate*/
    BYTE  byFpsDecA; /*audio decode frame rate*/
    BYTE  byRes1[7];
    DWORD dwDecodedV; /*decoded video frame number*/
    DWORD dwDecodedA; /*decoded video frame number*/
    WORD  wImgW; /*image size*/
    WORD  wImgH;
    BYTE  byStreamMode ; //stream source(valid for video platform): 1-Network, 2-Video platform inter coder, 3-screen server, 0xff-invalid
    BYTE  byRes2[31];
}NET_DVR_WALL_WIN_STATUS, *LPNET_DVR_WALL_WIN_STATUS;

typedef struct tagNET_DVR_WININDEX_INFO
{
    DWORD dwWinIndex; //window No.
    DWORD dwSubWinIndex;//sub window No.
    BYTE  byType ;//resource type\A3\AC1-decode\A3\AC2-pic preview
    BYTE  byWallNo ; //Wall No
    BYTE  byRes[6];
}NET_DVR_WININDEX_INFO, *LPNET_DVR_WININDEX_INFO;

typedef struct tagNET_DVR_ASSOCIATEDDEV_CHAN_INFO
{
    DWORD  dwSize ;
    BYTE   sAddress[MAX_DOMAIN_NAME];//address,ip or domain
    WORD   wDVRPort;                 /* port */
    WORD   wChannel;                /* channel */
    BYTE   sUserName[NAME_LEN];    /* username */
    BYTE   sPassword[PASSWD_LEN];    /* password */
    BYTE   byRes[24];
}NET_DVR_ASSOCIATEDDEV_CHAN_INFO,*LPNET_DVR_ASSOCIATEDDEV_CHAN_INFO;

typedef struct tagNET_DVR_WALLOUTPUTPARAM
{
    DWORD dwSize;
    DWORD dwResolution; //Resolution
    NET_DVR_VIDEOEFFECT struRes;
    BYTE  byVideoFormat;  //video format,0-invalid\A3\AC1-NTSC\A3\AC2-PAL
    BYTE  byDisplayMode;/*display mode,1-BNC,2-VGA,3-HDMI,4-DVI,5-SDI, 6-FIBER, 7-RGB, 8-YPrPb, 9-VGA/HDMI/DVI self adapt,0xff-invalid*/
    BYTE  byBackgroundColor; //backgroundcolor,0-invalid,1-red,2-green,3-blue,4-yellow,5-purple,6-cyan\A3\AC7-black\A3\AC8-white
    BYTE  byUseEDIDResolution; //use EDID resolution, 0-not use, 1-use
    WORD  wLEDWidth;     //LED output width resolution
    WORD  wLEDHeight;    //LED output height resolution
    BYTE  byRes2[56];
}NET_DVR_WALLOUTPUTPARAM, *LPNET_DVR_WALLOUTPUTPARAM;

#define     MAX_UNITEDMATRIX_NUM        8  //max united video platform number

typedef struct NET_DVR_SUBMATRIXSYSTEMINFO
{
    DWORD        dwSequence;//video platform number
    BYTE        sAddress[MAX_DOMAIN_NAME];//address,ip or domain
    WORD        wSubMatrixPort;        /*sub system port*/
    BYTE        byRes1[6];
    BYTE        sUserName[NAME_LEN];    /*username*/
    BYTE        sPassword[PASSWD_LEN];    /*password */
    BYTE        byRes2[36];
}NET_DVR_SUBMATRIXSYSTEMINFO,*LPNET_DVR_SUBMATRIXSYSTEMINFO;

typedef struct tagNET_DVR_UNITEDMATRIXSYSTEMINFO
{
    DWORD dwSize;
    //united video platform information
    NET_DVR_SUBMATRIXSYSTEMINFO struMatrixInfo[MAX_UNITEDMATRIX_NUM];
    BYTE  byRes[32];
}NET_DVR_UNITEDMATRIXSYSTEMINFO,*LPNET_DVR_UNITEDMATRIXSYSTEMINFO;

typedef struct tagNET_DVR_SUBSTREAM_SWITCH_CFG
{
    BYTE  byAutoSwitchEnable;
    BYTE     byRes1[3];
    WORD  wSubWndWidth;
    WORD  wSubWndHeight;
}NET_DVR_SUBSTREAM_SWITCH_CFG, *LPNET_DVR_SUBSTREAM_SWITCH_CFG;

typedef struct tagNET_DVR_WALL_CFG
{
    DWORD dwSize;
    BYTE  byTransparency;//transparency,0-100,0 represents not transparent
    BYTE  byWinStaticMode; //the display model after decode stop, 1-black screen ,2-show last frame
    BYTE  byStreamFailedMode;
    BYTE  byRes1;
    NET_DVR_SUBSTREAM_SWITCH_CFG  struSubStreamSwitch;
    BYTE  byLEDShowMode;
    BYTE  byRes[51];
}NET_DVR_WALL_CFG,*LPNET_DVR_WALL_CFG;
/********************************video wall end*********************************/

/************************************200 million pixels high definition infrared ball(V5.0.2)  begin*******************************/
typedef struct tagNET_DVR_LOW_LIGHT_CFG
{
    DWORD  dwSize;
    BYTE  byLowLightLimt;
    BYTE  byLowLightLimtLevel;
    BYTE  byRes[66];
}NET_DVR_LOW_LIGHT_CFG, *LPNET_DVR_LOW_LIGHT_CFG;

typedef struct tagNET_DVR_FOCUSMODE_CFG
{
    DWORD  dwSize;
    BYTE  byFocusMode;
    BYTE  byAutoFocusMode;
    WORD  wMinFocusDistance;
    BYTE  byZoomSpeedLevel;
    BYTE  byFocusSpeedLevel;
    BYTE  byOpticalZoom;
    BYTE  byDigtitalZoom;
    float fOpticalZoomLevel;
    DWORD dwFocusPos;
    BYTE   byFocusDefinitionDisplay;
    BYTE  byRes[55];
}NET_DVR_FOCUSMODE_CFG, *LPNET_DVR_FOCUSMODE_CFG;

typedef struct tagNET_DVR_INFRARE_CFG
{
    DWORD  dwSize;
    BYTE  byIrControlMode;
    BYTE  byIrBrightness;
    BYTE  byIrSensitivity;
    BYTE  byIrTrigMode; /* TriggerMode 0-camera,1-photosensitive (work in Auto Mode)*/
    BYTE  byIrBrightnessLimit;/* Brightness Limit (work in Auto Mode)*/
    BYTE  byRes[63];
}NET_DVR_INFRARE_CFG, *LPNET_DVR_INFRARE_CFG;

typedef struct tagNET_DVR_AEMODECFG
{
    DWORD  dwSize;
    int  iIrisSet;
    int  iGainSet;
    int  iGainLimit;
    int  iExposureCompensate;
    BYTE  byExposureModeSet;
    BYTE  byShutterSet;
    BYTE  byImageStabilizeLevel;
    BYTE  byCameraIrCorrect;
    BYTE  byHighSensitivity;
    BYTE  byInitializeLens;
    BYTE  byChromaSuppress;
    BYTE  byMaxShutterSet;     //Max Shutter Set
    BYTE  byMinShutterSet;     //Min Shutter Set
    BYTE  byMaxIrisSet; //Max Iris Set
    BYTE  byMinIrisSet;    //Min Iris Set
    BYTE  byExposureLevel;//Exposure levels (model for automatic exposure, aperture priority, shutter priority is effective), the default 4 level 1-5, compatible with the old version of the SDK configuration of new equipment, keep byte 0, so the byte 0, is also the default for exposure level is 1
    BYTE  byRes[60];
}NET_DVR_AEMODECFG, *LPNET_DVR_AEMODECFG;
typedef struct tagNET_DVR_FLASH_CFG
{
    DWORD      dwSize;
    DWORD    dwChan;
    DWORD    dwInNumbers;
    DWORD    dwOutNumbers;
    DWORD    dwStartTime;
    DWORD    dwEndTime;
    DWORD    dwEhomeFlag;
    DWORD    dwAlarmFlag;
    BYTE       byRes[1024];
}NET_DVR_FLASH_CFG, *LPNET_DVR_FLASH_CFG;
/************************************200 million pixels high definition infrared ball(V5.0.2)  end*******************************/

typedef struct tagNET_DVR_DECODER_JOINT_PARAM
{
    DWORD    dwSize;
    BYTE    byJointed;        //  0-not jointed  1-jointed
    BYTE    byRes1[3];
    NET_DVR_IPADDR    struIP;    // IP of jointed decoder
    WORD    wPort;            // Port of jointed decoder
    WORD    wChannel;        // channel of jointed decoder
    BYTE    sDeviceName[NAME_LEN];    //device name of jointed decoder
    BYTE    sChanName[NAME_LEN];    //channel name of jointed decoder
    BYTE    byRes2[32];
}NET_DVR_DECODER_JOINT_PARAM, *LPNET_DVR_DECODER_JOINT_PARAM;

/***************************************CVCS V2.1 begin**************************************/

typedef struct tagNET_MATRIX_DIGITALMATRIX
{
    NET_DVR_IPADDR  struAddress;
    WORD    wPort;
    BYTE    byNicNum; //0 - eth0, 1 - eth1
    BYTE    byRes[69];
}NET_MATRIX_DIGITALMATRIX, *LPNET_MATRIX_DIGITALMATRIX;
typedef struct tagNET_MATRIX_ANALOGMATRIX
{
    BYTE    bySerPortNum;   // Serial port , 0xff - loop through access*/
    BYTE    byMatrixSerPortType;//0 --- Matirx protocol 1 --- keyboard protocol
    BYTE    byRes1[2];
    NET_DVR_SINGLE_RS232 struRS232;    //232 serial port parameter, it is invaild when loop through access
    BYTE    byRes2[200];
}NET_MATRIX_ANALOGMATRIX, *LPNET_MATRIX_ANALOGMATRIX;

typedef union tagNET_MATRIX_UNION
{
    NET_MATRIX_DIGITALMATRIX struDigitalMatrix;
    NET_MATRIX_ANALOGMATRIX struAnalogMatrix;
}NET_MATRIX_UNION, *LPNET_MATRIX_UNION;

typedef struct tagNET_DVR_EXTERNAL_MATRIX_CFG
{
    DWORD        dwSize;
    BYTE        byValid;            // set matrix config when byValid is 1 and delete matrix when byValid is 0
    BYTE        byRes1[3];
    BYTE        sMatrixName[NAME_LEN/*32*/];       // matrix name
    DWORD          dwMatrixID;        // matrix id, only can be geted
    WORD        wMatrixInputChanNum;            // input channel number of matrix
    WORD        wMatrixOutputChanNum;            // output channel number of matrix
    WORD           wMatrixOutputChanRef[MAX_CAM_COUNT];   // the relation between output channel of matrix and input channel of cvcs
    //when > 0, it means bind output channel to input channel, when = 0, it means delete the binding. screen server use screen index and  matrix output channel to bind
    BYTE        byMatrixChanType;// matrix type 1-BNC\A1\A22-VGA\A1\A23-RGB\A1\A24-DVI
    BYTE        byMatrixProtocol;    // matrix protocol 1\A1\A2ZT1.0\A1\A22.ZT2.0\A1\A23.Extron\A1\A24.Creator
    BYTE        byMatrixType;        //1-analog matrix\A3\AC2-digital matrix
    BYTE        byRes2;
    NET_MATRIX_UNION struMatrixUnion;
    BYTE        byRes3[128];
}NET_DVR_EXTERNAL_MATRIX_CFG, *LPNET_DVR_EXTERNAL_MATRIX_CFG;


#define MAX_INPUTNUMS 1024
#define MAX_OUTPUTNUMS 256
typedef struct tagNET_DVR_ASSOCIATE_INPUT_PARAM
{
    BYTE    byEnable;
    BYTE    byRes1[3];
    DWORD    dwDeviceIndex;    //device index of dvcs
    WORD    wInputIndex;    //input signal index
    BYTE    byRes2[18];
}NET_DVR_ASSOCIATE_INPUT_PARAM, *LPNET_DVR_ASSOCIATE_INPUT_PARAM;

typedef struct tagNET_DVR_ASSOCIATE_OUTPUT_PARAM
{
    BYTE    byEnable;
    BYTE    byWallNo;        //wall no. start from 1
    BYTE    byRes1[2];
    DWORD    dwOutputIndex;    //screen index
    BYTE    byRes2[20];
}NET_DVR_ASSOCIATE_OUTPUT_PARAM,*LPNET_DVR_ASSOCIATE_OUTPUT_PARAM;

typedef struct tagNET_DVR_VCS_USER_INFO
{
    DWORD    dwSize;
    BYTE    sUserName[NAME_LEN];        // username\A3\ACmax length is 16
    BYTE    sPassWord[PASSWD_LEN];        // password
    NET_DVR_IPADDR    struUserIP;            // ip address, 0 means every ip
    BYTE    byMacAddr[MACADDR_LEN];        // mac address
    BYTE    byPriority;                    // priority 1-administrator\A3\AC2-operater
    BYTE    byRes1;
    DWORD    dwRight;/*remote right\A3\ACevery bit is a right\A3\AC0-not support\A3\AC1-support*/
    //bit0-get/set base parameter
    //bit1-manage screen
    //bit2-manage window
    //bit3-manage signal source
    //bit4-manage layout
    //bit5-manage plan
    //bit6-manage picture
    //bit7-manage OSD
    //bit8-picture view
    //bit9-arm
    //bit10-upgrade
    //bit11-resume
    //bit12-input and output config file
    //bit13-search log
    //bit14-restart
    //bit15-Screen area manage
    NET_DVR_ASSOCIATE_INPUT_PARAM struInputParam[MAX_INPUTNUMS/*1024*/];
    NET_DVR_ASSOCIATE_OUTPUT_PARAM struOutputParam[MAX_OUTPUTNUMS/*256*/];
    NET_DVR_RECTCFG_EX struManageRegion;   //screen manage region
    BYTE   byWallNo;    //wall No. of screen area manage
    BYTE   byRes[107];
} NET_DVR_VCS_USER_INFO, *LPNET_DVR_VCS_USER_INFO;
/***************************************CSCS V2.1 end**************************************/

/*************************************63T 64T 65D V2.0.0 start****************************/
typedef struct tagNET_DVR_STREAM_MEDIA_SERVER_CFG_V41
{
    BYTE    byValid; //enable media server\A3\AC0-disable\A3\AC1-enable
    BYTE    byRes1[3];
    BYTE    byAddress[MAX_DOMAIN_NAME];   //IP or domain
    WORD    wDevPort;            /*media server port*/
    BYTE    byTransmitType;        /*transmit type 0-TCP\A3\AC1-UDP*/
    BYTE    byRes2[69];
}NET_DVR_STREAM_MEDIA_SERVER_CFG_V41,*LPNET_DVR_STREAM_MEDIA_SERVER_CFG_V41;

typedef struct tagNET_DVR_DEV_CHAN_INFO_V41
{
    BYTE    byAddress[MAX_DOMAIN_NAME];    //domain of device
    WORD     wDVRPort;                 //device port
    BYTE     byChannel;                //channel num
    BYTE    byTransProtocol;        //transmit type 0-TCP\A3\AC1-UDP
    BYTE    byTransMode;            //stream mode 0\A3\ADmain stream 1\A3\ADsub stream
    BYTE    byFactoryType;            /*device factory type*/
    BYTE    byDeviceType; //Device type(Used by videoplatfom VCA card)\A3\AC1-decoder\A3\A8use decode channel No. or display channel depends on byVcaSupportChanMode in videoplatform ability struct\A3\A9\A3\AC2-coder
    BYTE    byDispChan;//Display channel No. used by VCA configuration
    BYTE    bySubDispChan;//Display sub channel No. used by VCA configuration
    BYTE    byResolution;    //Resolution: 1-CIF 2-4CIF 3-720P 4-1080P 5-500w used by big screen controler
    BYTE    byRes[2];
    BYTE    sUserName[NAME_LEN];    //Remote device user name
    BYTE    sPassword[PASSWD_LEN];    //Remote device password
}NET_DVR_DEV_CHAN_INFO_V41,*LPNET_DVR_DEV_CHAN_INFO_V41;

typedef struct tagNET_DVR_STREAM_MEDIA_SERVER
{
    BYTE   byValid;
    BYTE   byRes1[3];
    BYTE   byAddress[MAX_DOMAIN_NAME];   //IP or Domain
    WORD   wDevPort;            /*Stream Media Server Port*/
    BYTE   byTransmitType;        /*Stream Trans Protocol 0-TCP\A3\AC1-UDP*/
    BYTE   byRes2[5];
}NET_DVR_STREAM_MEDIA_SERVER,*LPNET_DVR_STREAM_MEDIA_SERVER;

typedef struct tagNET_DVR_DEV_CHAN_INFO_EX
{
    BYTE    byChanType;              //Channal Type\A3\AC0-Normal Channal,1-Zero Channal,2-Stream ID,3-Local input,4-virtual screen server channel,5-Joint channel,6-screen server
    BYTE    byStreamId[STREAM_ID_LEN];//Stream ID
    BYTE    byRes1[3];
    DWORD   dwChannel;   //Channel No.
    BYTE    byRes2[24];
    BYTE    byAddress[MAX_DOMAIN_NAME];    //Device Domain
    WORD     wDVRPort;                 //Port
    BYTE     byChannel;                //Channel No. if dwChannel is not equal to 0,this value is invalid
    BYTE    byTransProtocol;        //Stream Trans Protocol 0-TCP\A3\AC1-UDP
    BYTE    byTransMode;            //Stream Trans Mode 0\A3\ADMain Stream  1\A3\ADSub stream
    BYTE    byFactoryType;            /*Factory Type*/
    BYTE    byDeviceType; //Device Type\A3\AC1-Decoder\A3\AC2-Encoder
    BYTE    byDispChan;//Display Channel Number
    BYTE    bySubDispChan;//Display Sub Channel Number
    BYTE    byResolution;    //; 1-CIF 2-4CIF 3-720P 4-1080P 5-500w big Stream use
    BYTE    byRes[2];
    BYTE    sUserName[NAME_LEN];    //Remote user
    BYTE    sPassword[PASSWD_LEN];    //Remote Password
}NET_DVR_DEV_CHAN_INFO_EX,*LPNET_DVR_DEV_CHAN_INFO_EX;

typedef struct tagNET_DVR_DEC_STREAM_DEV_EX
{
    NET_DVR_STREAM_MEDIA_SERVER    struStreamMediaSvrCfg;
    NET_DVR_DEV_CHAN_INFO_EX                struDevChanInfo;
}NET_DVR_DEC_STREAM_DEV_EX,*LPNET_DVR_DEC_STREAM_DEV_EX;

typedef struct tagNET_DVR_DEC_STREAM_DEV
{
    NET_DVR_STREAM_MEDIA_SERVER_CFG_V41    struStreamMediaSvrCfg;
    NET_DVR_DEV_CHAN_INFO_V41                struDevChanInfo;
}NET_DVR_DEC_STREAM_DEV,*LPNET_DVR_DEC_STREAM_DEV;

typedef struct tagNET_DVR_DEV_DDNS_INFO
{
    BYTE   byDevAddress[MAX_DOMAIN_NAME];    //Domain
    BYTE   byTransProtocol;        //Trans protocol 0-TCP\A3\AC1-UDP, 2-MCAST
    BYTE   byTransMode;            //Stream Trams Mode 0\A3\ADMain Stream 1\A3\ADSub Stream
    BYTE   byDdnsType;         //Server TYPE\A3\AC0-IPServer 1\A3\ADDyndns 2\A3\ADPeanutHull\A3\AC3- NO-IP, 4- hiDDNS
    BYTE   byRes1;
    BYTE   byDdnsAddress[MAX_DOMAIN_NAME];  //DDNS Server Address
    WORD   wDdnsPort;                 //DDNS Server Port
    BYTE   byChanType;              //0-Normal Channal,1-Zero Channal,2-Stream ID
    BYTE   byFactoryType;            //Factory Type
    DWORD  dwChannel; //Channal Number
    BYTE   byStreamId[STREAM_ID_LEN]; //Stream ID
    BYTE   sUserName[NAME_LEN];    //Remote User
    BYTE   sPassword[PASSWD_LEN];    //Remote Password
    WORD   wDevPort;                //Remote Port
    BYTE   byRes2[2];
}NET_DVR_DEV_DDNS_INFO,*LPNET_DVR_DEV_DDNS_INFO;

typedef struct tagNET_DVR_DEC_DDNS_DEV
{
    NET_DVR_DEV_DDNS_INFO struDdnsInfo;
    NET_DVR_STREAM_MEDIA_SERVER struMediaServer;
}NET_DVR_DEC_DDNS_DEV,*LPNET_DVR_DEC_DDNS_DEV;

typedef union tagNET_DVR_DEC_STREAM_MODE
{
    NET_DVR_DEC_STREAM_DEV_EX struDecStreamDev;
    NET_DVR_PU_STREAM_URL struUrlInfo;
    NET_DVR_DEC_DDNS_DEV struDdnsDecInfo;
    BYTE byRes[300];
}NET_DVR_DEC_STREAM_MODE,*LPNET_DVR_DEC_STREAM_MODE;

typedef struct tagNET_DVR_PU_STREAM_CFG_V41
{
    DWORD                                dwSize;
    BYTE                                byStreamMode;//stream mode\A3\AC0-invalid\A3\AC1-get stream by IP or Domain\A3\AC2-get stream by URL
    BYTE                                byRes1[3];
    NET_DVR_DEC_STREAM_MODE             uDecStreamMode;//stream info
    BYTE  byRes2[64];
}NET_DVR_PU_STREAM_CFG_V41,*LPNET_DVR_PU_STREAM_CFG_V41;

typedef struct  tagNET_DVR_MATRIX_CHAN_INFO_V41
{
    BYTE                                byEnable; //enable the node\A3\AC0-disable\A3\AC1-enable
    BYTE                                byStreamMode;//stream mode\A3\AC0-invalid\A3\AC1-get stream by IP or Domain\A3\AC2-get stream by URL
    BYTE                                byRes[2];
    NET_DVR_DEC_STREAM_MODE             uDecStreamMode;//stream info
}NET_DVR_MATRIX_CHAN_INFO_V41,*LPNET_DVR_MATRIX_CHAN_INFO_V41;

typedef struct  tagNET_DVR_MATRIX_LOOP_DECINFO_V41
{
    DWORD                            dwSize;
    DWORD                            dwPoolTime;        /*loop interval*/
    NET_DVR_MATRIX_CHAN_INFO_V41    struchanConInfo[MAX_CYCLE_CHAN_V30];
    BYTE                           byRes[16];
}NET_DVR_MATRIX_LOOP_DECINFO_V41,*LPNET_DVR_MATRIX_LOOP_DECINFO_V41;

typedef struct tagNET_DVR_MATRIX_DEC_CHAN_INFO_V41
{
    DWORD    dwSize;
    BYTE                                byStreamMode;//stream mode\A3\AC0-invalid\A3\AC1-get stream by IP or Domain\A3\AC2-get stream by URL
    BYTE                                byRes1[3];
    NET_DVR_DEC_STREAM_MODE             uDecStreamMode;//decode stream info
    DWORD    dwPlayMode;        /* 0-dynamic decode 1\A3\ADloop decode 2\A3\ADpaly back by time 3\A3\ADpaly back by name */
    NET_DVR_TIME StartTime;         /* start time for playback by time mode,  */
    NET_DVR_TIME StopTime;         /* stop time for playback by time mode */
    char    sFileName[128];         /* file name for playback by file mode */
    DWORD   dwGetStreamMode;    //Fetch Stream Mode: 1- Positive, 2- Passive
    NET_DVR_MATRIX_PASSIVEMODE    struPassiveMode;
    BYTE    byRes2[32];
}NET_DVR_MATRIX_DEC_CHAN_INFO_V41,*LPNET_DVR_MATRIX_DEC_CHAN_INFO_V41;

/*************************************63T 64T 65D V2.0.0 end******************************/
typedef struct tagNET_DVR_TRUNK_USE_STATE
{
    DWORD        dwSize;
    DWORD        dwTrunkID;    //trunk ID
    WORD        wReserveUserID;    //reserve user ID\A3\BA 1~256 \A3\AC0 means release trunk
    BYTE        byStatus;  //1-free\A3\AC2-used\A3\AC3-reuse */
    BYTE        byRes1;
    BYTE          byUserId[256];  //Array subscript is user id\A3\ACthe user 1 is using it when byUserID[0] is 1.
    BYTE           byRes2[64];
}NET_DVR_TRUNK_USE_STATE,  *LPNET_DVR_TRUNK_USE_STATE;


typedef struct tagNET_DVR_PTZ_CTRL_INFO
{
    DWORD    dwSize;
    DWORD    dwCtrlDelayTime;        //PTZ control time, the user of low lever can not use it in this time, unit: s
    BYTE    byRes[64];
}NET_DVR_PTZ_CTRL_INFO, *LPNET_DVR_PTZ_CTRL_INFO;

#define        MAX_MATRIX_CASCADE        32
typedef struct tagNET_DVR_MATRIX_ROUTE_INFO
{
    DWORD        dwSize;
    DWORD           dwCamNo;
    DWORD       dwMonNo;
    DWORD        dwSubWin;
    DWORD        dwUserId;
    DWORD       dwTrunkId[MAX_MATRIX_CASCADE/*32*/];//trunkId[0] is the first cascade\A3\ACtrunkId[1] is the second cascade, there is no trunk when trunkId[i] is 0
    BYTE        byRes[64];
}NET_DVR_MATRIX_ROUTE_INFO, *LPNET_DVR_MATRIX_ROUTE_INFO;

typedef struct tagNET_DVR_PTZ_STATUS
{
    DWORD        dwSize;
    DWORD        dwUserID;    //1~256\A3\AC0 means no user
    DWORD       dwStatus;      // PTZ control state 0-stop\A1\A21-run
    DWORD        dwRestTime;  //rest time
    BYTE        byRes[64];
}NET_DVR_PTZ_STATUS, *LPNET_DVR_PTZ_STATUS;


typedef struct tagNET_DVR_SAFETYCABIN_WORK_MODE
{
    DWORD dwSize;
    BYTE  byWorkMode; //work mode\A3\AC0-always open if no person\A3\AC1-always locked if no person
    BYTE  byRes[15];
}NET_DVR_SAFETYCABIN_WORK_MODE,*LPNET_DVR_SAFETYCABIN_WORK_MODE;

typedef struct tagNET_DVR_SAFETYCABIN_PERSON_SIGNAL_CFG
{
    DWORD dwSize;
    BYTE  bySensorType; //sensor type,0-Infrared,1-curtain
    BYTE  bySensitivity; //sensor sensitivity,range:0-100
    BYTE  byDevUseTimeout; //cabin use timeout,unit:min,range:5-30,default:15min,upload alarm when timeout
    BYTE  byRes1;
    WORD  wCurtainDelayTime; //curtain sensor delay time,unit:second\A3\ACrange\A3\BA0-10
    WORD  wCurtainResponseTime; //curtain sensor response time,unit:second, range:0-300
    BYTE  byRes2[32];
}NET_DVR_SAFETYCABIN_PERSON_SIGNAL_CFG,*LPNET_DVR_SAFETYCABIN_PERSON_SIGNAL_CFG;

/********************************IPC 5.0 SDK BEG***************************************/

typedef struct tagNET_DVR_ETHERNET_IPV6_COND
{
    DWORD        dwSize;
    BYTE  byMACAddr[MACADDR_LEN]; //The physical address of the network card
    BYTE  byRes[64];
}NET_DVR_ETHERNET_IPV6_COND,*LPNET_DVR_ETHERNET_IPV6_COND;

typedef struct tagNET_DVR_ETHERNET_IPV6_CFG
{
    DWORD        dwSize;
    BYTE  byState;              //IPv6 status, 0 - routing allocation 1 - automatically set
    BYTE  byRes1[3];
    BYTE  byIPv6[MAX_IPV6_LEN]; //IPv6 address
    BYTE  byRes[64];
}NET_DVR_ETHERNET_IPV6_CFG,*LPNET_DVR_ETHERNET_IPV6_CFG;
/********************************IPC 5.0 SDK END***************************************/

/*********************************IPC 5.1.0 begin**************************************/
typedef struct  //8
{
    BYTE byHour;//0~24
    BYTE byMinute;//0~60
    BYTE bySecond;//0~60
    BYTE byRes;
    WORD wMilliSecond; //0~1000
    BYTE byRes1[2];
}NET_DVR_DAYTIME,*LPNET_DVR_DAYTIME;

typedef struct
{
    NET_DVR_DAYTIME  struStartTime;
    NET_DVR_DAYTIME  struStopTime;
}NET_DVR_SCHEDULE_DAYTIME, *LPNET_DVR_SCHEDULE_DAYTIME;

typedef struct
{
    BYTE byObjectSize;//ObjectSize[0,100]
    BYTE byMotionSensitive; /*MotionSensitive, [1,100],0xff close*/
    BYTE byRes[6];
}NET_DVR_DNMODE, *LPNET_DVR_DNMODE;

typedef struct //60
{
    BYTE byAreaNo;//Area No(IPC- 1~8)
    BYTE byRes[3];
    NET_VCA_RECT struRect;
    NET_DVR_DNMODE  struDayNightDisable;
    NET_DVR_DNMODE  struDayModeParam;
    NET_DVR_DNMODE  struNightModeParam;
    BYTE byRes1[8];
}NET_DVR_MOTION_MULTI_AREAPARAM, *LPNET_DVR_MOTION_MULTI_AREAPARAM;

typedef struct
{
    BYTE byDayNightCtrl;//DayNightCtrl 0~close,1~Auto,2~Schedule
    BYTE byAllMotionSensitive;
    BYTE byRes[2];
    NET_DVR_SCHEDULE_DAYTIME struScheduleTime;
    NET_DVR_MOTION_MULTI_AREAPARAM struMotionMultiAreaParam[MAX_MULTI_AREA_NUM];
    BYTE byRes1[60];
}NET_DVR_MOTION_MULTI_AREA,*LPNET_DVR_MOTION_MULTI_AREA;

typedef struct
{
    BYTE byMotionScope[64][96];        /*Motion detection area, 0- 96 bits stand for 64 lines and there are 96*64 small areas,  1- - it is motion detection area, 0- - not*/
    BYTE byMotionSensitive;            /*sensitive grade of motion detection,  0 -  5 (5 is most sensitive) ,  oxff turn off*/
    BYTE byRes[3];
}NET_DVR_MOTION_SINGLE_AREA, *LPNET_DVR_MOTION_SINGLE_AREA;

typedef struct
{
    NET_DVR_MOTION_SINGLE_AREA  struMotionSingleArea; //Normal mode
    NET_DVR_MOTION_MULTI_AREA struMotionMultiArea; //Expert mode
}NET_DVR_MOTION_MODE_PARAM, *LPNET_DVR_MOTION_MODE_PARAM;

typedef struct
{
    NET_DVR_MOTION_MODE_PARAM  struMotionMode;
    BYTE byEnableHandleMotion;/* Process motion alarm  0- No 1- Yes*/
    BYTE byEnableDisplay;    /*Display motion detect,0- No 1- Yes*/
    BYTE byConfigurationMode; //0~Nomrmal,1~Expert
    BYTE byRes1;
    DWORD   dwHandleType;////Way to handle,  result of operation OR
    /*0x00:  No response*/
    /*0x01:  Alarm on monitor*/
    /*0x02:  Audio Alarm*/
    /*0x04:  Upload to center*/
    /*0x08:  Trigger alarm output*/
    /*0x10:  Grab JPEG image and EMail it*/
    /*0x20:  wireless voice and light alarm*/
    /*0x40:  Trigger electric map(only PCNVR supports)*/
    /*0x200: capture jpeg and update to FTP*/
    /*0x1000:capture jpeg and update to cloud*/
    DWORD   dwMaxRelAlarmOutChanNum ; //the max of dvr support can trigger the alarm output channel number (read-only)
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40]; //The actual trigger alarm output, according to the values, the compact arrangement, the subscript 0 - dwRelAlarmOut -1 effectively, if encountered in the middle 0xFFFFFFFF, subsequent invalid
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];
    DWORD     dwMaxRecordChanNum;   //The maximum number of channels - video equipment support read-only
    DWORD     dwRelRecordChan[MAX_CHANNUM_V40];     /* The actual trigger video channel, according to the values, the compact arrangement, the subscript 0 - dwRelRecordChan -1 effectively, if encountered in the middle 0xFFFFFFFF, subsequent invalid*/
    BYTE  byRes[128];
}NET_DVR_MOTION_V40,*LPNET_DVR_MOTION_V40;

typedef struct
{
    DWORD dwEnableVILostAlarm;                /* Enable Video Lost Alarm 0-no,1-yes*/
    DWORD   dwHandleType;        //Way to handle,  result of operation OR
    /*0x00:  No response*/
    /*0x01:  Alarm on monitor*/
    /*0x02:  Audio Alarm*/
    /*0x04:  Upload to center*/
    /*0x08:  Trigger alarm output*/
    /*0x10:  Grab JPEG image and EMail it*/
    /*0x20:  wireless voice and light alarm*/
    /*0x40:  Trigger electric map(only PCNVR supports)*/
    /*0x200: capture jpeg and update to FTP*/
    /*0x1000:capture jpeg and update to cloud*/
    DWORD   dwMaxRelAlarmOutChanNum ; //Alarm output channel trigger (read-only) maximum support number
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40]; /*Trigger the alarm output, according to the values, the compact arrangement, the subscript 0 - dwRelAlarmOut -1 effectively, if encountered in the middle 0xFFFFFFFF, subsequent invalid*/
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];
    BYTE    byVILostAlarmThreshold;    /*0-99*/
    BYTE    byRes[63];
}NET_DVR_VILOST_V40,*LPNET_DVR_VILOST_V40;

typedef struct
{
    NET_DVR_COLOR      struColor[MAX_TIMESEGMENT_V30];
    NET_DVR_SCHEDTIME  struHandleTime[MAX_TIMESEGMENT_V30];
}NET_DVR_VICOLOR, *LPNET_DVR_VICOLOR;


typedef struct
{
    DWORD  dwSize;
    BYTE  sChanName[NAME_LEN];
    DWORD  dwVideoFormat;        /* Read only,  Video Standard 1- NTSC 2- PAL*/
    NET_DVR_VICOLOR struViColor;
    DWORD  dwShowChanName; // Display channel name or not, 0- no, 1- display size = 704*576
    WORD    wShowNameTopLeftX;/* X- coordinate of display position */
    WORD    wShowNameTopLeftY;/* Y- coordinate of display position  */
    DWORD  dwEnableHide;        /* Enable Tamper Alarm , 0- disable, 1- enable*/
    NET_DVR_SHELTER struShelter[MAX_SHELTERNUM];
    //OSD
    DWORD  dwShowOsd;    // Display OSD or not, 0- No OSD, 1- Display Area for display:  704*576
    WORD   wOSDTopLeftX;/* X- coordinate of OSD */
    WORD   wOSDTopLeftY;/* Y- coordinate of OSD*/
    BYTE    byOSDType;/* OSD Type  (format of Year/Month/Day)  */
    /* 0: XXXX- XX- XX Year Month Day */
    /* 1: XX- XX- XXXX Month Day Year */
    /* 2: XXXXYearXXNonthXXDay */
    /* 3: XXMonthXXDayXXXXYear */
    /* 4: XX- XX- XXXX Day Month Year*/
    /* 5: XXDayXXMonthXXXXYear */
    /* 6: xx/xx/xxxx(Month/Day/Year) */
    /* 7: xxxx/xx/xx(Year/Month/Day) */
    /* 8: xx/xx/xxxx(Day/Month/Year)*/
    BYTE    byDispWeek;    /* display Week */
    BYTE    byOSDAttrib;/* OSD attribute:  Transparent, Flash */
    /* 1:  Transparent, Flash */
    /* 2:  Transparent, not Flash */
    /* 3:  Flash, not Transparent */
    /* 4:  not Transparent,  not Flash */
    BYTE    byHourOSDType;/* : 24- Hour system, 12- Hour system */
    BYTE    byFontSize;
    BYTE    byOSDColorType;    //0-default\A3\BB1-Custom
    BYTE    byAlignment;//Alignment
    BYTE    byOSDMilliSecondEnable;//OSD MilliSecond Enable
    NET_DVR_VILOST_V40 struVILost;
    NET_DVR_VILOST_V40 struAULost;
    NET_DVR_MOTION_V40 struMotion;
    NET_DVR_HIDEALARM_V40 struHideAlarm;
    NET_DVR_RGB_COLOR    struOsdColor;//OSD color
    BYTE    byRes[124];
}NET_DVR_PICCFG_V40,*LPNET_DVR_PICCFG_V40;

typedef struct  //
{
    DWORD                   dwSize;
    BYTE   byWorkType;// 0-SelfAdaptive mode, 1-Schedule mode
    BYTE   byRes[3];
    NET_DVR_SCHEDULE_DAYTIME  struDayNightScheduleTime;
    NET_DVR_CAMERAPARAMCFG_EX   struSelfAdaptiveParam;
    NET_DVR_CAMERAPARAMCFG_EX   struDayIspAdvanceParam;
    NET_DVR_CAMERAPARAMCFG_EX   struNightIspAdvanceParam;
    BYTE   byRes1[512];
}NET_DVR_ISP_CAMERAPARAMCFG,*LPNET_DVR_ISP_CAMERAPARAMCFG;

typedef struct
{
    DWORD       dwSize;
    BYTE         byIrLampServer;//IR lamp Server Cfg 0\A1\ABclose\A3\AC1\A1\ABopen
    BYTE         bytelnetServer;//telnet  Server Cfg 0\A1\ABclose\A3\AC1\A1\ABopen
    BYTE         byABFServer;//ABF cfg 0\A1\ABopen\A3\AC1\A1\ABclose
    BYTE         byEnableLEDStatus;//State indicating lamp control 0\A1\ABclose\A3\AC1\A1\ABopen
    BYTE         byEnableAutoDefog;//Automatic defrosting control 0\A1\ABopen, 1\A1\ABclose
    BYTE         byEnableSupplementLight;//Supplement Light\A3\BB0-open\A3\AC1-close
    BYTE         byEnableDeicing;//Deicing 0-close\A3\AC1-open
    BYTE         byRes[249];
}NET_DVR_DEVSERVER_CFG,*LPNET_DVR_DEVSERVER_CFG;

typedef struct tagNET_DVR_GBT28181_ACCESS_CFG
{
    DWORD         dwSize;
    BYTE         byEnable;//28181 protcol enable ; 0-close 1-open
    BYTE         byTransProtocol;//TransProtocol:0-UDP\A1\A21-TCP\A1\A2default 0-UDP
    WORD         wLocalSipPort;//1024-65535(IPC)
    char         szServerID[MAX_SERVERID_LEN];
    char         szServerDomain[MAX_SIPSERVER_ADDRESS_LEN];
    char         szSipServerAddress[MAX_SIPSERVER_ADDRESS_LEN];
    WORD         wServerSipPort;
    BYTE         byProtocolVersion;
    BYTE         byRes3;
    char         szSipUserName[MAX_SERVERNAME_LEN];
    char         szSipAuthenticateID[MAX_AUTHENTICATEID_LEN];
    char         szSipAuthenticatePasswd[MAX_AUTHENTICATEPASSWD_LEN];
    DWORD        dwRegisterValid;
    BYTE         byHeartbeatInterval;
    BYTE         byMaxHeartbeatTimeOut;
    BYTE         byStreamType;
    BYTE            byDeviceStatus; //Whether the equipment online, 0- reserve, 1- online, 2- offline
    DWORD        dwRegisterInterval;//Registration: registration failure interval register again time interval, the range of 60-600s, the default 60s
    DWORD        dwAutoAllocChannelID ; // whether to auto distribute channel ID , every bit has meaning, 0 - manual set, 1 - auto distribute, bit1-auto distribute code channel, bit2-auto distribute alarm in channel, bit3-auto distribute code channel ID
    char         szDeviceDomain[MAX_SIPSERVER_ADDRESS_LEN] ;//Device domain
    BYTE         byRes4[116];
}NET_DVR_GBT28181_ACCESS_CFG,*LPNET_DVR_GBT28181_ACCESS_CFG;


typedef struct tagNET_DVR_GBT28181_CHANINFO_CFG
{
    DWORD                   dwSize;
    char    szVideoChannelNumID[MAX_COMPRESSIONID_LEN];
    BYTE             byRes[256];
}NET_DVR_GBT28181_CHANINFO_CFG,*LPNET_DVR_GBT28181_CHANINFO_CFG;


typedef struct tagNET_DVR_ALARMIN_INFO
{
    NET_DVR_STREAM_INFO struStreamInfo;
    DWORD  dwAlarmInChannel;
    BYTE  byRes[32];
}NET_DVR_ALARMIN_INFO,*LPNET_DVR_ALARMIN_INFO;


typedef struct tagNET_DVR_GBT28181_ALARMINCFG
{
    DWORD                   dwSize;
    char    szAlarmInNumID[MAX_COMPRESSIONID_LEN];//dev Alarm input ID
    BYTE             byRes[256];
}NET_DVR_GBT28181_ALARMINCFG,*LPNET_DVR_GBT28181_ALARMINCFG;
/*********************************IPC 5.1.0 end**************************************/

/*********************************Capture machineV2V3 begin**************************************/
typedef struct tagNET_DVR_CAMERA_SETUPCFG
{
    DWORD dwSize;
    WORD wSetupHeight; //Erecting height [0,20] units: meters
    BYTE byLensType; //The focal length of the lens type\A3\AC0-unknow,1-8mm,2-12mm,3-16mm,4-25mm,5-35mm,6-50mm,7-4mm,8-6mm
    BYTE bySetupHeightUnit;// Height 0 ~ M, 1~CM
    DWORD dwSceneDis; //Between the edge position and camera image under the horizontal distance, unit: cm
    float fPitchAngle; //Camera pitch angle [-180 \A1\E3, 180 \A1\E3], float * 1000
    float fInclineAngle; //Camera tilt angle [-180 \A1\E3, 180 \A1\E3], float * 1000
    float fRotateAngle;  //Camera rotation angle [-180 \A1\E3, 180 \A1\E3], float * 1000
    WORD  wVideoDetCoefficient; //Video test coefficient [0300] (3.6 new)
    BYTE  byErectMethod; //Erection of 0- dress, 1- side mounted (3.6 new)
    BYTE  byCameraViewAngle;//The camera view (0- vertical, 1- inclined, \A3\A8Default\A3\A9 0- vertical)
    DWORD dwHorizontalDistance;//Camera Horizontal distance: 1-1000, (Default) 30, unit\A3\BAcm, pay attention to the camera angle to tilt the effective
    BYTE  byDetailLensType;//Range\A3\BA 1-100, Default\A3\BA 28, unit\A3\BA 0.1mm
    BYTE  byRes[3];
    float fHorFieldAngle; //[0\A1\E3, 360\A1\E3]
    float fVerFieldAngle; //[0\A1\E3, 360\A1\E3]
    BYTE  byRes1[24];
}NET_DVR_CAMERA_SETUPCFG, *LPNET_DVR_CAMERA_SETUPCFG;

typedef struct tagNET_DVR_SCHEDDATE
{
    BYTE   byStartMonth;   //Start month
    BYTE   byStartDay;     //Start day
    BYTE   byStopMonth;    //Stop month
    BYTE   byStopDay;      //Stop day
}NET_DVR_SCHEDDATE,*LPNET_DVR_SCHEDDATE;

typedef struct tagNET_DVR_OUTPUT_SCHEDULE
{
    NET_DVR_SCHEDTIME struTime;  //Time when take effect
    BYTE byState;                //0\A8COff, 1\A8COn
    BYTE byRes[11];              //Reserved
} NET_DVR_OUTPUT_SCHEDULE ,*LPNET_DVR_OUTPUT_SCHEDULE;

typedef struct tagNET_DVR_ONE_OUTPUT_SCHEDULE_RULE
{
    BYTE                     byEnable;    //0-Disable,1-Enable
    BYTE                     byRes1[3];   //Reserved
    NET_DVR_SCHEDDATE        struDate;    //Date in which this rule takes effect
    NET_DVR_OUTPUT_SCHEDULE  struOutputSchedule[MAX_TIMESEGMENT_V30];  //Support max 8 time segments one day
    BYTE                     byRes2[16];  //Reserved
}NET_DVR_ONE_OUTPUT_SCHEDULE_RULE,*LPNET_DVR_ONE_OUTPUT_SCHEDULE_RULE;

typedef struct tagNET_DVR_OUTPUT_SCHEDULE_RULECFG
{
    DWORD  dwSize; //Structure size
    NET_DVR_ONE_OUTPUT_SCHEDULE_RULE struOutputRule[MAX_RULE_NUM]; //Support max 8 date segments on year
    BYTE   byRes[64];  //Reserved
}NET_DVR_OUTPUT_SCHEDULE_RULECFG,*LPNET_DVR_OUTPUT_SCHEDULE_RULECFG;

//Traffic statistics alarm parameters
typedef struct tagNET_DVR_TPS_ALARMCFG
{
    DWORD dwSize;
    BYTE byEnable; //Whether to enable traffic statistics alarm upload
    BYTE byRes1[3];    //
    DWORD dwInterval;//The Statistics interval (unit: minutes)
    BYTE  byRes[248];
}NET_DVR_TPS_ALARMCFG, *LPNET_DVR_TPS_ALARMCFG;

typedef struct tagNET_DVR_DOWNLOAD_ALARM_RECORD_COND
{
    DWORD dwSize;
    WORD  wAlarmRecordID;    //The alarm recording ID (used to query video only when byResultType 2)
    BYTE  byRes[130];
}NET_DVR_DOWNLOAD_ALARM_RECORD_COND, *LPNET_DVR_DOWNLOAD_ALARM_RECORD_COND;
/*********************************Capture machineV2V3 end**************************************/

/*********************************Capture machineV5 begin**************************************/
typedef struct tagNET_DVR_CABINET_AlARM_PARAMCFG
{
    char  sCabinetName[NAME_LEN];
    BYTE  byAssociateIO;//wherein 1-4 represents a IO channel, specific, 0xff is not enabled
    BYTE  byCabinetState;//The 0- low level, the 1- high level
    BYTE  byAlarmIntervalTime;//The range of 1-60, unit: s
    BYTE  byRes1[25];
}NET_DVR_CABINET_AlARM_PARAMCFG, *LPNET_DVR_CABINET_AlARM_PARAMCFG;

typedef struct tagNET_DVR_CABINET_CFG
{
    DWORD dwSize;
    BYTE  byEnable;//0 not enabled, 1 enabled
    BYTE  byRes[3];
    NET_DVR_CABINET_AlARM_PARAMCFG struCabinetCfg[MAX_CABINET_COUNT];
    BYTE  byRes1[84];
} NET_DVR_CABINET_CFG, *LPNET_DVR_CABINET_CFG;
/*********************************Capture machineV5 end**************************************/

/*************************************TS-5XXX-L begin*******************************/
typedef  struct  tagNET_ITS_GATE_LANE_CFG
{
    BYTE      byGateSiteID[MAX_ID_LEN];    //Gate Numbers
    BYTE      byGateInfo[MAX_ID_LEN];      //Gate Info
    BYTE      byLaneName[NAME_LEN];
    BYTE      byValid;              //0 indicates whether to enable is not enabled, 1 to enable
    BYTE      byCamLaneId;     //The corresponding camera lane number from 1 to 16 (camera configuration lane number, you can jump, can be the same)
    WORD      wLaneid;            //Lane number 1 to 32 (index lane number, you can jump logic lane)
    BYTE      byRelativeIoNum;         //Logical lane number associated output port number
    BYTE      byDirection;          //The direction number; 0 - 1 admission 2 3 appearances bidirectional
    BYTE      byLprMode; //Brand identification release all configuration 0 into 1 in addition to the blacklist into the white list into
    BYTE       byCardMode; //The card release configuration 0 all into an addition to the blacklist into the white list into
    BYTE       byGateLaneMode;//Release of entrances and exits configuration mode - all into 1 - only the brand identify matching release only credit card matching put / / line 3 - brand identification card has a matching release - brand identification card at the same time match release - all into
    //2013-11-19 Add Parameter
    BYTE      byCharge;//Charge 0- No Charge\A3\AC1-Charge
    BYTE      byChargeMode;//Charge Mode 0-Plate Charge\A3\AC1-Card Charge
    BYTE      byRes1;
    BYTE      byLedRelativeIndex[MAX_INDEX_LED];//LED Relative Index (1~255)
    BYTE      byGateRelativeIndex;//Gate Relative Index
    BYTE      byFarRrRelativeIndex;// Far reader Relative Index
    BYTE      byRes[82];
}NET_ITS_GATE_LANE_CFG, *LPNET_ITS_GATE_LANE_CFG;

typedef    struct  tagNET_ITS_IPC_CHAN_LANE_CFG
{
    DWORD     dwSize;
    BYTE      byIpcType;  //0 - no, 1 - license plate capture, 2 - face capture, 3 - surveillance camera
    BYTE      byRes[135];
    NET_ITS_GATE_LANE_CFG  struGateLane[4];
}NET_ITS_IPC_CHAN_LANE_CFG, *LPNET_ITS_IPC_CHAN_LANE_CFG;

typedef    struct    tagNET_ITS_REMOTE_COMMAND
{
    WORD            wLaneid; //Lane number 1 to 32 (index lane number, you can jump)
    BYTE             byCamLaneId;    //The corresponding camera lane number from 1 to 16 (camera configuration lane number, you can jump, can be the same)
    BYTE            byRes;
    DWORD           dwCode;       //Command code 0x0 gate 0x1 closing, to be extended
    BYTE            byRes1[128];
}NET_ITS_REMOTE_COMMAND,*LPNET_ITS_REMOTE_COMMAND;

typedef  struct    tagNET_ITS_REMOTE_CONTROL_
{
    DWORD          dwSize;
    NET_ITS_REMOTE_COMMAND    struRemoteCommand;
}NET_ITS_REMOTE_CONTROL,*LPNET_ITS_REMOTE_CONTROL;

typedef struct tagNET_ITS_ECT_CHANNELSTATE
{
    DWORD dwSize;
    BYTE  byRecordStatic; //Channel in the video - 0 no Record - 1 Record
    BYTE  bySignalStatic; //The connected signal state, 0 -normal, 1 - Loss of Signal
    BYTE  byHardwareStatic;//Channel hardware status, 0 - normal, 1 - exceptions, such as the DSP die
    BYTE  byChannelArmState; //Access IPC armed state
    DWORD dwChannel;
    DWORD dwBitRate;//The actual bit rate
    DWORD dwLinkNum;//The number of client connections
    NET_DVR_IPADDR struClientIP[MAX_LINK];//The client's IP address
    DWORD dwIPLinkNum;//If the channel is IP access, which means that the IP access this number of connections
    BYTE  byExceedMaxLink;    // Than 128 connections 0 - does not exceed 1 - beyond
    BYTE  byRes[139];
}NET_ITS_ECT_CHANNELSTATE, *LPNET_ITS_ECT_CHANNELSTATE;

/*************************************TS-5XXX-L end*******************************/

/*************************************PJ03C2013060554 park DS-TP5016-P begin*****************************/
typedef struct tagNET_DVR_PARK_EXTERNAL_SUBINFO
{
    BYTE   byEnable; //0 \A1\AB close 1 \A1\AB open
    BYTE   byFlicker;//0 \A1\AB no flashing 1 \A1\AB flashing
    BYTE   byIOState;//0 \A1\AB Low level  1 \A1\AB Hight level (external light work)
    BYTE   byLampColor;
    BYTE   byRes[4];
}NET_DVR_PARK_EXTERNAL_SUBINFO, *LPNET_DVR_PARK_EXTERNAL_SUBINFO;

typedef struct tagNET_DVR_PARK_INLAY_SUBINFO
{
    BYTE   byEnable; //0 \A1\AB close 1 \A1\AB open
    BYTE   byFlicker;//0 \A1\AB no flashing 1 \A1\ABflashing
    BYTE   byLampColor;//0-close 1-red 2-green 3-yellow 4-blue 5-magenta  6-cyan 7-white (lamp work)
    BYTE   byRes[21];
}NET_DVR_PARK_INLAY_SUBINFO, *LPNET_DVR_PARK_INLAY_SUBINFO;

typedef struct tagNET_DVR_PARKINFO
{
    NET_DVR_PARK_EXTERNAL_SUBINFO   struNormalParkIOState;//car IO level status
    NET_DVR_PARK_EXTERNAL_SUBINFO   struNormalNoParkIOState;//no car IO level status
    NET_DVR_PARK_EXTERNAL_SUBINFO   struSpecialParkIOState;//spacial car park IO level status
    NET_DVR_PARK_EXTERNAL_SUBINFO   struSpecialNoParkIOState;//special no car park IO level status
    BYTE   byRes[32];
}NET_DVR_PARKINFO, *LPNET_DVR_PARKINFO;

typedef struct tagNET_DVR_EXTERNAL_LAMP_CTRL_MODE
{
    NET_DVR_PARKINFO  struParkInfo[MAX_PARKING_NUM];/*External light off a message, a channel 4 largest parking Spaces (from left to right an array of 0 ~ 3)*/
    BYTE   byRes[32];
}NET_DVR_EXTERNAL_LAMP_CTRL_MODE, *LPNET_DVR_EXTERNAL_LAMP_CTRL_MODE;

typedef struct tagNET_DVR_INLAY_LAMP_CTRL_MODE
{
    NET_DVR_PARK_INLAY_SUBINFO  struLampStateCtrl[MAX_PARKING_STATUS];
    BYTE   byRes[96];
}NET_DVR_INLAY_LAMP_CTRL_MODE, *LPNET_DVR_INLAY_LAMP_CTRL_MODE;

typedef struct tagNET_DVR_LAMP_INFO //8
{
    BYTE   byEnable; //0 \A1\AB close 1 \A1\AB open
    BYTE   byFlicker;//0 \A1\AB no flashing 1 \A1\ABflashing
    BYTE   byLampColor;//0-close 1-red 2-green 3-yellow 4-blue 5-magenta  6-cyan 7-white (lamp work)
    BYTE   byRes[5];
}NET_DVR_LAMP_INFO, *LPNET_DVR_LAMP_INFO;

typedef struct tagNET_DVR_PARKLAMP_CTRL_MODE//size == 72
{
    //State 0 represents no car parking spaces, 1 representatives of car, 2 representative line (highest priority), 3 special parking spaces
    NET_DVR_LAMP_INFO  struLampInfo[MAX_PARKING_STATUS/*8*/];
    //Association parking lamp (0- built-in lamp, 1- external lamp 1, 2- external lamp 2, 3- external lamp 3)
    BYTE   byLampType;
    BYTE   byRes[7];
}NET_DVR_PARKLAMP_CTRL_MODE, *LPNET_DVR_PARKLAMP_CTRL_MODE;

typedef struct tagNET_DVR_LAMP_PARAM //4
{
    BYTE   byEnable;
    BYTE   byFlicker;
    BYTE   byLampColor;
    BYTE   byRes[3];
}NET_DVR_LAMP_PARAM, *LPNET_DVR_LAMP_PARAM;

typedef struct tagNET_DVR_EXTERNAL_PARKLAMP //size == 56
{
    NET_DVR_LAMP_PARAM  struLampParam[MAX_PARKING_STATUS/*8*/];
    BYTE   byLampType;
    BYTE   byRes[7];
}NET_DVR_EXTERNAL_PARKLAMP, *LPNET_DVR_EXTERNAL_PARKLAMP;

typedef struct tagNET_DVR_BUILTIN_PARKLAMP
{
    BYTE   byEnable;
    BYTE   byFlicker;
    BYTE   byLampColor;
    BYTE   byRes[5];
}NET_DVR_BUILTIN_PARKLAMP, *LPNET_DVR_BUILTIN_PARKLAMP;

typedef struct tagNET_DVR_MIXLAMP_CTRL_MODE
{
    NET_DVR_EXTERNAL_PARKLAMP  struExternalParkLamp[MAX_PARKING_NUM/*4*/];
    NET_DVR_BUILTIN_PARKLAMP  struBuiltInParkLamp[MAX_PARKING_STATUS/*8*/];
}NET_DVR_MIXLAMP_CTRL_MODE, *LPNET_DVR_MIXLAMP_CTRL_MODE;

typedef struct tagNET_DVR_SINGLELAMP_CTRL_MODE
{
    NET_DVR_PARK_EXTERNAL_SUBINFO   struExternLampStateCtrl[MAX_PARKING_STATUS/*4*/];
    BYTE byLampType;
    BYTE byRes[23];
}NET_DVR_SINGLELAMP_CTRL_MODE, *LPNET_DVR_SINGLELAMP_CTRL_MODE;

typedef union tagNET_DVR_LAMP_CTRL_MODE_UNION
{
    BYTE uLen[288];
    NET_DVR_INLAY_LAMP_CTRL_MODE struInlayLampCtrlMode;
    NET_DVR_EXTERNAL_LAMP_CTRL_MODE struExternalLampCtrlMode;
    NET_DVR_PARKLAMP_CTRL_MODE struParkLampCtrlMode[MAX_PARKING_NUM/*4*/];
    NET_DVR_MIXLAMP_CTRL_MODE  struMixLampCtrlMode;
    NET_DVR_SINGLELAMP_CTRL_MODE struSingleExternalLampCtrlMode;
}NET_DVR_LAMP_CTRL_MODE_UNION, *LPNET_DVR_LAMP_CTRL_MODE_UNION;

typedef struct tagNET_DVR_LAMP_CTRL_INFO
{
    DWORD     dwSize;
    BYTE      byLampCtrlMode;/*Mode: 1-Lamp\A3\AC2-external Lamp\A3\AC3 - lamp && external lamp*/
    BYTE      byCtrlChannelIndex;/*Alternate control channel number*/
    BYTE      byRes[2];
    NET_DVR_LAMP_CTRL_MODE_UNION  uLampCtrlMode;
    BYTE      byRes2[32];
}NET_DVR_LAMP_CTRL_INFO, *LPNET_DVR_LAMP_CTRL_INFO;

//Parking configuration properties (the default is normal)
typedef struct tagNET_DVR_PARKSPACE_INFO
{
    BYTE      byParkSpaceAttribute; //0~normal Park 1\A1\ABspecial Park
    BYTE      byRes[23];
}NET_DVR_PARKSPACE_INFO, *LPNET_DVR_PARKSPACE_INFO;

typedef struct tagNET_DVR_PARKSPACE_ATTRIBUTE
{
    DWORD     dwSize;
    NET_DVR_PARKSPACE_INFO  struParkSpaceInfo[MAX_PARKING_NUM];//A channel 4 largest parking Spaces (from left to right an array of 0 ~ 3)
    BYTE      byRes[64];
}NET_DVR_PARKSPACE_ATTRIBUTE, *LPNET_DVR_PARKSPACE_ATTRIBUTE;

typedef struct tagNET_DVR_LAMP_STATE
{
    BYTE      byFlicker;//0\A1\ABno flashing 1 \A1\AB flashing
    BYTE      byParkingIndex;//ParkingNo 1\A1\AB3
    BYTE      byRes1[2];
    DWORD     dwIONo;//1~IO1;2~IO2;4~IO3;
    BYTE      byRes2[8];
}NET_DVR_LAMP_STATE, *LPNET_DVR_LAMP_STATE;

typedef struct tagNET_DVR_LAMP_EXTERNAL_CFG
{
    DWORD     dwSize;
    BYTE      byEnable; //ExterNal 0\A1\ABno enable 1\A1\ABenable
    BYTE      byRes1[3];
    NET_DVR_LAMP_STATE     struLampStateCtrl;
    BYTE      byRes2[32];
}NET_DVR_LAMP_EXTERNAL_CFG, *LPNET_DVR_LAMP_EXTERNAL_CFG;

// the parking enforcement at most a channel 4 parking Spaces
typedef struct tagNET_DVR_COMPEL_CAPTURE
{
    DWORD      dwSize;
    BYTE       byParkIndex;/*Parking space number from left to right(0- said the current several parking spaces, will upload some pictures)1,2,3,4*/
    BYTE       byRes[63];
}NET_DVR_COMPEL_CAPTURE, *LPNET_DVR_COMPEL_CAPTURE;

typedef struct tagNET_DVR_EXTERNAL_CONTROL_ALARM
{
    DWORD     dwSize;
    DWORD      dwChannelNo;
    NET_DVR_LAMP_STATE      struLampStateCtrl;
    NET_DVR_TIME      struExternalBeginTime;
    BYTE      byRes1[64];
}NET_DVR_EXTERNAL_CONTROL_ALARM, *LPNET_DVR_EXTERNAL_CONTROL_ALARM;
/*************************************PJ03C2013060554 park DS-TP5016-P end*******************************/

/*****************PJ03D2013112505 Entrance controller*********************/

/* Devices Type */
typedef enum tagEXTERNAL_DEVICES_TYPE
{
    DEVICES_TYPE_RES1 = 0,
    DEVICES_TYPE_FAR_SCR = 1,
    DEVICES_TYPE_ENTRANCE_CONTROL = 2,
    DEVICES_TYPE_WJ_LED_DEV = 3,
    DEVICES_TYPE_NJ_LED_DEV = 4,
    DEVICES_TYPE_VEH_DETECT_DEV = 5,
    DEVICES_TYPE_DZ_DEV = 6,
    DEVICES_TYPE_PX_SCR_DEV = 7,
    DEVICES_TYPE_KJ_SCR_DEV = 8,
    DEVICES_TYPE_FKJ_DEV = 9,
    DEVICES_TYPE_SKJ_DEV = 10,
    DEVICES_TYPE_HDD_DEV = 11,
    DEVICES_TYPE_DZ_LOCK = 12,
    DEVICES_TYPE_PAPER_PRINTER = 13,
    DEVICES_TYPE_PAPER_SCANNERS = 14,
    DEVICES_TYPE_IPC_ALARM = 15
}EXTERNAL_DEVICES_TYPE;

/* Devices Status */
typedef enum tagEXTERNAL_DEVICES_STATUS
{

    DEVICES_STATUS_NORMAL = 0,
    DEVICES_STATUS_ABNORMAL = 1,


    DEVICES_STATUS_TOO_LESS_CARD = 20,
    DEVICES_STATUS_NO_CARD = 21,
    DEVICES_STATUS_SENDCARD_ERROR = 22,
    DEVICES_STATUS_CARD_BLOCKED = 23,
    DEVICES_STATUS_CARD_FULL = 24,

    DEVICES_STATUS_OPENING = 40,
    DEVICES_STATUS_CLOSING = 41,
    DEVICES_STATUS_OPENED  = 42,
    DEVICES_STATUS_CLOSED  = 43,
    DEVICES_STATUS_NOSIGNAL = 44,
    DEVICES_STATUS_LOCK= 45,

    PP_STATUS_OFFLINE = 61,
    PP_STATUS_PRINT_HEADER_UP,
    PP_STATUS_FEED_BUTTON_FEEDING,
    PP_STATUS_ONLINE_WAITING,
    PP_STATUS_FEED_BUTTON_ENABLE,
    PP_STATUS_JAMR_PAPER_ERROR,
    PP_STATUS_CUT_PAPER_ERROR,
    PP_STATUS_AUTO_FEED_ERROR,
    PP_STATUS_EXIT_RECOVERY_ERROR,
    PP_STATUS_EXIT_AUTO_RECOVERY_ERROR,
    PP_STATUS_PULL_PAPER_ERROR,
    PP_STATUS_LESS_PAPER ,
    PP_STATUS_NO_PAPER,
    PP_STATUS_PRINT_FAIL,
    PP_STATUS_PRINTING,
}EXTERNAL_DEVICES_STATUS;


typedef struct  tagNET_DVR_GATE_ALARMINFO
{
    DWORD  dwSize;
    //0x1 vehicle illegal intrusion alarm
    //0x2 gateway timeout is not closed alarm
    //0x3 vehicle coil timeout
    //0x4 card alarm (no card)
    //0x5 card alarm (Defect card)
    //0x6 card (card abnormal alarm)
    BYTE  byAlarmType;
    BYTE  byExternalDevType;//EXTERNAL_DEVICES_TYPE
    BYTE  byExternalDevStatus;//EXTERNAL_DEVICES_STATUS
    BYTE  byRes;
    NET_DVR_TIME_V30  struAlarmTime;
    union
    {
        BYTE  uLen[128];
        struct
        {
            char  sLicense[MAX_LICENSE_LEN/*16*/];//Car License
            /*vehicle type 0- retains 1- fixed car, temporary 2- car, 3- car car booking, 4- levels, 5- authorized vehicles*/
            BYTE  byVehicleType;
            BYTE  byRes1[111];
        }struVehicleInfo;//(struAlarmType == 0x1)
    }uAlarmInfo;
    BYTE  byRes2[64];
}NET_DVR_GATE_ALARMINFO, *LPNET_DVR_GATE_ALARMINFO;
/*****************PJ03D2013112505 Entrance controller*********************/

typedef struct tagNET_DVR_VOLTAGE
{
    int iPhaseAVol;            //Phase A voltage
    int iPhaseBVol;            //Phase B voltage
    int iPhaseCVol;            //Phase C voltage
    int iAveragePhaseVol;    //Average of phase voltage
}NET_DVR_VOLTAGE, *LPNET_DVR_VOLTAGE;

typedef struct _tagNET_DVR_LINE_VOLTAGE
{
    int iLineVolAB;            //AB line voltage
    int iLineVolBC;            //BC line voltage
    int iLineVolCA;            //CA line voltage
    int iAverageLineVol;    //Average of line voltage
} NET_DVR_LINE_VOLTAGE,*LPNET_DVR_LINE_VOLTAGE;

typedef struct tagNET_DVR_CURRENT
{
    int iPhaseACurrent;            //Phase A Current
    int iPhaseBCurrent;            //Phase B Current
    int iPhaseCCurrent;            //Phase C Current
    BYTE byRes[4];
}NET_DVR_CURRENT, *LPNET_DVR_CURRENT;

typedef struct tagNET_DVR_POWER
{
    int iPhaseAPower;            //Phase A Power
    int iPhaseBPower;            //Phase B Power
    int iPhaseCPower;            //Phase C Power
    int iSysTotalPower;            //System Total Power
}NET_DVR_POWER, *LPNET_DVR_POWER;

typedef struct tagNET_DVR_POWER_FACTOR
{
    int iPhaseAPowerFactor;        //Phase A Power Factor
    int iPhaseBPowerFactor;        //Phase B Power Factor
    int iPhaseCPowerFactor;        //Phase C Power Factor
    int iTotalPowerFactor;        //Total Power Factor
}NET_DVR_POWER_FACTOR, *LPNET_DVR_POWER_FACTOR;

typedef struct tagNET_DVR_FREQUENCY
{
    int iPhaseAFrequency;        //Phase A Frequency
    int iPhaseBFrequency;        //Phase B Frequency
    int iPhaseCFrequency;        //Phase C Frequency
    BYTE byRes[4];
}NET_DVR_FREQUENCY, *LPNET_DVR_FREQUENCY;

typedef struct tagNET_DVR_LOAD_FACTOR
{
    int iPhaseALoadFactor;        //Phase A Load Factor
    int iPhaseBLoadFactor;        //Phase B Load Factor
    int iPhaseCLoadFactor;        //Phase C Load Factor
    BYTE    byRes[4];
} NET_DVR_LOAD_FACTOR, *LPNET_DVR_LOAD_FACTOR;

typedef struct tagNET_DVR_ALARMHOST_UPS_STATE
{
    NET_DVR_VOLTAGE        struInputVoltage;    //input voltage
    NET_DVR_VOLTAGE        struBypassVoltage;    //bypass voltage
    NET_DVR_VOLTAGE        struOutputVoltage;    //output voltage
    int iRectifierVol;            //rectifier voltage
    int iInverterVol;            //inverter voltage

    NET_DVR_CURRENT    struInputCurrent;    //input current
    NET_DVR_CURRENT    struBypassCurrent;    //bypass current
    NET_DVR_CURRENT    struOutputCurrent;    //output current
    int iInverterCurrent;        //inverter current

    NET_DVR_FREQUENCY    struInputFrequency;        //input frequency
    NET_DVR_FREQUENCY    struBypassFrequency;    //bypass frequency
    NET_DVR_FREQUENCY    struOutputFrequency;    //output frequency
    int iInverterFre;            //inverter frequency

    NET_DVR_POWER         struInputPower;    //input power
    NET_DVR_POWER        struBypassPower;//bypass power
    NET_DVR_POWER        struOutputPower;//output power
    NET_DVR_POWER        struComplexPower;//complex power

    int iNormalPower;            //normal power
    int iPowerFacter;            //power factor

    NET_DVR_LOAD_FACTOR    struBatteryLoadFactor;    //battery load factor
    int iBatteryEstimated;        //battery estimated time
    int iBatteryTemperature;    //battery temperature
    int iBatteryVoltage;            //Battery Voltage


    BYTE    byRectifierState;        //Rectifier State 1-normal 2-abnormal
    BYTE    byInverterState;        //Inverter State 1-normal 2-abnormal
    BYTE    byChargeState;        //Charge State 1-normal 2-abnormal
    BYTE    byBatteryState;        //Battery State 1-normal 2-abnormal
    BYTE    byAutoBypassState;    //Auto Bypass State 1-normal 2-abnormal
    BYTE    byRes2[247];
} NET_DVR_ALARMHOST_UPS_STATE, *LPNET_DVR_ALARMHOST_UPS_STATE;

typedef struct tagNET_DVR_ALARMHOST_SWITCH_POWER_STATE
{
    NET_DVR_VOLTAGE        struACVoltage;    //AC Voltage
    int     iDCConvertVoltage;    //DC Convert Voltage
    NET_DVR_CURRENT        struACCurrent;    //AC Current
    int     iTotalCurrent;            //Total Current
    int     iBattery1Temperature;    //Temperature of Battery 1
    int     iBattery2Temperature;    //Temperature of Battery 2
    int     iBattery1Current;        //Current of Battery 1
    int     iBattery2Current;        //Current of Battery 2
    int     iBattery3Current;        //Current of Battery 3
    int     iBattery4Current;        //Current of Battery 4
    int     iBatteryTestVoltage;    //test voltage of battery
    int     iRectifierOutputVoltage;    //Rectifier Output Voltage
    int     iRectifierOutputCurrent;    //Rectifier Output Current
    int     iDCOutputVoltage;        //DC Output Voltage
    BYTE    byRes[432];
} NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_STATE,
        *LPNET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_STATE;

typedef struct tagNET_DVR_ALARMHOST_GAS_DETECTOR_STATE
{
    int        iSF6;            //unit:ppm
    int      iFlow;           //unit:ml/min
    int        iTemperature;
    int        iO2;            //unit:%
    int        iHumidity;        //unit:%
    BYTE    byRes[492];
} NET_DVR_ALARMHOST_GAS_DETECTOR_STATE,
        *LPNET_DVR_ALARMHOST_GAS_DETECTOR_STATE;

typedef struct tagNET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE
{
    int        iTemperature;    //unit: 'c
    int        iHumidity;        //unit: %
    BYTE    byRes[504];
} NET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE, *LPNET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE;

typedef struct tagNET_DVR_ALARMHOST_AIRCONDITION_STATE
{
    int        iTemperature;    //unit: 'c
    int        iHumidity;        //unit: %
    BYTE   byRunState;        //1-running\A3\AC2-stop
    BYTE    byRes[503];
} NET_DVR_ALARMHOST_AIRCONDITION_STATE, *LPNET_DVR_ALARMHOST_AIRCONDITION_STATE;


typedef struct tagNET_DVR_ALARMHOST_ELECTRICITY_STATE
{
    int        iDCVoltage;        //DC Voltage
    int        iDCCurrent;        //DC Current
    NET_DVR_VOLTAGE        struPhaseVoltage;    //Phase Voltage
    NET_DVR_LINE_VOLTAGE struLineVoltage;    //Line Voltage
    NET_DVR_CURRENT    struCurrent[4];        //current\A3\ACstruCurrent[0] means the current of first load
    int iAverageCurrent;        //Average Current
    int iNeutralCurrent;        //Neutral Current
    NET_DVR_POWER    struActivePower[4];    //Active Power struActivePower[0]means the active power of first load
    NET_DVR_POWER    struReactivePower[4];    //Reactive Power struReactivePower[0] means the reactive power of first load
    NET_DVR_POWER    struApparentPower[4];    //Apparent Power struApprentPower[0]means the apparent power of first load
    NET_DVR_POWER_FACTOR    struPowerFactor[4];    //Power Factor\A3\ACstruPowerFactor[0]means the power factor of first load
    NET_DVR_FREQUENCY        struFrequency;            //Frequency
    BYTE byRes[128];
}NET_DVR_ALARMHOST_ELECTRICITY_STATE, *LPNET_DVR_ALARMHOST_ELECTRICITY_STATE;

typedef struct  tagNET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE
{
    int        iPhaseATemperature;        //phase A temperature
    int        iPhaseBTemperature;        //phase B temperature
    int        iPhaseCTemperature;        //phase C temperature
    int        iPhaseDTemperature;        //phase D temperature
    BYTE     byRes[496];
}NET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE, *LPNET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE;


//water level sensor
typedef struct tagNET_DVR_ALARMHOST_WATERLEVEL_SENSOR
{
    LONG    iWaterLevel;        //water level
    BYTE    byRes[508];
}NET_DVR_ALARMHOST_WATERLEVEL_SENSOR, *LPNET_DVR_ALARMHOST_WATERLEVEL_SENSOR;

//dust and noise sensor
typedef struct tagNET_DVR_ALARMHOST_DUSTNOISE_SENSOR
{
    LONG    iDust;        //dust
    LONG    iNoise;       //noise
    BYTE    byRes[504];
}NET_DVR_ALARMHOST_DUSTNOISE_SENSOR, *LPNET_DVR_ALARMHOST_DUSTNOISE_SENSOR;

//environment logger
typedef struct tagNET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER
{
    LONG    iAmmoniaNitrogen;    //Ammonia and Nitrogen
    LONG    iCOD;                //COD
    LONG    iPH;                //PH
    LONG    iOxygen;            //Oxygen
    LONG    iSulfurDioxide;    //Sulfur Dioxide
    LONG    iSoot;            //Soot
    LONG    iFluoride;        //Fluoride
    LONG    iPollutedWater;    //Polluted Water
    LONG    iTotalPhosphorus;    //Total Phosphorus
    LONG    iExhaust;            //Exhaust
    LONG    iNitrogenOxides;    //Nitrogen Oxides
    LONG    iFlueGasTemperature;//Flue Gas Temperature
    LONG    iFlueGasPressure;    //Flue Gas Pressure
    BYTE    byRes[460];
}NET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER, *LPNET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER;

typedef union tagNET_DVR_EXTERNAL_DEVICE_STATE_UNION
{
    NET_DVR_ALARMHOST_UPS_STATE struUpsState;        //UPS state
    NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_STATE struSwitchPowerState;//switch power state
    NET_DVR_ALARMHOST_GAS_DETECTOR_STATE struGasDetectorState;//gas detector state
    NET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE struTempHumiSensorState;//TH Sensor state
    NET_DVR_ALARMHOST_AIRCONDITION_STATE struAirConditionState;//air condition state
    NET_DVR_ALARMHOST_ELECTRICITY_STATE struElectricityState;//electricity state
    NET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE struTransformerTempState;    //transfarmer state
    NET_DVR_ALARMHOST_WATERLEVEL_SENSOR struWaterLevelSensor;//water level sensor
    NET_DVR_ALARMHOST_DUSTNOISE_SENSOR struDustNoiseSensor;//dust and noise sensor
    NET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER struEnvironmentLogger;//environmental logger
    BYTE    byRes[512];
} NET_DVR_EXTERNAL_DEVICE_STATE_UNION, *LPNET_DVR_EXTERNAL_DEVICE_STATE_UNION;

typedef struct tagNET_DVR_ALARMHOST_EXTERNAL_DEVICE_STATE
{
    DWORD dwSize;
    BYTE    byDevType;    //1-UPS state\A3\AC2-switch power state 3-gas detector state\A3\AC4-TH Sensor state\A3\AC5-air condition state\A3\AC6-electricity state\A3\AC7-transfarmer state, 8-water level sensor\A1\A29-dust and noise sensor\A1\A210-environment logger
    BYTE    byRes1[3];
    NET_DVR_EXTERNAL_DEVICE_STATE_UNION struDevState;
    BYTE    byRes2[32];
} NET_DVR_ALARMHOST_EXTERNAL_DEVICE_STATE, *LPNET_DVR_ALARMHOST_EXTERNAL_DEVICE_STATE;

typedef struct tagNET_DVR_ALARMHOST_UPS_LIMIT_VALUE
{
    int iInputVolHigh;        //input voltage of high limit
    int iInputVolLow;        //input voltage of low limit
    int iInputFreHigh;        //input frequency of high limit
    int iInputFreLow;        //input frequency of low limit
    int iOutputVolHigh;        //output voltage of high limit
    int iOutputVolLow;        //output voltage of low limit
    int iBatteryVoltageLow;    //battery voltage low
    int iBatterySurplus;        //battery surplus low
    int iBatteryTemperatureHigh;//Battery temperature High
    BYTE    byRes[64];            //res
}NET_DVR_ALARMHOST_UPS_LIMIT_VALUE, *LPNET_DVR_ALARMHOST_UPS_LIMIT_VALUE;

typedef struct tagNET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE
{
    int iTemperatureHighLimit;    //high limit value of temperature
    int iTemperatureLowLimit;    //low limit value of temperature
    int iHumidityHighLimit;        //high limit value of humidity
    int iHumidityLowLimit;        //low limit value of humidity
    BYTE    byRes[84];
} NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE, *LPNET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE;

typedef union tagNET_DVR_EXTERNAL_DEVICE_LIMIT_VALUE_UNION
{
    NET_DVR_ALARMHOST_UPS_LIMIT_VALUE struUpsLimitValue;
    NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE struTempHumidityLimitValue;
}NET_DVR_EXTERNAL_DEVICE_LIMIT_VALUE_UNION,*LPNET_DVR_EXTERNAL_DEVICE_LIMIT_VALUE_UNION;

typedef struct tagNET_DVR_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE
{
    DWORD dwSize;
    BYTE    byDevType;    //1-UPS\A3\AC2-TH Sensor
    BYTE    byRes1[3];
    NET_DVR_EXTERNAL_DEVICE_LIMIT_VALUE_UNION struAlarmValue;
    BYTE    byRes2[32];
}NET_DVR_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE, *LPNET_DVR_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE;

#define    ALARMHOST_ALARMOUT_NUM    64  //max trigger number
typedef struct  tagNET_DVR_ALARMHOST_SENSOR_JOINT_CFG
{
    DWORD         dwSize;
    BYTE        bySensorJointAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM/*512*/];
    BYTE        bySensorJointSiren[ALARMHOST_MAX_SIREN_NUM/*8*/];
    BYTE        bySensorAlarmTypeJointAlarmOut[ALARMHOST_ALARMOUT_NUM/*64*/];//sensor joint alarmout by alarm type\A3\ACit is expend from bySensorJointAlarmOut\A1\A3array index if trigger no.\A3\ACevery bit is a alarm type,1-limit1\A3\BB2-limit2\A3\BB3-limit3\A3\BB4-limit4\A3\BB5-fault
    BYTE        bySesorAlarmTypeJointSiren[ALARMHOST_MAX_SIREN_NUM]; //siren joint alarmout by alarm type\A3\ACit is expend from bySensorJointAlarmOut\A1\A3array index if trigger no.\A3\ACevery bit is a alarm type,1-limit1\A3\BB2-limit2\A3\BB3-limit3\A3\BB4-limit4\A3\BB5-fault
    BYTE        byChan;        //chan number
    BYTE        byRes[55];
}NET_DVR_ALARMHOST_SENSOR_JOINT_CFG, *LPNET_DVR_ALARMHOST_SENSOR_JOINT_CFG;

typedef struct tagNET_DVR_ALARMHOST_UPS_ALARMINFO
{
    BYTE    byAlarmType;/*alarm type\A3\BA1.phase A input voltage out of limit value 2.phase B input voltage out of limit value 3.phase C input voltage out of limit value
    4.phase A output voltage out of limit value 5.phase B output voltage out of limit value 6.phase C output voltage out of limit value 7.phase A input frequency out of limit value 8.phase B input frequency out of limit value9.phase C input frequency out of limit value
    10.Rectifier voltage out of limit value 11.overoad alarm 12.battery voltage low 13.battery supplus low 14.battery tempetature high 15.inverter close
    16.auto bypass open 17.Rectifier fault 18.inverter fault 19.charger fault    20.battery fault     21.auto bypass fault */
    BYTE    byChanNo;    //485 channel no
    BYTE   bySlotNo;    //485 slot no
    BYTE    byRes1;
    int         iAlarmValue;    //alarm value
    BYTE    byRes2[64];        //res
}NET_DVR_ALARMHOST_UPS_ALARMINFO, *LPNET_DVR_ALARMHOST_UPS_ALARMINFO;

typedef struct tagNET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO
{
    BYTE    byAlarmType;    /*alarm type\A3\BA1-battery test fail  2-AC-DC fault\A3\AC3-AB/A out of limit\A3\AC4-BC/B out of limit\A3\AC5-CA/C out of limit\A3\AC6-output current A out of limit\A3\AC
    7-output current B out of limit\A3\AC8-output current C out of limit\A3\AC9-rectifier module fault\A3\AC10-fan fault\A3\AC11-DC voltage out of limit*/
    BYTE    byChanNo;        //485 Channel No
    BYTE    bySlotNo;        //485 Slot No
    BYTE    byRes1;
    int     iAlarmValue;    //alarm value
    BYTE    byRes2[64];
}NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO,
        *LPNET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO;

typedef struct tagNET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO
{
    BYTE    byAlarmType;    /*alarm type\A3\BA1- SF6 content abnormal\A3\AC2-O2 content abnormal\A3\AC3-temperature abnormal 4-humidity abnormal 5-Flow abnormal*/
    BYTE    byChanNo;    //485 Channel No, start from 1
    BYTE    bySlotNo;    //485 Slot No
    BYTE    byRes1;
    int     iAlarmValue;        //alarm value
    BYTE    byRes2[64];
}NET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO,
        *LPNET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO;

typedef struct tagNET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO
{
    BYTE    byAlarmType;    //1-temperature abnormal\A3\AC2-humidity abnormal
    BYTE    byChanNo;        //485 Channel No
    BYTE    bySlotNo;        //485 Slot No
    BYTE    byRes1;
    int     iAlarmValue;    //alarm value
    BYTE    byRes2[64];
} NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO, *LPNET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO;

typedef union  tagNET_DVR_485_DEVICE_ALARM_UNION
{
    NET_DVR_ALARMHOST_UPS_ALARMINFO struUPSAlarm; //UPS alarm
    NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO struSwitchPowerAlarm; //Switch power alarm
    NET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO struGasDetectSystemAlarm; //gas detector alarm
    NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO struTempHumiditySensorAlarm; //TH Sensor alarm
    BYTE    byRes[72];
} NET_DVR_485_DEVICE_ALARM_UNION, *LPNET_DVR_485_DEVICE_ALARM_UNION;

typedef struct  tagNET_DVR_485_EXTERNAL_DEVICE_ALARMINFO
{
    DWORD dwSize;
    BYTE    byAlarmType;    //1-UPS Alarm\A3\AC2-Switch power alarm\A3\AC3-gas detector alarm\A3\AC4-TH Sensor alarm
    BYTE    byRes1[3];
    NET_DVR_485_DEVICE_ALARM_UNION struAlarmInfo;
    BYTE    byRes2[16];
} NET_DVR_485_EXTERNAL_DEVICE_ALARMINFO, *LPNET_DVR_485_EXTERNAL_DEVICE_ALARMINFO;

typedef struct tagNET_DVR_ALARMHOST_RS485_SLOT_CFG
{
    DWORD       dwSize;
    BYTE        sDeviceName[NAME_LEN];     // device name
    WORD        wDeviceType;            // ALARM_FRONT_DEVICE_TYPE
    WORD        wDeviceProtocol;        // device protocol
    WORD        wAddress;                // device address
    BYTE        byChannel;          //485 channel
    BYTE        bySlotChan;         //slot chan
    BYTE        byRes[60];                // res
}NET_DVR_ALARMHOST_RS485_SLOT_CFG, *LPNET_DVR_ALARMHOST_RS485_SLOT_CFG;

typedef struct tagNET_DVR_MRD_SEARCH_PARAM
{
    DWORD                dwSize;
    NET_DVR_STREAM_INFO    struStreamInfo;
    WORD                 wYear;
    BYTE                 byMonth;
    BYTE                byDrawFrame;    // 0-Do not draw frame 1-draw frame
    BYTE                byStreamType;   //0-main 1-stream
    BYTE                byRes[31];
}NET_DVR_MRD_SEARCH_PARAM, *LPNET_DVR_MRD_SEARCH_PARAM;

typedef struct tagNET_DVR_MRD_SEARCH_RESULT
{
    DWORD            dwSize;
    BYTE            byRecordDistribution[LEN_32];
    BYTE            byHasEventRecode[LEN_31];
    BYTE            byRes;
}NET_DVR_MRD_SEARCH_RESULT, *LPNET_DVR_MRD_SEARCH_RESULT;


//Corridor Mode
typedef struct tagNET_DVR_CORRIDOR_MODE
{
    DWORD        dwSize;
    BYTE        byEnableCorridorMode; // Modes 0 to enable or disable the corridor is not enabled, 1 to enable
    BYTE        byMirrorMode;            //Mirror Mode 0-Cosed; 1-Left and right; 2The upper and lower; 3 intermediate
    BYTE        byRes[126];
}NET_DVR_CORRIDOR_MODE, *LPNET_DVR_CORRIDOR_MODE;

//Face Detect
typedef struct tagNET_DVR_DETECT_FACE
{
    DWORD     dwSize;
    BYTE     byEnableDetectFace; //Whether to enable 0 to enable, 1 to enable
    BYTE     byDetectSensitive; //Sensitivity 10 Level 1 to 10
    BYTE     byEnableDisplay;    /*Enable motion detection to highlight, 0 - no, 1 - yes*/
    BYTE     byEnableFaceRecog;  //enable face regcog\A3\AC0-no\A3\AC1-yes
    NET_DVR_HANDLEEXCEPTION_V40  struAlarmHandleType; /*Treatment*/
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*Arming Time */
    DWORD    dwMaxRelRecordChanNum;     //Alarm triggered video channel (read-only) the maximum number of support
    DWORD    dwRelRecordChanNum;     //Number of alarm-triggered video channel support
    DWORD    dwRelRecordChan[MAX_CHANNUM_V30];    /* Alarm triggered video channel*/
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30]; //holiday time
    WORD     wDuration;  //duration
    BYTE     byRes1[30];
}NET_DVR_DETECT_FACE, *LPNET_DVR_DETECT_FACE;

typedef struct tagNET_DVR_MUL_STREAM_CHANNEL_GROUP
{
    DWORD        dwSize;
    DWORD       dwGroup ;
    NET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND  struMultiStreamCfg;
    BYTE         byRes[64] ;
}NET_DVR_MUL_STREAM_CHANNEL_GROUP,*LPNET_DVR_MUL_STREAM_CHANNEL_GROUP;

typedef struct tagNET_DVR_CHANNEL_GROUP
{
    DWORD        dwSize;
    DWORD       dwChannel;
    DWORD       dwGroup;
    BYTE        byID;//Dev Region Setint ID
    BYTE        byRes1[3];
    DWORD       dwPositionNo; //Position No.
    BYTE        byRes[56];
}NET_DVR_CHANNEL_GROUP, *LPNET_DVR_CHANNEL_GROUP;

typedef struct tagNET_DVR_TIME_DETECTION
{
    NET_DVR_SCHEDTIME  struSchedTime; //Sched Time
    BYTE   byDetSceneID;//Scence ID [1,4],IPC: 0
    BYTE   byRes[15];
}NET_DVR_TIME_DETECTION,*LPNET_DVR_TIME_DETECTION;

//Conditions
typedef struct tagNET_DVR_GUARD_COND
{
    DWORD  dwSize;
    DWORD  dwChannel; //Channel No.
    /*
    0 Invalid\A3\AC
    1 VIA Mode;
    2 HVT Mode
    */
    BYTE   byRelateType;
    BYTE   byGroupNo;
    BYTE   byRes[62];
}NET_DVR_GUARD_COND,*LPNET_DVR_GUARD_COND;

//Capture trigger mode support association Alarm time and Upload Center
typedef struct tagNET_DVR_GUARD_CFG
{
    DWORD  dwSize;
    //Alarm Time
    NET_DVR_TIME_DETECTION    struAlarmSched[MAX_DAYS/*7*/][MAX_TIMESEGMENT_V30/*8*/];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //Exception processing mode
    DWORD  dwMaxRelRecordChanNum ;
    DWORD  dwRelRecordChanNum ;
    DWORD  dwRelRecordChan[MAX_CHANNUM_V30];
    NET_DVR_TIME_DETECTION  struHolidayTime[MAX_TIMESEGMENT_V30];
    BYTE   byRes[88];
}NET_DVR_GUARD_CFG,*LPNET_DVR_GUARD_CFG;

typedef    struct  tagNET_DVR_SNAPINFO_COND_
{
    DWORD    dwSize;
    DWORD    dwChan;
    /*
    0 MPR Mode
    1 HVT Mode
    ...
    */
    BYTE     byRelateType;
    BYTE     byRes[63];
}NET_DVR_SNAPINFO_COND, *LPNET_DVR_SNAPINFO_COND;

//Snap Picture Info
typedef struct tagNET_DVR_SNAPINFOCFG
{
    DWORD dwSize;
    BYTE  byCurPicType;//0- picture Quality, 1- Picture size
    BYTE  byPicQuality;//picture Quality[1,100]
    BYTE  byRes1[2];
    DWORD dwPicSize;//Picture size[64k,2048k]
    BYTE  byRes2[128];
}NET_DVR_SNAPINFOCFG,*LPNET_DVR_SNAPINFOCFG;

//ptz Track Mode
typedef enum _PTZ_TRACK_MODE_
{
    PTZ_TRACK_MODE_ALWAYS  = 1,   //Track always
    PTZ_TRACK_MODE_BYTIME  = 2,   //Track for a specified time
    PTZ_TRACK_MODE_NEXT    = 3,   //Track next targets when it appears
}PTZ_TRACK_MODE;

//ptz track parameters
typedef struct _NET_DVR_PTZ_TRACK_PARAM_
{
    DWORD dwSize;     //Structure size
    BYTE  byTrackMode; //Track mode,refer to PTZ_TRACK_MODE
    BYTE byLinkageTarget; //Linkage Target 0-default,1-IPD1
    BYTE byAutoTrackEnable;//Auto Track enable 0-open\A3\AC1-close
    BYTE byRes1; //Res
    DWORD dwTrackTime; //Track time
    //When PTZ_TRACK_MODE_ALWAYS\A3\ACthis filed is not used
    //When PTZ_TRACK MODE_BYTIME\A3\ACrange[1,60]\A3\ACdefault 10 seconds
    //When PTZ_TRACK MODE_NEXT\A3\ACrange[1,10]\A3\ACdefault 2 seconds
    BYTE  byRes2[256]; //Reserved
}NET_DVR_PTZ_TRACK_PARAM,*LPNET_DVR_PTZ_TRACK_PARAM;

#define MAX_ALERTLINE_NUM    8 //Max alter line number
typedef struct tagNET_VCA_TRAVERSE_PLANEPARAM
{
    DWORD    dwSize;
    BYTE    byEnable;
    BYTE    byEnableDualVca;// enable dual vca 0-disable\A3\AC1-enable
    BYTE    byRes1[2];
    NET_VCA_TRAVERSE_PLANE struAlertParam[MAX_ALERTLINE_NUM];
    NET_DVR_SCHEDTIME struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //Exception
    DWORD  dwMaxRelRecordChanNum;
    DWORD  dwRelRecordChanNum;
    DWORD byRelRecordChan[MAX_CHANNUM_V30]; //Channel triggered to record
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30]; //holiday time
    BYTE byRes2[100];
}NET_VCA_TRAVERSE_PLANE_DETECTION, *LPNET_VCA_TRAVERSE_PLANE_DETECTION;

#define MAX_INTRUSIONREGION_NUM    8 //Max field number
typedef struct tagNET_VCA_FIELDDETECION
{
    DWORD dwSize;
    BYTE byEnable;
    BYTE byEnableDualVca;// enable dual vca 0-disable\A3\AC1-enable
    BYTE byRes1[2];
    NET_VCA_INTRUSION struIntrusion[MAX_INTRUSIONREGION_NUM];
    NET_DVR_SCHEDTIME struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //Exception
    DWORD  dwMaxRelRecordChanNum;
    DWORD  dwRelRecordChanNum;
    DWORD  byRelRecordChan[MAX_CHANNUM_V30];//Channel triggered to record
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30]; //holiday Schedule time
    BYTE byRes2[100];
}NET_VCA_FIELDDETECION, *LPNET_VCA_FIELDDETECION;

typedef struct tagNET_DVR_ROI_DETECT_NUM
{
    DWORD   dwSize;
    DWORD   dwGroup;
    DWORD   dwStreamType;    //Stream type, 0 - the main stream, 1 - sub-stream, 2 - the type of event, 3 - stream 3, ...
    DWORD   dwRoiFixNum; //The total number of fixed area to determine the follow-up once again to obtain the group number
    DWORD   dwRoiFixID[MAX_ROIDETECT_NUM];//IPC now supports four ball machine now supports 24
    BYTE    szFixRoiName[MAX_ROIDETECT_NUM][NAME_LEN];//The fixed ROI region name
    DWORD   dwRoiTrackNum; //The total number of automatic tracking area, to determine the follow-up once again to get the group number
    DWORD   dwRoiTrackID[MAX_ROIDETECT_NUM];//IPC now supports four ball machine now supports 24
    BYTE    byRes[320];
}NET_DVR_ROI_DETECT_NUM, *LPNET_DVR_ROI_DETECT_NUM;

typedef  enum  _DETECT_ROI_TYPE_
{
    DETECT_FIX_ROI  =  0, //Detection ROI fixed area
    DETECT_TRACK_ROI = 1 //Automatic detection ROI tracking area
}DETECT_ROI_TYPE;

typedef struct tagNET_DVR_ROI_DETECT_COND
{
    DWORD   dwSize;
    DWORD   dwRoiID; //The area detection number one PTZ support 4
    NET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND  struMultiStreamCfg;
    BYTE    byRoiDetectType; // DECTECT_ROI_TYPE
    BYTE    byRoiDetectTrackType;//When a fixed region, this field is invalid; tracking area 1 to the face detection (IPC), 2 to the moving object tracking,3-Plate tracking
    BYTE    byRes[30];
}NET_DVR_ROI_DETECT_COND,*LPNET_DVR_ROI_DETECT_COND;


typedef struct tagNET_DVR_ROI_FIX_RECT_CFG
{
    BYTE  byEnableFixRoi; // ROI fixed area mode is enabled 0 to enable, 1 to enable
    BYTE  byImageQualityLevel; //Image quality to enhance the level 1 to 6
    BYTE  byRes[2];
    BYTE  szFixRoiName[NAME_LEN];
    NET_VCA_RECT  struRoiRect;
    BYTE  byRes1[468];
}NET_DVR_ROI_FIX_RECT_CFG, *LPNET_DVR_ROI_FIX_RECT_CFG;


typedef struct tagNET_DVR_ROI_TRACK_RECT_CFG
{
    BYTE  byEnableTrackRoi; // ROI automatic tracking mode is enabled 0 to enable, 1 to enable
    BYTE  byImageQualityLevel; //Image quality to enhance the level 1 to 6
    BYTE  byModeType;//0 to 1 to face mode (mobile and stationary objects), 2 to moving object tracking (moving objects),3-Plate tracking
    BYTE  byRes[509];
}NET_DVR_ROI_TRACK_RECT_CFG, *LPNET_DVR_ROI_TRACK_RECT_CFG;

typedef union tagNET_DVR_ROI_DETECT_UNION
{
    DWORD      uLen[128];
    NET_DVR_ROI_FIX_RECT_CFG   strRoiFixRectCfg;
    NET_DVR_ROI_TRACK_RECT_CFG   strRoiTrackRectCfg;
}NET_DVR_ROI_DETECT_UNION,*LPNET_DVR_ROI_DETECT_UNION;

typedef struct tagNET_DVR_ROI_DETECT_CFG
{
    DWORD      dwSize;
    DWORD       dwStreamType;    //Stream type - the main stream, 1 - sub-stream, 2 - the type of event, 3 - stream 3, ...
    BYTE       byRoiDetectType; // DECTECT_ROI_TYPE
    BYTE       byRes[3];
    NET_DVR_ROI_DETECT_UNION  uRoiDetectInfo;
    BYTE       byRes1[36];
}NET_DVR_ROI_DETECT_CFG, *LPNET_DVR_ROI_DETECT_CFG;

//defouce detection
typedef struct tagNET_VCA_DEFOCUSPARAM
{
    DWORD dwSize;
    BYTE byEnable;
    BYTE  bySensitiveLevel;// 1-100\A3\ACdefault 50\A3\ACThe higher sensitivity to alarm easier
    BYTE  byRes1[2];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;
    BYTE byRes2[24];
}NET_VCA_DEFOCUSPARAM,*LPNET_VCA_DEFOCUSPARAM;

/************************VQD iVMS-6200(D) V2.1.0 begin***********/
typedef struct tagNET_DVR_QUERY_STATUS
{
    DWORD      dwSize;
    BYTE       byCpuLoad;    ///< CPU \A3\BA0-100
    BYTE       byMemLoad;    ///< Memory \A3\BA0-100
    WORD       wAbility;    ///< DEV Ablity
    WORD       wRemainAbility;    ///<last Ablity
    WORD       wTotalPlanNum;      ///<max plan 64>
    WORD       wCurPlanNum;  ///<current plan num>
    BYTE       byRes[62];
}NET_DVR_QUERY_STATUS, *LPNET_DVR_QUERY_STATUS;

typedef struct tagNET_DVR_MONITOR_VQDCFG
{
    DWORD   dwSize;
    BYTE   byEnable;       ///
    BYTE   byDevType;         //\A3\BA0-no PTZ dev\A3\AC1-PTZ dev
    BYTE   bySignalPoint;   ///< 0-100
    BYTE   byBlurPoint;    ///< 0-100
    BYTE   byLumaPoint;    ///< 0-100
    BYTE   byChromaPoint;    ///< 0-100
    BYTE   bySnowPoint;    ///< 0-100
    BYTE   byStreakPoint;    ///< 0-100
    BYTE   byFreezePoint;    ///< 0-100
    BYTE   byPTZPoint;    ///< 0-100
    BYTE   byMonitorDel;  //< 0-no del\A3\AC 1-del
    BYTE   byContrastThreshold; //Contrast Threshold, 0-100
    BYTE   byMonoThreshold;     //Mono Threshold, 0-100
    BYTE   byShakeThreshold;    //Shake Threshold, 0-100
    BYTE   byFlashThreshold;    //Flash Threshold, 0-100
    BYTE   byCoverThreshold;    //Cover Threshold, 0-100
    BYTE   bySceneThreshold;    //Scene Threshold, 0-100
    BYTE   byDarkThreshold;     //Dark Threshold, 0-100
    BYTE   byRes[46];
}NET_DVR_MONITOR_VQDCFG, *LPNET_DVR_MONITOR_VQDCFG;

typedef struct tagNET_DVR_DIAGNOSIS_UPLOAD
{
    DWORD  dwSize;
    char   sStreamID[STREAM_ID_LEN];    ///< streamId\A3\AC
    char  sMonitorIP[64];  ///<
    DWORD  dwChanIndex;  ///<
    DWORD  dwWidth;  ///<
    DWORD  dwHeight;  ///<
    NET_DVR_TIME  struCheckTime;  ///<\A3\BA2012-08-06 13:00:00
    BYTE  byResult;  ///0-no check 1-norm 2 - abnormal 3 - Login failed - to take flow anomaly
    BYTE  bySignalResult; ///< video loss detection results 0 - 1 - normal - not detected abnormal
    BYTE  byBlurResult;  ///< image blur detection results 0 - not detected 1 - normal - abnormal
    BYTE  byLumaResult;  ///< brightness anomaly detection results 0 - 1 - normal 2 not detected - abnormal
    BYTE  byChromaResult;  ///< the cast test results, 0 - 1 - normal - not detected abnormal
    BYTE  bySnowResult;  ///< the snow point interference detection results 0 - not detected 1 - normal - abnormal
    BYTE  byStreakResult;  ///< the fringe interference detection results 0 - not detected 1 - normal - abnormal
    BYTE  byFreezeResult;  ///< screen freeze test results 0 - 1 - normal - not detected abnormal
    BYTE  byPTZResult;  ///< the PTZ test results, 0 - 1 - normal - not detected abnormal
    BYTE  byContrastResult;     //Contrast result, 0-not detected, 1-normal, 2-abnormal
    BYTE  byMonoResult;         //Mono result, 0-not detected, 1-normal, 2-abnormal
    BYTE  byShakeResult;        //Shake result, 0-not detected, 1-normal, 2-abnormal
    char  sSNapShotURL[256];    ///<pic URL address
    BYTE  byFlashResult;        //Flash result, 0-not detected, 1-normal, 2-abnormal
    BYTE  byCoverResult;        //Cover result, 0-not detected, 1-normal, 2-abnormal
    BYTE  bySceneResult;        //Scene change result, 0-not detected, 1-normal, 2-abnormal
    BYTE  byDarkResult;         //Dark result, 0-not detected, 1-normal, 2-abnormal
    BYTE  byStreamType;            //stream type, 0-invalid, 1-unknown, 2-national standard type, 3-not national standard type
    BYTE  byRes2[59];
}NET_DVR_DIAGNOSIS_UPLOAD, *LPNET_DVR_DIAGNOSIS_UPLOAD;

typedef struct tagNET_DVR_DOWN_LOAD_REQUEST
{
    NET_DVR_STREAM_INFO  struStreamInfo;
    char   sSnapShotURL[256];
    BYTE   byRes[32];
}NET_DVR_DOWN_LOAD_REQUEST, *LPNET_DVR_DOWN_LOAD_REQUEST;

typedef struct tagNET_DVR_VQD_RESULT_INFO
{
    DWORD  dwSize;
    char   sStreamID[32];
    DWORD  dwPicLength;
    BYTE   byStatus;
    BYTE   byRes[31];
    char   *pSnapShot;      ///< (700k)
}NET_DVR_VQD_RESULT_INFO, *LPNET_DVR_VQD_RESULT_INFO;

typedef struct tagNET_DVR_PLAN_VQD_CFG
{
    DWORD   dwSize;
    BYTE    sPlanID[PLAN_ID_LEN];    ///
    NET_DVR_SCHEDTIME  struDetectTime[MAX_DAYS][MAX_TIMESEGMENT_V30];    ///<
    BYTE    byPlanMode;  ///0: immediate plans: cycle plan
    BYTE    byRes1;//
    BYTE    byCheckFlag;  ///< detected, 0 - not detected, 1 - detection
    BYTE    bySignal;  ///<video loss is detected, 0 - do not detect, 1 - detection
    BYTE    byBlur;  ///< image blurring is detected, 0 - does not detect, 1 - detection
    BYTE    byLuma;  ///< brightness whether the abnormality is detected, 0 - does not detect 1 - detection
    BYTE    byChroma;  ///< whether the color cast detection detection, 0 - not detected, 1 - detection
    BYTE    bySnow;  ///<snowflake points interference is detected, 0 - does not detect, 1 - detection
    BYTE    byStreak;  ///<whether the stripes interference is detected, 0 - not detected, 1 - detection
    BYTE    byFreeze;  ///<whether the screen freezes detection, 0 - not detected, 1 - detection
    BYTE    byPTZ;  ///<the PTZ whether detection, 0 - does not detect 1 - detection
    BYTE    byEnablePlanRound;  ///plan cycle is on
    BYTE    byContrast;  //Contrast detection, 0 - does not detect 1 - detection
    BYTE    byMono;      //Mono detection, 0 - does not detect 1 - detection
    BYTE    byShake;     //Shake detection, 0 - does not detect 1 - detection
    BYTE    byFlash;     //Flash detection, 0 - does not detect 1 - detection
    BYTE    byCover;     //Cover detection, 0 - does not detect 1 - detection
    BYTE    byScene;     //Scene detection, 0 - does not detect 1 - detection
    BYTE    byDark;      //Dark detection, 0 - does not detect 1 - detection
    BYTE    byRes[13];
}NET_DVR_PLAN_VQD_CFG, *LPNET_DVR_PLAN_VQD_CFG;

//IPC5.1.0
typedef struct tagNET_DVR_PRESET_NAME
{
    DWORD dwSize;
    WORD  wPresetNum; //the number of preset
    BYTE  byRes1[2];
    char  byName[NAME_LEN]; //the name of name
    WORD wPanPos;//The level of parameter If access to the data of more than 360 minus 360 by default
    WORD wTiltPos;//The vertical parameters If access to the data of more than 360 minus 360 by default
    WORD wZoomPos;//Variable times parameters if access to the data of more than 360 minus 360 by default
    BYTE byRes[58];
}NET_DVR_PRESET_NAME, *LPNET_DVR_PRESET_NAME;

typedef struct
{
    NET_DVR_SCHEDTIME struSchedTime; //time
    WORD  wAction;  ///< action for schdule
    WORD  wActionNum; ///< the child number of action
    BYTE byres[12];
}NET_DVR_SCHEDTASK,* LPNET_DVR_SCHEDTASK;

typedef struct tagNET_DVR_TIME_TASK
{
    DWORD dwSize;
    BYTE byTaskEnable;   ///1-open,0-close
    BYTE byRes[3];    ///
    NET_DVR_SCHEDTASK struTask[MAX_DAYS][MAX_SCH_TASKS_NUM];
    DWORD dwParkTime;   ///< park time 5s-720s
    BYTE byRes1[64];
}NET_DVR_TIME_TASK,*LPNET_DVR_TIME_TASK;

typedef struct tagNET_DVR_CHANNEL_INDEX
{
    DWORD dwSize;
    DWORD dwChannel ;           //channelNo
    DWORD dwIndex ;             //Index
    BYTE  byRes[64] ;
}NET_DVR_CHANNEL_INDEX, *LPNET_DVR_CHANNEL_INDEX;

typedef struct tagNET_DVR_AUDIO_NAME
{
    DWORD dwSize;
    char  cName[NAME_LEN] ;          //name
    BYTE  byRes[64];
}NET_DVR_AUDIO_NAME, *LPNET_DVR_AUDIO_NAME;

//Logon device param
typedef struct tagNET_DVR_LOGIN_DEVICE_PARAM_
{
    DWORD  dwSize;       //Structure size
    BYTE   byMobileDev;  //Device type, 0- Not mobile device, 1 - Mobile device
    BYTE   byRes[63];    //Reserved
}NET_DVR_LOGIN_DEVICE_PARAM, *LPNET_DVR_LOGIN_DEVICE_PARAM;

typedef enum RECV_DATA_TYPE
{
    ENUM_RECV_ERRCODE = 0x0, //return ErrCode
} RECV_DATA_TYPE;

//Stream output mode
typedef enum tagFISHEYE_STREAM_OUTPUT_MODE_
{
    FISHEYE_STREAM_MODE_FISHEYE    = 1,   //Fisheye
    FISHEYE_STREAM_MODE_PTZ        = 2,   //PTZ
    FISHEYE_STREAM_MODE_PANORAMA   = 3    //Panorama
}FISHEYE_STREAM_OUTPUT_MODE;

//Callback data type
typedef enum _CALLBACK_TYPE_DATA_ENUM_
{
    ENUM_FISHEYE_STREAM_STATUS   = 1,  //Stream output status
    ENUM_FISHEYE_PTZPOS          = 2,  //ptz position of current channel under the picture of fishieye
    ENUM_FISHEYE_REALTIME_OUTPUT = 3   //Realtime output mode
}CALLBACK_TYPE_DATA_ENUM;

//Fisheye stream status
typedef struct tagNET_DVR_FISHEYE_STREAM_STATUS_
{
    DWORD  dwSize;        //Structure size
    BYTE   byStreamMode;  //Stream output mode,refer to FISHEYE_STREAM_OUTPUT_MODE
    BYTE   byRes[63];     //Reserved
}NET_DVR_FISHEYE_STREAM_STATUS,*LPNET_DVR_FISHEYE_STREAM_STATUS;

//Callback data of long link
typedef struct tagNET_DVR_CALLBACK_TYPE_DATA
{
    DWORD  dwChannel;      //Channel number
    DWORD  dwDataType;     //Data type,refer to CALLBACK_TYPE_DATA_ENUM
    DWORD  dwDataLen;      //Data length
    BYTE*  pData;          //Data pointer,if dwTypeData is ENUM_FISHEYE_STREAM_STATUS,pData is a pointer to NET_DVR_FISHEYE_STREAM_STATUS
    BYTE   byRes[64];      //Reserved
}NET_DVR_CALLBACK_TYPE_DATA,*LPNET_DVR_CALLBACK_TYPE_DATA;

//Drag ptz param of fisheye
typedef struct tagNET_DVR_DRAG_POS_PARAM
{
    DWORD           dwChannel;     //Channel number
    DWORD           dwPtzChannel;  //Linkage drag ptz channel.if dwChannel's stream output mode is FISHEYE_STREAM_MODE_FISHEYE,this is the linkage drag ptz channel. When a non-fisheye channel mode,set this to 0
    NET_VCA_POINT   struToPoint;   //Target point,relative to the upper left corner of preview window
    NET_VCA_POINT   struOriPoint;  //Original point,this is the positon that relative to the upper left corner of preview window when beigin dragging
    BYTE            byRes[56];     //Reserved
}NET_DVR_DRAG_POS_PARAM,*LPNET_DVR_DRAG_POS_PARAM;

/************************VQD iVMS-6200(D) V2.1.0 end***********/

typedef struct tagNET_DVR_TEST_SPOTCFG
{
    DWORD dwSize;
    BYTE  byStepCount;
    BYTE  byStepIndex;
    BYTE  byRes[14];
}NET_DVR_TEST_SPOTCFG, *LPNET_DVR_TEST_SPOTCFG;

typedef struct tagNET_DVR_ACCESS_DEVICE_INFO
{
    DWORD    dwSize;
    BYTE     byGroup;
    BYTE    byProType;
    BYTE    byAccessMode;
    BYTE    byRes1;
    char    szUserName[NAME_LEN];
    char    szPassword[PASSWD_LEN];
    char    szDomain[MAX_DOMAIN_NAME];
    NET_DVR_IPADDR struIP;
    WORD    wPort;
    BYTE    szGB28181DevID[DEV_ID_LEN]; //GB28181 protocol access device server ID
    BYTE    byRes2[2];
}NET_DVR_ACCESS_DEVICE_INFO, *LPNET_DVR_ACCESS_DEVICE_INFO;

typedef struct tagNET_DVR_ACCESS_DEVICE_CHANNEL_INFO
{
    DWORD    dwSize;
    DWORD    dwTotalChannelNum;
    BYTE     byChannel[MAX_CHANNUM_V30];
    BYTE    byRes[32];
}NET_DVR_ACCESS_DEVICE_CHANNEL_INFO, *LPNET_DVR_ACCESS_DEVICE_CHANNEL_INFO;

typedef struct tagNET_DVR_PREVIEW_SWITCH_COND
{
    DWORD    dwSize;
    BYTE    byGroup;
    BYTE    byVideoOutType;
    BYTE    byRes[2];
}NET_DVR_PREVIEW_SWITCH_COND, *LPNET_DVR_PREVIEW_SWITCH_COND;

typedef struct tagNET_DVR_PREVIEW_SWITCH_CFG
{
    DWORD    dwSize;
    WORD    wSwitchSeq[MAX_WINDOW_V40];
    BYTE    byPreviewNumber;
    BYTE    byEnableAudio;
    BYTE    bySwitchTime;
    BYTE    bySameSource;
    BYTE    byRes[32];
}NET_DVR_PREVIEW_SWITCH_CFG,* LPNET_DVR_PREVIEW_SWITCH_CFG;

// CVR 2.0.X
typedef struct tagNET_DVR_USER_COND
{
    char        szUserName[NAME_LEN];
    BYTE        byRes[48];
}NET_DVR_USER_COND, *LPNET_DVR_USER_COND;

typedef struct tagNET_DVR_USER_RIGHT_CFG
{
    DWORD            dwSize;
    BYTE            byAddMonitoringPointRight;
    BYTE            byModMonitoringPointRight;
    BYTE            byDelMonitoringPointRight;
    BYTE            bySetRecordPlanRight;
    BYTE            byDelRecordPlanRight;
    BYTE            byEnableOrDisableRecordPlanRight;
    BYTE            byManualRecordRight;
    BYTE            bySetAlarmRecordRight;
    BYTE            byRecordBackupRight;
    BYTE            byRecordDownloadRight;
    BYTE            byRecordDeleteRight;
    BYTE            byDelBackupRecordRight;
    BYTE            bySetBackupVolumeRight;
    BYTE            byRecordPlayBackRight;
    BYTE            byLogDeleteRight;
    BYTE            byLogDownloadRight;
    BYTE            byAddUserRight;
    BYTE            byDelUserRight;
    BYTE            byModUserRight;
    BYTE            byAllocUserRight;
    BYTE            byRes[128];
}NET_DVR_USER_RIGHT_CFG, *LPNET_DVR_USER_RIGHT_CFG;

typedef struct tagNET_DVR_MACHINE_MAX_NUM_CFG
{
    DWORD                dwSize;
    DWORD               dwMaxNum;
    BYTE                   byRes[32];
}NET_DVR_MACHINE_MAX_NUM_CFG, *LPNETDVR_MACHINE_MAX_NUM_CFG;


typedef struct tagNET_DVR_N_PLUS_ONE_WORK_MODE_CFG
{
    DWORD    dwSize ;
    BYTE    byWorkMode;        //0-working device 1-redundant device
    BYTE    byRes[127];
}NET_DVR_N_PLUS_ONE_WORK_MODE_CFG, *LPNET_DVR_N_PLUS_ONE_WORK_MODE_CFG;

typedef struct tagNET_DVR_ADD_PARAM
{
    NET_DVR_IPADDR    struIP;
    char            szPassword[PASSWD_LEN];
    BYTE             byAddType;
    BYTE             byDisableBackup;
}NET_DVR_ADD_PARAM, *LPNET_DVR_ADD_PARAM;

typedef struct tagNET_DVR_DEL_PARAM
{
    NET_DVR_IPADDR    struIP;
    BYTE             byDelType;
}NET_DVR_DEL_PARAM, *LPNET_DVR_DEL_PARAM;

typedef union tagNET_DVR_NPO_PARAM_UNION
{
    NET_DVR_ADD_PARAM    struAddParam;
    NET_DVR_DEL_PARAM     struDelParam;
}NET_DVR_NPO_PARAM_UNION, *LPNET_DVR_NPO_PARAM_UNION;

typedef struct tagNET_DVR_N_PLUS_ONE_DEVICE_PARAM
{
    DWORD                    dwSize;
    NET_DVR_NPO_PARAM_UNION unionParam;
    BYTE                     byType;
    BYTE                      byRes2[255];
}NET_DVR_N_PLUS_ONE_DEVICE_PARAM, *LPNET_DVR_N_PLUS_ONE_DEVICE_PARAM;

typedef struct tagNET_DVR_HD_STATUS
{
    DWORD     dwSize;
    BYTE     bySleepStatus;/*0-Not sleep 1-sleep*/
    BYTE      byRes[127];
}NET_DVR_HD_STATUS, *LPNET_DVR_HD_STATUS;

typedef struct tagNET_DVR_RAID_BTS_CFG
{
    DWORD     dwSize;
    BYTE     bySpeed;    /*0-Low 1-Mid 2-High*/
    BYTE      byRes[127];
}NET_DVR_RAID_BTS_CFG, *LPNET_DVR_RAID_BTS_CFG;

typedef struct tagNET_DVR_DATA_CALLBACK_CFG
{
    DWORD                dwSize;
    BYTE                   byEnable;
    BYTE                   byDelData;
    BYTE                   byRes[30];
}NET_DVR_DATA_CALLBACK_CFG, *LPNET_DVR_DATA_CALLBACK_CFG;

typedef struct tagNET_DVR_LUN_CLONE
{
    DWORD                dwSize;
    DWORD                dwSrcLunID;
    DWORD               dwDstLunID;
    BYTE                   byRes[32];
}NET_DVR_LUN_CLONE, *LPNET_DVR_LUN_CLONE;

typedef struct tagNET_DVR_LUN_EXPAND
{
    DWORD                dwSize;
    DWORD                dwLunID;
    DWORD                dwHSize;
    DWORD                dwLSize;
    char                szArrayIDGroup[NAME_LEN];
    char                   szNewLunName[MAX_NAMELEN];
    BYTE                   byRes[32];
}NET_DVR_LUN_EXPAND, *LPNET_DVR_LUN_EXPAND;

typedef struct tagNET_DVR_DVR_NET_DISK_CREATE
{
    DWORD                dwSize;
    char                   szRaidName[MAX_NAMELEN];
    char                   szDvrNetDiskName[MAX_NAMELEN];
    DWORD                dwBlockSize;
    DWORD               dwHCapacity;
    DWORD               dwLCapacity;
    NET_DVR_IPADDR        struWarrantIP;
    BYTE                   byRes[32];
}NET_DVR_DVR_NET_DISK_CREATE, *LPNET_DVR_DVR_NET_DISK_CREATE;

typedef struct tagNET_DVR_DVR_NET_DISK_MODIFY
{
    DWORD                dwSize;
    char                szOldDvrNetDiskName[MAX_NAMELEN];
    char                   szNewDvrNetDiskName[MAX_NAMELEN];
    NET_DVR_IPADDR        struWarrantIP;
    BYTE                   byRes[32];
}NET_DVR_DVR_NET_DISK_MODIFY, *LPNET_DVR_DVR_NET_DISK_MODIFY;

typedef struct tagNET_DVR_DVR_NET_DISK_DEL_
{
    DWORD                dwSize;
    char                szDvrNetDiskName[MAX_NAMELEN];
    BYTE                   byRes[32];
}NET_DVR_DVR_NET_DISK_DEL, *LPNET_DVR_DVR_NET_DISK_DEL;

typedef struct tagNET_DVR_NAS_PARAM
{
    DWORD                dwSize;
    DWORD                dwLunID;
    BYTE                   byRes[32];
}NET_DVR_NAS_PARAM, *LPNET_DVR_NAS_PARAM;

typedef struct tagNET_DVR_ISCSI_PARAM
{
    DWORD                dwSize;
    DWORD                dwTargetID;
    DWORD                dwLunID;
    DWORD                dwAccessMode;
    NET_DVR_IPADDR        struClientIP;
    BYTE                   byRes[32];
}NET_DVR_ISCSI_PARAM, *LPNET_DVR_ISCSI_PARAM;

typedef struct tagNET_DVR_FC_PARAM
{
    DWORD                dwSize;
    DWORD                dwStoreLunID;
    DWORD                dwLogicLunID;
    DWORD                dwHbaID;
    DWORD                dwAccessMode;
    char                szClientWWWPN[NAME_LEN];
    BYTE                   byRes[32];
}NET_DVR_FC_PARAM, *LPNET_DVR_FC_PARAM;

typedef struct tagNET_DVR_LUN_PARAM
{
    DWORD        dwHCapacity;
    DWORD        dwLCapacity;
    char        szName[MAX_NAMELEN];
    DWORD        dwBlockSize;
    char        szArrayIDGroup[NAME_LEN];
}NET_DVR_LUN_PARAM, *LPNET_DVR_LUN_PARAM;


typedef struct tagNET_DVR_DVR_PARAM_
{
    DWORD        dwHCapacity;
    DWORD        dwLCapacity;
    char            szName[MAX_NAMELEN];
    DWORD        dwBlockSize;
    NET_DVR_IPADDR    struWarrantIP;
    char            szArrayIDGroup[NAME_LEN];
}NET_DVR_DVR_PARAM, *LPNET_DVR_DVR_PARAM;

typedef union tagNET_DVR_VD_UNION
{
    BYTE                        byUnionLen[256];
    NET_DVR_OPERATE_VD_PARAM    struHikVDParam;
    NET_DVR_LUN_PARAM            struLunParam;
    NET_DVR_DVR_PARAM            struDvrParam;
}NET_DVR_VD_UNION, *LPNET_DVR_VD_UNION;

typedef struct tagNET_DVR_OPERATE_VD_PARAM_EX
{
    BYTE                byVDType;
    BYTE                byRes1[3];
    NET_DVR_VD_UNION     uVDParam;
    BYTE                byRes2[32];
}NET_DVR_OPERATE_VD_PARAM_EX, *LPNET_DVR_OPERATE_VD_PARAM_EX;


typedef struct tagNET_DVR_CVR_ALARM
{
    char            szFirstType[NAME_LEN];
    char            szFirstIndex[NAME_LEN];
    char            szSecondType[NAME_LEN];
    NET_DVR_TIME    struTime;
    BYTE             byStatus;
    BYTE            byAlarmLevel;
    BYTE            byRes1[2];
    char               szSecondIndex[NAME_LEN];
    char            szThirdType[NAME_LEN];
    char            szThirdIndex[NAME_LEN];
    char            szFourthType[NAME_LEN];
    char            szFourthIndex[NAME_LEN];
    BYTE              byRes2[92];
}NET_DVR_CVR_ALARM, *LPNET_DVR_CVR_ALARM;

typedef struct tagNET_DVR_WORKING_DEVICE_INFO
{
    NET_DVR_IPADDR    struIP;
    BYTE             byLinkStatus;
    BYTE             byWorkStatus;
    BYTE             byBacupStatus;
    BYTE             bySyncProgress;
    NET_DVR_TIME_EX    struSyncBeginTime;
    NET_DVR_TIME_EX    struSyncEndTime;
    char            szSerialNumber[SERIALNO_LEN] ;
    DWORD            dwSoftwareVersion ;
    BYTE              byWorkingDeviceGUID[GUID_LEN];
    char            szDevTypeName[DEV_TYPE_NAME_LEN];
    WORD            wDevType;
}NET_DVR_WORKING_DEVICE_INFO, *LPNET_DVR_WORKING_DEVICE_INFO;

typedef struct tagNET_DVR_REDUNDANT_DEVICE_INFO
{
    NET_DVR_IPADDR    struIP;
    BYTE     byWorkStatus;
    BYTE     byBackupStatus;
    WORD    wBackupPort;
}NET_DVR_REDUNDANT_DEVICE_INFO, *LPNET_DVR_REDUNDANT_DEVICE_INFO;

typedef union tagNET_DVR_NPO_DEV_INFO_UNION
{
    BYTE                             byUnionLen[512];
    NET_DVR_WORKING_DEVICE_INFO        struWorkingDeviceInfo;
    NET_DVR_REDUNDANT_DEVICE_INFO    struRedundantDeviceInfo;
}NET_DVR_NPO_DEV_INFO_UNION, *LPNET_DVR_NPO_DEV_INFO_UNION;

typedef struct tagNET_DVR_N_PLUS_ONE_DEVICE_INFO
{
    DWORD                        dwSize;
    NET_DVR_NPO_DEV_INFO_UNION    unionDevInfo;
    BYTE                        byType;
    BYTE                           byRes[127];
}NET_DVR_N_PLUS_ONE_DEVICE_INFO, *LPNET_DVR_N_PLUS_ONE_DEVICE_INFO;


typedef struct tagNET_DVR_UPGRADE_IPC_PARAM
{
    NET_DVR_STREAM_INFO    struStreamInfo[MAX_CHANNUM_V30];
    char                  szFileName[260];
}NET_DVR_UPGRADE_IPC_PARAM, *LPNET_DVR_UPGRADE_IPC_PARAM;

typedef struct tagNET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE
{
    NET_DVR_STREAM_INFO    struStreamInfo;
    WORD                wErrCode;
    BYTE                byRes[30];
}NET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE, *LPNET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE;

typedef struct tagNET_DVR_UPGRADE_IPC_ERR_INFO
{
    NET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE struErrInfoSingle[MAX_CHANNUM_V30];
}NET_DVR_UPGRADE_IPC_ERR_INFO, *LPNET_DVR_UPGRADE_IPC_ERR_INFO;

typedef struct tagNET_DVR_IPC_CFG_FILE_PARAM
{
    char          szFileName[260];
    BYTE        byRes[32];
}NET_DVR_IPC_CFG_FILE_PARAM, *LPNET_DVR_IPC_CFG_FILE_PARAM;

typedef struct tagNET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE
{
    WORD     wRow;
    WORD    wErrCode;
    BYTE    byRes[32];
}NET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE, *LPNET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE;

typedef struct tagNET_DVR_IPC_CFG_FILE_ERR_INFO
{
    NET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE     struErrInfoSingle[MAX_CHANNUM_V30];
}NET_DVR_IPC_CFG_FILE_ERR_INFO, *LPNET_DVR_IPC_CFG_FILE_ERR_INFO;

typedef struct tagNET_DVR_PTZ_PATTERN
{
    DWORD dwSize;
    DWORD dwChannel; //channel
    DWORD dwPatternCmd; //pattern command
    DWORD dwPatternID; //pattern ID
    BYTE  byRes[64];
}NET_DVR_PTZ_PATTERN, *LPNET_DVR_PTZ_PATTERN;

typedef struct tagNET_DVR_PTZ_PARKACTION_CFG
{
    DWORD dwSize;
    BYTE  byEnable; //enable,0-no,1-yes
    BYTE  byOneTouchSwitch;//One Key Switch, 0-no,1-yes 2014-03-15
    BYTE  byRes1[2];
    DWORD dwParkTime; //park time, second
    WORD  wActionType; //action type,0-atuoScan\A3\AC1-frameScan\A3\AC2-randomScan\A3\AC3-patrol\A3\AC4-pattern\A3\AC5-preset,\A3\AC6-panoramaScan\A3\AC7-verticalScan\A3\AC8-8-regionScan
    WORD  wID; //ID
    BYTE  byRes[128];
}NET_DVR_PTZ_PARKACTION_CFG, *LPNET_DVR_PTZ_PARKACTION_CFG;

typedef struct tagNET_DVR_PTZ_MANUALTRACE
{
    DWORD dwSize;
    DWORD dwChannel;
    NET_VCA_POINT struPoint;
    BYTE  byTrackType;
    BYTE  byLinkageType;
    BYTE  byRes[2];
    NET_VCA_POINT struPointEnd;
    NET_DVR_TIME_V30 struTime;//Time\A1\A3
    DWORD dwSerialNo;//Serial No.\A3\BB
    BYTE  byRes1[36];
}NET_DVR_PTZ_MANUALTRACE, *LPNET_DVR_PTZ_MANUALTRACE;

/************************************VQD start ******************************************/

typedef enum tagVQD_TYPE
{
    VQD_BLUR_FLAG     = 0x00000001, //Blurred Image
    VQD_LUMA_FLAG     = 0x00000002, //Abnormal Brightness
    VQD_CHROMA_FLAG   = 0x00000004,  //Color Cast
    VQD_SNOW_FLAG     = 0x00000008,  //Snow Noise
    VQD_STREAK_FLAG   = 0x00000010,  //Stripe Noise
    VQD_FREEZE_FLAG   = 0x00000020,  //Freeze Frame
    VQD_SIGLOSE_FLAG  = 0x00000040,  //Signal Loss
    VQD_PTZ_FLAG      = 0x00000080   //PTZ Control Failed
}VQD_TYPE;


typedef struct tagNET_DVR_VQD_LOOP_DIAGNOSE_CFG
{
    DWORD   dwSize ;        //struct size
    BYTE    byEnable;        //enbale  0 :close, 1:open
    BYTE     byRes1[3] ;
    BYTE    byVQDTypeEnable[32]; /*The diagnosis mode   result of operation OR such as */
    /*0- Blur, 1-Luma, 2-Chroma,    3-Snow,   4-Streak,  5-Freeze,  6-Siglose,  7-PTZ*/
    BYTE    byThresholdValue[32] ;       //Threshold value 0~100\A3\ACThe different diagnostic mode has its own Threshold
    NET_DVR_HANDLEEXCEPTION_V40      struAlarmHandleType;   //alarm
    NET_DVR_SCHEDTIME   struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_SCHEDTIME   struHolidayAlarmTime[MAX_TIMESEGMENT_V30];
    BYTE    byRes[324];
}NET_DVR_VQD_LOOP_DIAGNOSE_CFG, *LPNET_DVR_VQD_LOOP_DIAGNOSE_CFG;


typedef struct tagNET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO
{
    DWORD  dwChannelNO;  //channel No.
    DWORD  dwVQDType;     // The diagnosis mode
    NET_DVR_TIME struDiagnoseTime;    //diagnose Time
    BYTE    byScoreValue;       //score value, centesimal system
    BYTE     byRes[27];
}NET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO ,*LPNET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO;


typedef struct tagNET_DVR_VQD_DIAGNOSE_INFO
{
    DWORD  dwSize ;
    NET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO  struVQDDiagnoseExceptionInfo ; //Diagnose info
}NET_DVR_VQD_DIAGNOSE_INFO, *LPNET_DVR_VQD_DIAGNOSE_INFO;
/************************************VQD End******************************************/

/********************************DS_19DXX 104 protocol begin****************************/
typedef struct tagNET_DVR_INPUT_INFO
{
    DWORD        dwSize;
    BYTE        byChanType;        //input type\A3\AC1-local sensor\A3\AC2-local switch\A3\AC3-485\A3\AC4-net
    BYTE        byRes1[3];
    DWORD        dwChanNo;        //channel no
    DWORD        dwSubChanNo;    //sub channel no.
    DWORD        dwVariableNo;    //variable no.
    BYTE        byRes2[60];
}NET_DVR_INPUT_INFO, *LPNET_DVR_INPUT_INFO;

typedef struct tagNET_DVR_ALARM_VARIABLE_CFG
{
    DWORD        dwSize;
    WORD        wVariableIndex;        //variable no. (only can be getted)
    WORD        wVariableType;        //variable type 1-sensor 2-switch(only can be getted)
    BYTE        sDescribe[NAME_LEN];//variable name
    BYTE        byLimitLineType;    //limit line type\A3\AC0-no limit line\A3\AC1-two limit lines\A3\AC2-four limit lines
    BYTE        byRes[31];
}NET_DVR_ALARM_VARIABLE_CFG, *LPNET_DVR_ALARM_VARIABLE_CFG;

typedef struct tagNET_DVR_ALARM_SENSOR_POINT_CFG
{
    int           nMeasureHigh;   // measure high
    int           nMeasureLow;    //  measure low
    BYTE        byAlarmMode;    //alarm mode -HHHH(1111)\A1\A2-HHHL(1110)\A1\A2-HHLL(1100)\A1\A2HLLL(1000)\A1\A2-LLLL(0000)
    BYTE         byRes1[3];
    int            nAlarmValue[4];       //alarm value
    DWORD          dwOsdCfg;        //osd, bit0 means channel 1, bit1 means channel2 .....
    DWORD        dwSensitive;
    DWORD        dwIPChanOsd;    // ip channel osd\A3\ACbit0 means channel 1, bit1 means channel2 .....
    BYTE        byRes[24];
}NET_DVR_ALARM_SENSOR_POINT_CFG,*LPNET_DVR_ALARM_SENSOR_POINT_CFG;

typedef struct tagNET_DVR_ALARM_SWITCH_POINT_CFG
{
    BYTE        byRes[64];
}NET_DVR_ALARM_SWITCH_POINT_CFG,*LPNET_DVR_ALARM_SWITCH_POINT_CFG;

typedef union tagNET_DVR_ALARM_POINT_PARAM_UNION
{
    BYTE    byLength[64];
    NET_DVR_ALARM_SENSOR_POINT_CFG struSensor;    //sensor parameter
    NET_DVR_ALARM_SWITCH_POINT_CFG struSwitch;    //switch parameter
}NET_DVR_ALARM_POINT_PARAM_UNION,*LPNET_DVR_ALARM_POINT_PARAM_UNION;

typedef struct tagNET_DVR_ALARM_POINT_CFG
{
    DWORD        dwSize;
    DWORD        dwPointNo;            //point no.
    BYTE        sPointDescribe[NAME_LEN];        //point describe
    NET_DVR_ALARM_POINT_PARAM_UNION struPointParam;
    BYTE        byPointType;        //point type\A3\AC1-sensor\A3\AC2-switch
    BYTE        byChanType;
    BYTE        byRes1[2];
    DWORD        dwChanNo;
    DWORD        dwSubChanNo;
    DWORD        dwVariableNo;
    BYTE        byRes[16];
}NET_DVR_ALARM_POINT_CFG, *LPNET_DVR_ALARM_POINT_CFG;

typedef struct _NET_DVR_SEARCH_CONDITION
{
    DWORD        dwSize;
    BYTE        byMajorType;    //major type\A3\AC1-aa\A3\AC2-time\A3\AC 3-type\A3\AC4-time && type
    BYTE        byMinorType;    //1-point\A3\AC2-channel && subchannel && variable
    BYTE        byRes1[2];
    NET_DVR_TIME        struStartTime;    //start time
    NET_DVR_TIME        struStopTime;    //stop time
    BYTE        byChanType;        //channel type;\A3\AC1-sensor\A3\AC2-switch\A3\AC3-485
    BYTE        byRes2[3];
    DWORD        dwChanNo;        //channel no. start from 1\A3\AC0xffffffff means invalid
    DWORD        dwSubChanNo;    //slot no\A3\ACstart from 1\A3\AC0xffffffff means invalid
    DWORD        dwVariableNo;    //variable no\A3\ACstart from 1\A3\AC0xffffffff means invalid
    DWORD        dwPointNo;        //point no\A3\AC0xffffffff means invalid
    BYTE        byDataType;        //0-normal data\A3\AC1-up data\A3\AC2-down data
    BYTE          byRes3[31];
}NET_DVR_SEARCH_CONDITION, *LPNET_DVR_SEARCH_CONDITION;

typedef struct _NET_DVR_HISTORY_DATA
{
    DWORD        dwSize;
    NET_DVR_TIME        struTime;    //time
    BYTE        byChanType;        //channel type\A3\AC1-sensor\A3\AC2-switch\A3\AC3-485\A3\AC0xff means invalid
    BYTE        byRes1[3];
    DWORD        dwChanNo;        //channel no. start from 1\A3\AC0xffffffff means invalid
    DWORD        dwSubChanNo;    //slot no\A3\ACstart from 1\A3\AC0xffffffff means invalid
    DWORD        dwVariableNo;    //variable no\A3\ACstart from 1\A3\AC0xffffffff means invalid
    DWORD        dwPointNo;        //point no\A3\AC0xffffffff means invalid
    int            iData;            //history data
    BYTE        byDataType;
    BYTE        byRes2[31];
}NET_DVR_HISTORY_DATA, *LPNET_DVR_HISTORY_DATA;

typedef struct tagNET_DVR_ALARMHOST_ALARM_MODE_CFG
{
    DWORD        dwSize;
    BYTE    byDataUploadMode;    //1-upload by channel\A3\AC2-upload by point
    BYTE    byRes[31];
}NET_DVR_ALARMHOST_ALARM_MODE_CFG,*LPNET_DVR_ALARMHOST_ALARM_MODE_CFG;


typedef struct tagNET_DVR_ALARMHOST_POINT_VALUE
{
    BYTE    byChanType;        //channel type\A3\AC1-sensor\A3\AC2-switch\A3\AC3-485\A3\AC4-net channel 0xff means invalid
    BYTE    byPointType;    //point type,1-sensor\A3\AC2-switch
    BYTE    byRes1[2];
    DWORD     dwChanNo;        //channel no. start from 1\A3\AC0xffffffff means invalid
    DWORD    dwSubChanNo;    //slot no\A3\ACstart from 1\A3\AC0xffffffff means invalid
    DWORD    dwVariableNo;    //variable no\A3\ACstart from 1\A3\AC0xffffffff means invalid
    DWORD     dwPointNo;        //point no\A3\AC0xffffffff means invalid
    int        iValue;            //point value
    BYTE    byRes[16];
}NET_DVR_ALARMHOST_POINT_VALUE,*LPNET_DVR_ALARMHOST_POINT_VALUE;

typedef union tagNET_DVR_ALARMHOST_DATA_UNION
{
    BYTE    byLength[40];
    NET_DVR_ALARMHOST_POINT_VALUE struPointValue;
}NET_DVR_ALARMHOST_DATA_UNION,*LPNET_DVR_ALARMHOST_DATA_UNION;

typedef struct tagNET_DVR_ALARMHOST_DATA_UPLOAD
{
    DWORD        dwSize;
    BYTE        byDataType;        //data type\A3\AC1-point value upload
    BYTE        byRes1[3];
    NET_DVR_ALARMHOST_DATA_UNION struAlarmData;
    BYTE        byRes2[32];
} NET_DVR_ALARMHOST_DATA_UPLOAD, *LPNET_DVR_ALARMHOST_DATA_UPLOAD;
/********************************DS_19DXX 104 protocol end****************************/

typedef struct  tagNET_DVR_INPUTVOLUME
{
    DWORD  dwSize;
    BYTE   byAudioInputChan;
    BYTE   byRes[63];
}NET_DVR_INPUTVOLUME, *LPNET_DVR_INPUTVOLUME;

//IPC5.0.5
typedef struct tagNET_DVR_AUDIOOUT_VOLUME
{
    DWORD  dwSize;
    BYTE   byAudioOutVolume;// LEVEL\A3\BA0-100
    BYTE   byRes[63];
}NET_DVR_AUDIOOUT_VOLUME,*LPNET_DVR_AUDIOOUT_VOLUME;

typedef struct tagNET_DVR_FUZZY_UPGRADE
{
    DWORD  dwSize;
    char  sUpgradeInfo[MAX_UPGRADE_INFO_LEN];
    BYTE  byRes[64];
}NET_DVR_FUZZY_UPGRADE,*LPNET_DVR_FUZZY_UPGRADE;

/************************************code splitter Start******************************************/

typedef struct tagNET_DVR_RS485_WORK_MODE
{
    DWORD dwSize;
    BYTE  byWorkMode; //work mode\A3\AC0-console\A3\AC1-private transparent channel\A3\AC2-transparent channel
    BYTE  byRes[31];
}NET_DVR_RS485_WORK_MODE, *LPNET_DVR_RS485_WORK_MODE;

typedef struct tagNET_DVR_TRANSPARENT_CLIENT_SINGLE
{
    BYTE byEnable; //enable transparent channel\A3\AC0-disable\A3\AC1-enable
    BYTE byRes1[3];
    NET_DVR_IPADDR struIP; //remote device ip
    WORD wPort; //remote device port
    BYTE byRes2[18];
}NET_DVR_TRANSPARENT_CLIENT_SINGLE, *LPNET_DVR_TRANSPARENT_CLIENT_SINGLE;

typedef struct tagNET_DVR_TRANSPARENT_SERVER_SINGLE
{
    BYTE byEnable; //enable transparent channel\A3\AC0-disable\A3\AC1-enable
    BYTE byRes1[3];
    NET_DVR_IPADDR struIP; //allowed access remote device ip
    BYTE byRes2[16];
}NET_DVR_TRANSPARENT_SERVER_SINGLE, *LPNET_DVR_TRANSPARENT_SERVER_SINGLE;

typedef struct tagNET_DVR_TRANSPARENT_CLIENT_MODE
{
    NET_DVR_TRANSPARENT_CLIENT_SINGLE struClientSingle[MAX_TRANSPARENT_CHAN_NUM];
    BYTE byRes[320];
}NET_DVR_TRANSPARENT_CLIENT_MODE, *LPNET_DVR_TRANSPARENT_CLIENT_MODE;

typedef struct tagNET_DVR_TRANSPARENT_SERVER_MODE
{
    WORD wPort; //local listen port
    BYTE byRes1[2];
    NET_DVR_TRANSPARENT_SERVER_SINGLE struServerSingle[MAX_TRANSPARENT_ACCESS_NUM];
    BYTE byRes2[332];
}NET_DVR_TRANSPARENT_SERVER_MODE, *LPNET_DVR_TRANSPARENT_SERVER_MODE;

typedef union tagNET_DVR_TRANSPARENT_CHAN_WORK_MODE_UNION
{
    BYTE byRes[512];
    NET_DVR_TRANSPARENT_CLIENT_MODE struClientMode;  //cilent mode config
    NET_DVR_TRANSPARENT_SERVER_MODE struServerMode; //server mode config
}NET_DVR_TRANSPARENT_CHAN_WORK_MODE_UNION, *LPNET_DVR_TRANSPARENT_CHAN_WORK_MODE_UNION;

typedef struct tagNET_DVR_TRANSPARENT_CHAN_CFG
{
    DWORD dwSize;
    BYTE  byWorkMode; //transparent channel work mode\A3\AC1-client mode\A3\AC2-server mode
    BYTE  byRes[3];
    NET_DVR_TRANSPARENT_CHAN_WORK_MODE_UNION struTransparentPara;
}NET_DVR_TRANSPARENT_CHAN_CFG, *LPNET_DVR_TRANSPARENT_CHAN_CFG;

/************************************code splitter End******************************************/


/********************************POS start*******************************************/

typedef struct tagNET_DVR_NAKED_DATA_INFO
{
    char   sSocketIP[128];
    WORD   wSocktPort;
    BYTE   byRes[258];
}NET_DVR_NAKED_DATA_INFO, *LPNET_DVR_NAKED_DATA_INFO;

typedef enum tagNAKED_DATA_TYPE
{
    NAKED_DATA_TYPE_NOT_DEFINED = 0, //Undefined
    NAKED_DATA_TYPE_POS_INFO    //Pos Info
}NAKED_DATA_TYPE;


typedef struct tagNET_DVR_NAKED_DATA_PARAM
{
    WORD  wPort;           //IP Port 7050
    BYTE byRes[130];
}NET_DVR_NAKED_DATA_PARAM, *LPNET_DVR_NAKED_DATA_PARAM;

#define UPLOAD_POS_INFO     1001  //Upload Pos Info

typedef struct tagNET_DVR_POS_INFO
{
    NET_DVR_STRUCTHEAD     struVerHead;  //Ver head
    DWORD dwChannelNum;          // channel numbers
    BYTE  byRes[60];
}NET_DVR_POS_INFO, *LPNET_DVR_POS_INFO;


#define MAX_IGNORE_STRING_NUM        4
#define FILTERRULE_NUM              4
#define MAX_POS_FILTER_DATA_LEN     128

typedef struct tagNET_DVR_POS_OSD_REGION
{
    NET_VCA_POINT   struStart;   //Start Point
    NET_VCA_POINT   struEnd;    //End Point
}NET_DVR_POS_OSD_REGION, *LPNET_DVR_POS_OSD_REGION;

typedef struct
{
    DWORD dwDelayTime;                /*delay time(5-3600s)*/
    BYTE  byPrevOsd;                   /*overlay osd on preview*/
    BYTE  byRes1[3];                    /*preserve*/
    NET_DVR_POS_OSD_REGION  struOsdPosInfo;          /*overlay osd rect info*/
    BYTE  byRes[64];                   /*preserve*/
}NET_DVR_POS_ACTION, *LPNET_DVR_POS_ACTION;

typedef struct
{
    BYTE sData[MAX_POS_FILTER_DATA_LEN];
    BYTE byExclusive;    //if or not include tag itself 0-include 1-not include
    BYTE byFlagType;    //flag type\A3\BA0-string\A3\BB1-hex
    BYTE byRes[2];                    /*Reserve*/
}NET_DVR_GENERIC_START, *LPNET_DVR_GENERIC_START;

typedef struct
{
    BYTE  sData[MAX_POS_FILTER_DATA_LEN];/*end of Transaction*/
    BYTE  byExclusive;    //if or not include tag itself 0-include 1-not include
    BYTE  byFlagType;    //flag type\A3\BA0-string\A3\BB1-hex
    BYTE  byRes[6];
} NET_DVR_GENERIC_END, *LPNET_DVR_GENERIC_END;

typedef struct
{
    BYTE  sData[MAX_POS_FILTER_DATA_LEN];
    BYTE  byFlagType;    //flag type\A3\BA0-string\A3\BB1-hex
    BYTE  byRes[3];
}NET_DVR_GENERIC_DATA_CFG, *LPNET_DVR_GENERIC_DATA_CFG;

typedef struct
{
    BYTE sData[MAX_POS_FILTER_DATA_LEN];/*Ignore char*/
}NET_DVR_IGNORE_STRING, *LPNET_DVR_IGNORE_STRING;

typedef struct
{
    BYTE  byCaseSensitive;/*Case Sensitive \A3\AC0->no\A3\AC1->yes*/
    BYTE  byRes1[7];
    NET_DVR_GENERIC_START struTransactionStart;/*start of transcation*/
    NET_DVR_GENERIC_END struTransactionEnd;/*end of transcation*/
    NET_DVR_GENERIC_DATA_CFG struLineDeli;/*New Line char*/
    NET_DVR_IGNORE_STRING struIgnoreString[MAX_IGNORE_STRING_NUM];/*Ingnore Char*/
    BYTE byRes[40];    // Reserve
}NET_DVR_POS_GENERIC, *LPNET_DVR_GENERIC;

typedef struct
{
    DWORD  dwPosAddr;/*Pos Address*/
    BYTE   byRes[948];
}NET_DVR_POS_AVE, *LPNET_DVR_AVE;

#define SERIAL_NUM_LEN 8
typedef struct tagNET_DVR_POS_NUCLEUS/*size 952byte*/
{
    char   szEmployeeNo[SERIAL_NUM_LEN];
    char   szTerminalNo[SERIAL_NUM_LEN];
    char   szShiftNo[SERIAL_NUM_LEN];
    BYTE      byRes[928];
}NET_DVR_POS_NUCLEUS, *LPNET_DVR_POS_NUCLEUS;

typedef  union _NET_DVR_POS_PROTOCOL_UNION
{
    BYTE byLenth[952];   //the union lenth
    NET_DVR_POS_GENERIC struGeneric;
    NET_DVR_POS_AVE struAve;
    NET_DVR_POS_NUCLEUS struNUCLEUS;
}NET_DVR_POS_PROTOCOL_UNION,*LPNET_DVR_POS_PROTOCOL_UNION;

typedef enum tagNET_DVR_CHARSET_ENUM
{
    ENUM_UTF8 =0,
    ENUM_GB2312,
    ENUM_LATIN1,
    ENUM_LATIN2,
    ENUM_LATIN3,
    ENUM_LATIN4,
    ENUM_CYRILLIC,
    ENUM_ARABIC,
    ENUM_GREEK,
    ENUM_HEBREW,
    ENUM_TURKISH,
    ENUM_NORDIC,
    ENUM_THAI,
    ENUM_LATIN7,
    ENUM_LATIN8,
    ENUM_LATIN9,
    ENUM_LATIN10,
    ENUM_CENTRAL_EUROPEAN,
    ENUM_CYRILLIC_SCRIPT,
    ENUM_HEBREW_DOS862
}NET_DVR_CHARSET_ENUM, *LPNET_DVR_CHARSET_ENUM;

typedef struct
{
    BYTE byEnable;    //
    BYTE byRes1[3];   //reserve
    BYTE  sPosName[NAME_LEN];/*POS Name */
    DWORD dwProtocolType;/*Protocal Type\A3\AC1->generic text, 2->AVE VSI-ADD    3->AVE Vnet  */
    NET_DVR_POS_PROTOCOL_UNION struPosProtocol;   //POS Protocal
    NET_DVR_POS_ACTION struAction;/*Action*/
    BYTE byRes[64];
}NET_DVR_FILTER_CONFIG, *LPNET_DVR_FILTER_CONFIG;

typedef struct
{
    DWORD   dwSize;
    BYTE     byEnable;            //Filter Enable
    BYTE     byCharSetType;      //NET_DVR_CHARSET_ENUM
    BYTE    byRes1;
    BYTE    byProtocolType;//Protocol Type, 1->generic text (universal Protocol), 2->AVE VSI-ADD     3->AVE Vnet,4-EPSON, 5 - NUCLEUS
    NET_DVR_POS_PROTOCOL_UNION uPosProtocol;   //POS
    BYTE    byRes[32];
}NET_DVR_POS_FILTER_CFG, *LPNET_DVR_POS_FILTER_CFG;

typedef struct  tagNET_DVR_NET_SNIFF
{
    BYTE       byEnableSourcePort;
    BYTE       byEnableDestAddr;
    BYTE       byEnableDestPort;
    BYTE       byRes1;
    BYTE       bySourceIpAddr[MAX_DOMAIN_NAME];
    BYTE       byDestinationIpAddr[MAX_DOMAIN_NAME];
    WORD          wSourcePort;
    WORD          wDestinationPort;
    BYTE       byRes[16];
}NET_DVR_NET_SNIFF, *LPNET_DVR_NET_SNIFF;


typedef struct
{
    WORD  wNetPort;  /*device net port*/
    BYTE  byRes[2];
}NET_DVR_NET_RECEIVE, *LPNET_DVR_NET_RECEIVE;

typedef struct tagNET_DVR_MONITOR_INFO
{
    WORD  wPort;
    BYTE   byRes1[2];
    NET_DVR_IPADDR  struRestrictRemoteIP;
    BYTE   byRes[164];
}NET_DVR_MONITOR_INFO, *LPNET_DVR_MONITOR_INFO;

typedef struct tagNET_DVR_ADDRESS
{
    NET_DVR_IPADDR struIP;
    WORD wPort;
    BYTE byRes[2];
}NET_DVR_ADDRESS,*LPNET_DVR_ADDRESS;

typedef union tagNET_DVR_POS_CONNECTMODE_UNION
{
    BYTE                       byLen[312];      //union Len
    NET_DVR_NET_RECEIVE     struNetRecv;     //Net recv mode
    NET_DVR_MONITOR_INFO     struTcpMonitor;    //tcp monitor mode
    NET_DVR_SINGLE_RS232     struRS232;        //RS232
    NET_DVR_MONITOR_INFO     struUdpMonitor;     //udp monitor mode
    NET_DVR_NET_SNIFF          struSniff;          //Sniff mode
    NET_DVR_ADDRESS            struMcast;          //multii-cast mode
    NET_DVR_USB_RS232         struUSBRS232;    //USB To Rs232 Mode
}NET_DVR_POS_CONNECTMODE_UNION, *LPNET_DVR_POS_CONNECTMODE_UNION;

//DVR and POS connect Mode
typedef struct
{
    DWORD   dwSize;
    BYTE     byConnectMode;    //Connect Mode 0->TCP Monitor,1->Net Recv,2->Serial ,3-UDP Monitor,4-sniff,5-Multicast,6-USB To Serial
    BYTE     byRes1[3];
    NET_DVR_POS_CONNECTMODE_UNION uPosConnMode;    //Connect Mode
    BYTE  byRes[64];
} NET_DVR_CONNECT_POS_CFG, *LPNET_DVR_CONNECT_POS_CFG;

typedef struct  tagNET_DVR_CHAN_FILTER_CFG
{
    DWORD                  dwSize;
    BYTE                  byFilterID;           //POS filter ID
    BYTE                 byFontSize;         //font size, 0-- 8*16  1--16*32  2--32*64
    BYTE                  byShowPosInfo;
    BYTE                byOverlayMode;
    DWORD                 dwDelayTime;        /*delay time(5-3600s)*/
    NET_DVR_POS_OSD_REGION  struOsdPosInfo;          /*overlay osd rect info*/
    NET_DVR_RGB_COLOR        struOsdColor;           //OSD color
    NET_DVR_SCHEDTIME        struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;
    DWORD                  dwMaxRelRecordChanNum ;
    DWORD                  dwRelRecordChanNum ;
    DWORD                  dwRelRecordChan[MAX_CHANNUM_V30];
    DWORD                 dwTimeOut;        /*time Out(5-3600s)*/ //You can't get a POS data timeout refers to the long time data at the end of the determining a packet.
    BYTE              byRes[60];
}NET_DVR_CHAN_FILTER_CFG, *LPNET_DVR_CHAN_FILTER_CFG;



/********************************POS start*******************************************/

#define        MAX_LAN_ENCODE_LEN        32    //max language encode length
typedef struct    tagNET_DVR_DEVICE_LAN_ENCODE
{
    DWORD        dwSize;
    BYTE        byLanEncode[MAX_LAN_ENCODE_LEN];    //device language encode
    BYTE        byRes[28];
}NET_DVR_DEVICE_LAN_ENCODE, *LPNET_DVR_DEVICE_LAN_ENCODE;

typedef struct tagNET_DVR_SCENECHANGE_DETECTION
{
    DWORD    dwSize;
    BYTE    byEnable; //Enable\A3\AC0~Enable,1~Disable
    BYTE    bySensitiveLevel;// 1-100\A3\ACdefault:50\A3\ACThe higher the sensitivity, the more easily the alarm .
    BYTE    byRes1[2];
    NET_DVR_SCHEDTIME struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //Exception processing mode
    DWORD    dwMaxRelRecordChanNum ;  //Alarm video channel trigger number (read-only) maximum support number
    DWORD    dwRelRecordChanNum ;     //Alarm number video channel number to trigger the practical support
    DWORD    dwRelRecordChan[MAX_CHANNUM_V30];//Trigger Video Channel
    //Alarm video channel trigger \A3\A8Four bytes of channel number, initial value 0xffffffff\A3\A9
    BYTE    byRes2[128];
}NET_DVR_SCENECHANGE_DETECTION,*LPNET_DVR_SCENECHANGE_DETECTION;

typedef struct tagNET_DVR_SCENECHANGE_DETECTION_RESULT
{
    DWORD           dwSize;
    NET_VCA_DEV_INFO     struDevInfo;    //DevInfo
    WORD    wDevInfoIvmsChannelEx;     //NET_VCA_DEV_INFO->byIvmsChannel
    BYTE            byRes[126];
}NET_DVR_SCENECHANGE_DETECTION_RESULT,*LPNET_DVR_SCENECHANGE_DETECTION_RESULT;


typedef enum
{
    PREVIEW_MOD = 0,
    ALARM_MOD,
    PLAYBACK_MOD,
    MAX_TYPE
}MODULE_TYPE;

//Parking Information
typedef struct tagNET_DVR_PARK_INFO
{
    char          sPlateNo[MAX_PlATE_NO_LEN];             //License plate number
    char          sParkIndex[MAX_PlATE_NO_LEN];        //Number of parking spaces
    BYTE          byRes[64];
}NET_DVR_PARK_INFO, *LPNET_DVR_PARK_INFO;


typedef struct tagNET_DVR_CROSSLINE_ALARM
{
    DWORD                 dwSize;
    NET_VCA_DEV_INFO     struDevInfo;
    NET_DVR_TIME_EX      struTriggerTime;/*Trigger Time*/
    NET_DVR_PARK_INFO    struParkInfo; //Parking Information
    BYTE                 byRes1[128];
}NET_DVR_CROSSLINE_ALARM, *LPNET_DVR_CROSSLINE_ALARM;

typedef struct tagNET_DVR_STREAM_SRC_CFG
{
    DWORD dwSize;
    NET_DVR_STREAM_INFO struStreamID; //Stream id information
    NET_DVR_STREAM_SRC_INFO struStreamSrcInfo; //Stream id source information
}NET_DVR_STREAM_SRC_CFG,*LPNET_DVR_STREAM_SRC_CFG;

typedef struct tagNET_DVR_ENCODEINFO
{
    BYTE  byFormatType; //Video format type\A3\AC1-original\A3\AC2-RTP\A3\AC3-PS\A3\AC4-TS\A3\AC5-private\A3\AC6-FLV\A3\AC7-ASF\A3\AC8-3GP, 9-RTP+PS(GB28181)\A3\AC0xff-invalid
    BYTE  byVideoEncType;//Video encode type\A3\AC0-private 264\A3\AC1-standard h264\A3\AC2-standard mpeg4\A3\AC7-M-JPEG\A3\AC0xff-invalid
    WORD  wWidth; //Image width
    WORD  wHeight; //Image height
    BYTE  byRes1[2];
    DWORD dwVideoBitrate;     //Video bit rate,unit:Kbps
    DWORD dwVideoFrameRate;    //Video frame rate\A3\AClarger than 200 represents below 1 frame/s\A3\ACelse represents reality frame rate,200-1/2,201-1/4,202-1/8,203-1/16
    BYTE  byAudioEncType;//Audio encode type\A3\AC0-G722\A3\AC1-G711_U\A3\AC2-G711_A\A3\AC5-MPEG2,6-G726\A3\AC7-AAC,0xff-invalid
    BYTE  byRes2[15];
}NET_DVR_ENCODEINFO, *LPNET_DVR_ENCODEINFO;

typedef struct tagNET_DVR_TRANSSTATUS
{
    DWORD dwSize;
    NET_DVR_STREAM_INFO struStreamInfo;//Stream ID and channel information
    BYTE  byMode;//Transcode type\A3\AC1-Active\A3\AC2-Passive
    BYTE  byLinkNums;//Link number
    BYTE  byPassiveTransMode; //Passive transcode mode\A3\AC0-invalid\A3\AC1-Real time stream\A3\AC2-File stream
    BYTE  byRes;
    NET_DVR_ADDRESS struDstIPInfo[MAX_LINK];//Target ip address
    BYTE  byTransResource;//Number of used resource,unit:D1 transcode resource
    BYTE  byRes1[15];
    NET_DVR_ENCODEINFO struSrcEncodeInfo;//Stream source encode information
    NET_DVR_ENCODEINFO struDstEncodeInfo[MAX_LINK /*6*/];//target encode information
    BYTE  byRes2[36];
}NET_DVR_TRANSSTATUS, *LPNET_DVR_TRANSSTATUS;
/**********************************Ehome Platform begin 2013-10-9*********************************/
typedef struct tagNET_DVR_CMS_PARAM
{
    DWORD            dwSize;
    NET_DVR_IPADDR    struAddr;
    WORD            wServerPort;
    BYTE            bySeverProtocolType;
    BYTE               byStatus;
    BYTE            sDeviceId[NAME_LEN/*32*/];
    char            sPassWord[PASSWD_LEN];
    /********* IPC5.1.7 new parameters Begin 2014-03-21***********/
    BYTE            sPlatformEhomeVersion[NAME_LEN];//Platform EHOME protocol version
    /********* IPC5.1.7 new parameters end 2014-03-21***********/
    BYTE            byNetWork;
    BYTE            byAddressType;            //0 - invalid, 1 - ipv4/ipv6 address\A3\AC2 - domain name
    BYTE               byRes1[2];
    BYTE            sDomainName[MAX_DOMAIN_NAME/*64*/];
    BYTE               byRes[140];
}NET_DVR_CMS_PARAM, *LPNET_DVR_CMS_PARAM;
/**********************************Ehome Platform end*********************************************/

typedef struct tagNET_DVR_TRANSDEVICE_STATUS
{
    DWORD dwSize;
    DWORD dwTotalResource;//Total transcode resource
    DWORD dwIdleResource;//Left transcode resource
    BYTE  byCpuLoad;//CPU load
    BYTE  byRes[67];
}NET_DVR_TRANSDEVICE_STATUS, *LPNET_DVR_TRANSDEVICE_STATUS;

typedef struct tagNET_DVR_PASSIVETRANSINFO
{
    DWORD dwSize;
    BYTE byStreamType;// Stream type\A3\AC0-main stream\A3\AC1-sub stream
    BYTE byLinkMode;//Passive transcode link mode 0\A3\BATCP mode,1\A3\BAUDP mode
    BYTE byPassiveTransMode; //Passive transcode mode\A3\AC1-real stream\A3\AC2-file stream
    BYTE byRes1[5];
    BYTE byDataType;//Data type\A3\AC1-SDP\A3\AC2-media head
    BYTE byRes2;
    WORD wDataLength;//Data length
    char *pBuffer;//Data buffer
    BYTE byRes3[32]; // RES
}NET_DVR_PASSIVETRANSINFO, *LPNET_DVR_PASSIVETRANSINFO;

typedef struct tagNET_DVR_DEV_WORK_MODE
{
    DWORD dwSize;
    BYTE  byWorkMode; //1-Channel mode\A3\AC2-Stream ID mode
    BYTE  byDisplayMode; //0-NORMAL\A3\AC1-Fluency
    BYTE  byEnableVcaDec; // wheter to start  vca decode, 0-not !0-start
    BYTE  byRes[61];
}NET_DVR_DEV_WORK_MODE,*LPNET_DVR_DEV_WORK_MODE;

typedef struct tagNET_DVR_BIG_SCREEN_AUDIO_CFG
{
    DWORD dwSize;
    DWORD dwWinIndex; //Window No.\A3\ACstart from 1\A3\AC0 represents basemap
    BYTE  byEnable; //Enable audio\A3\AC1-enable\A3\AC0-disable
    BYTE  byRes[31];
}NET_DVR_BIG_SCREEN_AUDIO_CFG, *LPNET_DVR_BIG_SCREEN_AUDIO_CFG;

typedef struct tagNET_DVR_WIN_ZOOM_STATUS
{
    DWORD dwSize;
    BYTE  byZoomStatus;  //electronic enlargement status:0-normal,1-enlarge
    BYTE  byRes1[3];
    NET_DVR_POINT_FRAME struPointFrame; //enlarge area
    BYTE  byRes2[32];
}NET_DVR_WIN_ZOOM_STATUS,NET_DVR_WIN_ZOOM_STATUS;

typedef struct tagNET_DVR_MOBILE_CAPTUREPIC_CFG
{
    DWORD       dwSize;
    BYTE  byPreviewFpsAdjMode;   /* preview Audio Framerate adjust mode:0-no adjust \A3\ACstandard Audio Framerate preview,1-standard low Audio Framerate preview,2-adjust Audio Framerate by GPS speed */
    BYTE  bySelPeccType;           /* choose illegal type 0-not choose; 1-choose */
    BYTE  byOptHabit;  /* Forensics operating habits, 0:Long press Forensics;1:Short press two time for forensics */
    BYTE  byEnablePeccRec;      /* 1: enable Illegal record grab, 0: disable Illegal record grab */
    BYTE  byPicSize;                /*0=CIF,1=QCIF,2=D1,3=UXGA(1600x1200), 4=SVGA(800x600), 5=HD720p(1280x720),6-VGA\A3\AC7-XVGA\A3\AC8-HD900p\A3\AC9-HD1080\A3\AC10-2560*1920\A3\AC11-1600*304\A3\AC12-2048*1536\A3\AC13-2448*2048,14-2448*1200\A3\AC15-2448*800\A3\AC16-XGA(1024*768)\A3\AC17-SXGA(1280*1024),18-WD1(960*576/960*480),19-1080i */
    BYTE  byPicQuality;            /* Picture quality 0-best 1-good 2-ok */
    BYTE  byRes[62];
}NET_DVR_MOBILE_CAPTUREPIC_CFG,*LPNET_DVR_MOBILE_CAPTUREPIC_CFG;

/*******************************IPC5.1.4 resume initial tracking position  begin********************/
//2013-10-28
typedef struct tagNET_DVR_RESUME_INITRACKPOS_CFG
{
    DWORD           dwSize;
    DWORD           dwChannel;;     // Channel number
    BYTE            byRes[16];      //
}NET_DVR_RESUME_INITRACKPOS_CFG,*LPNET_DVR_RESUME_INITRACKPOS_CFG;
/*******************************IPC5.1.4  end *********************************/

typedef  struct tagNet_DVR_TEST_SELFCHECK_RESULT
{
    DWORD   dwSize;
    DWORD   dwChannel;      //Channel number
    BYTE    bySelfCheckStatus;   //self check status  0-not start\A3\AC1-success\A3\AC2-fail\A3\AC3-self checking
    BYTE    byRes[23];   //
}NET_DVR_TEST_SELFCHECK_RESULT, *LPNET_DVR_TEST_SELECHECK_RESULT;

#define  MAX_TEST_COMMAND_NUM 32
typedef struct  tagNET_DVR_TEST_COMMAND
{
    DWORD   dwSize;
    DWORD   dwChannel;       //Channel number
    BYTE    byTestCommand[MAX_TEST_COMMAND_NUM];
    //0 -not to test  1 - to test
    //the subscript 0 of the array means whether enable the olding  test
    //the subscript 1 of the array means whether enable the red light come in test
    //the subscript 2 ICR aging test, 0 means closed, 1 is open, can be combined with bit0, such as 0000 _0001 (open only cruise aging), 0000 _0101 aging (at the same time open cruise and ICR), 0000 _0100 (ICR) aging only open
    //the subscript 3 - ball machine status since the correction function, 0 means the ball machine since the correction function is not cleared, 1 ball machine since the correction function has been removed
    //the subscript 4 synchronized scanning test program, 0 means closed, 1 is open
    //the subscript 5 electronic compass calibration program, 0 means closed, 1 is open WORD wICRIntervalTime;
    // icr time interval (byTestCommand in table 2 in the array value is 1, icr switch time interval, the unit of a second)
    WORD    wICRIntervalTime;
    BYTE      byElectronicCompassState;//Compass state return, 0 - normal, 1 - not normal
    BYTE    byRes1[1];
    float     fDeviceTem; //Precision equipment machine core temperature 0.001
    BYTE    byRes[12];
}NET_DVR_TEST_COMMAND, *LPNET_DVR_TEST_COMMAND;

typedef struct  tagNET_DVR_AGING_TRICK_SCAN
{
    DWORD   dwSize;
    DWORD   dwChannel;       //Channel number
    BYTE     byAging; // Said set of parameters for aging before or after aging tools,0 - before aging ,1 - after aging
    BYTE     byWriteReadEnalbe; //Literacy instruction enabled, 0 - set read instructions, 1 - set up writing instruction
    BYTE     byRes[126];
}NET_DVR_AGING_TRICK_SCAN, *LPNET_DVR_AGING_TRICK_SCAN;

#define IPC_PARAM_AGING_TRICK_SCAN       0x00000001 //Clear pattern scanning parameter Settings
typedef struct tagNET_DVR_IPC_PARAM_TYPE
{
    DWORD dwSize;
    DWORD dwParamType; //Parameter types, according to the who said
    // #define IPC_PARAM_AGING_TRICK_SCAN       0x00000001 //Clear pattern scanning parameter Settings
    BYTE byRes[32];
}NET_DVR_IPC_PARAM_TYPE, *LPNET_DVR_IPC_PARAM_TYPE;

typedef struct  tagNET_DVR_ECCENTRIC_CORRECT_STATE
{
    DWORD   dwSize;
    DWORD   dwChannel;       //Channel number
    BYTE     byEccentricCorrectState; // Eccentric correction status, 0 - calibration failure,1 - calibration success,2 - in the correction
    BYTE     byRes[127];
}NET_DVR_ECCENTRIC_CORRECT_STATE, *LPNET_DVR_ECCENTRIC_CORRECT_STATE;


#define MAX_DEVMODULE_NUM 8
typedef struct tagNET_DVR_TEST_DEVMODULE_CFG
{
    DWORD   dwSize;
    DWORD   dwChannel;      //Channel number
    BYTE    byDevFanModuleType[MAX_DEVMODULE_NUM]; //the type of the testing device
    // 0 - unable  1 - enable
    // bit0 - to test the number 1 fan
    // bit1 - to test the number 2 fan
    BYTE    byDevHeaterModuleType[MAX_DEVMODULE_NUM]; //the type of the testing device
    // 0 - unable  1 - enable
    // bit0 - to test the number 1 heater
    // bit1 - to test the number 2 heater
    BYTE    byRes[22];      //
}NET_DVR_TEST_DEVMODULE_CFG, *LPNET_DVR_TEST_DEVMODULE_CFG;


/****************2013-11-04 PJ01R2013091201 entrance capture begin***************/
////////////////////////////entrance capture CFG begin///////////////////////////////
typedef struct tagNET_DVR_BARRIERGATE_COND
{
    BYTE   byLaneNo;//Lane No.\A3\A80-Invalid,1-Lane 1\A3\A9
    BYTE   byRes[3];
}NET_DVR_BARRIERGATE_COND,*LPNET_DVR_BARRIERGATE_COND;

typedef struct tagNET_DVR_VEHICLE_CONTROL
{
    BYTE   byGateOperateType;//0-No operation,1-Open Gateway
    BYTE   byRes1;
    WORD   wAlarmOperateType;//0-No operation,bit0-Relay output alarm, bit1-A output arm bit3-Alarm host upload\A3\A8Can check\A3\A9(0-Close\A3\AC1-Open)
    BYTE   byRes2[8];
}NET_DVR_VEHICLE_CONTROL,*LPNET_DVR_VEHICLE_CONTROL;

typedef struct tagNET_DVR_RELAY_PARAM
{
    BYTE   byAccessDevInfo;//0-Not access equipment\A1\A21-Open Gate\A1\A22-Close Gate\A1\A23-Stop Gate\A1\A24-alarm\A1\A25-Often bright lamp
    BYTE   byRes[3];
}NET_DVR_RELAY_PARAM,*LPNET_DVR_RELAY_PARAM;

//Entrance CFG
typedef struct tagNET_DVR_ENTRANCE_CFG
{
    DWORD   dwSize;
    /*0x00: Do not match.*/
    /*0x01: license plate matching (with license plate color).*/
    /*0x02: license plate matching (without the license plate color).*/
    /*0x04: card matching.*/
    BYTE    byEnable ;// Enable;0-Close\A3\AC1-Open
    BYTE    byBarrierGateCtrlMode;//0-automatic Camera Ctrl\A3\AC1-platform Ctrl
    BYTE    byRes1[2];
    DWORD   dwRelateTriggerMode;//Trigger Mode,ITC_TRIGGERMODE_TYPE
    DWORD   dwMatchContent; //Match Content
    NET_DVR_RELAY_PARAM  struRelayRelateInfo[MAX_RELAY_NUM/*12*/];//Relay Relate Info(A relay can control an access device) Array of 0 represents a relay 1 array of 1 represents a relay 2 turn 12
    BYTE byGateSingleIO[MAX_IOIN_NUM/*8*/]; //A single IO trigger parameters, a single IO trigger parameters, an array of 0 IO1, 1 IO2 array, and so on; the array values meaning (0- no, 1- gate open place, 2- gate is closed in place, 3- fire alarm)
    NET_DVR_VEHICLE_CONTROL struVehicleCtrl[MAX_VEHICLE_TYPE_NUM/*8*/];//Vehicle information management
    BYTE    byNotCloseCarFollow;//Not Close Car Follow\A3\AC0-Close\A3\AC1-Open
    BYTE    byRes2[63];
}NET_DVR_ENTRANCE_CFG,*LPNET_DVR_ENTRANCE_CFG;

// Barrier Gate Ctrl
typedef struct tagNET_DVR_BARRIERGATE_CFG
{
    DWORD dwSize;
    DWORD dwChannel; //Channel
    BYTE  byLaneNo;  //Gate No\A3\A80-Invalid,1-Gate 1\A3\A9
    BYTE  byBarrierGateCtrl;//0-Close Gate,1-Open Gate,2-Stop Gate 3-Lock Gate,4-Unlock Gate
    BYTE  byEntranceNo;//Entrance No [1,8]
    BYTE  byUnlock;//Unlock Enable
    BYTE  byRes[12];
}NET_DVR_BARRIERGATE_CFG, *LPNET_DVR_BARRIERGATE_CFG;
////////////////////////////entrance capture CFG end///////////////////////////////

//Vehicle Control List Info
typedef struct  tagNET_DVR_VEHICLE_CONTROL_LIST_INFO
{
    DWORD  dwSize;
    DWORD  dwChannel;//channel
    DWORD  dwDataIndex;//Data Index
    char   sLicense[MAX_LICENSE_LEN]; //License
    BYTE   byListType;//List Type
    BYTE   byPlateType;    //Plate Type
    BYTE   byPlateColor;    //Plate Color
    BYTE   byRes[21];
    char   sCardNo[MAX_CARDNO_LEN]; // Card No.
    NET_DVR_TIME_V30  struStartTime;//Start Time
    NET_DVR_TIME_V30  struStopTime;//Stop Time
    char   sOperateIndex[MAX_OPERATE_INDEX_LEN]; //Operate Index 2014-03-03
    BYTE   byRes1[224];
} NET_DVR_VEHICLE_CONTROL_LIST_INFO,*LPNET_DVR_VEHICLE_CONTROL_LIST_INFO;


typedef struct tagNET_DVR_VEHICLE_CONTROL_COND
{
    DWORD  dwChannel;//Channel
    DWORD  dwOperateType;//Operate Type\A3\ACVCA_OPERATE_TYPE\A1\A3
    char   sLicense[MAX_LICENSE_LEN];//License
    char   sCardNo[MAX_CARDNO_LEN]; // Card No.
    BYTE   byListType;//List Type;0-white list\A3\AC1-black list\A3\AC0xff-all
    //2014-02-25
    BYTE   byRes1[3];
    DWORD  dwDataIndex;//Data Index
    BYTE   byRes[116];
}NET_DVR_VEHICLE_CONTROL_COND,*LPNET_DVR_VEHICLE_CONTROL_COND;


typedef struct
{
    DWORD    dwSize;
    DWORD    dwDataIndex;//Data Index
    char     sOperateIndex[MAX_OPERATE_INDEX_LEN]; //Operate Index 2014-03-03
    BYTE     byRes[32];
}NET_DVR_VEHICLE_CONTROL_LIST_DSALARM, *LPNET_DVR_VEHICLE_CONTROL_LIST_DSALARM;


typedef struct tagNET_DVR_VEHICLE_CONTROL_ALARM
{
    DWORD dwSize;
    BYTE  byListType;   //List Type;0-white list\A3\AC1-black list\A3\AC2-Provisional List
    BYTE  byPlateType;  //Plate Type
    BYTE  byPlateColor;    //Plate Color
    BYTE  byRes1;
    char  sLicense[MAX_LICENSE_LEN];//License
    char  sCardNo[MAX_CARDNO_LEN];  //Card No.
    NET_DVR_TIME_V30 struAlarmTime; //Alarm Time
    DWORD dwChannel;
    DWORD dwPicDataLen;   //
    BYTE  byPicType;    //picture type\A3\AC0-JPEG
    BYTE  byRes3[3];
    char    *pPicData;
    BYTE  byRes2[48];
}NET_DVR_VEHICLE_CONTROL_ALARM,*LPNET_DVR_VEHICLE_CONTROL_ALARM;


typedef struct tagNET_DVR_FIRE_ALARM
{
    DWORD            dwSize;
    NET_DVR_TIME_V30 struAlarmTime;//Alarm Time
    BYTE             byRes[128];
}NET_DVR_FIRE_ALARM,*LPNET_DVR_FIRE_ALARM;


typedef struct
{
    DWORD       dwSize;
    DWORD dwDelType;//Delete Type VCA_OPERATE_TYPE
    char  sLicense[16]; //License
    char  sCardNo[48];  //Card No
    BYTE  byPlateType;    //Plate Type
    BYTE  byPlateColor;    //Plate Color
    BYTE  byOperateType;//Operate Type(0-Delete a,0xff-Delete All)
    //2014-02-25
    BYTE  byListType;//List Type;0-White List\A3\AC1-Black List 2014-03-03
    DWORD dwDataIndex;//Data Index
    char  sOperateIndex[MAX_OPERATE_INDEX_LEN]; //Operate Index 2014-03-03
    BYTE  byRes[24];
} NET_DVR_VEHICLE_CONTROL_DELINFO, *LPNET_DVR_VEHICLE_CONTROL_DELINFO;


typedef struct tagNET_DVR_GATELAMP_INFO
{
    DWORD dwSize;
    DWORD dwChannel; //Channel
    BYTE  byLaneNo; //LaneNo\A3\A80-invalid,1-Lane 1\A3\A9
    BYTE  byBrightlampCtrl;//0-Close Brightlamp\A3\AC1-Open Brightlamp
    BYTE  byRes[14];
}NET_DVR_GATELAMP_INFO,*LPNET_DVR_GATELAMP_INFO;


//SDI matrix 1.0
#define  MATRIX_MAX_OUTPUT_NUM      256              //SDI matix max output num
typedef struct tagNET_DVR_MATRIX_BASE_CFG
{
    DWORD dwSize;
    DWORD dwValidInputNum;     //vaild input num
    DWORD dwValidOutputNum;    //vaild output num
    BYTE  byRes[64];
}NET_DVR_MATRIX_BASE_CFG, *LPNET_DVR_MATRIX_BASE_CFG;

typedef struct tagNET_DVR_MATRIX_SWITCH_INFO
{
    DWORD   dwSize;
    DWORD   dwInputChan;        //input channel\A3\AC 0 mean delete the relation of the output channel
    DWORD   dwOutputChan;       //output channel to relate ,(screen server use screen index(1byte device No + 1byte Res + 2byte screen index))0xffffffff mean relate all the all ouput
    DWORD   dwMatrixID; //Matrix ID
    BYTE    byRes[28];
}NET_DVR_MATRIX_SWITCH_INFO, *LPNET_DVR_MATRIX_SWITCH_INFO;

typedef struct tagNET_DVR_IO_RELATION_INFO
{
    DWORD   dwSize;
    DWORD   dwIORelation[MATRIX_MAX_OUTPUT_NUM];  //output channel relate the input channel,  dwIORelation[i] = j mean output channel (i + 1) and input channel (j) has a relation,
    //dwIORelation[i] = 0 mean output channel (i +1) didn't relate any input channel
    BYTE    byRes[256];
}NET_DVR_IO_RELATION_INFO, *LPNET_DVR_IO_RELATION_INFO;

typedef struct tagNET_DVR_CURTRIGGERMODE //(3.7Ver)
{
    DWORD  dwSize;
    DWORD  dwTriggerType; //TriggerType\A3\ACITC_TRIGGERMODE_TYPE
    BYTE   byRes[24];
}NET_DVR_CURTRIGGERMODE, *LPNET_DVR_CURTRIGGERMODE;


typedef struct tagNET_DVR_TEMP_HUMI
{
    DWORD    dwSize;
    DWORD       dwChannel;         // Channel
    int      iHumidity;         // Humidity
    int      iTemp;             // Temp
    BYTE     byRes[8];
}NET_DVR_TEMP_HUMI, *LPNET_DVR_TEMP_HUMI;

typedef struct tagNET_DVR_ALARMSOUNDMODE_CFG
{
    DWORD    dwSize;
    DWORD    dwChannel;     // Channel Number, Default 1
    DWORD    dwSoundMode;   // Alarm Sound Mode: 0~Hint Mode\A3\BB1~Alarm Mode\A3\BB2~Mute Mode
    BYTE     byRes[12];
}NET_DVR_ALARMSOUNDMODE_CFG, *LPNET_DVR_ALARMSOUNDMODE_CFG;

typedef struct tagNET_DVR_SECURITYMODE
{
    DWORD    dwSize;
    DWORD    dwChannel;
    DWORD    dwMode;
    char     szRandCode[6];
    BYTE     byRes[6];
}NET_DVR_SECURITYMODE, *LPNET_DVR_SECURITYMODE;

typedef struct tagNET_DVR_BASEMAP_CONTROL_CFG
{
    DWORD dwSize;
    BYTE  byEnable;        //show enable\A3\AC1-show \A3\AC0-hide
    BYTE  byBaseMapType;    //basemap type\A3\AC1-picture\A3\AC2-virtual screen
    BYTE  byRes1[2];
    DWORD dwBaseMapNo;     /*base map No. ,Base map type 1:picture No;Basemap type 2:virtual screen input No.(1byte:video platform No.
    +1byte:sub board No.+1byte:input No.+1byte:0)*/
    BYTE  byRes2[64];
}NET_DVR_BASEMAP_CONTROL_CFG,*LPNET_DVR_BASEMAP_CONTROL_CFG;

typedef struct tagNET_DVR_VIRTUAL_SCREEN_CFG
{
    DWORD dwSize;
    DWORD dwResolution; //resolution
    BYTE  byRes2[64];
}NET_DVR_VIRTUAL_SCREEN_CFG, *LPNET_DVR_VIRTUAL_SCREEN_CFG;

typedef struct tagNET_DVR_BASEMAP_WINCFG
{
    DWORD dwSize;
    BYTE  byEnable;
    BYTE  byRes1[7];
    NET_DVR_RECTCFG_EX struWinPosition;//base map window position,window length and hight must be integer multiple of the base unit
    BYTE  byRes2[64];
}NET_DVR_BASEMAP_WINCFG, *LPNET_DVR_BASEMAP_WINCFG;

typedef struct tagNET_DVR_BASEMAP_PIC_INFO
{
    DWORD  dwSize;
    BYTE   sPicName[NAME_LEN];//base map picture name
    BYTE   byUsed; //picture exist\A3\AC0-not exist\A3\AC1-exist
    BYTE   byRes[31];
}NET_DVR_BASEMAP_PIC_INFO,*LPNET_DVR_BASEMAP_PIC_INFO;

typedef struct tagNET_DVR_MATRIX_LOGO_INFO
{
    DWORD  dwSize;
    DWORD  dwLogoSize;//LOGO size,include BMP head, should be smaller than 100Kb,length and hight should be integer multiple of 32
    BYTE   byRes[32];
}NET_DVR_MATRIX_LOGO_INFO,*LPNET_DVR_MATRIX_LOGO_INFO;

typedef struct tagNET_DVR_MATRIX_LOGO_CFG
{
    DWORD  dwSize;
    BYTE   byExist;  //logo exist,0-not exist\A3\AC1-exist(read only)
    BYTE   byRes1[3];
    DWORD  dwLogoSize;//LOGO size, include BMP head(read only)
    BYTE   byLogoName[NAME_LEN];  //logo name
    DWORD  dwLogoNo;    //logo No.(valid for getting all logos' configuration)
    BYTE   byRes2[28];
}NET_DVR_MATRIX_LOGO_CFG,*LPNET_DVR_MATRIX_LOGO_CFG;

typedef struct tagNET_DVR_WIN_LOGO_CFG
{
    DWORD  dwSize;
    DWORD  dwLogoNo; //logo No.
    BYTE   byEnable; //logo show or hide\A3\AC1-show\A3\AC0-hide
    BYTE   byRes1[3];
    DWORD  dwCoordinateX;    //picture x coordinate
    DWORD  dwCoordinateY;    //picture y coordinate
    BYTE   byFlash;  //flash or not,1-flash\A3\AC0-not flash
    BYTE   byTranslucent; //translucent or not,1-translucent\A3\AC0-not translucent
    BYTE   byRes2[34];
}NET_DVR_WIN_LOGO_CFG,*LPNET_DVR_WIN_LOGO_CFG;


typedef struct tagNET_DVR_HEATMAP_COND
{
    DWORD   dwSize;
    DWORD   dwChannel; //Channel No.
    BYTE    byDetSceneID;//Detecetion Scene ID[1],Dome: 1, IPC:0
    BYTE    byRes[63];
}NET_DVR_HEATMAP_COND, *LPNET_DVR_HEATMAP_COND;

typedef struct tagNET_DVR_HEATMAP_PARAM
{
    BYTE byTargetTrackEnable;//Target tracking: 0- Close, 1- open, Default 0- Close
    BYTE bySensitivity;  // Sensitivity ;Range:1-100\A3\ACDefault:50
    BYTE byBackgroundUpdateRate;//Background updating speed: Range:1-100\A3\ACDefault:50
    BYTE bySceneChangeLevel;//Scene change level: Range:1-100, Default:50
    BYTE byMinTargetSize;//minimum target : Range: 1-100, Default: 50
    BYTE byRes[15];
}NET_DVR_HEATMAP_PARAM, *LPNET_DVR_HEATMAP_PARAM;

#define MAX_HEATMAPREGION_NUM 8

//Heat map
typedef struct tagNET_DVR_HEATMAP_CFG
{
    DWORD   dwSize;
    BYTE    byEnable; //Enable
    BYTE    byRes[3];
    NET_VCA_POLYGON struRegion[MAX_HEATMAPREGION_NUM/*8*/];//Region
    NET_DVR_HEATMAP_PARAM  struHeatMap ;
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //Exception processing mode
    //Alarm Time
    NET_DVR_SCHEDTIME struAlarmSched[MAX_DAYS/*7*/][MAX_TIMESEGMENT_V30/*8*/];
    BYTE  byRes1[512];
}NET_DVR_HEATMAP_CFG, *LPNET_DVR_HEATMAP_CFG;

typedef struct tagNET_DVR_HEATMAP_RESULT
{
    DWORD  dwSize;
    NET_VCA_DEV_INFO  struDevInfo;/*Device Info*/
    NET_DVR_TIME_EX   struStartTime;/*Start Time*/
    NET_DVR_TIME_EX   struEndTime;/*End Time*/
    DWORD  dwMaxHeatMapValue ;
    DWORD  dwMinHeatMapValue ;
    DWORD  dwTimeHeatMapValue ;
    WORD   wArrayLine ;//Array Line
    WORD   wArrayColumn ;//Array Column
    BYTE*  pBuffer;  //Heat Map Picture
    BYTE   byDetSceneID;//Detecetion Scene ID[1],Dome: 1, IPC:0
    BYTE   byBrokenNetHttp;     //Offline continuingly flags, 0 - not the retransmission data, 1 - retransmission data
    WORD   wDevInfoIvmsChannelEx;     //NET_VCA_DEV_INFO->byIvmsChannel
    BYTE   byRes[124];
}NET_DVR_HEATMAP_RESULT,*LPNET_DVR_HEATMAP_RESULT;

typedef struct tagNET_DVR_HEATMAP_QUERY_COND
{
    DWORD   dwSize;
    DWORD   dwChannel ;//Channel No.
    NET_DVR_TIME_EX   struStartTime;/*Start Time*/
    NET_DVR_TIME_EX   struEndTime;/*End Time*/
    BYTE    byReportType;//0-Invalid\A3\AC1-Day list\A3\AC2-Week list\A3\AC3-Month list\A3\AC4-Year list
    BYTE    byDetSceneID;//Detecetion Scene ID[1],Dome: 1, IPC:0
    BYTE    byHeatMapInfoType;//Info type
    BYTE    byRes[125];
}NET_DVR_HEATMAP_QUERY_COND,*LPNET_DVR_HEATMAP_QUERY_COND;

typedef struct tagNET_DVR_HEATMAP_INFO
{
    DWORD  dwSize;
    NET_DVR_TIME_EX   struStartTime;/*Start Time*/
    NET_DVR_TIME_EX   struEndTime;  /*End Time*/
    DWORD  dwHeatMapPicLen;         /*Heat Map Picture Length*/
    BYTE*  pBuffer;                 //Heat Map Picture
    DWORD  dwTimeHeatMapValue ;     //Time Heat Map Value
    DWORD  dwHeatMapMaxValue;
    DWORD  dwHeatMapMinValue;
    WORD   wArrayLine;//Array Line
    WORD   wArrayColumn;//Array Column
    BYTE*  pArrayBuffer; //Array Buffer
    BYTE   byArrayUnitType;//Array info Unit type\A3\AC0~byte\A3\AC1~int
    BYTE   byRes[107];
}NET_DVR_HEATMAP_INFO,*LPNET_DVR_HEATMAP_INFO;

typedef struct tagNET_DVR_PDC_QUERY_COND
{
    DWORD   dwSize;
    DWORD   dwChannel;//Channel
    NET_DVR_TIME_EX   struStartTime;/*Start Time*/
    NET_DVR_TIME_EX   struEndTime;/*End Time*/
    BYTE   byReportType;//0-Invalid\A3\AC1-Day list\A3\AC2-Week list\A3\AC3-Month list\A3\AC4-Year list
    BYTE    byEnableProgramStatistics; //According to the statistics show, 0 - no, 1 - is
    BYTE    byRes1[2];
    DWORD   dwPlayScheduleNo; //According to the statistics show the related schedule number
    BYTE    byRes[120];
}NET_DVR_PDC_QUERY_COND,*LPNET_DVR_PDC_QUERY_COND;

typedef struct tagNET_DVR_PROGRAM_INFO
{
    DWORD   dwProgramNo; //program num
    BYTE    sProgramName[NAME_LEN]; //gropram name
    BYTE    byRes[16];
}NET_DVR_PROGRAM_INFO, *LPNET_DVR_PROGRAM_INFO;

typedef struct tagNET_DVR_PDC_RESULT
{
    DWORD   dwSize;
    NET_DVR_TIME_EX   struStartTime;/*Start Time*/
    NET_DVR_TIME_EX   struEndTime;/*End Time*/
    DWORD   dwEnterNum;   //Enter Num
    DWORD   dwLeaveNum;  //Leave Num
    NET_DVR_PROGRAM_INFO struProgramInfo;        //program info
    DWORD  dwPeoplePassing;        //People Passing
    BYTE    byRes[200];
}NET_DVR_PDC_RESULT, *LPNET_DVR_PDC_RESULT;

typedef struct tagNET_DVR_MOBILE_PLATE_RECOGCFG
{
    DWORD dwSize;
    BYTE  byDefaultCHN[MAX_CHJC_NUM]; /*Province of shorthand  3 */
    BYTE  byTimeOsd;// the time information superposition 0 - no Superposition\A3\AC1- Superposition
    BYTE  byRecogResultOsd;//recognize result superposition  0 - no Superposition\A3\AC1- Superposition
    BYTE  byRecogHint;//recognize success with prompt. 0 - no prompt\A3\AC 1- prompt
    BYTE  byRecogDir;//recoginze order 0: forward, 1: reverse
    BYTE  byRecogEnv;//recognize environment 0: daytime, 1: night
    BYTE  byRecogPlateType;//0-small licence plate recongnize\A3\AC1-big licence plate recongnize
    BYTE  byUploadPlate;//0 -not upload licence plate\A3\AC 1-upload licence plate
    BYTE  byRes[62];
}NET_DVR_MOBILE_PLATE_RECOGCFG,*LPNET_DVR_MOBILE_PLATE_RECOGCFG;

typedef struct tagNET_DVR_MOBILE_RADAR_CFG
{
    DWORD  dwSize;
    BYTE   byEnableRadar;   /* 0:not start radar  1:start radar */
    BYTE   byEnableAlarm;   /* 0:start alarm  1:not start alarm */
    WORD   wOverSpeed;    /* 20~250 */
    BYTE   bySpeedUnits;  /* 0:kph   1:mph */
    BYTE   bydirection;     /* 0:reverse\A3\A8the same order of radar and car\A3\A9 1:forward\A3\A8not the same order of rader and car\A3\A9 */
    BYTE   byMeasureMode;   /* 0:static state (radar state)       1:dynamic state (radar state)*/
    BYTE   byTargetType;    /* 0:the fast  1:the last*/
    BYTE   bySensitivity;  /* sensitivity[0,100] */
    BYTE   byCaptureNum;   /* capture number[0,255] */
    BYTE   byUploadPlate;  /*upload or not the over speed capture picture 0-not upload\A3\AC1-upload*/
    BYTE   byRes[61];
}NET_DVR_MOBILE_RADAR_CFG,*LPNET_DVR_MOBILE_RADAR_CFG;

typedef struct tagNET_DVR_MOBILE_LOCALPLATECHK_CFG
{
    DWORD       dwSize;
    BYTE  byCheck;  /* 0-black list check\A3\AC1-no black list check*/
    BYTE  byCheckAlarm;/* check success with alarm 0-not alarm\A3\AC1-alarm*/
    BYTE  byCheckHint; /* check success with promte (software promte) 0-no promte\A3\AC1-promte*/
    BYTE  byUploadBlackCar; /*0-not upload black car info\A3\AC1-upload black car info*/
    BYTE  byRes[64];
}NET_DVR_MOBILE_LOCALPLATECHK_CFG,*LPNET_DVR_MOBILE_LOCALPLATECHK_CFG;

typedef struct tagNET_DVR_VEHICLE_CHECK
{
    DWORD dwSize;
    DWORD  dwChannel;//channel number 0xff - all channel\A3\A8default 1,represent one channel\A3\A9
    NET_DVR_PLATE_INFO  struPlateInfo; //lpate info
    WORD  wIllegalType; //illegal type
    BYTE  byRes[2];
    char sIllegalTypeInfo[128];// illegal type info
    NET_DVR_TIME_V30  struIllegalTime;//illegal time
    BYTE  byIllegalVehicleNum;//illegal times
    BYTE  byRes1[3];
    char sCustomInfo[64];//custom info
    BYTE  byRes2[128]; // res
}NET_DVR_VEHICLE_CHECK,*LPNET_DVR_VEHICLE_CHECK;

typedef enum _LONG_CFG_SEND_DATA_TYPE_ENUM_
{
    ENUM_DVR_VEHICLE_CHECK = 1, //vehicle Black list check
    ENUM_MSC_SEND_DATA = 2,  //screen control data type
    ENUM_ACS_SEND_DATA = 3, //access card data type
    ENUM_TME_CARD_SEND_DATA = 4, //Parking Card data type
    ENUM_TME_VEHICLE_SEND_DATA = 5, //TME Vehicle Info data type
    ENUM_DVR_DEBUG_CMD = 6, //Debug Cmd
    ENUM_DVR_SCREEN_CTRL_CMD =7, //Screen interactive
    ENUM_CVR_PASSBACK_SEND_DATA = 8 //CVR get passback task executable data type
}LONG_CFG_SEND_DATA_TYPE_ENUM;

typedef enum _LONG_CFG_RECV_DATA_TYPE_ENUM_
{
    ENUM_DVR_ERROR_CODE = 1, //Error code
    ENUM_MSC_RECV_DATA=2, //screen control data type
    ENUM_ACS_RECV_DATA=3 //ACS control data type
}LONG_CFG_RECV_DATA_TYPE_ENUM;
//2013-11-25
typedef struct tagNET_DVR_WIPER_CONTINUEWORK_PARAM
{
    BYTE  byWorkTimeInterval;//WorkTime Interval\A3\A8Unit\A3\BASec\A3\A9[2s~60s]
    BYTE  byRes[3];
    DWORD dwContinueWorkTime;//Continue WorkTime\A3\A8Unit\A3\BASec\A3\A9[2min~24h]Interface display by the minute units
    BYTE  byRes1[8];
}NET_DVR_WIPER_CONTINUEWORK_PARAM,*LPNET_DVR_WIPER_CONTINUEWORK_PARAM;

typedef union tagNET_DVR_WIPERMODE_PARAM_UNION
{
    BYTE uLen[16];
    //if byWiperWorkMode = 1,valid.
    NET_DVR_WIPER_CONTINUEWORK_PARAM struWiperContinueWorkParam;
}NET_DVR_WIPERMODE_PARAM_UNION,*LPNET_DVR_WIPERMODE_PARAM_UNION;

typedef struct tagNET_DVR_WIPERINFO_CFG
{
    DWORD dwSize;
    //Wiper Work Mode
    //0- single mode, 1- Continue mode (according to the configuration of NET_DVR_ROTATE_OPERATE_PARAM)
    BYTE  byWiperWorkMode;
    BYTE  byRes[23];
    NET_DVR_WIPERMODE_PARAM_UNION ustruWiperModeParam;
}NET_DVR_WIPERINFO_CFG,*LPNET_DVR_WIPERINFO_CFG;

//Set Autofocus Test 2013-10-26
typedef struct tagNET_DVR_AUTOFOCUS_TESTCFG
{
    DWORD     dwSize;
    DWORD     dwChannel;            //Channel
    BYTE      byRes[24];
}NET_DVR_AUTOFOCUS_TESTCFG,*LPNET_DVR_AUTOFOCUS_TESTCFG;

/*******************************LCD begin******************************************/
//////////////////////////LCD Screen Display begin 2013-08-28////////////////////////////////
typedef struct tagNET_DVR_VIDEO_OUT_CFG
{
    BYTE    byDisplayMode;        //Display Mode\A3\AC1-Standard\A3\AC2-Cool Colour\A3\AC3-Warm Colour\A3\AC0xff-User Defined
    BYTE     byBrightnessLevel;     // Brightness 0-100
    BYTE    byContrastLevel;     // Contrast 0-100
    BYTE     bySharpnessLevel;     // Sharpness 0-100
    BYTE     bySaturationLevel;     // Saturation 0-100
    BYTE     byHueLevel;         // Hue0-100
    BYTE    byImageMode;        // Image mode, 0-normal, 1-night model 1, 2 - night model 2, 3 - night model 3, 4 - day model 1, 5 - day model 2, 6 - day model 3
    BYTE    byRes[5];            //
}NET_DVR_VIDEO_OUT_CFG, *LPNET_DVR_VIDEO_OUT_CFG;
//Color Temperature
typedef struct tagNET_DVR_COLOR_TEMPERATURE_CFG
{
    BYTE    byRed;                //Red\A3\AC 0-100
    BYTE    byGreen;            //Green\A3\AC 0-100
    BYTE    byBlue;                //Blue\A3\AC0-100
    BYTE    byRedOffset;        //Red Offset\A3\AC0-100
    BYTE    byGreenOffset;        //Green Offset\A3\AC0-100
    BYTE    byBlueOffset;        //Blue Offset\A3\AC0-100
    BYTE    byRes[6];
}NET_DVR_COLOR_TEMPERATURE_CFG, *LPNET_DVR_COLOR_TEMPERATURE_CFG;

typedef struct tagNET_DVR_ADC_CFG
{
    BYTE    byGainR;            //Gain R\A3\AC 0-100
    BYTE    byGainG;            //Gain G\A3\AC0-100
    BYTE    byGainB;            //Gain B\A3\AC0-100
    BYTE    byOffsetR;            //Offset R\A3\AC0-100
    BYTE    byOffsetG;            //Offset G\A3\AC0-100
    BYTE    byOffsetB;            //Offset B\A3\AC0-100
    BYTE    byRes[6];
}NET_DVR_ADC_CFG, *LPNET_DVR_ADC_CFG;

typedef struct tagNET_DVR_SCREEN_EDGE_CFG
{
    BYTE    byEnable;           //Whether to enable the screen edge  0-Disable 1-Enable
    BYTE    byLeftEdge;           //Left Edge\A3\AC0-100
    BYTE    byRightEdge;       //Right Edge\A3\AC0-100
    BYTE    byTopEdge;           //Top Edge\A3\AC0-100
    BYTE    byLowerEdge;       //Lower Edge\A3\AC0-100
    BYTE    byRes[7];
}NET_DVR_SCREEN_EDGE_CFG, *LPNET_DVR_SCREEN_EDGE_CFG;

typedef struct tagNET_DVR_SCREEN_DISPLAY_CFG
{
    DWORD   dwSize;
    BYTE    byCfgType;       /*Set Parameter type \A3\ACGet Parameter Invalid\A3\AC
                               0-Invalid\A3\AC1-Back Light\A3\AC2-Video Out Cfg\A3\AC3-Color Temperature Cfg\A3\AC4-ADC\A3\AC5-Screen Edge Cfg*/
    BYTE    byBackLight;        //Back Light 0~100
    BYTE    byRes1[3];
    NET_DVR_VIDEO_OUT_CFG           struVideoOutCfg;     //Video Out Cfg\A3\A8Picture mode\A3\A9
    NET_DVR_COLOR_TEMPERATURE_CFG struColorTempCfg;  //Color Temperature Cfg
    NET_DVR_ADC_CFG               struAdcCfg;        //ADC
    NET_DVR_SCREEN_EDGE_CFG       struScreenEdgeCfg; //Screen Edge Cfg
    BYTE byRes[32];
}NET_DVR_SCREEN_DISPLAY_CFG, *LPNET_DVR_SCREEN_DISPLAY_CFG;
//////////////////////////LCD Screen Display end/////////////////////////////////////////////

//Control Type
typedef enum tagNET_DVR_SCREEN_REMOTE_CTRL_TYPE
{
    REMOTE_CTRL_POWERSUPPLY_OPEN = 1,//1-power supply Open
    REMOTE_CTRL_POWERSUPPLY_CLOSE = 2,//2-power supply Close
    REMOTE_CTRL_SIGNALSOURCE,//3-signal source
    REMOTE_CTRL_MENU,//4-menu
    REMOTE_CTRL_DETERMINATION,//5-determination
    REMOTE_CTRL_ON,//6-On
    REMOTE_CTRL_UNDER,//7-Under
    REMOTE_CTRL_LEFT,//8-Left
    REMOTE_CTRL_RIGHT,//9-Right
    REMOTE_CTRL_INFO,//10-INFO
    REMOTE_CTRL_RETURN,// 11-returns a layer
    REMOTE_CTRL_NUM, //12-number key
}SCREEN_REMOTE_CTRL_TYPE;

//Simulate Screen Remote Ctrl 2013-09-05
typedef struct tagNET_DVR_SIMULATE_SCREEN_REMOTE_CTRL
{
    DWORD       dwSize;
    BYTE        byControlType;    /*1- power supply, 2- power supply, 3- signal source, the 4- menu,
    5- determination\A3\AC6-On\A3\AC7-Under\A3\AC8-Left\A3\AC9-Right,  10-INFO, 11- returns a layer 12-digital key,13-power on/off*/
    BYTE        byControlParam; //operate parameter, when operate type is 12, it means key value(0-9), other invaild.
    BYTE        byRes[14];
}NET_DVR_SIMULATE_SCREEN_REMOTE_CTRL,*LPNET_DVR_SIMULATE_SCREEN_REMOTE_CTRL;

//Screen Signal CFG
typedef struct tagNET_DVR_SCREEN_SIGNAL_CFG
{
    DWORD    dwSize;
    BYTE     bySignalSourceType;    //Signal Source Type\A3\ACRefer to NET_DVR_CAM_MODE
    BYTE     byNoSignalPic;            //No Signal Pic\A3\AC1- Blue screen, 2- Black screen, 3-LOGO screen
    BYTE     byRes[14];
}NET_DVR_SCREEN_SIGNAL_CFG, *LPNET_DVR_SCREEN_SIGNAL_CFG;

//Screen Splice Cfg
typedef struct tagNET_DVRSCREEN_SPLICE_CFG
{
    DWORD   dwSize;
    BYTE    bySpliceIndex;            //Splice Screen Index\A3\AC0 - No splicing\A3\ACOther values - Splice Screen Index\A1\A3
    BYTE    bySpliceX;                //Splice X
    BYTE    bySpliceY;                //Splice Y
    BYTE    byWidth;                //Weight
    BYTE    byHeight;               //Height
    BYTE    byRes[11];
}NET_DVR_SCREEN_SPLICE_CFG, *LPNET_DVR_SCREEN_SPLICE_CFG;

//Fan Work Mode
typedef struct tagNET_DVR_SCREEN_FAN_WORK_MODE_CFG
{
    DWORD       dwSize;
    BYTE        byWorkMode;                 //1- normally open, 2- automatically
    BYTE        byTemperatureLimitValue; //Temperature Limit Value\A3\ACworking mode is automatically,Parameters effective\A1\A3
    BYTE        byRes[14];
}NET_DVR_SCREEN_FAN_WORK_MODE_CFG, *LPNET_DVR_SCREEN_FAN_WORK_MODE_CFG;

//VGA
typedef struct tagNET_DVR_SCREEN_VGA_CFG
{
    DWORD       dwSize;
    BYTE        byEnableAutoAdjust;     //Enable Auto Adjust\A3\AC0-No\A3\AC1-Yes\A3\ACEnable Auto Adjust,The following parameters effective.
    BYTE        byHorizontalPosition;   //Horizontal Position 0-100
    BYTE        byVerticalPosition;      //Vertical Position 0-100
    BYTE        byClock;                //Clock \A3\AC0-100
    BYTE        byPhase;                //Phase\A3\AC0-100
    BYTE        byRes[11];
}NET_DVR_SCREEN_VGA_CFG, *LPNET_DVR_SCREEN_VGA_CFG;

//Screen Menu
typedef struct tagNET_DVR_SCREEN_MENU_CFG
{
    DWORD       dwSize;
    BYTE        byMenuLanguage; //Language\A3\AC1-Chinese\A3\AC2-English
    BYTE        byTransparency; //Transparency 0-opacitas\A3\AC1-Low\A3\AC2-Middle\A3\AC3-High
    BYTE        byDuration;        //Duration\A3\AC0-normally open\A3\AC1-5 sec\A3\AC2-15 sec\A3\AC3-30 sec
    BYTE        byRes[13];
}NET_DVR_SCREEN_MENU_CFG, *LPNET_DVR_SCREEN_MENU_CFG;

//Pip
typedef struct tagNET_DVR_PIP_CFG
{
    DWORD   dwSize;
    BYTE    byEnable;                 //Enable 0~Disable\A3\AC1~Enable
    BYTE    bySubWindowSource;         //Sub Window Source\A3\ACRefer to NET_DVR_CAM_MODE
    BYTE    bySubWindowBorderColor;     //Sub Window Border Color\A3\AC 1-Blue\A3\AC2-Black
    BYTE    byRes1;
    NET_DVR_RECTCFG  struPosition;   //Sub Window Position\A3\ACThe total size of the 100*100 screen
    BYTE    byRes2[12];
}NET_DVR_PIP_CFG, *LPNET_DVR_PIP_CFG;

//Defog
typedef struct tagNET_DVR_DEFOG_LCD
{
    DWORD   dwSize;
    BYTE    byDefogEnable;    //Defog Enable\A3\AC0~Disable\A3\AC1~Enable
    BYTE    byDefogModel;     //Defog Model\A3\AC0~automatically\A3\AC1~manual
    BYTE    byDefogLevel;     //Defog Level\A3\AC1-7Levels\A3\AC Default Level is 4\A1\A3Level 1 is 0.5\A3\BBLevel 2 is 0.55\A3\BBLevel 3 is 0.60\A3\BBLevel 4 is 0.65\A3\BBLevel 5 is 0.70\A3\BBLevel 6 is 0.75\A3\BBLevel 7 is 0.80\A1\A3\A3\A8Defog Model is manual\A3\ACParameters effective\A3\A9
    BYTE    byRes[33];
}NET_DVR_DEFOG_LCD,*LPNET_DVR_DEFOG_LCD;

//Screen Wall
typedef struct tagNET_DVR_SCREEN_WALL_CFG
{
    DWORD    dwSize;
    BYTE    byEnable; //Enable Screen Wall\A1\A30-Disable\A3\BB1-Enable
    BYTE    byRes[35];
}NET_DVR_SCREEN_WALL_CFG, *LPNET_DVR_SCREEN_WALL_CFG;

//Screen Pos
typedef struct tagNET_DVR_SCREEN_POS_CFG
{
    DWORD     dwSize;
    BYTE     byScreenRowNum;//Screen Row Num\A1\A3
    BYTE     byScreenColNum;//Screen Col Num\A1\A3
    BYTE     byRes[34];
}NET_DVR_SCREEN_POS_CFG, *LPNET_DVR_SCREEN_POS_CFG;
/*******************************LCD end******************************************/
typedef struct tagNET_DVR_VIDEO_AUDIOIN_CFG
{
    DWORD     dwSize ;
    DWORD     dwChanNo;   //Video and Audio Channel NO., if the binding is enabled, voice intercom channel is then bound as the audio source for the channel
    BYTE      byEnable;   //enable voice intercom as the audio input source: 0 - not enabled 1 - Enabled
    BYTE      byRes[31] ;          //res
}NET_DVR_VIDEO_AUDIOIN_CFG, *LPNET_DVR_VIDEO_AUDIOIN_CFG;

typedef struct _NET_DVR_VCA_DETION_CFG
{
    DWORD    dwSize;
    BYTE    byEnable;
    BYTE    byRes1[3];
    NET_DVR_SCHEDTIME    struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;
    DWORD    dwMaxRelRecordChanNum ;
    DWORD    dwRelRecordChanNum ;
    DWORD    dwRelRecordChan[MAX_CHANNUM_V30/*64*/];
    BYTE    byEnablePreset[MAX_CHANNUM_V30];
    BYTE    byPresetNo[MAX_CHANNUM_V30];
    BYTE    byEnableCruise[MAX_CHANNUM_V30];
    BYTE    byCruiseNo[MAX_CHANNUM_V30];
    BYTE    byEnablePtzTrack[MAX_CHANNUM_V30];
    BYTE    byPTZTrack[MAX_CHANNUM_V30];
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30/*8*/];
    BYTE  byRes[224];
}NET_DVR_VCA_DETION_CFG, *LPNET_DVR_VCA_DETION_CFG;

typedef struct tagNET_DVR_VCA_DETECTION_CFG_V40
{
    DWORD dwSize;
    BYTE	byEnable;
    BYTE   byRes1[3];
    NET_DVR_SCHEDTIME    struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    DWORD   dwHandleType;
    DWORD   dwMaxRelAlarmOutChanNum ;
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40/*4128*/];
    DWORD     dwMaxRecordChanNum;
    DWORD     dwRelRecordChan[MAX_CHANNUM_V40/*512*/];
    DWORD dwEnablePresetChanNum;
    NET_DVR_PRESETCHAN_INFO struPresetChanInfo[MAX_CHANNUM_V40/*512*/];
    BYTE byRes2[516];
    DWORD dwEnableCruiseChanNum;
    NET_DVR_CRUISECHAN_INFO struCruiseChanInfo[MAX_CHANNUM_V40/*512*/];
    DWORD dwEnablePtzTrackChanNum;
    NET_DVR_PTZTRACKCHAN_INFO struPtzTrackInfo[MAX_CHANNUM_V40/*512*/];
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30];
    BYTE    byRes[224];
}NET_DVR_VCA_DETECTION_CFG_V40, *LPNET_DVR_VCA_DETECTION_CFG_V40;

typedef struct tagNET_DVR_CLOUD_STORAGE_CFG
{
    DWORD    dwSize;   ;
    BYTE     byEnableCS;  //start CS  0-close 1-enable
    BYTE     byRes[511];
} NET_DVR_CLOUD_STORAGE_CFG, *LPNET_DVR_CLOUD_STORAGE_CFG;


typedef struct tagNET_DVR_CHANS_RECORD_STATUS_CFG
{
    DWORD dwSize ;
    BYTE  byValid;
    BYTE    byRecord;
    DWORD   dwRelatedHD;  //Relate HD
    BYTE    byOffLineRecord;  //Off Line Recording Function 0-close 1-open
    BYTE     byRes[63];
}NET_DVR_CHAN_RECORD_STATUS_CFG, *LPNET_DVR_CHAN_RECORD_STATUS_CFG;

#define  MAX_CAMERAID_LEN    64
typedef struct  tagNET_DVR_UPLOAD_RECORD_INFO
{
    DWORD             dwSize;
    DWORD             dwRecordType; //The video type: 0- scheduled recording, 1- motion detection, 2- semaphore (IO) alarm, 3- semaphore (IO) alarm or motion detection, 4- semaphore (IO) alarm and motion detection, 5- command trigger, 6- manual recording, 7- vibration alarm, 8- environment alarm, 9- intelligent alarm (including retrograde, transboundary, item lost, remnants, and so on), 10- tampering alarm
    BYTE              sCameraID[MAX_CAMERAID_LEN]; //camera id;
    NET_DVR_TIME_EX   struStartTime;  //Start Time
    NET_DVR_TIME_EX   struStopTime;
    DWORD             dwStoragePoolID;
    BYTE              byFormatType ;     //video format type\A3\AC1-original\A3\AC2-RTP\A3\AC3-PS\A3\AC4-TS\A3\AC5-private\A3\AC6-FLV\A3\AC7-ASF\A3\AC8-3GP,9-RTP+PS(GB28181)\A3\AC0xff-Invalid
    BYTE  byVideoEncType;   //Video Code Type:  0-private h264;1-standard H264;2-standard MPEG4;5-MPEG2;7-M-JPEG;0xfe- auto;0xff-invalid
    BYTE  byAudioEncType;   //Audio Code Type:  0- G722; 1- G711_U; 2- G711_A;5-MP2L2;6-G726;7-AAC;0xfe- auto\A3\AC0xff-invalid
    BYTE               byRes[125];
}NET_DVR_UPLOAD_RECORD_INFO,*LPNET_DVR_UPLOAD_RECORD_INFO;


#define NET_DVR_GET_TEST_VERSION_HEAD           268435441
#define NET_DVR_SET_TEST_VERSION_HEAD           268435442
#define NET_DVR_GET_TEST_VERSION_HEAD_V1        268435443
#define NET_DVR_SET_TEST_VERSION_HEAD_V1        268435444
#define NET_DVR_GET_TEST_VERSION_HEAD_V2        268435445
#define NET_DVR_SET_TEST_VERSION_HEAD_V2        268435446
#define NET_DVR_GET_TEST_VERSION_HEAD_ONLY_0    268435447
#define NET_DVR_SET_TEST_VERSION_HEAD_ONLY_0    268435448

typedef struct tagNET_DVR_LOCAL_CHECK_DEV
{
    DWORD   dwCheckOnlineTimeout;     //heart check time,Unit (ms), min 30s, max 120s, while set Cfg ,0 meas use the default 120s
    DWORD   dwCheckOnlineNetFailMax;  //Since the maximum  number of reasons for the failure of the network,
    //Exceed the value of the SDK before the callback user exception, while set cfg ,0 means use the default value of 1
    BYTE    byRes[252];
}NET_DVR_LOCAL_CHECK_DEV,*LPNET_DVR_LOCAL_CHECK_DEV;

typedef struct tagNET_DVR_LOCAL_CFG_VERSION
{
    BYTE    byVersion;
    BYTE    byRes[63];
}NET_DVR_LOCAL_CFG_VERSION, *LPNET_DVR_LOCAL_CFG_VERSION;

typedef struct tagNET_DVR_TEST_VERSION_HEAD
{
    DWORD        dwSize;
    DWORD        dwParam1;
    BYTE         byParam2;
    BYTE         byRes[31];
}NET_DVR_TEST_VERSION_HEAD, *LPNET_DVR_TEST_VERSION_HEAD;

typedef struct tagNET_DVR_TEST_VERSION_HEAD_V1
{
    DWORD        dwSize;
    DWORD        dwParam1;
    BYTE         byParam2;
    BYTE         byRes[31];
    DWORD        dwParam1_1;
    BYTE         byParam1_2;
    BYTE         byRes1[31];
}NET_DVR_TEST_VERSION_HEAD_V1, *LPNET_DVR_TEST_VERSION_HEAD_V1;

typedef struct tagNET_DVR_TEST_VERSION_HEAD_V2
{
    DWORD        dwSize;
    DWORD        dwParam1;
    BYTE         byParam2;
    BYTE         byRes[31];
    DWORD        dwParam1_1;
    BYTE         byParam1_2;
    BYTE         byRes1[31];
    DWORD        dwParam2_1;
    BYTE         byParam2_2;
    BYTE         byRes2[31];
}NET_DVR_TEST_VERSION_HEAD_V2, *LPNET_DVR_TEST_VERSION_HEAD_V2;


//External Device CFG 2013-11-19
typedef struct tagNET_DVR_EXTERNAL_DEVCOND
{
    DWORD  dwSize;
    BYTE   byExternalDevTpye;//0-\A3\AC1- remote reading head device, 2- entrance control machine, all information of 3-LED screen 0xff- (using long connection access)
    BYTE   byRelativeIndex;//Other 0- (retention), index (relative to the access type (1~8 0xff-) all information using long connection access)
//    BYTE   byLaneID;// Lane ID
    BYTE   byRes[30];
}NET_DVR_EXTERNAL_DEVCOND,*LPNET_DVR_EXTERNAL_DEVCOND;

typedef struct tagNET_DVR_EXTERNAL_DEVCFG
{
    DWORD         dwSize;
    BYTE          byExternalDevTpye;//Other 0-, 1- remote reading head device, 2- entrance control machine, 3-LED screen
    BYTE          byRes2[3];
    char          sDevName[MAX_DEVNAME_LEN];
    union
    {
        BYTE    byUnionLen[656];
        struct
        {
            NET_DVR_IPADDR  struDevIP;//Device IP 144
            WORD     wDevPort;//Device Port
            BYTE     byRes[510];
        }struRrReader;//Long distance reading head device

        struct
        {
            BYTE byRs485No; //RS485 Number
            BYTE byDevCtrlCode;//Code address, used to distinguish the equipment (1-255)
            BYTE byAutoIssuedData;//Whether automatic send no automatic card data 0-, 1- automatically.
            BYTE byOfflineDetEnable;//Offline Detection Enable,0-Close\A3\AC1-Open
            BYTE byDetCycle;//Detection Cycle\A3\A80\A1\AB60 s\A3\A9
            BYTE byRes[651];
        }struGateway;//Entrance control machine

        struct
        {
            BYTE byExternalMode;//0-RS485,1-Network
            BYTE byRes[3];
            NET_DVR_IPADDR  struDevIP;//DEV IP address 144
            WORD wDevPort;//Device Port
            BYTE byRs485No; //RS485 No.
            BYTE byDevCtrlCode;//Code address, used to distinguish the equipment (1-255)
            //led screen display is controlled by control card, different control card display type support in different ways
            BYTE byCtrlCardType;//Control card type 0- retention (invalid value) 1- EQ2013
            BYTE byLedScreenType;//Screen type 0- monochrome screen 1- double color screen
            BYTE byLedScreenUse;//Screen uses 0- other 1- location screen 2- screen prompts 3- fee screen
            BYTE byLedDisplayMode;//The screen font display see instructions
            char sLedCustomInfo[MAX_LED_INFO];//The screen font display information
            DWORD dwLedScreenH;//Display height takes LED points
            DWORD dwLedScreenW;//Display width is required on the LED points
            BYTE byRes1[236];
        }struLed;//led screen
    }uExternalDevInfo; //By the byExternalMode value to determine which effectively
    BYTE byRes[128];
}NET_DVR_EXTERNAL_DEVCFG, *LPNET_DVR_EXTERNAL_DEVCFG;


typedef struct tagNET_DVR_EXTERNAL_DEVSTATUS
{
    DWORD  dwSize;
    char   sDevName[MAX_DEVNAME_LEN];//Device Name
    BYTE   byExternalDevTpye;//External Device Tpye
    BYTE   byRelativeIndex;//Relative Index
    BYTE   byOnline;//0-Not online\A3\AC1-online
    BYTE   byRes[125];
}NET_DVR_EXTERNAL_DEVSTATUS,*LPNET_DVR_EXTERNAL_DEVSTATUS;


typedef struct tagNET_DVR_ENTRANCEDET_CFG
{
    DWORD   dwSize;
    BYTE   byOfflineDetEnable;//Offline Enable 0-Close\A3\AC1-Open
    BYTE   byDetCycle;//Detection Cycle
    BYTE   byDevCtrlCode;//Detection Ctrl Code
    BYTE   byRes[61];
}NET_DVR_ENTRANCEDET_CFG,*LPNET_DVR_ENTRANCEDET_CFG;

typedef struct tagNET_DVR_ENTRANCEDEV_COMMAND
{
    DWORD   dwSize;
    BYTE   byDevCtrlCode;//Device Ctrl Code
    BYTE   byManualIssuedData;//Manual Issued Data 0-Disable\A3\AC1-Enable
    BYTE   byRes[62];
}NET_DVR_ENTRANCEDEV_COMMAND,*LPNET_DVR_ENTRANCEDEV_COMMAND;

typedef struct tagNET_DVR_ENISSUED_DATADEL
{
    DWORD   dwSize;
    BYTE   byDevCtrlCode;//Device Ctrl Code
    BYTE   byRes[27];
}NET_DVR_ENISSUED_DATADEL,*LPNET_DVR_ENISSUED_DATADEL;

typedef  struct  _tagNET_ITS_PASSVEHICLE_COST_ITEM
{
    DWORD   dwSize;
    DWORD   dwPassVehicleID; //Pass Vehicle ID
    BYTE    byIntime[MAX_TIME_LEN]; //In Time, Time format: yyyymmddhh24missfff
    BYTE    byOuttime[MAX_TIME_LEN]; //Out Time, Time format:yyyymmddhh24missfff
    BYTE    byCardNo[MAX_CARD_LEN];   //Card No
    BYTE    byPlateInfo[MAX_LICENSE_LEN]; //Plate Info
    float   fPayCost;       //Pay Cost
    BYTE    byOperatorName[MAX_OPERATORNAME_LEN]; //Operator Name
    BYTE    byVehicleType; //Vehicle Type  0-Small Vehicle 2-Big Vehicle
    BYTE    byRes1[3];
    DWORD   dwPayRuleID; // Pay Rule ID
    DWORD   dwFreeRuleID; // Free Rule ID
    BYTE    byRes2[256];
}NET_ITS_PASSVEHICLE_COST_ITEM, *LPNET_ITS_PASSVEHICLE_COST_ITEM;

typedef struct  _tagNET_ITS_HANDOVER_INFO
{
    DWORD   dwSize;
    BYTE    byOperatorName[MAX_OPERATORNAME_LEN]; //Operator Name
    BYTE    byOperatorCard[MAX_CARD_LEN]; //Operator Card
    BYTE    byStartTime[MAX_TIME_LEN];//Start Time, Time format:yyyymmddhh24miss
    BYTE    byEndTime[MAX_TIME_LEN]; //End Time, Time format:yyyymmddhh24miss
    float   fTotal_Pay;    //Total Pay
    DWORD   dwTotal_Records;   //Total Records
    BYTE    byRes[64];
}NET_ITS_HANDOVER_INFO, *LPNET_ITS_HANDOVER_INFO;

typedef struct tagNET_DVR_IOOUT_COND
{
    DWORD dwSize;
    BYTE  bySyncOutputNo;//Synchronization ouput number(0-F1,1-F2,2-F3)
    BYTE  byRes[63];
}NET_DVR_IOOUT_COND,*LPNET_DVR_IOOUT_COND;

typedef struct tagNET_DVR_IOOUT_CFG
{
    DWORD dwSize;
    BYTE   byWorkMode;//0-alarm ouput,1-Strobe Lamp(default)
    BYTE   byRes1[3];
    union
    {
        BYTE    byUnionLen[128];
        struct
        {
            BYTE   byDefaultState;//default state 0-low level(default)\A3\AC1-high level
            BYTE   byWorkState;//work state  0-low lever(default),1-high level,2-pulse
            BYTE   byFreqMulti;//frequency multiplication\A3\ACrange[1,15]
            BYTE   byDutyRatio;//duty ratio, range[0,40%]
            BYTE   byRes[3];
            BYTE   byFlashLightEnable;    //set enable time of flash light: 0-disalbe;1-enable
            NET_DVR_SCHEDTIME  struFlashLightTime;//flash light enable time period
            BYTE   byRes1[116];
        }struStrobeLamp;    // valid when byWorkMode value is 1-Strobe Lamp
    }uWorkModeInfo;
    BYTE   byRes2[128];
}NET_DVR_IOOUT_CFG,*LPNET_DVR_IOOUT_CFG;

//signal light Synchronization Configuration

typedef struct tagNET_DVR_SIGNAL_SYNCCFG
{
    DWORD  dwSize;
    WORD   wPhase;//phase, range[0,360]
    BYTE   byLineLock;//Synchronous power, 0-disable\A3\AC1-enable
    BYTE   byRes[125];
}NET_DVR_SIGNAL_SYNCCFG,*LPNET_DVR_SIGNAL_SYNCCFG;

typedef struct
{
    DWORD    dwSize;
    BYTE    byEnable;// enable EZVIZ access 0\A1\ABdisable\A3\AC1\A1\ABenable
    BYTE    byDeviceStatus; //Whether the equipment online\A3\AC0-Reserve\A3\AC1-Online\A3\AC2-Offline
    BYTE    byAllowRedirect;    // allow redirection, 0-Retain, 1-yes, 2-no
    BYTE    byDomainName[MAX_DOMAIN_NAME];
    BYTE    byRes [445];
}NET_DVR_EZVIZ_ACCESS_CFG,*LPNET_DVR_EZVIZ_ACCESS_CFG;


#define MAX_DISPLAY_NUM         512  //max display channel number
#define MAX_LEDCONTENT_NUM      512  //max length of virtual led content
#define MAX_PPT_CHAN            128

typedef struct tagNET_DVR_VIDEOWALLDISPLAYMODE
{
    DWORD dwSize;
    BYTE  byEnable;//enable video wall,0-disable,1-enable
    BYTE  byRes1[3];
    NET_DVR_RECTCFG_EX struRect;//video wall scale,base on reference coordinate
    BYTE    sName[NAME_LEN]; //name of video wall
    BYTE     byRes2[100];
}NET_DVR_VIDEOWALLDISPLAYMODE, *LPNET_DVR_VIDEOWALLDISPLAYMODE;

typedef struct tagNET_DVR_DISPLAYPARAM
{
    DWORD dwDisplayNo;//display channel No.
    BYTE  byDispChanType;/*display channel mode,1-BNC,2-VGA,3-HDMI,4-DVI,5-SDI, 6-FIBER, \
                                    7-RGB, 8-YPrPb, 9-VGA/HDMI/DVI adapter\A3\AC10-3GSDI,11-VGA/DVI adapter, 12-HDBaseT, 0xff-invaild*/

    BYTE  byRes[11];
}NET_DVR_DISPLAYPARAM,*LPNET_DVR_DISPLAYPARAM;

typedef struct tagNET_DVR_DISPLAYCFG
{
    DWORD  dwSize;
    NET_DVR_DISPLAYPARAM struDisplayParam[MAX_DISPLAY_NUM/*512*/] ;
    BYTE   byRes[128];
}NET_DVR_DISPLAYCFG,*LPNET_DVR_DISPLAYCFG;

typedef struct tagNET_DVR_VIDEOWALLDISPLAYPOSITION
{
    DWORD dwSize;
    BYTE  byEnable;
    BYTE  byRes1[3];
    DWORD dwVideoWallNo;  //video wall No., one byte video wall No. + three byte reserved
    DWORD dwDisplayNo;    //diaplay channel No.
    NET_DVR_RECTCFG_EX struRectCfg; //position of dispaly channel on the video wall
    BYTE    byRes2[64];
}NET_DVR_VIDEOWALLDISPLAYPOSITION,*LPNET_DVR_VIDEOWALLDISPLAYPOSITION;

typedef struct tagNET_DVR_VIDEOWALLWINDOWPOSITION
{
    DWORD dwSize;
    BYTE  byEnable;  //window enable, 0-disable,1-enable
    BYTE  byWndOperateMode;  //Window operation mode, 0 - coordinate system, 1 - resolution coordinates
    BYTE  byRes1[6];
    DWORD dwWindowNo;//window No.
    DWORD dwLayerIndex;//layer index of window
    NET_DVR_RECTCFG_EX struRect;//position of window on the video wall
    NET_DVR_RECTCFG_EX struResolution; //Window to coordinate resolution, get or set effective according to the resolution of the coordinates
    DWORD dwXCoordinate;
    DWORD dwYCoordinate;
    BYTE  byRes2[36];
}NET_DVR_VIDEOWALLWINDOWPOSITION,*LPNET_DVR_VIDEOWALLWINDOWPOSITION;

typedef struct tagNET_DVR_VIDEO_WALL_INFO
{
    DWORD dwSize;
    DWORD dwWindowNo; //window No.
    DWORD dwSceneNo;  //scene No.
    BYTE  byRes[20];
}NET_DVR_VIDEO_WALL_INFO,*LPNET_DVR_VIDEO_WALL_INFO;

typedef struct tagNET_DVR_VIRTUALLED_PARAM
{
    DWORD   dwSize;
    BYTE    byEnable; //enable virtual led, 0-disable,1-enable
    BYTE    byDispMode;//display mode,1-transparent,2-translucent,3-cover
    BYTE    byRes1[6];
    NET_DVR_RGB_COLOR struContentColor;//font color
    NET_DVR_RGB_COLOR struBackColor;//background color
    NET_DVR_RECTCFG_EX struRect;
    DWORD   dwContentNum;/*content length*/
    BYTE    byLedContent[MAX_LEDCONTENT_NUM/*512*/]; /*content of led*/
    BYTE    byMoveMode;  //move mode,1-normal,2-smooth,3-static
    BYTE    byFontSize; //font size\A3\AC1-1 time\A3\AC2-2 times\A3\AC3-4 times
    BYTE    byMoveDirection; //move direction,0-default(left to right),1-left to right,2-right to left,3-top to buttom,4-buttom to top
    BYTE    byMoveSpeed; //character move speed,1-speed1,2-speed2
    BYTE    byRes2[124];
}NET_DVR_VIRTUALLED_PARAM,*LPNET_DVR_VIRTUALLED_PARAM;

typedef struct tagNET_DVR_IMAGE_CUT_MODE
{
    DWORD dwSize;
    BYTE  byCutMode;  //image cut mode,1-4:3,2-16:9
    BYTE  byRes[31];
}NET_DVR_IMAGE_CUT_MODE,*LPNET_DVR_IMAGE_CUT_MODE;

typedef struct tagNET_DVR_USING_SERIALPORT
{
    DWORD  dwSize ;
    DWORD  dwSerialPort; //current use serial port
    BYTE byProtocolType; //serial protocol type \A3\AC1-LCD-S1 , 2-LCD-S2 , 3-LCD-L1 , 4-LCD-DLP\A3\AC 5-LCD-S3 , 6-LCD-D20\A3\AC7-LCD-L2,8-LCD-Z1\A3\AC9-LCD-D20/D,10-LCD-D20/S,11-LCD-D20/P,12-LCD-D20/T,13-LCD-D20/F,14-LCD-D20/DF,15-LCD-D20/FS,16-LCD-D20/FP,17-LCD-D20/FT,18-LCD-D5022,19-LCD-D5032,20-LCD-D5042+
    BYTE byRes[31];
}NET_DVR_USING_SERIALPORT,*LPNET_DVR_USING_SERIALPORT;

typedef struct tagNET_DVR_VIDEOWALLSCENECFG
{
    DWORD dwSize;
    BYTE  sSceneName[NAME_LEN];//scene name
    BYTE  byEnable;//scene valid, 1-valid\A3\AC0-invalid
    BYTE  bySceneIndex;     //scene index,only for getting
    BYTE  byRes [78];
}NET_DVR_VIDEOWALLSCENECFG, *LPNET_DVR_VIDEOWALLSCENECFG;

typedef struct tagNET_DVR_SCENE_CONTROL_INFO
{
    DWORD dwSize;
    NET_DVR_VIDEO_WALL_INFO struVideoWallInfo; //video wall information
    DWORD dwCmd; //scene control command,1-scene switch,2-initialize scene,3-force switch,4-save current scene to
    BYTE  byRes[4];
}NET_DVR_SCENE_CONTROL_INFO, *LPNET_DVR_SCENE_CONTROL_INFO;

typedef struct tagNET_DVR_SHOW_CONTROL_INFO
{
    DWORD dwSize;
    DWORD dwDisplayNo;  //display channel No., assign 0xffffffff to operate all display channels
    BYTE  byEnable;     //enable display, 0-disable, 1-enable
    BYTE  byChanType;   //channel type to show, 1-display channel No.,2-screen No.
    BYTE  byRes1[2];
    DWORD dwWallNo;     //wall no\A3\AC1 byte wall No.(high bit)+3 bytes 0,valid when display screen No.
    BYTE byRes2[56];
}NET_DVR_SHOW_CONTROL_INFO,*LPNET_DVR_SHOW_CONTROL_INFO;



typedef struct tagNET_DVR_BUF_INFO
{
    void*   pBuf;    //buffer pointer
    DWORD   nLen;    //buffer length
}NET_DVR_BUF_INFO, *LPNET_DVR_BUF_INFO;

typedef struct tagNET_DVR_IN_PARAM
{
    NET_DVR_BUF_INFO struCondBuf;            //condition buffer
    NET_DVR_BUF_INFO struInParamBuf;         //parameter buffer
    DWORD  dwRecvTimeout;      //receive timeout, unit:ms,assign 0 to use default timeout
    BYTE   byRes[32];
}NET_DVR_IN_PARAM,LPNET_DVR_IN_PARAM;

typedef struct tagNET_DVR_OUT_PARAM
{
    NET_DVR_BUF_INFO struOutBuf; //output buffer
    void*  lpStatusList;         //status buffer
    BYTE   byRes[32];
}NET_DVR_OUT_PARAM,LPNET_DVR_OUT_PARAM;

typedef struct tagNET_DVR_AUDIO_CHAN_INFO
{
    DWORD dwSize;
    DWORD dwChannel;   //audio channel combine(1 byte device no+1 byte subboard no +2 byte audio channel no)
    BYTE  byRes[48];
}NET_DVR_AUDIO_CHAN_INFO, *LPNET_DVR_AUDIO_CHAN_INFO;

typedef struct tagNET_DVR_AUDIO_CHAN_CFG
{
    DWORD         dwSize;
    BYTE          sChanName[NAME_LEN]; //audio channel name
    BYTE          byEnable; //enable the audio, 0-close 1-open
    BYTE          byAudioSwitchType; //audio switch type, 1-according to IPC source, 2- according to window decode
    BYTE          byRes[2];
    NET_DVR_PU_STREAM_CFG_V41 struAudioSrcInfo;  //audio source information it is avalid when byAudioSwitchType is 1
    DWORD         dwWindowNo; //Window No( 1 byte wall No. + 1 byte sub window No. + 2byte window No.)
    BYTE          byRes2[28];
}NET_DVR_AUDIO_CHAN_CFG, *LPNET_DVR_AUDIO_CHAN_CFG;

typedef struct tagNET_DVR_MAINBOARD_SERIAL_CFG
{
    DWORD dwSize;
    BYTE bySerialWorkMode; //serial work mode\A3\AC1-RS484,2-RS232
    BYTE byFunType; //function type\A3\AC1-matrix serial control\A3\AC2-screen control\A3\AC3-serial data through 4-PPP Mode  5-Console mode 6-Direct connect 7-Keyboard control 8-Monitor control 9-PTZ control
    BYTE byDataBit;// data bit 0\A3\AD5bit\A3\AC1\A3\AD6bit\A3\AC2\A3\AD7bit\A3\AC3\A3\AD8bit;
    BYTE byStopBit;// stop bit,  0\A3\AD1bit\A3\AC1\A3\AD2bit;
    DWORD dwBaudRate;//baud rate 0\A3\AD50\A3\AC1\A3\AD75\A3\AC2\A3\AD110\A3\AC3\A3\AD150\A3\AC4\A3\AD300\A3\AC5\A3\AD600\A3\AC6\A3\AD1200\A3\AC7\A3\AD2400\A3\AC8\A3\AD4800\A3\AC9\A3\AD9600\A3\AC10\A3\AD19200\A3\AC 11\A3\AD38400\A3\AC12\A3\AD57600\A3\AC13\A3\AD76800\A3\AC14\A3\AD115.2k;
    BYTE byParity;//check 0\A3\ADno check\A3\AC1\A3\ADodd\A3\AC2\A3\ADeven;
    BYTE byFlowcontrol;// 0\A3\ADno control\A3\AC1\A3\ADsoft control,2-hard control
    BYTE byRes[34];
}NET_DVR_MAINBOARD_SERIAL_CFG, *LPNET_DVR_MAINBOARD_SERIAL_CFG;

#define MAX_SUBBOARD_NUM        42        //C10s  subboard number
#define MAX_SINGLE_BOARD_EXCEPTION_NUM 16 //single board exception number
typedef struct tagNET_DVR_SUBBOARD_INFO
{
    DWORD      dwSize;
    BYTE       byBoardType;    //board type 0-mainboard  1-DVI-I input\A3\AC2-YPbPr input\A3\AC3-BNC input\A3\AC4-SDI input\A3\AC 5-DVIdouble link inupt\A3\AC 6-ordinary decode input\A3\AC 7-DVI-I output\A3\AC 8-SDI output, 9-enhance decode input  0xff-unknow
    BYTE       byInterfaceNum;  //interface number
    BYTE       byStatus;        //status 0-except 1-normal
    BYTE       byRes[1];
    DWORD      dwSlotNo;       //slot No where the board is in .
    BYTE       byRes2[32];
}NET_DVR_SUBBOARD_INFO, *LPNET_DVR_SUBBOARD_INFO;

typedef struct tagNET_DVR_DEVICE_SUBBOARD_INFO
{
    DWORD     dwSize;
    BYTE      byBackBoardType;  //backboard type , 1-4U, 2-8U, 3-13U, 0xff-unknow
    BYTE      bySoltNum;        //solt number
    BYTE      byBoardNum;   //vaild number
    BYTE      byRes1[1];
    NET_DVR_SUBBOARD_INFO struSubBoadInfo[MAX_SUBBOARD_NUM]; //the first byBoardNum items is vaild
    BYTE       byRes2[32];
}NET_DVR_DEVICE_SUBBOARD_INFO, *LPNET_DVR_DEVICE_SUBBOARD_INFO;

typedef struct tagNET_DVR_DEVICE_BOARD_EXCEPINFO
{
    DWORD       dwSize;
    BYTE         byExceptNum;         //Exception number
    BYTE        byRes1[3];
    BYTE        byMajor[MAX_SINGLE_BOARD_EXCEPTION_NUM];    //Major type
    WORD        wMinor[MAX_SINGLE_BOARD_EXCEPTION_NUM];    //Minor type
    BYTE        byRes2[32];
}NET_DVR_DEVICE_BOARD_EXCEPINFO, *LPNET_DVR_DEVICE_BOARD_EXCEPINFO;

typedef struct tagNET_DVR_ALARM_RELATE_COND
{
    DWORD  dwSize;
    /*
    0 mobile detection,
    1 video occlusion,
    2 video loss,
    3  PIR alarm,
    4  wireless alarm,
    5  emergency alarm,
    6  intelligent capture,
    7  face detection,
    8  boundary detection detection,
    9  regional intrusion detection,
    10 scene change detection\A3\AC
    11 Abnormal detection\A3\AC
    0xff alarm input
    */
    BYTE  byAlarmType;
    //linkage action 0- is invalid, 1- screenshots upload FTP, 2-Jpeg screenshots upload Email
    BYTE  byRelateActType;
    BYTE  byRes[2];
    // alarm input number or the channel number or wireless number
    // (when byAlarmType ==0xff, dwChannel represents the alarm input number)
    // (when byAlarmType ==4, said dwChannel is the wireless serial number)
    DWORD  dwChannel;
    BYTE  byRes1[64];
}NET_DVR_ALARM_RELATE_COND,*LPNET_DVR_ALARM_RELATE_COND;

typedef struct tagNET_DVR_ALARM_RELATE_CFG
{
    DWORD   dwSize;
    DWORD   dwMaxRelateChanNum ; // alarm correlation channel number triggered (read-only) maximum support number
    //initial value of dwRelateChan is an array of 0xFFFFFFFF; fill in the actual channel number;
    DWORD   dwRelateChan[MAX_CHANNUM_V40/*512*/];
    BYTE    byRes1[256];
}NET_DVR_ALARM_RELATE_CFG,*LPNET_DVR_ALARM_RELATE_CFG;

typedef struct tagNET_DVR_PTZ_BASICPARAMCFG
{
    DWORD  dwSize;
    BYTE   byProportionalPan; //Enable proportion variable times configuration 0-disable, 1-able
    BYTE   byPresetFreezing; //Enable the preset video freeze 0-disable, 1-able
    BYTE   byPresetSpeed;//Preset speed grade 1--8, the default 4
    BYTE   byKeyboardCtrlSpeed;//Manual speed grade 0-low,1-middle,2-high
    BYTE   byAutoScanSpeed;//Scanning speed grade: 1--40, the default 28
    BYTE   byZoomingSpeed;//Zoom speed: 1--3, the default 3
    BYTE   byManualControlSpeed;// Manual Control Speed: 0- res,1-human,2-nonMotorVehicle, 3-motorVehicle, 4-adaptive
    BYTE   byPTZMotionTrack;//PTZ Motion Track 0-open, 1-close
    BYTE   byRes[124];
}NET_DVR_PTZ_BASICPARAMCFG,*LPNET_DVR_PTZ_BASICPARAMCFG;

typedef struct tagNET_DVR_PTZ_OSDCFG
{
    DWORD  dwSize;
    BYTE   byZoomStatus; //Lens multiple display: 1-2 seconds, 2-5 second, 3-10 second, 0xff- 0- normally closed, normally open, the default 2 seconds
    BYTE   byPtStatus;//Azimuth display: 1-2 second, 2-5 second, 3-10 second, 0xff- 0- normally closed, normally open, the default 2 seconds
    BYTE   byPresetStatus;//Preset title display: 1-2 second, 2-5 second, 3-10 second, 0xff- 0- normally closed, normally open, the default 2 seconds
    BYTE   byPositionDisplayFormat;//Azimuth display format 0- in accordance with PT display (P179|T-02), 1- in accordance with the direction of display (SE123|T-02)
    BYTE   byRes[124];
}NET_DVR_PTZ_OSDCFG,*LPNET_DVR_PTZ_OSDCFG;

typedef struct tagNET_DVR_PTZ_POWEROFFMEMCFG
{
    DWORD  dwSize;
    BYTE   byResumeTimePoint; //Power off memory models: Oxff-, 1-30, 2-60 disable seconds seconds seconds seconds, 3-300, 4-600, default is 30 seconds
    BYTE   byRes[127];
}NET_DVR_PTZ_POWEROFFMEMCFG,*LPNET_DVR_PTZ_POWEROFFMEMCFG;

typedef struct tagNET_DVR_PTZ_LIMITCOND
{
    DWORD  dwSize;
    DWORD  dwChan;
    BYTE   byLimitMode;//The limiting mode 0- retention, 1- key control limit, 2- scanning limit
    BYTE   byRes[63];
}NET_DVR_PTZ_LIMITCOND, *LPNET_DVR_PTZ_LIMITCOND;

typedef struct tagNET_DVR_PTZ_LIMITCFG
{
    DWORD  dwSize;
    BYTE   byEnable;//Enable 0-disable\A3\AC1-able
    BYTE   byLimitStatus; //The limit state 0- is not limiting, 1- has a limit (not editable)

    BYTE   byRes[122];
}NET_DVR_PTZ_LIMITCFG,*LPNET_DVR_PTZ_LIMITCFG;

typedef struct tagNET_DVR_PTZ_LIMITCTRL
{
    DWORD  dwSize;
    DWORD  dwChan;
    BYTE   byLimitMode; //Limiting 0- retention, 1- key control limit, 2- scanning limit
    BYTE   byWorkMode ;//0-set\A3\AC1-clear
    BYTE   byRes[122];
}NET_DVR_PTZ_LIMITCTRL,*LPNET_DVR_PTZ_LIMITCTRL;

typedef struct tagNET_DVR_PTZ_LOCKCFG
{
    DWORD   dwSize;
    BYTE   byWorkMode ;//PTZ lock control 0- unlock, 1-lock
    BYTE   byRes[123];
}NET_DVR_PTZ_LOCKCFG,*LPNET_DVR_PTZ_LOCKCFG;

typedef struct tagNET_DVR_PTZLOCKINFO_COND
{
    DWORD   dwSize;
    DWORD   dwChannel;
    BYTE   byRes[64];
}NET_DVR_PTZLOCKINFO_COND,*LPNET_DVR_PTZLOCKINFO_COND;

typedef struct tagNET_DVR_PTZLOCKINFO
{
    DWORD   dwSize;
    DWORD   dwRemainingSec;//Remaining Sec
    BYTE    byRes[128];
}NET_DVR_PTZLOCKINFO, *LPNET_DVR_PTZLOCKINFO;

typedef struct tagNET_DVR_CRUISEPOINT_COND
{
    DWORD  dwSize;
    DWORD  dwChan;
    WORD   wRouteNo;
    BYTE   byRes[30];
}NET_DVR_CRUISEPOINT_COND,*LPNET_DVR_CRUISEPOINT_COND;

typedef struct
{
    WORD    wPresetNo;
    WORD    wDwell;
    BYTE    bySpeed;
    BYTE    bySupport256PresetNo;//256th preset point compatibility before whether the force
    BYTE    byRes[6];
}NET_DVR_CRUISEPOINT_PARAM,*LPNET_DVR_CRUISEPOINT_PARAM;

typedef struct
{
    DWORD  dwSize;
    NET_DVR_CRUISEPOINT_PARAM struCruisePoint[MAX_CRUISE_POINT_NUM];
    BYTE     Res[64];
}NET_DVR_CRUISEPOINT_V40, *LPNET_DVR_CRUISEPOINT_V40;

typedef struct
{
    DWORD  dwSize;
    NET_DVR_CRUISEPOINT_PARAM struCruisePoint[MAX_CRUISEPOINT_NUM_V50];
    BYTE   Res[64];
}NET_DVR_CRUISEPOINT_V50, *LPNET_DVR_CRUISEPOINT_V50;


//2014-03-15 Set Limit scanning parameters
typedef struct tagNET_DVR_LINEARSCAN
{
    DWORD   dwSize;
    DWORD   dwChan;           //Channel Number
    BYTE    byLinearScanType; //Limiting type, 0- retention, 1- left boundary setting, 2- right boundary setting
    BYTE    byRes[63];
}NET_DVR_LINEARSCAN, *LPNET_DVR_LINEARSCAN;

//Stream attach information
typedef struct tagNET_DVR_STREAM_ATTACHINFO_CFG
{
    DWORD dwSize;          //Structure Size
    BYTE  byStreamWithVca; //Add vca info in stream\A3\ACwhich can be available for later retrieval\A1\A30-not add,1-add
    BYTE  byRes[127];      //
}NET_DVR_STREAM_ATTACHINFO_CFG,*LPNET_DVR_STREAM_ATTACHINFO_CFG;

typedef struct tagNET_DVR_SUBSYSTEM_NETCFG
{
    DWORD  dwSize;
    BYTE   byDefaultRoute;  //default route, 0 means struEtherNet[0], 1 means struEtherNet[1]
    BYTE   byNetworkCardNum;      //the usable netcard number in  the device
    BYTE   byCurDetectType;// current detection area type\A3\AC0-Polygon\A3\AC1-Detection line
    BYTE   byRes1;
    NET_DVR_ETHERNET_MULTI struEtherNet [MAX_NETWORK_CARD]; //etherNet card
    BYTE   byRes2[128];
}NET_DVR_SUBSYSTEM_NETCFG, *LPNET_DVR_SUBSYSTEM_NETCFG;

typedef struct tagNET_DVR_CLEARCTRL
{
    DWORD  dwSize;
    DWORD  dwChan;
    BYTE   byAllPreset; //Remove all the preset point\A3\BA0-disable\A3\AC1-able
    BYTE   byAllPatrols; //Remove all the patrols\A3\BA0-disable\A3\AC1-able
    BYTE   byAllPatterms; //Remove all the patterms\A3\BA0-disable\A3\AC1-able
    BYTE   byAllPrivacyMasks; //Remove all the privacy masks\A3\BA0-disable\A3\AC1-able
    BYTE   byAllPTZLimited; //Remove all the ptz limit\A3\BA0-disable\A3\AC1-able
    BYTE   byAllScheduledTasks; //Remove all the scheduled tasks\A3\BA0-disable\A3\AC1-able
    BYTE   byAllParkAction; //Remove all the park action\A3\BA0-disable\A3\AC1-able
    BYTE   byRes[125];
}NET_DVR_CLEARCTRL, *LPNET_DVR_CLEARCTRL;

typedef struct tagNET_DVR_PTZ_PRIORITIZECFG
{
    DWORD  dwSize;
    BYTE   byPTZPrioritize; //PTZPrioritize\A3\BA0-Rs485\A3\AC1-net(default)
    BYTE   byRes[3];
    DWORD  dwDelay; //2---200s
    BYTE   byRes1[124];
}NET_DVR_PTZ_PRIORITIZECFG, *LPNET_DVR_PTZ_PRIORITIZECFG;

typedef struct tagNET_DVR_INITIALPOSITIONCTRL
{
    DWORD  dwSize;
    DWORD  dwChan;
    BYTE   byWorkMode ;//0-Set\A3\AC1-Clear
    BYTE   byRes[127];
}NET_DVR_INITIALPOSITIONCTRL,*LPNET_DVR_INITIALPOSITIONCTRL;

typedef struct tagNET_DVR_PRIVACY_MASKS_COND
{
    DWORD  dwSize;
    DWORD  dwChan;
    BYTE   byRegionalID; //RegionalID  1\A1\AB24
    //Delete the corresponding current ID privacy information 0- retention, deletion of 1- (WriteOnly)
    BYTE   byDelPrivacyMaskCfg;
    BYTE   byRes[62];
}NET_DVR_PRIVACY_MASKS_COND, *LPNET_DVR_PRIVACY_MASKS_COND;

typedef struct tagNET_DVR_PRIVACY_MASKS_CFG
{
    DWORD  dwSize;
    BYTE   byEnable;//Enable 0-disable\A3\AC1-able
    //Privacy zone configuration parameters are displayed  0-disable\A3\AC1-able\A3\A8ReadOnly\A3\A9
    BYTE   byPrivacyMaskCfgEnable;
    BYTE   byColorType; //0- reserves, 1- gray, red, green, 2- 3- 4- 5-, 6- blue, orange yellow, 0xff- mosaic
    BYTE   byActiveZoomRatio;//Shielding rate\A3\BA1--100
    char  sPrivacyMaskName[NAME_LEN/*32*/];
    NET_VCA_POLYGON  struRegion;
    //The current regional coordinate is valid or not (0-disable, 1-able is for a single locale regional coordinate information, and a single scene of locale regional coordinate information)
    BYTE   byCurrentRegionEnable;
    // 0- byActiveZoomRatio ;1- fActiveZoomRatio(Support curActiveZoomRatioType)
    BYTE   byCurZoomRatio ;
    BYTE   byRes[2];
    float  fActiveZoomRatio; //[1.0-100.0]
    BYTE   byRes1[120];
}NET_DVR_PRIVACY_MASKS_CFG, *LPNET_DVR_PRIVACY_MASKS_CFG;

typedef struct tagNET_DVR_PRIVACY_MASKS_ENABLECFG
{
    DWORD  dwSize;
    BYTE   byEnable;//Enable 0-disable\A3\AC1-able
    BYTE   byRes[127];
}NET_DVR_PRIVACY_MASKS_ENABLECFG,*LPNET_DVR_PRIVACY_MASKS_ENABLECFG;

typedef struct tagNET_DVR_SMARTTRACKCFG
{
    DWORD dwSize;
    BYTE  byEnable;//Enable 0-disable\A3\AC1-able
    BYTE  byRes[3];
    DWORD dwDuration;//Duration: 0--300 seconds, the default 300 seconds
    BYTE  byRes1[124];
}NET_DVR_SMARTTRACKCFG,*LPNET_DVR_SMARTTRACKCFG;

typedef struct tagNET_DVR_ZOOMRATIOCTRL
{
    DWORD  dwSize;
    DWORD  dwChan;
    BYTE   byRes[128];
}NET_DVR_ZOOMRATIOCTRL,*LPNET_DVR_ZOOMRATIOCTRL;

typedef struct tagNET_DVR_SUBSYSTEMINFO_V40
{
    /*Subsystem type, 1-decode subsystem, 2-code subsystem, 3-cascading output subsystem, 4-cascading input subsystem, 5-distributor subsystem, 6-alarm host subsystem,
    7-smart subsystem, 8-V6 decode subsystem, 9-V6 subsystem, 10-transform subsystem, 11-X86 server subsystem, 12-UItra HD input subsystem, 13-X86 center server board,
    14-X86 business server board,15-IPC fusion subsystem,16-siber switch subsystem,17-X86 joint subsystem,18-general joint subsystem, 0-NULL*/
    BYTE        bySubSystemType;
    //subsystem channel number, for distributor subsystem, it means 485 serial number (just for get)
    BYTE        byChan;
    BYTE        byLoginType;//Login type, 1-direction 2-DNS, 3-peanuthull
    BYTE        bySlotNum ;//slot number, (just for getting)
    BYTE        byRes1[4];
    NET_DVR_IPADDR   struSubSystemIP;        /*IPaddress (can change)*/
    NET_DVR_IPADDR   struSubSystemIPMask;//subnet mask
    NET_DVR_IPADDR   struGatewayIpAddr;    /* gateway address*/
    WORD        wSubSystemPort;        //subsystem port (can change)
    BYTE        byRes2[6];
    BYTE        sUserName[NAME_LEN];    /*username (just for getting)*/
    BYTE        sPassword[PASSWD_LEN];    /*password (can change)*/
    char        sDomainName[MAX_DOMAIN_NAME];//domain name (can change)
    char        sDnsAddress[MAX_DOMAIN_NAME];/*domain name or ip address*/
    BYTE        sSerialNumber[SERIALNO_LEN];//serial number (just for getting)
    BYTE        byBelongBoard;//belong board, from 1 to start, 0xff means invaild
    BYTE        byInterfaceType;//interface type\A3\AC0-none, 1-BNC\A3\AC2-VGA\A3\AC3-HDMI\A3\AC4-DVI\A3\AC5-SDI, 6-FIBER, 7-RGB, 8-YPrPb, 9-VGA/HDMI/DVI adapter\A3\AC10-3GSDI,11-VGA/DVI adapter\A3\AC12-HDTVI\A3\AC13-HDBaseT\A3\AC14-DP\A3\AC15-DVIT\A3\AC0xff-invaild
    BYTE        byInterfaceNums;//interface number\A3\AC0xff means invaild
    BYTE        byInterfaceStartNum;//interface number to start\A3\AC0xff means invaild
    BYTE        byDeviceName[20];//subsystem name
    BYTE        byAudioChanNums;  //audio channel number
    BYTE        byAudioChanStartNum; //the start of audio channel
    BYTE        byAudioChanType;   //audio channel type, 0-invalid, 1-audio in, 2-audio out
    BYTE		byRes3[33];
}NET_DVR_SUBSYSTEMINFO_V40, *LPNET_DVR_SUBSYSTEMINFO_V40;

#define  MAX_SUBSYSTEM_NUM_V40  120
typedef struct tagNET_DVR_ALLSUBSYSTEMINFO_V40
{
    DWORD dwSize;
    NET_DVR_SUBSYSTEMINFO_V40 struSubSystemInfo[MAX_SUBSYSTEM_NUM_V40];
    BYTE byRes[8];
}NET_DVR_ALLSUBSYSTEMINFO_V40, *LPNET_DVR_ALLSUBSYSTEMINFO_V40;

//Dial Switch Cfg
typedef struct tagNET_DVR_DIAL_SWITCH_CFG
{
    DWORD  dwSize;
    DWORD  dwSwitchState;//Dial Switch State
    BYTE   byRes[28];
}NET_DVR_DIAL_SWITCH_CFG,*LPNET_DVR_DIAL_SWITCH_CFG;

typedef struct tagNET_ALARM_RECORDFILE_LOSS
{
    NET_DVR_TIME_EX struInspectStart; //inspect start time
    NET_DVR_TIME_EX struInspectEnd;   //inspect End time
    NET_DVR_IPADDR  struIP;           //lost records IP addresses
    DWORD  dwChanNo;
    DWORD  dwIDIndex;                //Encoder ID
    BYTE   sName[STREAM_ID_LEN];       //Encoder Name
    NET_DVR_TIME_EX struLossStartTime; //lost record start Time
    NET_DVR_TIME_EX struLossEndTime;   //lost record End Time
    DWORD  dwLostNum;                 //lost record num. 0xffffffff -- all records lost
    BYTE   byRes[240];
} NET_ALARM_RECORDFILE_LOSS, *LPNET_ALARM_RECORDFILE_LOSS;

typedef struct tagNET_ALARM_STREAM_EXCEPTION
{
    NET_DVR_IPADDR  struIP;
    DWORD  dwChanNo;
    DWORD  dwIDIndex;
    BYTE   sName[STREAM_ID_LEN];
    BYTE   byExceptionCase;           //exception reason\A3\AC0-write exception 1-network exception
    BYTE   byRes[307];
} NET_ALARM_STREAM_EXCEPTION, *LPNET_ALARM_STREAM_EXCEPTION;


typedef struct tagNET_ALARM_RESOURCE_USAGE
{
    BYTE   byLevel;    // 0-normal, 1-One alarm limit 2-Two alarm limit 3-Three alarm limit
    BYTE   byRes[491];
}NET_ALARM_RESOURCE_USAGE, *LPNET_ALARM_RESOURCE_USAGE;

typedef struct tagNET_ALARM_RECORD_EXCEPTION
{
    BYTE    byReason;    // 0 - Recording Volume least ,1-Volume error 2-No volume lun
    BYTE    byRes1[3];
    BYTE    sVolumeName[MAX_VOLUMENAME_LEN];
    DWORD  dwVolumeID;  //volume ID
    BYTE    byRes[452];
}NET_ALARM_RECORD_EXCEPTION, *LPNET_ALARM_RECORD_EXCEPTION;

typedef union tagNET_ALARM_CVR_SUBINFO_UNION
{
    BYTE byLen[492];
    NET_ALARM_RECORDFILE_LOSS     struRecordLost;
    NET_ALARM_STREAM_EXCEPTION     struStreamException;
    NET_ALARM_RESOURCE_USAGE     struResourceUsage;
    NET_ALARM_RECORD_EXCEPTION   struRecordException;
}NET_ALARM_CVR_SUBINFO_UNION, *LPNET_ALARM_CVR_SUBINFO_UNION;

#define  MAX_VARIABLE_DATA_NUM    65535


typedef struct tagNET_DVR_ALARMINFO_DEV_V40
{
    DWORD            dwAlarmType; //Alarm subtype 0 - encoder (channel) signal alarms; 1 - Volume II private damage; 2 - NVR service exits; 3 - encoder abnormal state; 4 - system clock anomaly; 5 - recording volume remaining capacity is too low; 6 - encoder (channel) motion detection alarm;
    // 8 - encoder (channel) Tampering; 8 - video loss alarm; 9 - real-time video monitoring and alarm; 10 - resource utilization alarm; 11 - CVR auto repair abnormal 12 - Video Abnormal
    NET_DVR_TIME     struTime;
    NET_ALARM_CVR_SUBINFO_UNION  uSubAlarmInfo; //Substructure alarm when the alarm type is 8,9,10,11,12 Commonwealth valid
    BYTE             byRes[256];
    DWORD            dwNumber; //Variable number of data
    WORD             *pNO; //When type is 0,3,6,7, there might be channel number; When type is 5, there may be a disk number. The range of values ??that can be represented as 0 to 65535
}NET_DVR_ALARMINFO_DEV_V40, *LPNET_DVR_ALARMINFO_DEV_V40;

//host recording control add by xzx
typedef struct tagNET_DVR_CONTROL_START_CFG //start recording info
{
    BYTE    byUseDefine; //use define, 0-use default,1-use define
    BYTE    byRes1;
    WORD    wCourseIndex; //course index
    BYTE    byRes[128];
}NET_DVR_CONTROL_START_CFG, *LPNET_DVR_CONTROL_START_CFG;

typedef struct tagNET_DVR_CONTROL_DELAY_CFG//one key delay recording control info
{
    BYTE    byUseDefine; //use define \A3\AC 0-use default\A3\AC1-use define
    BYTE    byRes1;
    WORD    wDelayTime; //recording delay time
    BYTE    byRes[128];
}NET_DVR_CONTROL_DELAY_CFG, *LPNET_DVR_CONTROL_DELAY_CFG;

typedef union tagNET_DVR_CONTROL_INFO_UNION
{
    BYTE    byLen[132];
    NET_DVR_CONTROL_START_CFG  struStartCfg;   //one key start
    NET_DVR_CONTROL_DELAY_CFG  struDelayCfg;  //one key delay
}NET_DVR_CONTROL_INFO_UNION, *LPNET_DVR_CONTROL_INFO_UNION;

typedef struct  tagNET_DVR_RECORDING_CONTROL_CFG_
{
    DWORD    dwSize;
    WORD    wCmdType;    //control\A3\AC0-one key start\A3\AC1-one key end\A3\AC2-one key pause\A3\AC3-one key resume\A3\AC4-one key delay,5- a button to start shielding 6- a key to stop shielding

    BYTE    byRes1 [2]; //res
    NET_DVR_CONTROL_INFO_UNION struControlInfo; //control info, use with control cmd
    BYTE    byRes[256]; //res
}NET_DVR_RECORDING_CONTROL_CFG, *LPNET_DVR_RECORDING_CONTROL_CFG;

typedef struct tagNET_DVR_RECORDING_HOST_CFG
{
    DWORD     dwSize;
    DWORD    dwOneKeyDelayTime; //one key delay time
    BYTE     byDirectedMode; //record mode\A3\AC0-auto record\A3\AC1-manual record
    BYTE     byClassroomType;    //classroom type, 0-invalid,1-mian classroom,2-sub classroom
    BYTE     byCourseDataStorageEnabled;//Class data is stored in hard disks, 0 - not stored, 1 - storage
    BYTE     byRes[125];
}NET_DVR_RECORDING_HOST_CFG, *LPNET_DVR_RECORDING_HOST_CFG;

typedef struct tagNET_DVR_STATISTIC_DATA_COND
{
    DWORD        dwSize;
    DWORD        dwTypeTarget; //Statistical object types, see TARGET_TYPE
    NET_DVR_TIME   struStartTime;//Began to count time
    NET_DVR_TIME   struStopTime;//End to count time
    BYTE        byRes[280];
}NET_DVR_STATISTIC_DATA_COND, *LPNET_DVR_STATISTIC_DATA_COND;

typedef struct tagNET_DVR_STATISTIC_DATA_CFG
{
    DWORD        dwSize;
    DWORD        dwTypeTarget; //Statistical object types, see TARGET_TYPE
    NET_DVR_TIME   struStartTime;//The event start time
    NET_DVR_TIME   struStopTime;//The event end time
    BYTE        byRes[300];
}NET_DVR_STATISTIC_DATA_CFG, *LPNET_DVR_STATISTIC_DATA_CFG;

//typedef enum
//{
//	NET_SDK_ALL_TARGET = 0,
//	NET_SDK_PPT_TARGET_ALARM,
//	NET_SDK_PPT_TARGET_VIEW,
//	NET_SDK_STU_SINGLE_ALARM,
//	NET_SDK_STU_SINGLE_VIEW,
//	NET_SDK_SUT_MULT_ALARM,
//	NET_SDK_STU_MULT_VIEW,
//	NET_SDK_STU_TEACHER_VIEW,
//	NET_SDK_TEA_UP_DOWN_ALARM,
//	NET_SDK_TEA_START_VIEW,
//	NET_SDK_BLA_WRITE_ALARM,
//	NET_SDK_BLA_WRITE_VIEW,
//	NET_SDK_TEA_FULL_VIEW,
//	NET_SDK_TEA_START_ALARM,
//	NET_SDK_TEA_WALK_ALARM,
//	NET_SDK_TEA_LEFT_ALARM,
//	NET_SDK_TEA_RUN_ALARM,
//	NET_SDK_TEA_MULT_ALARM
//}TARGET_TYPE;


typedef struct tagNET_DVR_AUTO_TRACK_CFG
{
    DWORD  dwSize;
    NET_DVR_DIRECT_CONNECT_CHAN_INFO struSDIInfo[MAX_CHANNUM_V30] ;
    //SDI chan
    BYTE   byCameraType[MAX_CHANNUM_V30];     //cameratype
    BYTE   byRes[64];
}NET_DVR_AUTO_TRACK_CFG, *LPNET_DVR_AUTO_TRACK_CFG;

typedef struct tagNET_DVR_PUBLISH_FTP_CFG
{
    BYTE                byProtocolType;    //protocol type 0-FTP\A3\AC1-SFTP
    BYTE                byRes1;     //res
    WORD                wFTPPort;  //port
    BYTE                   byAddress[MAX_DOMAIN_NAME];  //IP or doamin,if doamin is with '.',than it's ip
    BYTE                szUserName[NAME_LEN/*32*/];        //admin
    BYTE                szPassWord[PASSWD_LEN/*16*/];        //password
    BYTE                szCustomDir[128];    //cunstom dir
    BYTE                byRes[12]; //res
} NET_DVR_PUBLISH_FTP_CFG, *LPNET_DVR_PUBLISH_FTP_CFG;

typedef struct tagNET_DVR_PUBLISH_HTTP_CFG
{
    BYTE   strUrl[256]; //publish URL info
}NET_DVR_PUBLISH_HTTP_CFG, *LPNET_DVR_PUBLISH_HTTP_CFG;

typedef struct tagNET_DVR_PUBLISH_FTP_CFG_DIR
{
    BYTE                byProtocolType;    //protocol type 0-FTP\A3\AC1-SFTP
    BYTE                byRes1;     //res
    WORD                wFTPPort;  //port
    BYTE               byAddress[MAX_DOMAIN_NAME];  //IP or doamin,if doamin is with '.',than it's ip
    BYTE                szUserName[NAME_LEN/*32*/];        //admin
    BYTE                szPassWord[PASSWD_LEN/*16*/];        //password
    BYTE                  byDirLevel;                     /*0 = use root dir,1 = use top dir,2=use sub dir*/
    BYTE                byTopDirMode;         /* Top Dir 0x1-use device name,0x2 = use device ID,0x3 = use device IP Address       0xff=use selfdefine*/
    BYTE                bySubDirMode;         /*Sub Dir 0x1=use channel name,0x2=use channel number,0x3=use course name, 0x4-use time,0xff-use selfdefine*/
    BYTE              byRes2;
    BYTE               byTopCustomDir[MAX_CUSTOMDIR_LEN/*32*/];/*self define Top Dir*/
    BYTE               bySubCustomDir[MAX_CUSTOMDIR_LEN/*32*/];/*self define Sub Dir*/
    BYTE                byRes[72];
}NET_DVR_PUBLISH_FTP_CFG_DIR, *LPNET_DVR_PUBLISH_FTP_CFG_DIR;

typedef  union tagNET_DVR_PUBLISH_ADD_UNION
{
    BYTE    byLen[256];
    NET_DVR_PUBLISH_HTTP_CFG struHttpCfg; //http cfg
    NET_DVR_PUBLISH_FTP_CFG  struFtpCfg;  //ftp cfg
    NET_DVR_PUBLISH_FTP_CFG_DIR struDirFtpCfg;  // support sub dir ftp
}NET_DVR_PUBLISH_ADD_UNION, *LPNET_DVR_PUBLISH_ADD_UNION;

typedef struct  tagNET_DVR_CHAN_RECORD_PUBLISH_INFO
{
    BYTE    byPublish; //0-no publish\A3\AC 1-publish
    BYTE    byRes1[3];
    DWORD  dwStreamType;
    //&0x1-main
    //&0x2-sub
    //&0x4-three
    BYTE    byRes[12];     //res
}NET_DVR_RECORD_PUBLISH_INFO,*LPNET_DVR_RECORD_PUBLISH_INFO;


typedef struct tagNET_DVR_PUBLISH_CFG
{
    DWORD  dwSize;
    BYTE   byPublishType;    //0-http,1-ftp,2-Dir FTP
    BYTE   byRes1[3];
    NET_DVR_PUBLISH_ADD_UNION struPublishAddr;  //publish addr
    NET_DVR_RECORD_PUBLISH_INFO  struChanPublish[MAX_CHANNUM_V30];
    NET_DVR_RECORD_PUBLISH_INFO struDirectChanPublish; //direct chan publish
    BYTE                  byUploadTime;      //enable upload by Timer\A3\AC1-disable, 2-enable
    BYTE                byTimerMode;
    BYTE                  byUploadStartHour;
    BYTE                byUoploadStartMin;
    BYTE                byRes[1020];
}NET_DVR_PUBLISH_CFG, *LPNET_DVR_PUBLISH_CFG;

typedef struct tagNET_DVR_ONEKEY_PUBLISH_CFG
{
    DWORD  dwSize;
    BYTE  byUseDefine;  //0-use default config\A3\AC1-use define publish config
    BYTE  byRes1[3];
    NET_DVR_RECORD_PUBLISH_INFO struChanPublish[MAX_CHANNUM_V30]; //record chan publish
    NET_DVR_RECORD_PUBLISH_INFO struDirectChanPublish; //direct chan publish
    NET_DVR_TIME_EX  struStartTime;  //record start time
    NET_DVR_TIME_EX  struEndTime;   //record end time
    BYTE       byRes[64];
}NET_DVR_ONEKEY_PUBLISH_CFG,*LPNET_DVR_ONEKEY_PUBLISH_CFG;

typedef struct  tagNET_DVR_COURSE_RECORDING_INFO
{
    DWORD    dwSize;
    char    sCourseName[COURSE_NAME_LEN/*32*/];
    char    sInstructorName[INSTRUCTOR_NAME_LEN/*16*/]; //teacher
    char    sCourseDescription[COURSE_DESCRIPTION_LEN /*256*/];  //description
    BYTE    byIndex;
    BYTE    byRes[15];
}NET_DVR_COURSE_RECORDING_INFO, *LPNET_DVR_COURSE_RECORDING_INFO;

typedef struct tagNET_DVR_EACH_LESSON_INFO_
{
    NET_DVR_SCHEDTIME struSchedTime;   //course start end time
    WORD  wCourseIndex;        //course index
    WORD  wSessionIndex;        //session index
    BYTE  byRes[4];
}NET_DVR_EACH_LESSON_INFO,*LPNET_DVR_EACH_LESSON_INFO ;

typedef struct tagNET_DVR_CURRICULUM_CFG
{
    DWORD  dwSize;
    NET_DVR_EACH_LESSON_INFO struLessonInfo[MAX_TIMESEGMENT_V40/*16*/]; //lession info
    BYTE   byRes[256];
}NET_DVR_CURRICULUM_CFG, *LPNET_DVR_CURRICULUM_CFG;

typedef  struct  tagNET_DVR_DATE_
{
    WORD         wYear;        //year
    BYTE        byMonth;        //month
    BYTE         byDay;        //day
}NET_DVR_DATE,*LPNET_DVR_DATE;

typedef struct _NET_DVR_PPT_DETECT_CFG_
{
    DWORD    dwSize ;
    BYTE    byEnablePPTDetect;
    BYTE    byPptDetLevel;
    BYTE    byEnablePartScreen;
    BYTE    byRes1;
    WORD    wX;
    WORD    wY;
    WORD    wWidth;
    WORD    wHeight;
    BYTE    byRes[32];
}NET_DVR_PPT_DETECT_CFG,*LPNET_DVR_PPT_DETECT_CFG;

typedef struct _NET_DVR_PPT_CHANNEL_CFG_
{
    DWORD    dwSize ;
    BYTE    byChan[MAX_PPT_CHAN];
    BYTE    byRes[32];
}NET_DVR_PPT_CHANNEL_CFG,*LPNET_DVR_PPT_CHANNEL_CFG;

typedef struct tagNET_DVR_BACKUP_RECORD_INFO
{
    BYTE   byEnable;
    BYTE   byRes[11];
    DWORD  dwStreamType;  //Stream Type
    //&0x1-main stream
    //&0x2-sub stream
    //&0x4-stream three
}NET_DVR_BACKUP_RECORD_INFO, *LPNET_DVR_BACKUP_RECORD_INFO;

typedef struct tagNET_DVR_BACKUP_RECORD_PARAM
{
    DWORD     dwSize ;
    NET_DVR_BACKUP_RECORD_INFO   struChanBackUp[MAX_CHANNUM_V30/*64*/];
    NET_DVR_BACKUP_RECORD_INFO   struDirectedChanBackUp;  //directed chan info
    BYTE    byRes[256];
}NET_DVR_BACKUP_RECORD_PARAM, *LPNET_DVR_BACKUP_RECORD_PARAM;

/****************************** LCD V1.2 begin*************************************/
#define MAX_SCREEN_ADDRESS_LEN 16 //Max address length
#define MAX_DAY_TIME_POINT 8   //max time point every day
#define MAX_TIME_POINT     16  //max time point every year

typedef struct tagNET_DVR_DEV_IP_INFO
{
    BYTE byUserName[NAME_LEN]; //
    BYTE byPassWord[PASSWD_LEN]; //
    NET_DVR_IPADDR struIPAddr; //
    WORD wPort; //
    BYTE byRes[24];
}NET_DVR_DEV_IP_INFO, *LPNET_DVR_DEV_IP_INFO;

typedef union tagNET_DVR_SCREEN_BASE_INFO
{
    BYTE byScreenAddress[MAX_SCREEN_ADDRESS_LEN]; //feature code , when the way adding device is zero , it is vaild.
    NET_DVR_DEV_IP_INFO struIPInfo; //screen IP address information
    BYTE byRes[100];
}NET_DVR_SCREEN_BASE_INFO,*LPNET_DVR_SCREEN_BASE_INFO;

typedef struct tagNET_DVR_SCREEN_INDEX_CFG
{
    DWORD dwSize;
    BYTE byEnbale; //enable \A3\AC0-disable\A3\AC1-enable
    BYTE byDevAddType; //the way add device\A3\AC0-feature code(when server and screen using serial port communication)\A3\AC1-IP address(when server and screen using net communication)
    BYTE byRes1[2];
    NET_DVR_SCREEN_BASE_INFO struScreenBaseInfo; //screen device base information
    BYTE byRes[32];
}NET_DVR_SCREEN_INDEX_CFG,*LPNET_DVR_SCREEN_INDEX_CFG;

//simulate remote control parameter
typedef struct tagNET_DVR_SIMULATE_REMOTE_CTRL
{
    BYTE        byControlType;    //1-power on, 2-power off, 3-signal, 4-menu, 5-sure, 6-up, 7-down, 8-left, 9-right, 11-back to last level, 12-digital key
    BYTE        byControlParam; //operate parameter, when operate type is 12, it means key value(0-9), other invaild.
    BYTE        byRes[14];
}NET_DVR_SIMULATE_REMOTE_CTRL, *LPNET_DVR_SIMULATE_REMOTE_CTRL;

//screen wall parameter
typedef struct tagNET_DVR_SCREEN_WALL_CTRL
{
    BYTE byEnable; //switch\A1\A30-close\A3\BB1-open
    BYTE byRes[15];
}NET_DVR_SCREEN_WALL_CTRL, *LPNET_DVR_SCREEN_WALL_CTRL;

//Zoom Area parameter
typedef struct tagNET_DVR_AREA_ZOOM_CFG
{
    BYTE byCmd;    //Zoom Area command\A3\AC1-enlarge\A3\AC2-reduction
    BYTE byRes[3];
    NET_DVR_RECTCFG struArea; //enlarge area\A3\ACtotal screen size is 1920*1920. it is invaild when the command is reduction
}NET_DVR_AREA_ZOOM_CFG, *LPNET_DVR_AREA_ZOOM_CFG;


typedef  union tagNET_DVR_SCREEN_CONTROL_PARAM
{
    NET_DVR_INPUT_INTERFACE_CTRL    struInputCtrl;
    NET_DVR_DISPLAY_COLOR_CTRL         struDisplayCtrl;
    NET_DVR_DISPLAY_POSITION_CTRL     struPositionCtrl;
    NET_DVR_SIMULATE_REMOTE_CTRL struSimulateRemoteCrtl; //simulate remote key control
    NET_DVR_SCREEN_WALL_CTRL struScreenWallCtrl; //screen wall control
    NET_DVR_AREA_ZOOM_CFG struZoomArea;  //Zoom Area parameter
    BYTE        byRes[16];
}NET_DVR_SCREEN_CONTROL_PARAM, *LPNET_DVR_SCREEN_CONTROL_PARAM;

typedef struct tagNET_DVR_SCREEN_CONTROL
{
    DWORD     dwSize;
    DWORD      dwCommand ;     /*comamnd, 1-open, 2-close, 3-choose screen input source, 4-colour control, 5-position control */
    BYTE       byProtocol;      //serial protocol type, 1:LCD-S1,2:LCD-S2
    BYTE    byRes1[3];
    NET_DVR_SCREEN_CONTROL_PARAM    struControlParam;
    BYTE       byRes2[52];
}NET_DVR_SCREEN_CONTROL, *LPNET_DVR_SCREEN_CONTROL;

typedef struct tagNET_DVR_SCREEN_CONTROL_V41
{
    DWORD   dwSize;
    BYTE    byRes[3];
    BYTE       byProtocol;             // Serial protocol type,  1-LCD-S1 , 2-LCD-S2 , 3-LCD-L1 \A3\AC 4-LCD-DLP\A3\AC 5-LCD-S3 , 6-LCD-H1\A3\AC7-LCD-L2,8-LCD-Z1,0xff-invaild\A3\AC
    //9-LCD-D20/D,10-LCD-D20/S,11-LCD-D20/P,12-LCD-D20/T,13-LCD-D20/F,14-LCD-D20/DF,15-LCD-D20/FS,
    //16-LCD-D20/FP,17-LCD-D20/FT,18-LCD-D5022,19-LCD-D5032,20-LCD-D5042+,21-LCD-D20/Z  0xff-invaild
    DWORD      dwCommand ;             //command, 1-open, 2-close, 3-choose screen input source, 4-colour control, 5-position control, 6-simulate remote control, 7-screen display status, 8-show feature code(this command use the default start point(0,0),width and height set to 0xffffffff),
    //9-screen wall control 10-recover default parameter, 11-show Ip(this command use the default start point(0,0),width and height set to 0xffffffff)
    NET_DVR_SCREEN_CONTROL_PARAM    struControlParam;
    BYTE    byWallNo;        // wall No.
    BYTE   byRes1[3];
    NET_DVR_RECTCFG_EX struRect;
    BYTE   byRes2[28];
}NET_DVR_SCREEN_CONTROL_V41, *LPNET_DVR_SCREEN_CONTROL_V41;

typedef struct tagNET_DVR_MSC_SPLICE_CFG
{
    DWORD dwSize;
    BYTE bySpliceNo;
    BYTE byWallNo;
    BYTE byEnable; //0-disable\A3\AC1-enable
    BYTE byRes1[1];
    NET_DVR_RECTCFG_EX struRectCfg; //splice area, when get the parameter, it is all zero
    BYTE byRes2[32];
}NET_DVR_MSC_SPLICE_CFG,*LPNET_DVR_MSC_SPLICE_CFG;

typedef struct tagNET_DVR_MSC_SCREEN_INTERFACE_CFG
{
    DWORD dwSize;
    BYTE  byInterfaceType;    //input source, see INPUT_INTERFACE_TYPE
    BYTE  byNoSignalPic;        //no signal display model, 1-blue screen, 1-black screen 3-Logo
    BYTE  byRes[30];
}NET_DVR_MSC_SCREEN_INTERFACE_CFG,*LPNET_DVR_MSC_SCREEN_INTERFACE_CFG;

//Back light configure
typedef struct tagNET_DVR_MSC_SCREEN_BACKLIGHT_CFG
{
    DWORD dwSize;
    BYTE byBacklight; //black light\A3\AC0-100
    BYTE byRes[15];
}NET_DVR_MSC_SCREEN_BACKLIGHT_CFG,*LPNET_DVR_MSC_SCREEN_BACKLIGHT_CFG;

//screen picture parameter
typedef struct tagNET_DVR_MSC_SCREEN_PIP_CFG
{
    DWORD dwSize;
    BYTE    byEnable;    // 0-disable 1-enable
    BYTE    bySubWindowSource;    //Sub windows Source\A3\ACsee INPUT_INTERFACE_TYPE
    BYTE    bySubWindowBorderColor;    //Sub window border colour\A3\AC 1-blue\A3\AC2-black
    BYTE    byRes1;
    NET_DVR_RECTCFG_EX  struPosition;    //sub windows position\A3\ACscreen total size is 1920*1920
    BYTE    byRes2[16];
}NET_DVR_MSC_SCREEN_PIP_CFG,*LPNET_DVR_MSC_SCREEN_PIP_CFG;

typedef struct tagNET_DVR_SCREEN_WORK_STATE
{
    DWORD dwSize;
    BYTE           byFanStatus;//fan status\A3\AC0-close\A3\AC1-open
    BYTE           byFanExceptionStatus;    //fan exception status\A3\AC0-not support\A3\AC1-normal 2-exception
    BYTE           byRes1[2];
    DWORD          dwWorkingHours; //working hour\A3\ACunit\A3\BAhour
    BYTE           byVersion[VERSION_LEN];//sofeware version
    int            iTemperature; //board temperature unit\A3\BACentigrade , accurate to a bit
    BYTE             byTempState;     //board temperature status\A3\AC0-not support \A3\AC1-normal\A3\AC2-exception
    BYTE           byRes[31];
}NET_DVR_SCREEN_WORK_STATE,*LPNET_DVR_SCREEN_WORK_STATE;

//boot logo parameter
typedef struct tagNET_DVR_BOOT_LOGO_CFG
{
    DWORD dwSize;
    BYTE byEnable; //whether to display logo,0-not to \A3\AC1-display
    BYTE byRes[31];
}NET_DVR_BOOT_LOGO_CFG,*LPNET_DVR_BOOT_LOGO_CFG;

typedef struct tagNET_DVR_LCD_AUDIO_CFG
{
    DWORD   dwSize;
    BYTE    byMute; //whether to mute, 0-no, 1-yes
    BYTE    byVolume; //volume, 0-100
    char    byBalance; //audio balance, -50 - +50
    BYTE    byRes[33];
}NET_DVR_LCD_AUDIO_CFG, *LPNET_DVR_LCD_AUDIO_CFG;

//screen parameter union
typedef union tagNET_DVR_MSC_SCREEN_PARAM
{
    NET_DVR_MSC_SCREEN_INTERFACE_CFG struInterfaceCfg; //input source parameter
    NET_DVR_SCREEN_FAN_WORK_MODE_CFG struFanWorkMode; //fan work mode parameter
    NET_DVR_SCREEN_VGA_CFG struVgaCfg; //VGA signal parameter
    NET_DVR_SCREEN_MENU_CFG struMenuCfg; //screen menu parameter
    NET_DVR_VIDEO_OUT_CFG struOutEffectCfg; //display parameter
    NET_DVR_COLOR_TEMPERATURE_CFG struColorTemperatureCfg; //color temperature parameter
    NET_DVR_ADC_CFG struAdcCfg; //ADC parameter
    NET_DVR_SCREEN_EDGE_CFG struScreenEdgeCfg; //screen edge parameter
    NET_DVR_MSC_SCREEN_BACKLIGHT_CFG struBacklight; //back light parameter
    NET_DVR_MSC_SCREEN_PIP_CFG struPicInPicCfg; //screen picture parameter
    NET_DVR_DEFOG_LCD struDefog; //defog parameter
    NET_DVR_SCREEN_WORK_STATE struWorkState; //screen work state parameter
    NET_DVR_BOOT_LOGO_CFG struBootLogoCfg; //boot display logo parameter
    NET_DVR_LCD_AUDIO_CFG struAudioCfg; //audio parameter
    BYTE byRes[256];
}NET_DVR_MSC_SCREEN_PARAM,*LPNET_DVR_MSC_SCREEN_PARAM;

typedef struct tagNET_DVR_MSC_SCREEN_PARAM_CFG
{
    DWORD dwSize;
    BYTE byParamType; //parameter type , 1-input source\A3\AC2-fan work mode\A3\AC3-VGA signal\A3\AC4-screen menu\A3\AC5-display\A3\AC6-color temperature\A3\AC7-ADC\A3\AC8-screen edge\A3\AC9-back light\A3\AC10-screen picture\A3\AC11-defog\A3\AC12-screen work state\A3\AC13-boot display logo  14-audio parameter
    BYTE byRes1[3];
    NET_DVR_MSC_SCREEN_PARAM struParam; //screen parameter
    BYTE byRes2[32];
}NET_DVR_MSC_SCREEN_PARAM_CFG,*LPNET_DVR_MSC_SCREEN_PARAM_CFG;

typedef struct tagNET_DVR_MSC_SCREEN_REMOTE_CFG
{
    DWORD dwSize;
    BYTE byWallNo; //
    BYTE byRes1[3];
    NET_DVR_RECTCFG_EX struRectCfg; //screen area
    NET_DVR_MSC_SCREEN_PARAM_CFG struScreenParam; //
    BYTE byRes2[32];
}NET_DVR_MSC_SCREEN_REMOTE_CFG,*LPNET_DVR_MSC_SCREEN_REMOTE_CFG;

typedef struct tagNET_DVR_MSC_SCREEN_PARAM_COND
{
    DWORD dwSize;
    BYTE byWallNo;
    BYTE byParamType; //parameter type , 1-input source\A3\AC2-fan work mode\A3\AC3-VGA signal\A3\AC4-screen menu\A3\AC5-display\A3\AC6-color temperature\A3\AC7-ADC\A3\AC8-screen edge\A3\AC9-back light\A3\AC10-screen picture\A3\AC11-defog\A3\AC12-screen work state\A3\AC13-boot display logo  14-audio parameter
    BYTE byRes1[2];
    NET_DVR_RECTCFG_EX struRectCfg; //
    BYTE byRes2[32];
}NET_DVR_MSC_SCREEN_PARAM_COND,*LPNET_DVR_MSC_SCREEN_PARAM_COND;

typedef struct tagNET_DVR_SWITCH_DAY_TIME
{
    BYTE byEnable; //whether to use this setting, 0-disable\A3\AC1-enable
    BYTE bySwitchType; //switch\A3\AC0-close\A3\AC1-open
    BYTE byRes1[2];
    NET_DVR_DAYTIME struTimePoint; //switch time point
    BYTE byRes2[8];
}NET_DVR_SWITCH_DAY_TIME,*LPNET_DVR_SWITCH_DAY_TIME;

typedef struct tagNET_DVR_SWITCH_TIME_POINT
{
    BYTE byEnable; //0-disable\A3\AC1-enable
    BYTE bySwitchType; //switch type\A3\AC0-close\A3\AC1-open
    BYTE byRes1[2];
    NET_DVR_SYSTEM_TIME struTimePoint; //switch time point
    BYTE byRes2[16];
}NET_DVR_SWITCH_TIME_POINT,*LPNET_DVR_SWITCH_TIME_POINT;

typedef struct tagNET_DVR_TIME_SWITCH_CFG
{
    DWORD dwSize;
    NET_DVR_SWITCH_DAY_TIME struSwitchDayTime[MAX_DAYS][MAX_DAY_TIME_POINT]; //week switch plan
    NET_DVR_SWITCH_TIME_POINT struSwitchTimePoint[MAX_TIME_POINT]; //time to switch
    BYTE byRes[64];
}NET_DVR_TIME_SWITCH_CFG,*LPNET_DVR_TIME_SWITCH_CFG;

typedef struct tagNET_DVR_VIDEO_WALL_AREA
{
    DWORD dwSize;
    BYTE byWallNo; //
    BYTE byRes1[3];
    NET_DVR_RECTCFG_EX struRect; //
    BYTE byRes2[32];
}NET_DVR_VIDEO_WALL_AREA, *LPNET_DVR_VIDEO_WALL_AREA;

typedef struct tagNET_DVR_DELAY_TIME
{
    DWORD dwSize;
    DWORD dwDelayTime; //delay time \A3\AC0-3000\A3\ACunit\A3\BAms
    BYTE byRes[32];
}NET_DVR_DELAY_TIME,*LPNET_DVR_DELAY_TIME;

/****************************** LCD V1.2 end **************************************/




/***********************68xxSeries of binocular 3D camera***********************/
//calibration Type
typedef enum _BV_CALIBRATION_TYPE_ENUM_
{
    ENUM_BV_CALIBRATION_NONE    = 0,
    ENUM_BV_CALIBRATION_DIRECT  = 1, //Direct calibration
    ENUM_BV_CALIBRATION_SAMPLE = 2, //Sample calibration
} BV_CALIBRATION_TYPE_ENUM;


//Sample calibration
typedef struct tagNET_DVR_BV_SAMPLE_CALIB_POINT
{
    BYTE  byCalibPtID;       //Calibration ID\A3\ACRange[1,5]
    BYTE  byRes1[3];
    NET_VCA_POINT struPoint; //Coordinates of calibration points
    BYTE  byRes2[16];
}NET_DVR_BV_SAMPLE_CALIB_POINT,*LPET_DVR_BV_SAMPLE_CALIB_POINT;

//Start calibration sample input parameters
typedef struct tagNET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM
{
    DWORD  dwCameraHeight;  //Camera height, unit: cm
    DWORD  dwHumanHeight;  //Human Height\A3\ACunit: cm
    BYTE    byRes[248];
}NET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM,*LPNET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM;

//The calibration set samples the input parameters
typedef struct tagNET_DVR_BV_SAMPLE_CALIB_SET_PARAM
{
    NET_DVR_BV_SAMPLE_CALIB_POINT struCalibPoint; //Calibration ID\A1\A3
    BYTE byRes[228];
}NET_DVR_BV_SAMPLE_CALIB_SET_PARAM,*LPNET_DVR_BV_SAMPLE_CALIB_SET_PARAM;

//end sample calibration input parameters
typedef struct tagNET_DVR_BV_SAMPLE_CALIB_END_PARAM
{
    BYTE byRes[256];
}NET_DVR_BV_SAMPLE_CALIB_END_PARAM,*LPNET_DVR_BV_SAMPLE_CALIB_END_PARAM;

//Sample calibration input parameters
typedef union tagNET_DVR_BV_SAMPLE_CALIB_PARAM_UNION
{
    BYTE byRes[256];
    NET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM struCalibBegin; //Begin calibration
    NET_DVR_BV_SAMPLE_CALIB_SET_PARAM struCalibSet; //Set calibration
    NET_DVR_BV_SAMPLE_CALIB_END_PARAM struCalibEnd; //End calibration
}NET_DVR_BV_SAMPLE_CALIB_PARAM_UNION,*LPNET_DVR_BV_SAMPLE_CALIB_PARAM_UNION;

//calibration Enum
typedef enum _BV_SAMPLE_CALIB_CMD_ENUM
{
    ENUM_BV_SAMPLE_CALIB_BEGIN    = 1,   //Begin calibration
    ENUM_BV_SAMPLE_CALIB_SETTING  = 2,   //Set calibration
    ENUM_BV_SAMPLE_CALIB_END      = 3    //End calibration
}BV_SAMPLE_CALIB_CMD_ENUM;

//Sample calibration
typedef struct tagNET_DVR_BV_SAMPLE_CALIBRATION
{
    DWORD   dwSize;
    DWORD   dwChannel;  //Channel No
    BYTE    byCommand;  //calibration command, see BV_SAMPLE_CALIB_CMD _ENUM
    BYTE    byRes1[3];
    NET_DVR_BV_SAMPLE_CALIB_PARAM_UNION uCalibParam; //calibration Param
    BYTE    byRes2[256] ;
}NET_DVR_BV_SAMPLE_CALIBRATION,*LPNET_DVR_BV_SAMPLE_CALIBRATION;

//Sample calibration Point Info
typedef struct tagNET_DVR_BV_SAMPLE_CALIB_CFG
{
    DWORD  dwSize;
    DWORD  dwCameraHeight; //Camera Height\A3\ACUnit:cm
    float  fPitchAngle;    //Camera Pitch Angle[0\A1\E3, 60\A1\E3],
    float  fInclineAngle;  //Camera Incline Angle[-20\A1\E3,20\A1\E3]
    NET_DVR_BV_SAMPLE_CALIB_POINT struCalibPoint[MAX_SAMPLE_NUM]; //Sample calibration
    BYTE  byRes[256];
}NET_DVR_BV_SAMPLE_CALIB_CFG,*LPNET_DVR_BV_SAMPLE_CALIB_CFG;

//Binocular image correction parameters
typedef struct tagNET_DVR_BINOC_RECTIFY_PARAM
{
    float   fCamInternalMatrix[3][3];  //camera intrinsic matrix
    float   fDistCoeffs[8];            //Lens distortion coefficient
    float   fRotateMatrix[3][3];       //After correction of the rotation matrix
    float   fProjectMatrix[3][4];      //After correction of the projection matrix
    BYTE    byRes[64];
}NET_DVR_BINOC_RECTIFY_PARAM, *LPNET_DVR_BINOC_RECTIFY_PARAM;

//Left and right camera calibration parameters
typedef struct _tagNET_DVR_BV_CORRECT_PARAM
{
    DWORD  dwSize;
    float  fReprojectMatrix[4][4];   //projection matrix
    NET_DVR_BINOC_RECTIFY_PARAM  struLCamParam; //left camera calibration parameters
    NET_DVR_BINOC_RECTIFY_PARAM  struRCamParam; //Right camera calibration parameters
    BYTE    byLensType;             //Camera Lens Type\A3\AC0-Unknow,1-8mm,2-12mm,3-16mm,4-25mm,5-35mm,6-50mm,7-4mm,8-6mm,9-2.0mm,10-2.8mm
    BYTE    byRes[255];
} NET_DVR_BV_CORRECT_PARAM,*LPNET_DVR_BV_CORRECT_PARAM;


//Output Video Type
typedef struct tagNET_DVR_OUTPUT_VIDEO_TYPE
{
    DWORD  dwSize;
    BYTE   byType;      //output video type, 1- mosaic, 2- depth map
    BYTE   byRes[63];
}NET_DVR_OUTPUT_VIDEO_TYPE,*LPNET_DVR_OUTPUT_VIDEO_TYPE;
/***********************68xxSeries of binocular 3D camera***********************/

#define MAX_CHECK_485CHAN        64

typedef struct tagNET_DVR_DEVICE_SELF_CHECK_STATE
{
    DWORD        dwSize;
    DWORD        dwRS485Chan[MAX_CHECK_485CHAN];
    DWORD        dwSensorChan[4];
    BYTE         byRes[32];
}NET_DVR_DEVICE_SELF_CHECK_STATE, *LPNET_DVR_DEVICE_SELF_CHECK_STATE;

//Complete Restore Ctrl
typedef struct tagNET_DVR_COMPLETE_RESTORE_INFO_
{
    DWORD   dwSize ; //struct size
    DWORD   dwChannel; //Channel No.
    BYTE    byRes[64];
}NET_DVR_COMPLETE_RESTORE_INFO, *LPNET_DVR_COMPLETE_RESTORE_INFO;

typedef struct  tagNET_DVR_UPLOAD_PICTURE_INFO
{
    DWORD       dwSize;
    DWORD        dwChannel;
    BYTE        byPictureType;
    BYTE         byRes1[3];
    NET_DVR_TIME_V30 struTime;
    char*        sPictureBuffer;
    DWORD        dwPictureLength;
    BYTE        byRes[128];
}NET_DVR_UPLOAD_PICTURE_INFO,*LPNET_DVR_UPLOAD_PICTURE_INFO;

#define  MAX_UPLOADFILE_URL_LEN      240
typedef struct  tagNET_DVR_UPLOAD_FILE_RET
{
    BYTE  sUrl[MAX_UPLOADFILE_URL_LEN] ;   //url
    BYTE  byRes[260];//
} NET_DVR_UPLOAD_FILE_RET,*LPNET_DVR_UPLOAD_FILE_RET;

#define MAX_FACE_PIC_NUM  30
typedef struct tagNET_DVR_FACE_EXTRA_INFO
{
    NET_VCA_RECT struVcaRect[MAX_FACE_PIC_NUM];
    BYTE     byRes[64];
}NET_DVR_FACE_EXTRA_INFO, *LPNET_DVR_FACE_EXTRA_INFO;
typedef union tagNET_DVR_PIC_EXTRA_INFO_UNION
{
    BYTE   byUnionLen[544];
    NET_DVR_FACE_EXTRA_INFO struFaceExtraInfo;
}NET_DVR_PIC_EXTRA_INFO_UNION, *LPNET_DVR_PIC_EXTRA_INFO_UNION;

typedef struct    tagNET_DVR_FIND_PICTURE_V40
{
    char    sFileName[PICTURE_NAME_LEN];
    NET_DVR_TIME struTime;
    DWORD dwFileSize;
    char    sCardNum[CARDNUM_LEN_V30];
    BYTE   byPlateColor ;
    BYTE   byVehicleLogo;
    BYTE   byFileType ;
    BYTE   byRecogResult ;
    char   sLicense[MAX_LICENSE_LEN/*16*/];
    BYTE   byEventSearchStatus;
    BYTE   byRes[75];
    NET_DVR_PIC_EXTRA_INFO_UNION  uPicExtraInfo;
}NET_DVR_FIND_PICTURE_V40,*LPNET_DVR_FIND_PICTURE_V40;

typedef struct tagNET_DVR_THUMBNAILS_COND
{
    DWORD  dwSize;             // Structure size
    NET_DVR_STREAM_INFO   struStreamInfo; //src Info
    BYTE   bySearchDataType;   // Find data type 0 - I frame data (CVR along the way, most 1 s 28 I frame), 1 - image data
    BYTE   byRes1[3];
    NET_DVR_TIME_V30  struStartTime;      //Start time of image search
    NET_DVR_TIME_V30  struStopTime;       // End time of image search
    DWORD  dwIntervalTime;  //Second time interval, unit, range: 0 ~ 24 * 60 * 60, if find over time is equal to find the start time, fill 0, fill in the other value is invalid
    BYTE   byRes2[512];
}NET_DVR_THUMBNAILS_COND, *LPNET_DVR_THUMBNAILS_COND;

typedef struct	tagNET_DVR_THUMBNAILS_RESULT   //Search results structure
{
    BYTE     byResultDataType;      // Find the result data type 0 - I frame data (CVR along the way, most 1 s 28 I frame), 1 - system header data, 2 - image data
    BYTE     byRes1[3];
    NET_DVR_TIME_SEARCH struTime;		//data time
    BYTE     byRes[252];
    DWORD   dwFileSize;			//data size
    char*     pBuffer;        		//data
}NET_DVR_THUMBNAILS_RESULT, *LPNET_DVR_THUMBNAILS_RESULT;

/*********************************IPC 5.2.2***************************************/

typedef struct tagNET_DVR_REGIONENTRANCE_REGION
{
    NET_VCA_POLYGON struRegion;//region range
    BYTE bySensitivity;        //sensitivity,[1-100]
    BYTE byDetectionTarget;    //Detection Target
    BYTE byRes[62];
}NET_DVR_REGIONENTRANCE_REGION, *LPNET_DVR_REGIONENTRANCE_REGION;

typedef    struct tagNET_DVR_REGION_ENTRANCE_DETECTION
{
    DWORD        dwSize;//struct size
    BYTE        byEnabled;  //enable,0- no,1- yes
    BYTE        byRes1[3];
    NET_DVR_REGIONENTRANCE_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_REGION_ENTRANCE_DETECTION,*LPNET_DVR_REGION_ENTRANCE_DETECTION;

typedef struct tagNET_DVR_SMART_REGION_COND
{
    DWORD dwSize;
    DWORD dwChannel;        //channel
    DWORD dwRegion;         //region id
}NET_DVR_SMART_REGION_COND, *LPNET_DVR_SMART_REGION_COND;

typedef struct tagNET_DVR_ENTRANCE_REGION
{
    NET_VCA_POLYGON struRegion;//region range
    BYTE bySensitivity;        //sensitivity,[1-100]
    BYTE byRes[63];
}NET_DVR_ENTRANCE_REGION, *LPNET_DVR_ENTRANCE_REGION;

typedef    struct tagNET_DVR_EVENT_TRIGGER
{
    DWORD        dwSize;//struct size
    NET_DVR_HANDLEEXCEPTION_V41 struHandleException;     //handle exception
    DWORD      dwRelRecordChan[MAX_CHANNUM_V40]; //record trigger channel,index from 0, invalid after 0xffffffff
    NET_DVR_PRESETCHAN_INFO struPresetChanInfo[MAX_CHANNUM_V40]; //preset info
    NET_DVR_CRUISECHAN_INFO struCruiseChanInfo[MAX_CHANNUM_V40]; //cruise info
    NET_DVR_PTZTRACKCHAN_INFO struPtzTrackInfo[MAX_CHANNUM_V40]; //track info
    BYTE        byRes2[256];
}NET_DVR_EVENT_TRIGGER,*LPNET_DVR_EVENT_TRIGGER;

typedef struct tagNET_DVR_DENSEFOGDETECTION_CFG
{
    DWORD dwSize;
    BYTE	byEnable;//enable
    BYTE   bySensitivity;  //sensitivity parameters,range from 0 to 100
    BYTE   byRes[258];
}NET_DVR_DENSEFOGDETECTION_CFG, *LPNET_DVR_DENSEFOGDETECTION_CFG;
/********************************IPC FFThe license plate  Start****************************/
typedef struct tagNET_DVR_FTPUPLOAD_PARAM
{
    char szRuleTypeItem[MAX_SINGLE_FTPPICNAME_LEN/*20*/];
    char szCameraName[MAX_CAMNAME_LEN/*32*/];
    BYTE byRes[64];
}NET_DVR_FTPUPLOAD_PARAM, *LPNET_DVR_FTPUPLOAD_PARAM;

//char szRuleTypeItem[MAX_SINGLE_FTPPICNAME_LEN/*20*/];
//Content is the fixed string   capture_time,plate_No,alarm_type,camera_name
//The array subscript said order

//char szCameraName[MAX_CAMNAME_LEN/*32*/];
//Depends on the situation of field represents the content of camera_name szRuleTypeItem
typedef struct tagNET_DVR_FTPUPLOADCFG
{
    DWORD dwSize;
    BYTE byEventType; //Event type, default, 0-1 - vehicle detection
    BYTE byMode; //Picture naming pattern, default, 0-1 - custom
    BYTE byRes[62];
    NET_DVR_FTPUPLOAD_PARAM  struCustomVehicle[MAX_FTPNAME_NUM/*12*/];
    BYTE byRes1[1024] ;
}NET_DVR_FTPUPLOADCFG, *LPNET_DVR_FTPUPLOADCFG;


/********************************IPC The license plate  End****************************/

typedef    struct tagNET_DVR_EVENT_SCHEDULE
{
    DWORD        dwSize;//struct size
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*arm time*/
    NET_DVR_SCHEDTIME struHolidayAlarmTime[MAX_TIMESEGMENT_V30]; /*holiday arm time*/
    BYTE        byRes[128];
}NET_DVR_EVENT_SCHEDULE,*LPNET_DVR_EVENT_SCHEDULE;
typedef struct  tagNET_DVR_ANR_ARMING_HOST
{
    DWORD   dwSize;//sizeof(NET_DVR_ANR_ ARMING_HOST)
    NET_DVR_IPADDR struANRArmingHostIpAddr; //Offline continuingly host IP address
    WORD    wANRAlarmHostPort; //Offline continuingly host their port
    BYTE     byANRAlarmType;//Continuingly without Internet connection type, 0 - SDK private continuingly without Internet connection, 1 - ehome continuingly without Internet connection
    BYTE     byConfirmMechanismEnabled;// Whether open the way to connect their confirmation mechanism, 0 to retain, 1 - there are no open 2 - open
    BYTE     byRes[512];
}NET_DVR_ANR_ARMING_HOST, *LPNET_DVR_ANR_ARMING_HOST;
typedef struct tagNET_DVR_REGIONEXITING_REGION
{
    NET_VCA_POLYGON struRegion;//region range
    BYTE bySensitivity;        //sensitivity,[1-100]
    BYTE byDetectionTarget;    //Detection Target
    BYTE byRes[62];             //
}NET_DVR_REGIONEXITING_REGION, *LPNET_DVR_REGIONEXITING_REGION;

typedef    struct tagNET_DVR_REGION_EXITING_DETECTION
{
    DWORD        dwSize;//struct size
    BYTE        byEnabled;  //enable,0- no,1- yes
    BYTE        byRes1[3];
    NET_DVR_REGIONEXITING_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_REGION_EXITING_DETECTION,*LPNET_DVR_REGION_EXITING_DETECTION;

typedef struct tagNET_DVR_LOITERING_REGION
{
    NET_VCA_POLYGON struRegion;//region range
    BYTE bySensitivity;        //sensitivity,[1-100]
    BYTE byTimeThreshold; //time threshold,[0-10],unit:s
    BYTE byRes[62];             //
}NET_DVR_LOITERING_REGION, *LPNET_DVR_LOITERING_REGION;

typedef    struct tagNET_DVR_LOITERING_DETECTION
{
    DWORD        dwSize;//region range
    BYTE        byEnabled;  //enable:0- no,1- yes
    BYTE        byRes1[3];
    NET_DVR_LOITERING_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_LOITERING_DETECTION,*LPNET_DVR_LOITERING_DETECTION;

typedef struct tagNET_DVR_GROUPDETECTION_REGION
{
    NET_VCA_POLYGON struRegion;//region range
    BYTE byObjectOccup; //occupation,[1-100]
    BYTE byRes[63];             //
}NET_DVR_GROUPDETECTION_REGION, *LPNET_DVR_GROUPDETECTION_REGION;

typedef    struct tagNET_DVR_GROUP_DETECTION
{
    DWORD        dwSize;//struct size
    BYTE        byEnabled;  //enable:0- no,1- yes
    BYTE        byRes1[3];
    NET_DVR_GROUPDETECTION_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_GROUP_DETECTION,*LPNET_DVR_GROUP_DETECTION;

typedef struct tagNET_DVR_RAPIDMOVE_REGION
{
    NET_VCA_POLYGON struRegion;//region range
    BYTE bySensitivity;        //sensitivity,[1-100]
    BYTE byDetectionTarget;    //Detection Target
    BYTE byRes[62];
}NET_DVR_RAPIDMOVE_REGION, *LPNET_DVR_RAPIDMOVE_REGION;

typedef    struct tagNET_DVR_RAPIDMOVE_DETECTION
{
    DWORD        dwSize;//struct size
    BYTE        byEnabled;  //enable,0- no,1- yes
    BYTE        byRes1[3];
    NET_DVR_RAPIDMOVE_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_RAPIDMOVE_DETECTION,*LPNET_DVR_RAPIDMOVE_DETECTION;

typedef struct tagNET_DVR_PARKING_REGION
{
    NET_VCA_POLYGON struRegion;//region range
    BYTE bySensitivity;        //sensitivity,[1-100]
    BYTE byTimeThreshold; //time threshold,[0-10],unit:s
    BYTE byRes[62];             //
}NET_DVR_PARKING_REGION, *LPNET_DVR_PARKING_REGION;

typedef    struct tagNET_DVR_PARKING_DETECTION
{
    DWORD        dwSize;//struct size
    BYTE        byEnabled;  //enable:0- no,1- yes
    BYTE        byRes1[3];
    NET_DVR_PARKING_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_PARKING_DETECTION,*LPNET_DVR_PARKING_DETECTION;

typedef struct tagNET_DVR_UNATTENDED_BAGGAGE_REGION
{
    NET_VCA_POLYGON struRegion;//region range
    BYTE bySensitivity;        //sensitivity,[1-100]
    BYTE byTimeThreshold; //time threshold,[0-10],unit:s
    WORD wTimeThreshold;//time threshold,[5-3600],unit:s
    BYTE byTimeThresholdMode;//(wo)0-byTimeThreshold  ,1-wTimeThreshold
    BYTE byRes[59];  //
}NET_DVR_UNATTENDED_BAGGAGE_REGION, *LPNET_DVR_UNATTENDED_BAGGAGE_REGION;

typedef    struct tagNET_DVR_UNATTENDED_BAGGAGE_DETECTION
{
    DWORD        dwSize;//struct size
    BYTE        byEnabled;  //enable:0- no,1- yes
    BYTE        byRes1[3];
    NET_DVR_UNATTENDED_BAGGAGE_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_UNATTENDED_BAGGAGE_DETECTION,*LPNET_DVR_UNATTENDED_BAGGAGE_DETECTION;

typedef struct tagNET_DVR_ATTENDED_BAGGAGE_REGION
{
    NET_VCA_POLYGON struRegion;//region range
    BYTE bySensitivity;        //sensitivity,[1-100]
    BYTE byTimeThreshold; //time threshold,[0-10],unit:s
    WORD wTimeThreshold;//time threshold,[5-3600],unit:s
    BYTE byTimeThresholdMode;//(wo)0-byTimeThreshold  ,1-wTimeThreshold
    BYTE byRes[59];  //
}NET_DVR_ATTENDED_BAGGAGE_REGION, *LPNET_DVR_ATTENDED_BAGGAGE_REGION;

typedef    struct tagNET_DVR_ATTENDED_BAGGAGE_DETECTION
{
    DWORD        dwSize;//struct size
    BYTE        byEnabled;  //enable:0- no,1- yes
    BYTE        byRes1[3];
    NET_DVR_ATTENDED_BAGGAGE_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_ATTENDED_BAGGAGE_DETECTION,*LPNET_DVR_ATTENDED_BAGGAGE_DETECTION;

typedef struct tagNET_DVR_REGION_CLIP_COND
{
    DWORD dwSize;
    DWORD dwChannel;        //channel
    DWORD dwStreamType;     //stream type:0- main stream,1- sub stream,2- third stream
    BYTE   byRes[8];
}NET_DVR_REGION_CLIP_COND, *LPNET_DVR_REGION_CLIP_COND;

typedef struct tagNET_DVR_REGION_CLIP_CFG
{
    DWORD        dwSize;//struct size
    BYTE        byEnabled;  //ebable:0- no,1- yes
    BYTE        byRes1[3];
    WORD      wResolutionWidth; //resolution width
    WORD      wResolutionHeight; //resolution height
    NET_VCA_POLYGON    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[64];
}NET_DVR_REGION_CLIP_CFG, *LPNET_DVR_REGION_CLIP_CFG;

#define MAX_DIALNUM_LENGTH  32
typedef struct tagNET_DVR_WIRELESSDIAL_CFG
{
    DWORD        dwSize;//struct size
    BYTE        byEnabled;  //enable wireless dial:0-no,1- yes
    BYTE       byDialMode; // 0-Auto\A1\A21-Manual,default manual,set dial schedule\A1\A2offline time\A1\A2manual dial only manual
    BYTE       byNetworkMode; //0-auto,1-4GFirst,2-3GFirst,3-manualto2G,4-manualto3G,5-manualto4G,6-cableFirst
    BYTE        byRes1;
    BYTE       byDialNum[MAX_DIALNUM_LENGTH]; //dial number
    BYTE       byUserName[NAME_LEN]; //user name
    BYTE       byPassword[NAME_LEN]; //password
    BYTE       byAPNName[NAME_LEN];  //APN
    BYTE       byUIMCardNum[NAME_LEN];  //UIM card num
    BYTE       byVerifProtocol;  // 0-Auto,1-CHAP,2-PAP
    BYTE       byRes2;
    WORD      wMTU; //MTU
    DWORD      dwOffineTime;  //off line time,30-65535,unit:s,valid only manual
    BYTE        byRes3[64];
}NET_DVR_WIRELESSDIAL_CFG, *LPNET_DVR_WIRELESSDIAL_CFG;

typedef    struct tagNET_DVR_WIRELESSDIAL_SCHEDULE
{
    DWORD        dwSize;//struct size
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*arm time*/
    BYTE        byRes[160];
}NET_DVR_WIRELESSDIAL_SCHEDULE,*LPNET_DVR_WIRELESSDIAL_SCHEDULE;

#define MAX_LENGTH_32   32
typedef    struct tagNET_DVR_WIRELESSDIAL_STATUS
{
    DWORD        dwSize;//struct size
    BYTE        byRealtimeMode[MAX_LENGTH_32]; //realtime mode(CDMA 1x\A1\A2EVDO\A1\A2HYBRID\A1\A2GSM\A1\A2GPRS\A1\A2EDGE\A1\A2WCDMA\A1\A2HSDPA\A1\A2HSUPA\A1\A2HSPA\A1\A2TDSCDMA\A1\A2TD-LTE\A1\A2FDD-LTE)
    BYTE        byUIMStatus[MAX_LENGTH_32]; //UIM status(UNKNOWN,VALID,NOVALID,ROAM,NOEXIST)
    DWORD       dwSignalQuality; //signal quality,1-100
    BYTE        byDialStatus[MAX_LENGTH_32]; //dial status
    NET_DVR_IPADDR    struIpAddr;  //IP address
    NET_DVR_IPADDR    struIPMask;  //mask address
    NET_DVR_IPADDR    struGatewayIPMask;  //gateway address
    NET_DVR_IPADDR    struDnsServerIpAddr; //DNS address
    BYTE        byRes[256];
}NET_DVR_WIRELESSDIAL_STATUS,*LPNET_DVR_WIRELESSDIAL_STATUS;

/****************************IPC 5.2.6********************************************/
typedef    struct tagNET_DVR_LITESTORAGE
{
    DWORD        dwSize;
    BYTE        byEnable; /*Enable 0-disable,1-enable*/
    BYTE        byStorageTime;/*Storage Time 1-30 */
    BYTE        byLevel; //Level Param\A3\AC0-invalid Value\A3\A8Res\A3\A9\A3\AC1-low, 2-medium, 3-high\A3\BB
    BYTE        byRes;
    float       fCapacity;//Capacity  ro
    BYTE        byDefLowStorageTime;//  ro
    BYTE        byDefMediumStorageTime; //  ro
    BYTE        byDefHighStorageTime; //   ro
    BYTE        byRes1[61];
}NET_DVR_LITESTORAGE,*LPNET_DVR_LITESTORAGE;

typedef struct tagNET_DVR_CALIBRATION
{
    DWORD            dwSize;
    NET_VCA_POLYGON  struRegion;//Region
    BYTE        byRes[64];
}NET_DVR_CALIBRATION,*LPNET_DVR_CALIBRATION;
/****************************IPC 5.2.6********************************************/

typedef    struct tagNET_DVR_WIRELESSDIAL_CONNECT
{
    DWORD        dwSize;//struct size
    DWORD       dwInterface; //interface id,1,2\A1\AD\A1\AD
    BYTE        byEnableConnect; //enable connect,0-disconnect,1-connect
    BYTE        byRes[255];
}NET_DVR_WIRELESSDIAL_CONNECT_PARAM,*LPNET_DVR_WIRELESSDIAL_CONNECT_PARAM;

typedef    struct    tagNET_DVR_STD_CONFIG
{
    void*        lpCondBuffer;        //[in]condition parameter,eg.channel
    DWORD        dwCondSize;            //[in] the size of condition parameter
    void*        lpInBuffer;            //[in]input parameter(struct)
    DWORD        dwInSize;            //[in] the size of input parameter
    void*        lpOutBuffer;        //[out]output parameter(XML format)
    DWORD        dwOutSize;            //[in]  the size of output parameter
    void*        lpStatusBuffer;        //[out]status parameter(XML format)
    DWORD        dwStatusSize;        //[in] the size of status parameter
    void*       lpXmlBuffer;    //[in/out]
    DWORD       dwXmlSize;      //[in/out]
    BYTE        byDataType;     //[in]
    BYTE        byRes[23];
}NET_DVR_STD_CONFIG,*LPNET_DVR_STD_CONFIG;

typedef    struct    tagNET_DVR_STD_ABILITY
{
    void*        lpCondBuffer;    //[in]condition parameter,eg.channel
    DWORD        dwCondSize;        //[in] the size of condition parameter
    void*        lpOutBuffer;    //[out]output parameter(XML format)
    DWORD        dwOutSize;        //[in] the size of output parameter
    void*        lpStatusBuffer;    //[out]status parameter(XML format)
    DWORD        dwStatusSize;    //[in] the size of status parameter
    DWORD        dwRetSize;        //[out]the returned data size,the size of output parameter or status parameter
    BYTE        byRes[32];
}NET_DVR_STD_ABILITY,*LPNET_DVR_STD_ABILITY;

typedef struct tagNET_DVR_STD_CONTROL
{
    void*        lpCondBuffer;    //[in]condition parameter,eg.channel
    DWORD        dwCondSize;        //[in] the size of condition parameter
    void*        lpStatusBuffer;    //[out]status parameter(XML format)
    DWORD        dwStatusSize;    //[in] the size of status parameter
    void*       lpXmlBuffer;    //[in/out]
    DWORD       dwXmlSize;      //[in/out]
    BYTE        byDataType;     //[in]
    BYTE        byRes[55];
}NET_DVR_STD_CONTROL, *LPNET_DVR_STD_CONTROL;
/*********************************IPC 5.2.2***************************************/
typedef struct tagNET_DVR_XML_CONFIG_INPUT
{
    DWORD   dwSize;
    void*    lpRequestUrl;
    DWORD    dwRequestUrlLen;
    void*    lpInBuffer;
    DWORD    dwInBufferSize;
    DWORD   dwRecvTimeOut;
    BYTE    byForceEncrpt;
    BYTE    byRes[31];
}NET_DVR_XML_CONFIG_INPUT, *LPNET_DVR_XML_CONFIG_INPUT;

typedef struct tagNET_DVR_XML_CONFIG_OUTPUT
{
    DWORD   dwSize;
    void*    lpOutBuffer;
    DWORD    dwOutBufferSize;
    DWORD   dwReturnedXMLSize;
    void*    lpStatusBuffer;
    DWORD    dwStatusSize;
    BYTE    byRes[32];
}NET_DVR_XML_CONFIG_OUTPUT, *LPNET_DVR_XML_CONFIG_OUTPUT;
//Entrance guard  V1.0
typedef struct tagNET_DVR_SIMPLE_DAYTIME
{
    BYTE byHour; //hour
    BYTE byMinute; //minute
    BYTE bySecond; //second
    BYTE byRes;
}NET_DVR_SIMPLE_DAYTIME, *LPNET_DVR_SIMPLE_DAYTIME;

typedef struct tagNET_DVR_TIME_SEGMENT
{
    NET_DVR_SIMPLE_DAYTIME struBeginTime; //begin time
    NET_DVR_SIMPLE_DAYTIME struEndTime;   //end time
}NET_DVR_TIME_SEGMENT, *LPNET_DVR_TIME_SEGMENT;

typedef struct tagNET_DVR_SINGLE_PLAN_SEGMENT
{
    BYTE byEnable; //whether to enable, 1-enable, 0-disable
    BYTE byDoorStatus; //door status,0-invaild, 1-always open, 2-always close, 3-ordinary status(used by door plan)
    BYTE byVerifyMode; //verify method, 0-invaild, 1-swipe card, 2-swipe card +password(used by card verify ) 3-swipe card(used by card verify) 4-swipe card or password(used by card verify)
    //5-fingerprint, 6-fingerprint and passwd, 7-fingerprint or swipe card, 8-fingerprint and swipe card, 9-fingerprint and passwd and swipe card
    BYTE byRes[5];
    NET_DVR_TIME_SEGMENT struTimeSegment; //time segment parameter
}NET_DVR_SINGLE_PLAN_SEGMENT, *LPNET_DVR_SINGLE_PLAN_SEGMENT;

typedef struct tagNET_DVR_WEEK_PLAN_CFG
{
    DWORD dwSize;
    BYTE byEnable;  //whether to enable, 1-enable, 0-disable
    BYTE byRes1[3];
    NET_DVR_SINGLE_PLAN_SEGMENT struPlanCfg[MAX_DAYS][MAX_TIMESEGMENT_V30]; //week plan parameter
    BYTE byRes2[16];
}NET_DVR_WEEK_PLAN_CFG, *LPNET_DVR_WEEK_PLAN_CFG;

typedef struct tagNET_DVR_HOLIDAY_PLAN_CFG
{
    DWORD dwSize;
    BYTE byEnable; //whether to enable, 1-enable, 0-disable
    BYTE byRes1[3];
    NET_DVR_DATE struBeginDate; //holiday begin date
    NET_DVR_DATE struEndDate; //holiday end date
    NET_DVR_SINGLE_PLAN_SEGMENT struPlanCfg[MAX_TIMESEGMENT_V30]; //time segment parameter
    BYTE byRes2[16];
}NET_DVR_HOLIDAY_PLAN_CFG, *LPNET_DVR_HOLIDAY_PLAN_CFG;

typedef struct tagNET_DVR_HOLIDAY_PLAN_COND
{
    DWORD dwSize;
    DWORD dwHolidayPlanNumber; //Holiday plan number
    WORD wLocalControllerID; //On the controller serial number [1, 64]
    BYTE byRes[106];
}NET_DVR_HOLIDAY_PLAN_COND, *LPNET_DVR_HOLIDAY_PLAN_COND;

typedef struct tagNET_DVR_WEEK_PLAN_COND
{
    DWORD dwSize;
    DWORD dwWeekPlanNumber; //Week plan number
    WORD wLocalControllerID; //On the controller serial number [1, 64]
    BYTE byRes[106];
}NET_DVR_WEEK_PLAN_COND, *LPNET_DVR_WEEK_PLAN_COND;

typedef struct tagNET_DVR_HOLIDAY_GROUP_CFG
{
    DWORD dwSize;
    BYTE byEnable; //whether to enable, 1-enable, 0-disable
    BYTE byRes1[3];
    BYTE byGroupName[HOLIDAY_GROUP_NAME_LEN]; //holiday group name
    DWORD dwHolidayPlanNo[MAX_HOLIDAY_PLAN_NUM]; //holiday plan No. fill in from the front side, invalid when meet zero.
    BYTE byRes2[32];
}NET_DVR_HOLIDAY_GROUP_CFG, *LPNET_DVR_HOLIDAY_GROUP_CFG;

typedef struct tagNET_DVR_HOLIDAY_GROUP_COND
{
    DWORD dwSize;
    DWORD dwHolidayGroupNumber; //Holiday group number
    WORD wLocalControllerID; //On the controller serial number [1, 64]
    BYTE byRes[106];
}NET_DVR_HOLIDAY_GROUP_COND, *LPNET_DVR_HOLIDAY_GROUP_COND;

typedef struct tagNET_DVR_PLAN_TEMPLATE
{
    DWORD dwSize;
    BYTE byEnable; //whether to enable, 1-enable, 0-disable
    BYTE byRes1[3];
    BYTE byTemplateName[TEMPLATE_NAME_LEN]; //template name
    DWORD dwWeekPlanNo; //week plan no. 0 invalid
    DWORD dwHolidayGroupNo[MAX_HOLIDAY_GROUP_NUM]; //holiday group. fill in from the front side, invalid when meet zero.
    BYTE byRes2[32];
}NET_DVR_PLAN_TEMPLATE, *LPNET_DVR_PLAN_TEMPLATE;

typedef struct tagNET_DVR_PLAN_TEMPLATE_COND
{
    DWORD dwSize;
    DWORD dwPlanTemplateNumber; //Plan template number, starting from 1, the maximum value from the entrance guard capability sets
    WORD wLocalControllerID; //On the controller serial number[1,64], 0 is invalid
    BYTE byRes[106];
}NET_DVR_PLAN_TEMPLATE_COND, *LPNET_DVR_PLAN_TEMPLATE_COND;

#define UNLOCK_PASSWORD_LEN                        8 //unlock password len
#define LOCAL_CONTROLLER_NAME_LEN                  32//On the controller name length
typedef struct tagNET_DVR_DOOR_CFG
{
    DWORD dwSize;
    BYTE byDoorName[DOOR_NAME_LEN]; //door name
    BYTE byMagneticType; //magnetic type, 0-always close 1-always open
    BYTE byOpenButtonType; //open button type,  0-always close 1-always open
    BYTE byOpenDuration; //open duration time, 1-255s
    BYTE byDisabledOpenDuration; //disable open duration , 1-255s
    BYTE byMagneticAlarmTimeout; //magnetic alarm time out , 0-255s\A3\AC0 means not to alarm
    BYTE byEnableDoorLock; //whether to enable door lock, 0-disable, 1-enable
    BYTE byEnableLeaderCard; //whether to enable leader card , 0-disable, 1-enable
    BYTE byLeaderCardMode; //First card mode, 0 - first card function is not enabled, and 1 - the first card normally open mode, 2 - the first card authorization mode (using this field, the byEnableLeaderCard is invalid )
    DWORD dwLeaderCardOpenDuration; //leader card open duration 1-1440minNET_DVR_CARD_CFG
    BYTE byStressPassword[STRESS_PASSWORD_LEN]; //stress ppassword
    BYTE bySuperPassword[SUPER_PASSWORD_LEN]; //super password
    BYTE byUnlockPassword[UNLOCK_PASSWORD_LEN]; //remove code
    BYTE byUseLocalController; //Read-only, whether the connection on the local controller, 0 - no, 1 - yes
    BYTE byRes1;
    WORD wLocalControllerID; //Read-only, on-site controller serial number, 1-64, 0 on behalf of unregistered
    WORD wLocalControllerDoorNumber; //Read-only, on-site controller door number, 1-4, 0 represents the unregistered
    WORD wLocalControllerStatus; //Read-only, on-site controller online status: 0 - offline, 1 - online, 2 - loop of RS485 serial port 1 on 1, 3 - loop of RS485 serial port 2 on 2, 4 - loop of RS485 serial port 1, 5 - loop of RS485 serial port 2, 6 - loop 3 of RS485 serial port 1, 7 - the loop on the RS485 serial port on the 3 4 2, 8 - loop on the RS485 serial port 1, 9 - loop 4 of RS485 serial port 2 (read-only)
    BYTE byLockInputCheck; //Whether to enable the door input detection (1 byte, 0 is not enabled, 1 is enabled, is not enabled by default)
    BYTE byLockInputType; //Door lock input type
    BYTE byDoorTerminalMode; //Gate terminal working mode
    BYTE byOpenButton; //Whether to enable the open button
    BYTE byRes2[44];
}NET_DVR_DOOR_CFG, *LPNET_DVR_DOOR_CFG;

typedef struct tagNET_DVR_DOOR_STATUS_PLAN
{
    DWORD dwSize;
    DWORD dwTemplateNo; //plan template No. 0 means cancel relation,resolve default status(ordinary status)
    BYTE byRes[64];
}NET_DVR_DOOR_STATUS_PLAN, *LPNET_DVR_DOOR_STATUS_PLAN;

typedef struct tagNET_DVR_CARD_READER_PLAN
{
    DWORD dwSize;
    DWORD dwTemplateNo; //plan template No. 0 means cancel relation,resolve default status(swipe card)
    BYTE byRes[64];
}NET_DVR_CARD_READER_PLAN, *LPNET_DVR_CARD_READER_PLAN;

typedef struct tagNET_DVR_VALID_PERIOD_CFG
{
    BYTE byEnable; //whether to enable , 0-disable 1-enable
    BYTE byRes1[3];
    NET_DVR_TIME_EX struBeginTime; //valid begin time
    NET_DVR_TIME_EX struEndTime; //valid end time
    BYTE byRes2[32];
}NET_DVR_VALID_PERIOD_CFG, *LPNET_DVR_VALID_PERIOD_CFG;

typedef struct _tagNET_DVR_GROUP_CFG
{
    DWORD dwSize;
    BYTE byEnable; //whether to enable , 0-disable 1-enable
    BYTE byRes1[3];
    NET_DVR_VALID_PERIOD_CFG struValidPeriodCfg; //group valid parameter
    BYTE byGroupName[GROUP_NAME_LEN]; //group name
    BYTE byRes2[32];
}NET_DVR_GROUP_CFG, *LPNET_DVR_GROUP_CFG;

typedef struct tagNET_DVR_GROUP_COMBINATION_INFO
{
    BYTE byEnable; //whether to use group combination, 0-disable 1-enable
    BYTE byMemberNum; //the number of member can swipe
    BYTE bySequenceNo; //group swipe sequence No.
    BYTE byRes;
    DWORD dwGroupNo;  //group No,0xffffffff means remote control\A3\AC0xfffffffe means super password
}NET_DVR_GROUP_COMBINATION_INFO, *LPNET_DVR_GROUP_COMBINATION_INFO;

typedef struct tagNET_DVR_MULTI_CARD_GROUP_CFG
{
    BYTE byEnable; //whether to use mutil card group, 0-disable 1-enable
    BYTE byEnableOfflineVerifyMode; //whether to use host offline to verify , 0-disable 1-enable
    BYTE byRes1[2];
    DWORD dwTemplateNo; //use plan template No. with  mutil card function
    NET_DVR_GROUP_COMBINATION_INFO struGroupCombination[GROUP_COMBINATION_NUM]; //group combination
}NET_DVR_MULTI_CARD_GROUP_CFG, *LPNET_DVR_MULTI_CARD_GROUP_CFG;

typedef struct tagNET_DVR_MULTI_CARD_CFG
{
    DWORD dwSize;
    BYTE byEnable; //whether to use mutil card group, 0-disable 1-enable
    BYTE bySwipeIntervalTimeout; //swipe interval time out , 1-255s default 10s
    BYTE byRes1[2];
    NET_DVR_MULTI_CARD_GROUP_CFG struGroupCfg[MULTI_CARD_GROUP_NUM]; //group swipe parameter
    BYTE byRes2[32];
}NET_DVR_MULTI_CARD_CFG, *LPNET_DVR_MULTI_CARD_CFG;

#define CARD_PARAM_CARD_VALID       0x00000001 //card valid parameter
#define CARD_PARAM_VALID            0x00000002  //valid period parameter
#define CARD_PARAM_CARD_TYPE        0x00000004  //card type parameter
#define CARD_PARAM_DOOR_RIGHT       0x00000008  //door right parameter
#define CARD_PARAM_LEADER_CARD      0x00000010  //leader card parameter
#define CARD_PARAM_SWIPE_NUM        0x00000020  //max swipe time parameter
#define CARD_PARAM_GROUP            0x00000040  //belong group parameter
#define CARD_PARAM_PASSWORD         0x00000080  //card password parameter
#define CARD_PARAM_RIGHT_PLAN       0x00000100  //card right plan parameter
#define CARD_PARAM_SWIPED_NUM       0x00000200  //has swiped card time parameter

typedef struct tagNET_DVR_CARD_CFG
{
    DWORD dwSize;
    DWORD dwModifyParamType;
    // the card parameter need to modify, valid when set card parameter, use by bit, every bit means a kind of parameter, 1 means modify, 0 means not
    // #define CARD_PARAM_CARD_VALID       0x00000001 //card valid parameter
    // #define CARD_PARAM_VALID            0x00000002  //valid period parameter
    // #define CARD_PARAM_CARD_TYPE        0x00000004  //card type parameter
    // #define CARD_PARAM_DOOR_RIGHT       0x00000008  //door right parameter
    // #define CARD_PARAM_LEADER_CARD      0x00000010  //leader card parameter
    // #define CARD_PARAM_SWIPE_NUM        0x00000020  //max swipe time parameter
    // #define CARD_PARAM_GROUP            0x00000040  //belong group parameter
    // #define CARD_PARAM_PASSWORD         0x00000080  //card password parameter
    // #define CARD_PARAM_RIGHT_PLAN       0x00000100  //card right plan parameter
    // #define CARD_PARAM_SWIPED_NUM       0x00000200  //has swiped card time parameter
    BYTE byCardNo[ACS_CARD_NO_LEN]; //card No
    BYTE byCardValid; //whether is a vaild card\A3\AC0-invalid\A3\AC1-valid(use to delete card, 0 means delete card when setting, it will be 1 when getting)
    BYTE byCardType; //card type \A3\AC1-ordinary card\A3\AC2-disable card\A3\AC3-black list card, 4-patrol card\A3\AC5-stress card\A3\AC6-super card\A3\AC7-client card\A3\AC8-remove card, default ordinary card
    BYTE byLeaderCard; //whether is leader card, 0-no, 1-yes
    BYTE byRes1;
    DWORD dwDoorRight; //door right , accord to bit, 1-has right 0-no right, from low bit to high bit means door 1-N have right
    NET_DVR_VALID_PERIOD_CFG struValid; //valid period parameter
    DWORD dwBelongGroup; //belong group , according to bit, 1-belong 0-not belong, from low bit to high bit means belong group 1-N
    BYTE byCardPassword[CARD_PASSWORD_LEN]; //card password
    BYTE byCardRightPlan[MAX_DOOR_NUM][MAX_CARD_RIGHT_PLAN_NUM]; //card right plan, value is from plan template No. use or method when same door has different plan template
    DWORD dwMaxSwipeTime; //max card time, 0 means infinite time
    DWORD dwSwipeTime; //has swiped card
    WORD wRoomNumber;  //room number
    SHORT wFloorNumber;   //floor number
    BYTE byRes2[20];
}NET_DVR_CARD_CFG, *LPNET_DVR_CARD_CFG;

typedef struct _NET_DVR_CARD_CFG_COND
{
    DWORD dwSize;
    DWORD dwCardNum; //card number, 0xffffffff means to get all card information when getting
    BYTE  byCheckCardNo; //whether to verify card No. 0-not to verify, 1-verify
    BYTE           byRes1[3];
    WORD wLocalControllerID; //On-site controller serial number, said to the local controller issued offline card parameters, 0 is access control host
    BYTE  byRes[26];
}NET_DVR_CARD_CFG_COND, *LPNET_DVR_CARD_CFG_COND;

typedef struct _NET_DVR_CARD_CFG_SEND_DATA
{
    DWORD dwSize;
    BYTE byCardNo[ACS_CARD_NO_LEN]; //card No
    BYTE byRes[16];
}NET_DVR_CARD_CFG_SEND_DATA, *LPNET_DVR_CARD_CFG_SEND_DATA;


typedef struct tagNET_DVR_CARD_USER_INFO_CFG
{
    DWORD dwSize;
    BYTE sUsername[NAME_LEN]; //user name
    BYTE byRes2[256];         //byRes2[0]--user num
}NET_DVR_CARD_USER_INFO_CFG, *LPNET_DVR_CARD_USER_INFO_CFG;

#define ACS_PARAM_DOOR_STATUS_WEEK_PLAN        0x00000001 //door status week plan
#define ACS_PARAM_VERIFY_WEEK_PALN             0x00000002 //card reader verify week plan
#define ACS_PARAM_CARD_RIGHT_WEEK_PLAN         0x00000004 //card right week plan
#define ACS_PARAM_DOOR_STATUS_HOLIDAY_PLAN     0x00000008 //door status holiday plan
#define ACS_PARAM_VERIFY_HOLIDAY_PALN          0x00000010 //card reader verify holiday plan
#define ACS_PARAM_CARD_RIGHT_HOLIDAY_PLAN      0x00000020 //card right holiday plan
#define ACS_PARAM_DOOR_STATUS_HOLIDAY_GROUP    0x00000040 //door status holiday group
#define ACS_PARAM_VERIFY_HOLIDAY_GROUP         0x00000080 //card reader verify holiday group
#define ACS_PARAM_CARD_RIGHT_HOLIDAY_GROUP     0x00000100 //card right holiday group
#define ACS_PARAM_DOOR_STATUS_PLAN_TEMPLATE    0x00000200 //door status plan template
#define ACS_PARAM_VERIFY_PALN_TEMPLATE         0x00000400 //card reader verify plan template
#define ACS_PARAM_CARD_RIGHT_PALN_TEMPLATE     0x00000800 //card right plan template
#define ACS_PARAM_CARD                         0x00001000 //card parameter
#define ACS_PARAM_GROUP                        0x00002000 //group parameter
#define ACS_PARAM_ANTI_SNEAK_CFG               0x00004000 //anti sneak config
#define ACS_PAPAM_EVENT_CARD_LINKAGE           0x00008000 //event card linkage
#define ACS_PAPAM_CARD_PASSWD_CFG              0x00010000 //card passwd open door parameter
#define ACS_PARAM_PERSON_STATISTICS_CFG           0x00020000 //The number of statistical parameters

typedef struct tagNET_DVR_ACS_PARAM_TYPE
{
    DWORD dwSize;
    DWORD dwParamType; //parameter type , according to bit
    // #define ACS_PARAM_DOOR_STATUS_WEEK_PLAN       0x00000001 //door status week plan
    // #define ACS_PARAM_VERIFY_WEEK_PALN             0x00000002 //card reader verify week plan
    // #define ACS_PARAM_CARD_RIGHT_WEEK_PLAN      0x00000004 //card right week plan
    // #define ACS_PARAM_DOOR_STATUS_HOLIDAY_PLAN 0x00000008 //door status holiday plan
    // #define ACS_PARAM_VERIFY_HOLIDAY_PALN        0x00000010 //card reader verify holiday plan
    // #define ACS_PARAM_CARD_RIGHT_HOLIDAY_PLAN   0x00000020 //card right holiday plan
    // #define ACS_PARAM_DOOR_STATUS_HOLIDAY_GROUP  0x00000040 //door status holiday group
    // #define ACS_PARAM_VERIFY_HOLIDAY_GROUP 0x00000080 //card reader verify holiday group
    // #define ACS_PARAM_CARD_RIGHT_HOLIDAY_GROUP   0x00000100 //card right holiday group
    // #define ACS_PARAM_DOOR_STATUS_PLAN_TEMPLATE 0x00000200 //door status plan template
    // #define ACS_PARAM_VERIFY_PALN_TEMPLATE 0x00000400//card reader verify plan template
    // #define ACS_PARAM_CARD_RIGHT_PALN_TEMPLATE  0x00000800 //card right plan template
    // #define ACS_PARAM_CARD                         0x00001000 //card parameter
    // #define ACS_PARAM_GROUP                        0x00002000 //group parameter
    // #define ACS_PARAM_ANTI_SNEAK_CFG              0x00004000 //anti sneak config
    //#define ACS_PAPAM_EVENT_CARD_LINKAGE           0x00008000 //event card linkage
    //#define ACS_PAPAM_CARD_PASSWD_CFG              0x00010000 //card passwd open door parameter
    //#define ACS_PARAM_PERSON_STATISTICS_CFG           0x00020000 //The number of statistical parameters
    WORD wLocalControllerID; //controller serial number [1,64],0 represent entrance guard host
    BYTE byRes[30];
}NET_DVR_ACS_PARAM_TYPE, *LPNET_DVR_ACS_PARAM_TYPE;

typedef struct tagNET_DVR_ANTI_SNEAK_CFG
{
    DWORD dwSize;
    BYTE byEnable; //whether to use anti sneak function, 1-enable, 0-disable
    BYTE byRes1[3];
    DWORD dwStartCardReaderNo; //anti sneak card reader No.
    BYTE byRes2[64];
}NET_DVR_ANTI_SNEAK_CFG, *LPNET_DVR_ANTI_SNEAK_CFG;

typedef struct tagNET_DVR_CARD_READER_ANTI_SNEAK_CFG
{
    DWORD dwSize;
    BYTE byEnable;  //whether to join in anti sneak path. 1-join  0-not join in
    BYTE byRes1[3];
    DWORD dwFollowUpCardReader[MAX_SNEAK_PATH_NODE]; //follow up card reader No, zero means don't care the anti sneak card reader No
    BYTE byRes2[32];
}NET_DVR_CARD_READER_ANTI_SNEAK_CFG, *LPNET_DVR_CARD_READER_ANTI_SNEAK_CFG;

typedef struct tagNET_DVR_PHONE_DOOR_RIGHT_CFG
{
    DWORD   dwSize;
    BYTE    byOpenRight[MAX_DOOR_NUM_256];         //by bit\A3\AC0-can\A3\AC1-can not
    BYTE    byCloseRight[MAX_DOOR_NUM_256];        //by bit\A3\AC0-can\A3\AC1-can not
    BYTE    byNormalOpenRight[MAX_DOOR_NUM_256];   //by bit\A3\AC0-can\A3\AC1-can not
    BYTE    byNormalCloseRight[MAX_DOOR_NUM_256];  //by bit\A3\AC0-can\A3\AC1-can not
    BYTE    byArmRight[MAX_ALARMHOST_ALARMIN_NUM];          //by bit\A3\AC0-can\A3\AC1-can not
    BYTE    byDisarmRight[MAX_ALARMHOST_ALARMIN_NUM];       //by bit\A3\AC0-can\A3\AC1-can not
    BYTE    byRes[256];
}NET_DVR_PHONE_DOOR_RIGHT_CFG,*LPNET_DVR_PHONE_DOOR_RIGHT_CFG;

typedef struct tagNET_DVR_MULTI_DOOR_INTERLOCK_CFG
{
    DWORD dwSize;
    BYTE byEnable; //whether to use multi door interlock, 1-enable 0-disable
    BYTE byRes1[3];
    DWORD dwMultiDoorGroup[MAX_MULTI_DOOR_INTERLOCK_GROUP][MAX_INTER_LOCK_DOOR_NUM]; //mutil door interlock parameter, fill in with door No.
    BYTE byRes2[64];
}NET_DVR_MULTI_DOOR_INTERLOCK_CFG, *LPNET_DVR_MULTI_DOOR_INTERLOCK_CFG;

typedef struct tagNET_DVR_CARD_READER_CFG
{
    DWORD dwSize;
    BYTE byEnable; //whether to enable, 1-enable, 0-disable
    BYTE byCardReaderType; //card reader type,1-DS-K110XM/MK/C/CK\A3\AC2-DS-K192AM/AMP\A3\AC3-DS-K192BM/BMP\A3\AC4-DS-K182AM/AMP\A3\AC5-DS-K182BM/BMP\A3\AC6-DS-K182AMF/ACF\A3\AC7-wiegand or 485 not online,8- DS-K1101M/MK\A3\AC9- DS-K1101C/CK\A3\AC10- DS-K1102M/MK/M-A
    //11- DS-K1102C/CK\A3\AC12- DS-K1103M/MK\A3\AC13- DS-K1103C/CK\A3\AC14- DS-K1104M/MK\A3\AC15- DS-K1104C/CK\A3\AC16- DS-K1102S/SK/S-A\A3\AC17- DS-K1102G/GK\A3\AC18- DS-K1100S-B\A3\AC19- DS-K1102EM/EMK\A3\AC20- DS-K1102E/EK\A3\AC
    //21- DS-K1200EF\A3\AC22- DS-K1200MF\A3\AC23- DS-K1200CF\A3\AC24- DS-K1300EF\A3\AC25- DS-K1300MF\A3\AC26- DS-K1300CF\A3\AC27- DS-K1105E\A3\AC28- DS-K1105M\A3\AC29- DS-K1105C\A3\AC30- DS-K182AMF\A3\AC31- DS-K196AMF\A3\AC32-DS-K194AMP
    //33-DS-K1T200EF/EF-C/MF/MF-C/CF/CF-C,34-DS-K1T300EF/EF-C/MF/MF-C/CF/CF-C\A3\AC35-DS-K1T105E/E-C/M/M-C/C/C-C\A3\AC36-DS-K1T803F/MF/SF/EF\A3\AC37-DS-K1A801F/MF/SF/EF,38-DS-K1107M/MK,39-DS-K1107E/EK,
    //40-DS-K1107S/SK,41-DS-K1108M/MK,42-DS-K1108E/EK,43-DS-K1108S/SK,44-DS-K1200F,45-DS-K1S110-I,46-DS-K1T200M-PG/PGC,47-DS-K1T200M-PZ/PZC,48-DS-K1109H
    BYTE byOkLedPolarity; //OK LED polarity\A3\AC0-negative\A3\AC1-positive
    BYTE byErrorLedPolarity; //Error LED polarity\A3\AC0-negative\A3\AC1-positive
    BYTE byBuzzerPolarity; //buzzer polarity\A3\AC0-negative\A3\AC1-positive
    BYTE bySwipeInterval; //swipe interval, unit: second
    BYTE byPressTimeout;  //press time out, unit:second
    BYTE byEnableFailAlarm; //whether to enable fail alarm, 0-disable 1-enable
    BYTE byMaxReadCardFailNum; //max reader card fail time
    BYTE byEnableTamperCheck;  //whether to support tamper check, 0-disable \A3\AC1-enable
    BYTE byOfflineCheckTime;  // offline check time, Uint second
    BYTE byFingerPrintCheckLevel;   //fingerprint check lever\A3\AC1-1/10\A3\AC2-1/100\A3\AC3-1/1000\A3\AC4-1/10000\A3\AC5-1/100000\A3\AC6-1/1000000\A3\AC7-1/10000000\A3\AC8-1/100000000\A3\AC9-3/100\A3\AC10-3/1000\A3\AC11-3/10000\A3\AC12-3/100000\A3\AC13-3/1000000\A3\AC14-3/10000000\A3\AC15-3/100000000\A3\AC16-Automatic Normal,17-Automatic Secure,18-Automatic More Secure
    BYTE byUseLocalController; //Read-only, whether the connection on the local controller, 0 - no, 1 - yes
    BYTE byRes1;
    WORD wLocalControllerID; //Read-only, on-site controller serial number, 1-64, 0 on behalf of unregistered
    WORD wLocalControllerReaderID; //Read-only, on-site controller card reader ID, 0 represents the unregistered
    WORD wCardReaderChannel; //Read-only, card reader communication channel number, 0 wiggins or offline, 1 - RS485A, 2 - RS485B
    BYTE byRes[18];
}NET_DVR_CARD_READER_CFG, *LPNET_DVR_CARD_READER_CFG;

typedef	struct tagNET_DVR_LOCAL_CONTROLLER_STATUS_COND
{
    DWORD			dwSize;
    WORD wLocalControllerID; //On the controller serial number, 0 to represent all
    BYTE        			byRes[306];
}NET_DVR_LOCAL_CONTROLLER_STATUS_COND, *LPNET_DVR_LOCAL_CONTROLLER_STATUS_COND;

typedef struct tagNET_DVR_LOCAL_CONTROLLER_STATUS
{
    DWORD			dwSize;
    WORD wLocalControllerID; //On the controller serial number
    BYTE byLocalAntiDismantleStatus; //On-site controller tamper condition, 0 to shut down, 1 to open it
    BYTE byPowerSupplyStatus; //Equipment state of power supply, 1 - ac power supply, 2 - battery power supply
    WORD wBatteryVoltage; //Battery voltage value, actual value multiplied 10 units: v
    BYTE byBatteryLowVoltage; //Whether the battery is in low pressure state, 0 - no, 1 - is
    BYTE byFireAlarm; //Fire alarm, 0 - normal, alarm 1 - short, 2 - disconnect the alarm
    BYTE bySerialNumber[SERIALNO_LEN];  //Equipment serial number
    BYTE byMagneticStatus[MAX_DOOR_NUM];// Magnetic door status: 0 normally closed, normally open, 1 2 damage short-circuit alarm, 3 damage breaking alarm, 4 abnormal alarm
    BYTE byDoorLockStatus[MAX_DOOR_NUM]; //Lock state, 0 normally closed,1 normally open, 2 damage short - circuit alarm, 3 damage breaking alarm, 4 abnormal alarm
    BYTE byCardReaderOnlineStatus[MAX_CARD_READER_NUM]; //Card reader online status, 0 - not online, 1 - online
    WORD wLocalControllerStatus; //Read-only, on-site controller online status: 0 - offline, 1 on 1 - online, 2 - loop of RS485 serial port 1 on 1, 3 - loop of RS485 serial port 2 on 2, 4 - loop of RS485 serial port 1, 5 - loop of RS485 serial port 2, 6 - loop 3 of RS485 serial port 1, 7 - the loop on the RS485 serial port on the 3 4 2, 8 - loop on the RS485 serial port 1, 9 - loop 4 of RS485 serial port 2 (read-only)
    BYTE byRes2[122];
}NET_DVR_LOCAL_CONTROLLER_STATUS, *LPNET_DVR_LOCAL_CONTROLLER_STATUS;

typedef struct tagNET_DVR_ONLINE_LOCAL_CONTROLLER_CFG
{
    DWORD			dwSize;
    BYTE byLocalControllerName[LOCAL_CONTROLLER_NAME_LEN]; //On the controller name
    WORD wLocalControllerID; //On the controller serial number
    WORD    wDevPort;                 // Equipment port
    NET_DVR_IPADDR    struDevIP;       // The device IP address
    NET_DVR_IPADDR    struSubnetMask;  // Subnet mask
    NET_DVR_IPADDR    struGateway;     // Gateway equipment
    BYTE         bySearchProgress; //Search progress, 0 means did not start, 100 indicates synchronization is complete
    BYTE         byEffectData;//For valid data, 0 means effective, 1 said equipment returns only search progress, as the heartbeat packets
    BYTE byRes[302];
}NET_DVR_ONLINE_LOCAL_CONTROLLER_CFG, *LPNET_DVR_ONLINE_LOCAL_CONTROLLER_CFG;

typedef struct tagNET_DVR_ACS_WORK_STATUS
{
    DWORD dwSize;
    BYTE byDoorLockStatus[MAX_DOOR_NUM]; //door lock status, 0-disable 1-enable
    BYTE byDoorStatus[MAX_DOOR_NUM]; //door status
    BYTE byMagneticStatus[MAX_DOOR_NUM]; //magnetic status 0-close 1-open
    BYTE byCaseStatus[MAX_CASE_SENSOR_NUM]; //case status, 0-no input, 1-input
    WORD wBatteryVoltage; //vattery voltage , multiply 10, unit: V
    BYTE byBatteryLowVoltage; //Is battery in low voltage, 0-no 1-yes
    BYTE byPowerSupplyStatus; //power supply status, 1-alternating current supply, 2-battery supply
    BYTE byMultiDoorInterlockStatus; //multi door interlock status, 0-close 1-open
    BYTE byAntiSneakStatus; //anti sneak status, 0-close 1-open
    BYTE byHostAntiDismantleStatus; //host anti dismantle status, 0-close, 1-open
    BYTE byIndicatorLightStatus; //Indicator Light Status 0-offLine,1-Online
    BYTE byCardReaderOnlineStatus[MAX_CARD_READER_NUM]; //card reader online status, 0-offline 1-online
    BYTE byCardReaderAntiDismantleStatus[MAX_CARD_READER_NUM]; //card reader anti dismantle status, 0-close 1-open
    BYTE byCardReaderVerifyMode[MAX_CARD_READER_NUM]; //card reader verify mode, 1-swipe 2-swipe+password 3-swipe card 4-swipe card or password
    BYTE bySetupAlarmStatus[MAX_ALARMHOST_ALARMIN_NUM];//alarm in setup alarm status,0- alarm in disarm status, 1 - alarm in arm status
    BYTE byAlarmInStatus[MAX_ALARMHOST_ALARMIN_NUM]; //alarm in status, 0-alarm in no alarm, 1-alarm in has alarm
    BYTE byAlarmOutStatus[MAX_ALARMHOST_ALARMOUT_NUM]; //alarm out status, 0-alarm out no alarm, 1-alarm out has alarm
    DWORD dwCardNum; //add card number
    BYTE byRes2[32];
}NET_DVR_ACS_WORK_STATUS, *LPNET_DVR_ACS_WORK_STATUS;

typedef struct tagNET_DVR_ACS_WORK_STATUS_V50
{
    DWORD dwSize;
    BYTE byDoorLockStatus[MAX_DOOR_NUM_256];//door lock status, 0 normally closed,1 normally open, 2 damage short - circuit alarm, 3 damage breaking alarm, 4 abnormal alarm
    BYTE byDoorStatus[MAX_DOOR_NUM_256]; //Door status, 1 - dormancy, 2 - normally open state, 3 - normally closed state, 4 - ordinary state
    BYTE byMagneticStatus[MAX_DOOR_NUM_256]; //magnetic status 0 normally closed,1 normally open, 2 damage short - circuit alarm, 3 damage breaking alarm, 4 abnormal alarm
    BYTE byCaseStatus[MAX_CASE_SENSOR_NUM]; //case status, 0-no input, 1-input
    WORD wBatteryVoltage; //vattery voltage , multiply 10, unit: V
    BYTE byBatteryLowVoltage; //Is battery in low voltage, 0-no 1-yes
    BYTE byPowerSupplyStatus; //power supply status, 1-alternating current supply, 2-battery supply
    BYTE byMultiDoorInterlockStatus;//multi door interlock status, 0-close 1-open
    BYTE byAntiSneakStatus; //anti sneak status, 0-close 1-open
    BYTE byHostAntiDismantleStatus; //host anti dismantle status, 0-close, 1-open
    BYTE byIndicatorLightStatus; //Indicator Light Status 0-offLine,1-Online
    BYTE byCardReaderOnlineStatus[MAX_CARD_READER_NUM_512]; //card reader online status, 0-offline 1-online
    BYTE byCardReaderAntiDismantleStatus[MAX_CARD_READER_NUM_512]; //card reader anti dismantle status, 0-close 1-open
    BYTE byCardReaderVerifyMode[MAX_CARD_READER_NUM_512]; //card reader verify mode, 1-swipe 2-swipe+password 3-swipe card 4-swipe card or password
    BYTE  bySetupAlarmStatus[MAX_ALARMHOST_ALARMIN_NUM];//alarm in setup alarm status,0- alarm in disarm status, 1 - alarm in arm status
    BYTE byAlarmInStatus[MAX_ALARMHOST_ALARMIN_NUM]; //alarm in status, 0-alarm in no alarm, 1-alarm in has alarm
    BYTE byAlarmOutStatus[MAX_ALARMHOST_ALARMOUT_NUM]; //alarm out status, 0-alarm out no alarm, 1-alarm out has alarm
    DWORD dwCardNum; //add card number
    BYTE byFireAlarmStatus; //Fire alarm status is displayed: 0 - normal, short-circuit alarm 1 -, 2 - disconnect the alarm
    BYTE byRes2[123];
}NET_DVR_ACS_WORK_STATUS_V50, *LPNET_DVR_ACS_WORK_STATUS_V50;

typedef struct tagNET_DVR_CASE_SENSOR_CFG
{
    DWORD dwSize;
    BYTE  byHostBuzzer;  //host buzzer, 0-not trigger, 1-trigger
    BYTE  byRes1[3];
    BYTE  byCardReaderBuzzer[MAX_CARD_READER_NUM]; //card reader buzzer, 0-not trigger, 1-trigger
    BYTE  byAssociateAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM];  // associate alarm out, 1- associate 0-not associate
    BYTE  byDoorOpen[MAX_DOOR_NUM]; //associate door whose ID is ranage 1 to N , 0-not associate 1-associate(open door)
    BYTE  byDoorClose[MAX_DOOR_NUM]; //associate door whose ID is ranage 1 to N , 0-not associate 1-associate(close door)
    BYTE  byRes2[64];
}NET_DVR_CASE_SENSOR_CFG, *LPNET_DVR_CASE_SENSOR_CFG;

typedef struct tagNET_DVR_PTZ_3D_SPEED_CONTROL
{
    DWORD  dwSize;
    DWORD  dwChannel;  //Channel number
    BYTE    byPSpeed;  // The X axis control the speed value (1-64)
    BYTE    byTSpeed;  // The Y axis control the speed value (1-64)
    BYTE    byZSpeed;  // z speed
    BYTE    byPDirect; // P direction, 1 - left, 2 - right
    BYTE    byTDirect; // T direction, 1 - left, 2 - right
    BYTE    byZDirect;  //direction  1-ZOOM+,  2-ZOOM-
    BYTE    byRes[18];
}NET_DVR_PTZ_3D_SPEED_CONTROL, *LPNET_DVR_PTZ_3D_SPEED_CONTROL;

typedef enum _ENUM_UPGRADE_TYPE
{
    ENUM_UPGRADE_DVR = 0, //rdinary device upgrade
    ENUM_UPGRADE_ADAPTER = 1, //DVR adpater upgrade
    ENUM_UPGRADE_VCALIB = 2,  //smart library upgrade
    ENUM_UPGRADE_OPTICAL = 3, //optical upgrade
    ENUM_UPGRADE_ACS = 4, //acs upgrade
    ENUM_UPGRADE_AUXILIARY_DEV = 5, //auxiliary device upgrade
    ENUM_UPGRADE_LED = 6, //LED receive and send card upgrade
}ENUM_UPGRADE_TYPE;

typedef struct tagNET_DVR_ACS_EVENT_INFO
{
    DWORD dwSize;
    BYTE byCardNo[ACS_CARD_NO_LEN]; //card No, 0 means invalid
    BYTE byCardType; //card type\A3\AC1-ordinary card\A3\AC2-disable card\A3\AC3-black list card, 4-patrol card\A3\AC5-stress card\A3\AC6-super card\A3\AC7-client card, 0 means invalid
    BYTE byWhiteListNo; //white list No, 1-8, 0 means invalid
    BYTE byReportChannel; //report channel, 1-alarmin updata, 2-center group 1, 3-center group 2, 0 means invalid
    BYTE byCardReaderKind;//4 - fingerprint head
    DWORD dwCardReaderNo; // card reader No, 0 means invalid
    DWORD dwDoorNo; //door No, 0 means invalid
    DWORD dwVerifyNo; //mutilcard verify No. 0 means invalid
    DWORD dwAlarmInNo;  //alarm in No, 0 means invalid
    DWORD dwAlarmOutNo; //alarm out No 0 means invalid
    DWORD dwCaseSensorNo; //case sensor No 0 means invalid
    DWORD dwRs485No;    //RS485 channel\A3\AC0 means invalid
    DWORD dwMultiCardGroupNo; //multicard group No.
    WORD wAccessChannel;    //Staff channel number
    BYTE  byDeviceNo; //device No\A3\AC0 means invalid
    BYTE byRes1[1];
    DWORD dwEmployeeNo; //employee No\A3\AC0 means invalid
    WORD wLocalControllerID; //On the controller number, 0 - access the host, 1-64 on behalf of the local controller
    BYTE  byInternetAccess; //Internet access ID
    BYTE    byType;     //Alarm type
    BYTE  byRes[20];
}NET_DVR_ACS_EVENT_INFO, *LPNET_DVR_ACS_EVENT_INFO;

typedef struct tagNET_DVR_ACS_ALARM_INFO
{
    DWORD dwSize;
    DWORD dwMajor; //alarm major, reference to macro
    DWORD dwMinor; //alarm minor, reference to macro
    NET_DVR_TIME struTime; //time
    BYTE    sNetUser[MAX_NAMELEN] ;//net operator user
    NET_DVR_IPADDR    struRemoteHostAddr ;//remote host address
    NET_DVR_ACS_EVENT_INFO struAcsEventInfo;
    DWORD dwPicDataLen;   //picture length, when 0 ,means has no picture
    char    *pPicData;  //picture data
    BYTE byRes[24];
}NET_DVR_ACS_ALARM_INFO, *LPNET_DVR_ACS_ALARM_INFO;


#define JUDGE_MAX_VIDEOOUT_NUM 9

typedef struct tagNET_DVR_AUDIO_ACTIVATION_CFG
{
    DWORD   dwSize;
    BYTE    byEnable;
    BYTE    byRes1[3];
    DWORD   dwChanNo;
    BYTE    bySensitivity;
    BYTE    byPriority;
    WORD    wDelayTime;
    BYTE    byRes2;
    BYTE    byEnablePreset;
    WORD    wPreset;
    WORD    wBase;
    BYTE    byRes3[2];
    BYTE    byVoChanNo[JUDGE_MAX_VIDEOOUT_NUM];
    BYTE    byRes[255];
}NET_DVR_AUDIO_ACTIVATION_CFG,*LPNET_DVR_AUDIO_ACTIVATION_CFG;

typedef struct tagNET_DVR_INFRARED_OUTPUT_CTRL_CFG
{
    DWORD  dwSize;
    BYTE   byIROutPort;
    BYTE   byIRCmdIndex;
    BYTE   byRes[254];
}NET_DVR_INFRARED_OUTPUT_CTRL_CFG, *LPNET_DVR_INFRARED_OUTPUT_CTRL_CFG;

#define  MAX_IR_CMD_NAME_LEN    32
#define  MAX_IR_CMD_NUM         32

typedef struct tagNET_DVR_INFRARED_CMD_INFO
{
    char   sCmdName[MAX_IR_CMD_NAME_LEN];
    BYTE   byRes[8];
} NET_DVR_INFRARED_CMD_INFO,*LPNET_DVR_INFRARED_CMD_INFO;


typedef struct tagNET_DVR_INFRARED_LEARN_CODE_CFG_
{
    DWORD  dwSize;
    BYTE      sIROutName[MAX_IR_CMD_NAME_LEN];
    NET_DVR_INFRARED_CMD_INFO  struIRCmdInfo[MAX_IR_CMD_NUM];
    BYTE   byRes[256];
} NET_DVR_INFRARED_CMD_NAME_CFG,*LPNET_DVR_INFRARED_CMD_NAME_CFG;

typedef enum tagIR_LEARN_SEND_DATA_TYPE_ENUM
{
    ENUM_SENDDATA = 0x0,
    ENUM_SEND_LEARN_IR_CMD_START,
    ENUM_SEND_LEARN_IR_CMD_END   = 0x2
}IR_LEARN_SEND_DATA_TYPE_ENUM;


typedef struct tagNET_DVR_INFRARED_LEARN_INFO
{
    DWORD dwSize;
    BYTE  byIROutPort;
    BYTE  byIRCmdIndex;
    BYTE  byRes[30];
} NET_DVR_INFRARED_LEARN_INFO, *LPNET_DVR_INFRARED_LEARN_INFO;

typedef struct tagNET_DVR_INFRARED_LEARN_END
{
    DWORD  dwSize;
    BYTE   bySaveLearnInfo;
    BYTE   byRes[255];
} NET_DVR_INFRARED_LEARN_END,*LPNET_DVR_INFRARED_LEARN_END;

#define MAX_VIDEOIN_TYPE_NUM  10

typedef struct tagNET_DVR_VIDEOIN_TYPE_INFO
{
    WORD  wInType;
    WORD  wInNum;
    WORD  wStartNo;
    BYTE   byRes[6];
}NET_DVR_VIDEOIN_TYPE_INFO, *LPNET_DVR_VIDEOIN_TYPE_INFO;

typedef  struct tagNET_DVR_TRIAL_SYSTEM_INFO
{
    DWORD dwSize;
    BYTE   byVideoInTypeNum;
    BYTE   byRes1[3];
    NET_DVR_VIDEOIN_TYPE_INFO struVideoIn[MAX_VIDEOIN_TYPE_NUM];
    BYTE   byRes[512 ];
} NET_DVR_TRIAL_SYSTEM_INFO, *LPNET_DVR_TRIAL_SYSTEM_INFO;




typedef struct tagNET_DVR_CASE_INFO
{
    DWORD   dwSize;
    BYTE    byCaseNo[CASE_NO_LEN];
    BYTE    byCaseName[CASE_NAME_LEN];
    BYTE    byLitigant1[LITIGANT_LEN];
    BYTE    byLitigant2[LITIGANT_LEN];
    BYTE    byChiefJudge[CHIEF_JUDGE_LEN];
    BYTE    byCaseType;
    BYTE    byShowCaseInfoTime;
    BYTE    byRes[254];
}NET_DVR_CASE_INFO, *LPNET_DVR_CASE_INFO;

#define     MICROPHONE_NUM            16
#define     FAN_NUM                8
#define     FPGA_NUM                8
#define     MAIN_BOARD                8
#define  LOCAL_INPUT_NUM        24
#define  LAMP_STATE_NAME        32
#define  LAMP_NAME                32
#define FILE_NAME_LEN            32
typedef  struct _NET_DVR_REMOTE_PLAY_
{
    DWORD    dwSize;
    BYTE    byFileName[FILE_NAME_LEN];
    BYTE    byVideoOut[7];
    BYTE    byRes1[5];
    BYTE    byType;
    BYTE      byRes[31];
}NET_DVR_REMOTE_PLAY, *LPNET_DVR_REMOTE_PLAY;

typedef  struct _NET_DVR_TRIAL_MICROPHONE_STATUS
{
    DWORD     dwSize ;
    BYTE    byMicrophoneStatus [MICROPHONE_NUM];
    BYTE    byRes[32] ;
}NET_DVR_TRIAL_MICROPHONE_STATUS, *LPNET_DVR_TRIAL_MICROPHONE_STATUS;

typedef  struct _NET_DVR_TRIAL_HOST_STATUS
{
    DWORD  dwSize ;
    DWORD  dwFanSpeed [FAN_NUM];
    WORD   wMainBoardTemp[MAIN_BOARD];
    BYTE   byFpgaTempWarn [FPGA_NUM];
    BYTE   byRes[32] ;
}NET_DVR_TRIAL_HOST_STATUS, *LPNET_DVR_TRIAL_HOST_STATUS;

typedef  struct _NET_DVR_LOCAL_INPUT_INFO_
{
    DWORD      dwSize;
    BYTE      byChannelName[NAME_LEN] ;
    BYTE      byRes[32] ;
}NET_DVR_LOCAL_INPUT_INFO, *LPNET_DVR_LOCAL_INPUT_INFO;

typedef struct tagNET_DVR_LAMP_STATUS
{
    BYTE     byEnable;
    BYTE     byRes1[3];
    BYTE     byLampName[LAMP_NAME];
    BYTE     byLampState1[LAMP_STATE_NAME];
    BYTE     byLampState2[LAMP_STATE_NAME];
    BYTE     byLampState3[LAMP_STATE_NAME];
    BYTE     byRes[32];
}NET_DVR_LAMP_STATUS,*LPNET_DVR_LAMP_STATUS;

typedef  struct _NET_DVR_LAMP_OUT
{
    DWORD        dwSize;
    NET_DVR_LAMP_STATUS  struLampInfo[2];
    BYTE  byRes[256];
}NET_DVR_LAMP_OUT, *LPNET_DVR_LAMP_OUT;

typedef  struct _NET_DVR_LAMP_CONTROL
{
    DWORD     dwSize ;
    BYTE  byLampNo ;
    BYTE  byLampStateNo ;
    BYTE  byRes[14] ;
}NET_DVR_LAMP_CONTROL, *LPNET_DVR_LAMP_CONTROL;

//TPS Param
typedef struct tagNET_DVR_TPS_PARAM
{
    BYTE                byStart;          // Start Code
    BYTE                byCMD;         // CMD
    BYTE                byRes[2];
    WORD                wDeviceID;      // Device ID
    WORD                wDataLen;       // Data Length
    BYTE                byLane;         // Lane
    BYTE                bySpeed;        // Speed\A3\A8KM/H\A3\A9
    BYTE                  byLaneState;     // Lane State\A3\BB0- no, 1- flow, 2- crowded, 3- plug
    BYTE                  byQueueLen;       // Queue Length
    BYTE                byRes1[24];
}NET_DVR_TPS_PARAM, *LPNET_DVR_TPS_PARAM;

//TPS Info
typedef struct tagNET_DVR_TPS_REAL_TIME_INFO
{
    DWORD                 dwSize;
    DWORD                 dwChan ;//Channel No.
    NET_DVR_TIME_V30      struTime;    //Detection Time
    NET_DVR_TPS_PARAM     struTPSRealTimeInfo;// TPS Param
    BYTE                  byRes[24];
}NET_DVR_TPS_REAL_TIME_INFO, *LPNET_DVR_TPS_REAL_TIME_INFO;

typedef struct tagNET_DVR_TPS_LANE_PARAM
{
    BYTE                  byLane;             // Lane
    BYTE                  bySpeed;             //Speed
    BYTE                  byRes[2];
    DWORD               dwLightVehicle;      // Light Vehicle Num
    DWORD               dwMidVehicle;        // Mid Vehicle Num
    DWORD               dwHeavyVehicle;      // Heavy Vehicle Num
    DWORD               dwTimeHeadway;      // Time Headway
    DWORD               dwSpaceHeadway;     // Space Headway
    float               fSpaceOccupyRation; // Space Occupy Ration
    float               fTimeOccupyRation;  // Time Occupy Ration
    BYTE                byRes1[16];
}NET_DVR_TPS_LANE_PARAM, *LPNET_DVR_TPS_LANE_PARAM;

typedef struct tagNET_DVR_TPS_STATISTICS_PARAM
{
    BYTE                byStart;          // Start Code
    BYTE                byCMD;         // CMD
    BYTE                byRes[2];
    WORD                wDeviceID;      // Device ID
    WORD                wDataLen;       //Data Len
    BYTE                byTotalLaneNum;  // Total Lane Num
    BYTE                byRes1[15];  // Total Lane Num
    NET_DVR_TIME_V30    struStartTime;    //Start Time
    DWORD                dwSamplePeriod;    //Sample Period
    NET_DVR_TPS_LANE_PARAM  struLaneParam[MAX_TPS_RULE/*8*/];
}NET_DVR_TPS_STATISTICS_PARAM, *LPNET_DVR_TPS_STATISTICS_PARAM;

typedef struct tagNET_DVR_TPS_STATISTICS_INFO
{
    DWORD                 dwSize;
    DWORD                 dwChan ;//Channel No.
    NET_DVR_TPS_STATISTICS_PARAM     struTPSStatisticsInfo;// TPS Statistics Param
    BYTE                  byRes[128];
}NET_DVR_TPS_STATISTICS_INFO, *LPNET_DVR_TPS_STATISTICS_INFO;


//Ctrl Type
#define     DPC_CORRECT                1    //Correct
#define     DPC_CORRECT_CANCEL         2    //Correct Cancel
#define     DPC_CROSS_DISPALY_OPEN     3    //Cross Dispaly Open
#define     DPC_CROSS_DISPALY_CLOSE    4    //Cross Dispaly Close
#define     DPC_POINT                  5    //Point
#define     DPC_UP                     6    //Up
#define     DPC_DOWN                   7    //Down
#define     DPC_RIGHT                  8    //Right
#define     DPC_LEFT                   9    //Left
#define     DPC_ALL_CORRECT            10   //All Correct
#define     DPC_SAVE                   11   //Save

typedef struct tagNET_DVR_DPC_PARAM
{
    DWORD   dwSize;
    DWORD   dwChannel; //Channel No.
    WORD    wCtrlType ;
    BYTE    byRes[2];
    NET_VCA_POINT struPoint; /*Image plane coordinate input, normalized to 0-1*/
    BYTE    byRes1[64];
}NET_DVR_DPC_PARAM, *LPNET_DVR_DPC_PARAM;

//FFC Manual Info
typedef struct tagNET_DVR_FFC_MANUAL_INFO
{
    DWORD  dwSize;
    DWORD  dwChannel; //Channel No.
    BYTE   byRes[64];
}NET_DVR_FFC_MANUAL_INFO, *LPNET_DVR_FFC_MANUAL_INFO;

//FFC Background Info
typedef struct tagNET_DVR_FFC_BACKCOMP_INFO
{
    DWORD  dwSize;
    DWORD  dwChannel; //Channel No.
    BYTE   byRes[64];
}NET_DVR_FFC_BACKCOMP_INFO, *LPNET_DVR_FFC_BACKCOMP_INFO;

//Storage Server Switch
typedef struct tagNET_DVR_STORAGE_SERVER_SWITCH_CFG
{
    DWORD  dwSize;
    BYTE   byPicEnable[MAX_PIC_SWITCH_STORAGE_SERVER]; //Picure Switch
    BYTE   byAddInfoEnable[MAX_INFO_SWITCH_STORAGE_SERVER];  //Add Info Switch
    BYTE   byRes[324];
} NET_DVR_STORAGE_SERVER_SWITCH_CFG,
        *LPNET_DVR_STORAGE_SERVER_SWITCH_CFG;

//Force Stop Forensics
typedef struct tagNET_DVR_FORCESTOP_FORENSICS_CFG
{
    DWORD  dwSize;
    DWORD  dwChannel; //Channel No.
    BYTE    byRes[64];
}NET_DVR_FORCESTOP_FORENSICS_CFG, *LPNET_DVR_FORCESTOP_FORENSICS_CFG;

typedef struct tagNET_DVR_DEC_VCA_ALARM
{
    DWORD dwSize;
    DWORD dwDisplayNo; //display No.
    BYTE  bySubWinNo;  //subWindow No.
    BYTE  byRes1[3];
    NET_DVR_TIME_V30 struTime; //alarm time
    NET_DVR_PU_STREAM_CFG_V41 struSourceInfo; //code source info
    BYTE  *byAlarmPic; //alarm picture memory
    DWORD dwAlarmPicSize; //alarm picture size , unit:BYTE
    BYTE  byRes2[64];
}NET_DVR_DEC_VCA_ALARM, *LPNET_DVR_DEC_VCA_ALARM;

typedef struct tagNET_DVR_DEC_VCA_ALARM_LOGO
{
    BYTE byEnableLogo;  //enable overlay alarm logo, 0-not, !0-overlay
    BYTE byFlash;   // whether to flash, 0-not !0-flash
    WORD wFlashTime; //flash time, unit:second, value , get range from ability.
    DWORD dwLogoX;  //logo X coordinate\A3\ACdecode window total size\A3\BA1920*1920
    DWORD dwLogoY;  //logo Y coordinate
    BYTE byRes[32];
}NET_DVR_DEC_VCA_ALARM_LOGO, *LPNET_DVR_DEC_VCA_ALARM_LOGO;

typedef struct tagNET_DVR_DEC_VCA_ALARM_PIC
{
    BYTE byUploadPic; //wheter to upload alarm picture , 0-not !0-upload
    BYTE byOverlayTargetInfo; //wheter to overlay target information, 0-not  !0-overlay
    BYTE byOverlayRuleInfo; //wheter to overlay smart rule information , 0-not !0-overlay
    BYTE byPicQuality;            //picture quality  0-best, 1-better, 2-soso
    /*picture size, get from the ability
                                0-CIF\A3\AC           1-QCIF\A3\AC           2-D1\A3\AC         3-UXGA(1600x1200), 4-SVGA(800x600),5-HD720p(1280x720)\A3\AC
                                6-VGA\A3\AC           7-XVGA\A3\AC           8-HD900p\A3\AC     9-HD1080\A3\AC     10-2560*1920\A3\AC
                                11-1600*304\A3\AC     12-2048*1536\A3\AC     13-2448*2048,  14-2448*1200\A3\AC 15-2448*800\A3\AC
                                16-XGA(1024*768), 17-SXGA(1280*1024),18-WD1(960*576/960*480),      19-1080i,      20-576*576\A3\AC
                                21-1536*1536,     22-1920*1920,      23-320*240,    24-720*720,    25-1024*768,
                                26-1280*1280,     27-1600*600,       28-2048*768,   0xff-Auto(current use resolution)*/
    BYTE byPicSize;
    BYTE byRes[27];
}NET_DVR_DEC_VCA_ALARM_PIC, *LPNET_DVR_DEC_VCA_ALARM_PIC;

typedef struct tagNET_DVR_DEC_VCA_ALARM_CFG
{
    DWORD dwSize;
    NET_DVR_DEC_VCA_ALARM_LOGO struAlarmLogo; //overlay logo configure
    NET_DVR_DEC_VCA_ALARM_PIC  struAlarmPic;  //picture configure
    BYTE byRes[64];
}NET_DVR_VCA_ALARM_CFG, *LPNET_DVR_DEC_VCA_ALARM_CFG;

typedef struct tagNET_DVR_OUTPUT_PIC_INFO
{
    DWORD  dwSize;
    BYTE   sPicName[NAME_LEN];//picture name
    BYTE   byUsed; //has used\A3\AC0-no\A3\AC1-yes
    BYTE   byRes[31];
}NET_DVR_OUTPUT_PIC_INFO,*LPNET_DVR_OUTPUT_PIC_INFO;

typedef struct tagNET_DVR_OUTPUT_PIC_CFG
{
    DWORD    dwSize;
    DWORD    dwOutputPicNo;  //picture No.
    BYTE    byEnable; //whether to show , 0-not show 1-show
    BYTE    byRes1[3];
    NET_DVR_RECTCFG_EX struRect;//logo position\A3\ACthe range of the output size is 1920 * 1920
    BYTE    byFlash;  //whether to flash, 1-flash, 0-not flash
    BYTE    byTranslucent; //whether to translucent, 1-translucent, 0-not translucent
    BYTE    byRes2[2];                //
    DWORD    dwOutputPicWinNo; //output picture window No.(1 byte device No. + 1byte output No. + 2byte output picture No),vaild when get all
    BYTE    byRes3[28];
}NET_DVR_OUTPUT_PIC_CFG,*LPNET_DVR_OUTPUT_PIC_CFG;

#define MAX_OSD_LEN                 64   //output OSD length
typedef struct tagNET_DVR_OUTPUT_OSD_CFG
{
    DWORD   dwSize;
    BYTE     byEnable; //whether to display OSD, 0-not 1-display
    BYTE     byFontSize; //Font Size, 1-big, 2-middle, 3-small
    BYTE     byOSDColor; //OSD colosr set\A3\AC0-default\A3\AC 1-black\A3\AC2-white\A3\AC3-red\A3\AC4-green\A3\AC5-blue
    BYTE     byRes1[1];
    BYTE     byOsdContent[MAX_OSD_LEN]; //OSD content
    NET_DVR_RECTCFG_EX struRect;//OSD position, the range of the output size is 1920 * 1920
    DWORD dwOsdWinNo; //output OSD window No.(1 byte device No. + 1byte output No. + 2byte output OSD No),vaild when get all
    BYTE     byRes2[32];                //
}NET_DVR_OUTPUT_OSD_CFG,*LPNET_DVR_OUTPUT_OSD_CFG;

typedef struct tagNET_DVR_CHAN_RELATION_RESOURCE
{
    DWORD dwSize;
    DWORD dwDisplayChan; //display Channel, (1byte device No+1byte retain+2byte display channel No)
    BYTE  byRelateAudio; //relate audio channel
    BYTE  byRes1[3];
    DWORD dwSubWinNo; //relate audio subwindow No(1byte Wall No+1byte sub window NO+ 2byte Window No)
    DWORD dwChannel; //encode channel, vaild when get all
    BYTE byRes2[32];
}NET_DVR_CHAN_RELATION_RESOURCE, *LPNET_DVR_CHAN_RELATION_RESOURCE;

typedef struct tagNET_DVR_ALARM_CHAN_ABLITITY
{
    DWORD    dwSize;
    BYTE    bySensorChan[64];
    BYTE    byAlarmInChan[64];
    BYTE    byAlarmOutChan[64];
    BYTE    by485Chan[64];
    BYTE    byRes[128];
}NET_DVR_ALARM_CHAN_ABLITITY, *LPNET_DVR_ALARM_CHAN_ABLITITY;

typedef struct
{
    DWORD    dwSize;
    BYTE    byOutScale[8];
    BYTE    byRes[16];
}NET_DVR_OUT_SCALE_CFG, *LPNET_DVR_OUT_SCALE_CFG;


typedef    struct     tagNET_DVR_MONITOR_LOCATION_COND
{
    DWORD   dwSize;
    DWORD   dwChan;
    /*
    0 MPR Mode
    1 HVT Mode
    ...
    */
    BYTE    byRelateType;
    BYTE    byRes[63];
}NET_DVR_MONITOR_LOCATION_COND, *LPNET_DVR_MONITOR_LOCATION_COND;


typedef    struct     tagNET_DVR_MONITOR_LOCATION_CFG
{
    DWORD   dwSize;
    BYTE    byMonitoringSiteID[MAX_ID_LEN/*48*/];        //Montioring Site ID
    BYTE    byDeviceID[MAX_ID_LEN/*48*/];                //Device ID
    BYTE    byDirectionNo;     //Monitoring direction; 1-Up, 2-Down, 3-Bi-directional, 4- Westward, 5- Northward, 6-Eastward, 7-Southward, 8-Other direction
    BYTE    byRes1[3];
    BYTE    byMonitorInfo[MONITORSITE_ID_LEN/*48*/];          //Monitor Info
    BYTE    byRes[128];
}NET_DVR_MONITOR_LOCATION_CFG, *LPNET_DVR_MONITOR_LOCATION_CFG;


typedef struct tagNET_DVR_REMOTECONTROL_COND
{
    DWORD   dwSize;
    DWORD   dwChannel; //Channel No.
    BYTE    byRes[64];
}NET_DVR_REMOTECONTROL_COND, *LPNET_DVR_REMOTECONTROL_COND;

typedef struct tagNET_DVR_REMOTECONTROL_STATUS_
{
    DWORD   dwSize;
    BYTE    byAlarmStatus;//Alarm Status
    BYTE    byRes[3];
    WORD    wAlarmDealyTime;//Alarm Dealy Time
    WORD    wDisAlarmDealyTime;//Alarm Dealy Delay Time
    BYTE    byRes1[64];
} NET_DVR_REMOTECONTROL_STATUS, *LPNET_DVR_REMOTECONTROL_STATUS;

typedef struct tagNET_DVR_SECURITY_CFG
{
    DWORD    dwSize;
    BYTE    byCommuMode;            //Communication Mode\A3\AC0-compatibility mode\A3\AC1-security mode
    BYTE    byRes1[2];
    BYTE    byWebAuthentication;    //web Authentication 0-digest\A1\A21-basic
    BYTE    byRtspAuthentication;   //rtsp Authentication 0-disable\A1\A21-basic;
    BYTE    byTelnetServer;         //telnet Server 0-Close\A3\AC1-Open
    BYTE    bySSHServer;            // SSH Server 0-Close\A3\AC1-Open
    BYTE    byIllegalLoginLock;     //Login Lock, 0-Open\A3\A8def\A3\A9\A3\AC1-Close
    BYTE    byStreamEncryption;     //Stream Encryption 0-no Encryption\A3\AC1-encryption
    BYTE    byAntiAttack;          //Whether open attack prevention function, 0 - is not enabled, 1 - to enable (socket delay 5 s closed)
    BYTE	byRes[26];
}NET_DVR_SECURITY_CFG,*LPNET_DVR_SECURITY_CFG;

typedef struct tagNET_DVR_PASSWORD_MANAGE_CFG
{
    DWORD    dwSize;
    BYTE     byRes[3];
    BYTE     byLockCount;      //0-lock function disable\A3\ACthe other value means locked count
    DWORD  dwLockTime;       //lock time
    BYTE     byRes1[128];
} NET_DVR_PASSWORD_MANAGE_CFG,*LPNET_DVR_PASSWORD_MANAGE_CFG;

typedef struct tagNET_DVR_UNLOCK_INFO
{
    DWORD    dwSize;
    BYTE    byUnlockType;    //0-invalid \A3\AC 1-Unlock by IP\A3\AC2-Unlock all IP
    BYTE    byIPVersion;    //1-IPV4\A3\AC2-IPV6\A3\ACwhen byUnlockType is 1\A3\ACthis param is valid
    BYTE    byRes1[2];
    NET_DVR_IPADDR struIPAddr;        //IP Address
    BYTE     byRes[64];
} NET_DVR_UNLOCK_INFO,*LPNET_DVR_UNLOCK_INFO;

typedef  struct  tagNET_DVR_LOCKED_INFO
{
    DWORD    dwSize;
    BYTE    byIPType;    //IP mode 0-invalid\A3\AC1-IPV4\A3\AC2-IPV6
    BYTE    byRes1[3];
    NET_DVR_IPADDR struIPAddress;
    BYTE    byRes[20];
} NET_DVR_LOCKED_INFO,*LPNET_DVR_LOCKED_INFO;


typedef struct tagNET_DVR_CMSPARAM
{
    DWORD   dwSize;
    NET_DVR_IPADDR struCmsAddr;
    WORD   wCmsPort;
    BYTE   byRes1[2];
    BYTE   sDeviceID[NAME_LEN];
    BYTE   byPassword[PASSWD_LEN];
    NET_DVR_IPADDR struPicServerAddr;
    WORD   wPicServerPort;
    WORD   wCmsUdpPort;
    BYTE   byRes2[12];
}NET_DVR_CMSPARAM, *LPNET_DVR_CMSPARAM;


#define DIALPASSWD_LEN  32

typedef struct tagNET_DVR_QOSPARAM
{
    WORD wMaxBitUL;    /* the maximum number of kbits/s in up-link traffic */
    WORD wMaxBitDL;    /* the maximum number of kbits/s in down-link traffic */
    BYTE byTrafficClass;    /* 0: conversationnal; 1: streaming; 2: interactive;3: background; 4: subscribed value(default) */
    BYTE byRes[7];
}NET_DVR_QOSPARAM, *LPNET_DVR_QOSPARAM;


typedef struct tagNET_DVR_PPPDPARAM
{
    BYTE byDialNum[NAME_LEN];        /* dial number, eg. "#777" */
    BYTE byUserName[NAME_LEN];    /* user name, eg. "card" */
    BYTE byPassword[DIALPASSWD_LEN];    /* password, eg. "card" */
    BYTE byApn[NAME_LEN];        /* access point name, eg. "cmnet" */
    NET_DVR_IPADDR struLocalIp;/* local IP address */
    NET_DVR_IPADDR struRemoteIp;/* remote IP address */
    WORD wMtuSize;        /* max transfer unit of ppp interface */
    BYTE byVerifyProtocal;    /* IPCP verify protocal: 0: auto; 1: CHAP; 2: PAP */
    BYTE byRes[25];
}NET_DVR_PPPDPARAM, *LPNET_DVR_PPPDPARAM;

#define MAX_PHONE_NUM                32

typedef struct tagNET_DVR_DIALPARAM
{
    DWORD dwSize;
    BYTE bEnable3G;        /* 0: disable; 1: enable 3g */
    BYTE byDialMethod;        /* dial methold: 0: auto dial; 1: manual dial; */
    BYTE bySwitchMethod;    /* switch methold: 0: auto switch;1\A3\BA3G first\A3\AC2: manual switch to 2G; 3: manual switch to 3G; */
    BYTE byEnaAlarmInDial;   /* AlarmIn Dial; 0: disable; 1: enable */
    BYTE byRes1[10];
    WORD wOffLineTime;        /* auto off line when no connection exist,5~65535 Min */
    NET_DVR_PPPDPARAM struPppdParam;
    NET_DVR_QOSPARAM struQosParam;
    BYTE byUimNumber[MAX_PHONE_NUM];
    BYTE byRes2[24];
}NET_DVR_DIALPARAM, *LPNET_DVR_DIALPARAM;

typedef struct tagNET_DVR_DIALREQUEST
{
    BYTE byConnNum;
    BYTE byNetType;
    BYTE byRes[6];
} NET_DVR_DIALREQUEST, *LPNET_DVR_DIALREQUEST;


/* UIM card information */
typedef enum
{
    UIM_UNKNOWN = 0,
    UIM_VALID = 1,
    UIM_NOVALID = 4,
    UIM_ROAM = 11,
    UIM_NOEXIST = 255
}UIM_INFO;

/* real 3g mode */
typedef enum
{
    /* evdo */
            RMODE_CDMA1X = 12,
    RMODE_EVDO = 14,
    RMODE_CDMAHYBRID = 18,
    /* wcdma */
            RMODE_GSM = 21,
    RMODE_GPRS = 22,
    RMODE_EDGE = 23,
    RMODE_WCDMA = 24,
    RMODE_HSDPA = 25,
    RMODE_HSUPA = 26,
    RMODE_HSPA = 27,
    /* tdscdma */
            RMODE_TGSM = 31,
    RMODE_TGPRS = 32,
    RMODE_TEDGE = 33,
    RMODE_TDSCDMA = 34,
    RMODE_TDHSDPA = 35,
    RMODE_TDHSUPA = 36,
    RMODE_TDHSPA = 37
}REAL_MODE;

typedef struct tagNET_DVR_DIALSTATUS
{
    BYTE byRealMode;        /* REAL_MODE ,real 3g mode networks */
    BYTE byUimCard;        /* UIM_INFO ,UIM card information */
    BYTE byRes1[6];
    DWORD dwSignal;            /* signal RSSI */
    DWORD dwDialStatus;        /* dial status */
    NET_DVR_IPADDR struLocalIp;    /* wireless networks IP address */
    NET_DVR_IPADDR struRemoteIp;    /* wireless networks gateway */
    NET_DVR_IPADDR struNetMask;    /* wireless networks netmask */
    NET_DVR_IPADDR struDns;        /* wireless networks DNS */
    BYTE  byRes2[16];
}NET_DVR_DIALSTATUS, *LPNET_DVR_DIALSTATUS;

#define MAX_WHITELIST_NUM            8

#define HARDDISKFULL_EXCEPTION      0x0
#define HARDDISKERROR_EXCEPTION     0x1
#define ETHERNETBROKEN_EXCEPTION    0x2
#define IPADDRCONFLICT_EXCEPTION    0x3
#define ILLEGALACCESS_EXCEPTION     0x4
#define VI_EXCEPTION                0x5
#define VS_MISMATCH_EXCEPTION       0x6
#define VIDEOCABLELOSE_EXCEPTION    0x7
#define AUDIOCABLELOSE_EXCEPTION    0x8
#define ALARMIN_EXCEPTION           0x9
#define MASKALARM_EXCEPTION         0xa
#define MOTDET_EXCEPTION            0xb
#define RECORDING_EXCEPTION         0xc
#define WIRELESS_EXCEPTION          0xd
#define PIR_EXCEPTION                0xe
#define CALLHELP_EXCEPTION          0xf

#define AUDIO_DETECTION_EXCEPTION              0x10
#define SCENECHANGE_DETECTION_EXCEPTION        0x11
#define DEFOCUS_DETECTION_EXCEPTION            0x12
#define FACE_DETECTION_ENTRANCE_EXCEPTION      0x13
#define LINE_DETECTION_ENTRANCE_EXCEPTION      0x14
#define FIELD_DETECTION_ENTRANCE_EXCEPTION     0x15
#define REGION_EXITING_EXCEPTION               0x16
#define REGION_ENTRANCE_EXCEPTION              0x17
#define LOITERING_EXCEPTION                    0x18
#define GROUP_EXCEPTION                        0x19
#define RAPIDMOVE_EXCEPTION                    0x1a
#define PARKING_EXCEPTION                      0x1b
#define UNATTENDEDBAGGAGE_EXCEPTION            0x1c
#define ATTENDEDBAGGAGE_EXCEPTION              0x1d


#define PHONECFG_RECEIVE_SMS        0x0
#define PHONECFG_SMS_CONTROL        0x1
#define PHONECFG_CALL_CONTROL       0x2
#define PHONECFG_SMS_REBOOT         0x3    /*support sms reboot*/
#define PHONECFG_DOOR_CONTROL       0x4    /*support door control*/

typedef struct tagNET_DVR_PHONECFG
{
    BYTE byWhiteList[MAX_PHONE_NUM];
    BYTE byPhonePerssion[32];
    BYTE byAlarmHandler[32];
    BYTE byRes[128];
} NET_DVR_PHONECFG, *LPNET_DVR_PHONECFG;

typedef struct tagNET_DVR_SMSRELATIVEPARAM
{
    DWORD dwSize;
    BYTE bEnableSmsAlarm;    /* 0: disable; 1: enable 3g */
    BYTE byRes1[7];
    NET_DVR_PHONECFG struWhiteList[MAX_WHITELIST_NUM];
    BYTE byRes2[32];
}NET_DVR_SMSRELATIVEPARAM, *LPNET_DVR_SMSRELATIVEPARAM;

typedef struct tagNET_DVR_SMSLISTINFO
{
    DWORD  dwSize;
    DWORD dwTotalSmsNum;
    BYTE  byRes[8];
    BYTE  *pSmsParam;
    DWORD dwBufLen;
}NET_DVR_SMSLISTINFO, *LPNET_DVR_SMSLISTINFO;

typedef struct tagNET_DVR_SMSPARAM
{
    DWORD dwIndex;            /* the index of sms */
    BYTE byStatus;            /* read yet or not */
    BYTE byRes[7];
    NET_DVR_TIME_EX struRecvTime;        /* sms receive time */
}NET_DVR_SMSPARAM, *LPNET_DVR_SMSPARAM;

#define    MAX_SMSCONTENT_LEN        140
typedef struct tagNET_DVR_SMSCONTENT
{
    BYTE byPhoneNum[MAX_PHONE_NUM];
    BYTE byMsg[MAX_SMSCONTENT_LEN];
}NET_DVR_SMSCONTENT, *LPNET_DVR_SMSCONTENT;

//pin
typedef enum
{
    CPIN_READY = 1,
    CPIN_PIN = 2,
    CPIN_PUK = 3,
    CPIN_PIN2 = 4,
    CPIN_PUK2 = 5
}PIN_READY;

typedef struct tagNET_DVR_PINSTATUS
{
    DWORD dwSize;
    BYTE byStatus;        /* PIN status, defination see enum: PIN_READY */
    BYTE byPinTimes;    /* remain input PIN times */
    BYTE byPukTimes;    /* remain input PUK times */
    BYTE bEnableLock;    /* now the PIN locking function is enabled or not: 0, not enabled lock; 1, lock enabled */
    BYTE byRes[4];
}NET_DVR_PINSTATUS, *LPNET_DVR_PINSTATUS;

typedef enum
{
    PIN_ENABLE = 1,
    PIN_DISABLE = 2,
    PIN_VERIFY = 3,
    PUK_VERIFY = 4,
    PIN_CHANGE = 5
}PIN_CMD;
#define MAX_PIN_LEN        12
typedef struct tagNET_DVR_PINCODEPARAM
{
    DWORD dwSize;
    BYTE byPinCmd;        /* PIN command, defination see enum: PIN_CMD */
    BYTE byRes1[3];
    BYTE byPinCode[MAX_PIN_LEN];        /* pin/puk code */
    BYTE byNewPinCode[MAX_PIN_LEN];    /* new pin code */
    BYTE byRes2[16];
}NET_DVR_PINCODEPARAM, *LPNET_DVR_PINCODEPARAM;
/********************************SDK API definition*********************************/

typedef struct tagNET_DVR_AUTO_LIMIT_WAVE_CFG
{
    BYTE  byFBCEnable;         //FBC enable 0-disable, 1-enable
    BYTE  byMode;              //auto limit wave mode, 0-fast, 1-common-,2-slow
    BYTE  byFilterQValue;      //Q value(Oct), 0-1/40,1-1/10, defalut:1/40 Oct
    BYTE  byStaticFilterNum;   //Filter Num, 0-12
    BYTE  byRes[16];
}NET_DVR_AUTO_LIMIT_WAVE_CFG,*LPNET_DVR_AUTO_LIMIT_WAVE_CFG;

typedef struct tagNET_DVR_MIX_AUDIOIN_CFG
{
    DWORD  dwSize;
    DWORD  dwHighPassFilter;         //High Pass Filter value:0-127
    DWORD  dwNoiseMargin;            //Noise Margin value:0-127
    NET_DVR_AUTO_LIMIT_WAVE_CFG  struLimitWave;  //auto limit wave info, When the audio input type is wavein efficient
    BYTE   byRes[64];
}NET_DVR_MIX_AUDIOIN_CFG,*LPNET_DVR_MIX_AUDIOIN_CFG;

typedef struct tagNET_DVR_MIX_AUDIOOUT_CFG
{
    DWORD   dwSize;
    BYTE    byModulatorEnbale;  //Modulator Enbale
    BYTE    byPostFilter;       //Post Filter  0-close,1-open
    BYTE    byLimitPressure;    //Limit Pressure 0-close,1-open
    BYTE    byRes1;
    WORD    wModulatorValue;    //Modulator Value value:0-127
    WORD    wTriggerTime;       //Trigger Time, value:0-127
    WORD    wFreeTime;          //Free Time, value:0-127
    BYTE    byCompressThreshold; //Compress Threshold 0-1X,1-2X,2-4X,3-8X
    BYTE    byCompressMode;     //Compress Mode 0-hard,1-soft
    BYTE    byCompressRate;    //Compress Rate
    BYTE    byRecoveryGain;    //Recovery Gain 0-1X,1-2X,2-4X,3-8X
    BYTE    byOutputGain;      //Output Gain; 0 ~100(Negative)
    BYTE    byRes[61];
}NET_DVR_MIX_AUDIOOUT_CFG,*LPNET_DVR_MIX_AUDIOOUT_CFG;

#define MAX_AUDIOOUT_PRO_TYPE                8    //Audio out process type
typedef struct tagNET_DVR_VOLUME_CFG
{
    DWORD	dwSize;
    WORD	wVolume[MAX_AUDIOOUT_PRO_TYPE];      //volume  0-127
    BYTE	byPhantomPowerSupply;	//user phantom power supply or not\A3\AC0-invalid\A3\AC1-no\A3\AC2-yes
    BYTE	byEnableAEC;	//enable AEC or not, 0-disable\A3\AC1-enable
    BYTE	byRes1[2];
    BYTE	byEnableFBC[MAX_AUDIOOUT_PRO_TYPE];	//enable FBC or not, 0-disable\A3\AC1-enable
    BYTE	byRes[20];
}NET_DVR_VOLUME_CFG,*LPNET_DVR_VOLUME_CFG;

typedef struct tagNET_DVR_VIDEOOUT_RESOLUTION_CFG
{
    DWORD       dwSize;
    BYTE         byResolution;     //resolution 0-1024x768, 1-1280x720,  2-1280x1024,  3-1680x1050, 4-1920x1080
    BYTE         byRes[63];
}NET_DVR_VIDEOOUT_RESOLUTION_CFG, *LPNET_DVR_VIDEOOUT_RESOLUTION_CFG;

//2014-12-03  T1Test state structure
typedef struct
{
    DWORD  dwSize;//structure size
    WORD   wPort;  //port
    //(Device through port control (port number of the device end is fixed, the upper not configured), start a separate socket connection, separate T1 test interactive content, go XML format)
    //0- close (close connection thread device, the release port), 1 open (separate from the internal device connection thread)
    BYTE   byPortState;
    BYTE   byRes[61];
}NET_DVR_T1TEST_PARAMCFG,*LPNET_DVR_T1TEST_PARAMCFG;

typedef struct tagNET_DVR_ADDR_DOMAIN_INFO
{
    BYTE   szDomainAddr[MAX_DOMAIN_NAME];
    WORD   wPort;
    BYTE   byRes[2];
}NET_DVR_ADDR_DOMAIN_INFO,*LPNET_DVR_ADDR_DOMAIN_INFO;

#define MAX_CENTERNUM_V40     6
//alarm host network config
typedef struct tagNET_DVR_ALARMCENTER_NETCFG
{
    DWORD    dwSize;
    BYTE    byAuxiliaryAlarmAddr[MAX_DOMAIN_NAME];
    WORD    wAuxiliaryAlarmPort;
    NET_DVR_ADDR_DOMAIN_INFO struHostAddr[MAX_CENTERNUM_V40];
    BYTE    byRes[172];
}NET_DVR_ALARMCENTER_NETCFG, *LPNET_DVR_ALARMCENTER_NETCFG;

typedef struct tagNET_DVR_VEHICLE_PARA
{
    BYTE  sLicense[MAX_LICENSE_LEN];

    /*country index
                            0-The algorithms library does not support\A3\AC1-CZ - Czech Republic\A3\AC2-FRA - France\A3\AC
                            3-DE - Germany,4-E - Spain, 5-IT - Italy\A3\AC6-NL - Netherlands\A3\AC7-PL - Poland\A3\AC8-SVK - Slovakia, 9-BY - Belorussia, 10-MDA - Moldova\A3\AC11-RU - Russia\A3\AC12-UA - Ukraine, 0xfe-Unrecognized
    */
    BYTE  byCountry;                   // country index
    BYTE  byRes[239];
}NET_DVR_VEHICLE_PARA, *LPNET_DVR_VEHICLE_PARA;

typedef struct tagNET_DVR_FACE_PIC_DATA_INFO
{
    DWORD              dwImageLen;
    NET_VCA_RECT       struVcaRect;
    DWORD              dwFaceScore;
    BYTE                byRes[228];
    BYTE               *pImage;
}NET_DVR_FACE_PIC_DATA_INFO, *LPNET_DVR_FACE_PIC_DATA_INFO;

typedef struct  tagNET_DVR_BEHAVIOUR_COND
{
    DWORD              dwSearchType;
    BYTE                byRes[252];
}NET_DVR_BEHAVIOUR_COND, *LPNET_DVR_BEHAVIOUR_COND;


typedef union tagNET_DVR_SMARTSEARCH_PIC_UNION
{
    BYTE                byLen[256];
    NET_DVR_VEHICLE_PARA     struVehiclePara; //Vehicle
    NET_VCA_HUMAN_FEATURE    struHumaFeature; //Huma Feature
    NET_DVR_FACE_PIC_DATA_INFO   struHumaPic;     //Huma Pic
    NET_DVR_BEHAVIOUR_COND   struBehaviourCond;  //Behaviour
}NET_DVR_SMARTSEARCH_PIC_UNION,*LPNET_DVR_SMARTSEARCH_PIC_UNION;

typedef struct tagNET_DVR_SMART_SEARCH_PIC_PARA
{
    DWORD                dwChanNo;
    DWORD                byStreamID[STREAM_ID_LEN] ;
    NET_DVR_TIME_EX         struStartTime;
    NET_DVR_TIME_EX         struEndTime;
    WORD                wSearchType;            //Search type   0-Vehicle \A3\AC1-Huma Feature  2-Huma Pic,3-Behaviour
    BYTE               byRes1[2];
    NET_DVR_SMARTSEARCH_PIC_UNION   uSmartSearchCond;
    BYTE               byRes[64];
}NET_DVR_SMART_SEARCH_PIC_PARA, *LPNET_DVR_SMART_SEARCH_PIC_PARA;

typedef struct tagNET_DVR_FACE_SUB_PIC_INFO
{
    DWORD          dwSimilarity;
    NET_VCA_RECT   struVcaRect;
    BYTE           byRes2[236];
}NET_DVR_FACE_SUB_PIC_INFO ,*LPNET_DVR_FACE_SUB_PIC_INFO;


typedef struct tagNET_DVR_BEHAVIOR_INFO
{
    NET_VCA_RECT      struVcaRect;
    BYTE         byRes2[240];
}NET_DVR_BEHAVIOR_INFO ,*LPNET_DVR_BEHAVIOR_INFO;

typedef union tagNET_DVR_PIC_FEATURE_UNION
{
    BYTE                         byLen[256];
    NET_DVR_PLATE_INFO              struPlateInfo;
    NET_DVR_FACE_SUB_PIC_INFO       struFaceSubInfo;
    NET_DVR_BEHAVIOR_INFO           struBehavior;
}NET_DVR_PIC_FEATURE_UNION,*LPNET_DVR_PIC_FEATURE_UNION;

typedef struct tagNET_DVR_SMART_SEARCH_PIC_RET
{
    char                sFileName[PICTURE_NAME_LEN];
    NET_DVR_TIME_EX     struTime;
    DWORD   dwFileSize;
    WORD    wPicType;
    BYTE    byRes1[2];
    NET_DVR_PIC_FEATURE_UNION   uPicFeature;
    BYTE    byRes[32];
}NET_DVR_SMART_SEARCH_PIC_RET, *LPNET_DVR_SMART_SEARCH_PIC_RET;

typedef struct tagNET_DVR_T1TEST_SEND_DATA_BUZZER
{
    BYTE  byHearSound;
    BYTE  byRes[31];
}NET_DVR_T1TEST_SEND_DATA_BUZZER,*LPNET_DVR_T1TEST_SEND_DATA_BUZZER;


typedef union NET_DVR_T1TEST_DATA_UNION
{
    BYTE  byUnionLen[32];
    NET_DVR_T1TEST_SEND_DATA_BUZZER struBuzzer;
    NET_DVR_TIME_V30  struCurTime;
}NET_DVR_T1TEST_DATA_UNION,*LPNET_DVR_T1TEST_DATA_UNION;


typedef struct tagNET_DVR_T1TEST_SEND_DATA
{
    DWORD     dwSize;
    BYTE  byDataType;
    BYTE  byRes1[3];
    NET_DVR_T1TEST_DATA_UNION uSendData;
    BYTE  byRes[64];
}NET_DVR_T1TEST_SEND_DATA,*LPNET_DVR_T1TEST_SEND_DATA;

typedef struct tagNET_DVR_PIC_MODEL_CFG
{
    DWORD       dwSize;
    BYTE         byEnable;
    BYTE         byRes[63];
}NET_DVR_PIC_MODEL_CFG, *LPNET_DVR_PIC_MODEL_CFG;

#define MAX_LEN_256                     256
#define MAX_GROUP_RECORD_NUM            10
typedef struct tagNET_DVR_AREA_MONITOR_COND
{
    DWORD  dwSize;
    DWORD  dwAreaID;
    DWORD  dwMonitorID;
    BYTE   byIsNeedGroup;
    BYTE   byRes [127];
}NET_DVR_AREA_MONITOR_COND,*LPNET_DVR_AREA_MONITOR_COND;

typedef struct tagNET_DVR_DEL_MONITOR_COND
{
    DWORD  dwSize;
    BYTE  byDelType;
    DWORD  dwAreaID;
    DWORD  dwMonitorID;
    BYTE   byRes[64];
}NET_DVR_DEL_MONITOR_COND,*LPNET_DVR_DEL_MONITOR_COND;

typedef struct tagNET_DVR_BLACKLIST_ALARM_COND
{
    DWORD       dwSize;
    BYTE        byType;
    BYTE        byRes1[3];
    DWORD       dwFaceID;
    DWORD       dwMaxSnapNum;
    BYTE        byRes[256];
}NET_DVR_BLACKLIST_ALARM_COND, *LPNET_DVR_BLACKLIST_ALARM_COND;

typedef struct tagNET_DVR_STORAGE_RESOURCE_COND
{
    DWORD      dwSize;
    DWORD        dwStorageID;
    BYTE        byRes[64];
}NET_DVR_STORAGE_RESOURCE_COND, *LPNET_DVR_STORAGE_RESOURCE_COND;

typedef struct tagNET_DVR_BLACKLIST_ALARM_RECORD
{
    DWORD          dwSize;
    DWORD            dwSnapFacePicID;
    DWORD            dwRegisterID;
    DWORD            dwGroupNo;
    BYTE            byRes[128];
}NET_DVR_BLACKLIST_ALARM_RECORD, *LPNET_DVR_BLACKLIST_ALARM_RECORD;

typedef struct tagNET_DVR_BLACKLIST_GROUP_INFO
{
    DWORD          dwSize;
    DWORD          dwGroupID;
    DWORD            dwGroupNo;
    BYTE            byGroupType;
    BYTE            byRes1;
    WORD            wThreshold;
    DWORD            dwListNum;
    BYTE            szGroupName[NAME_LEN];
    BYTE            szRemark[MAX_LEN_256];
    BYTE            byStorageAddr[MAX_DOMAIN_NAME];
    WORD            wStoragePort;
    BYTE            byRes[126];
}NET_DVR_BLACKLIST_GROUP_INFO, *LPNET_DVR_BLACKLIST_GROUP_INFO;


typedef struct tagNET_DVR_SINGLE_BLACKLIST_GROUP_RECORD
{
    DWORD          dwSize;
    DWORD            dwGroupRecordID;
    DWORD            dwGroupNo;
    DWORD            dwFaceDBID;
    DWORD            dwFaceRecordID;
    BYTE            byAlarmLevel;
    BYTE            byRes1[3];
    NET_DVR_ADDR_DOMAIN_INFO struStorageAddr;
    BYTE            byRes[256];
}NET_DVR_SINGLE_BLACKLIST_GROUP_RECORD,*LPNET_DVR_SINGLE_BLACKLIST_GROUP_RECORD;

typedef struct tagNET_DVR_BLACKLIST_GROUP_RECORD_COND
{
    DWORD          dwSize;
    DWORD            dwRecordID;
    BYTE            byRes[64];
}NET_DVR_BLACKLIST_GROUP_RECORD_COND, *LPNET_DVR_BLACKLIST_GROUP_RECORD_COND;

typedef struct tagNET_DVR_BLACKLIST_GROUP_RECORD_CFG
{
    DWORD          dwSize;
    DWORD            dwRecordNum;
    NET_DVR_SINGLE_BLACKLIST_GROUP_RECORD struRecord[MAX_GROUP_RECORD_NUM];
    BYTE            byRes[256];
}NET_DVR_BLACKLIST_GROUP_RECORD_CFG,*LPNET_DVR_BLACKLIST_GROUP_RECORD_CFG;

typedef struct tagNET_DVR_BLACKLIST_GROUP_CFG
{
    DWORD          dwSize;
    DWORD            dwGroupNum;
    NET_DVR_BLACKLIST_GROUP_INFO struGroup[MAX_GROUP_RECORD_NUM];
    BYTE            byRes[256];
}NET_DVR_BLACKLIST_GROUP_CFG,*LPNET_DVR_BLACKLIST_GROUP_CFG;

typedef struct tagNET_DVR_BLACKLIST_GROUP_COND
{
    DWORD        dwSize;
    DWORD            dwGroupID;
    BYTE            byRes[64];
}NET_DVR_BLACKLIST_GROUP_COND, *LPNET_DVR_BLACKLIST_GROUP_COND;

typedef struct  tagNET_DVR_MOUSE_EVENT_PARAM
{
    DWORD           dwSize;
    BYTE            byMouseEvent;
    BYTE            byRes1[3];
    NET_VCA_POINT   struPoint;
    BYTE            byRes[64];
}NET_DVR_MOUSE_EVENT_PARAM, *LPNET_DVR_MOUSE_EVENT_PARAM;

//Radar Alarm Info
typedef struct tagNET_DVR_ALARM_RADARINFO
{
    DWORD        dwSize;
    DWORD        dwRadarTriggerTimeSecond;//Radar Trigger Time  ;Unit:s
    DWORD        dwRadarTriggerTimeMSecond;//Radar Trigger Time\A3\ACUnit:ms
    DWORD        dwVedioTriggerTimeSecond;//Vedio Trigger Time \A3\ACUnit:s
    DWORD        dwVedioTriggerTimeMSecond;//Vedio Trigger Time \A3\ACUnit:ms
    DWORD        dwVedioRadarDiffTimeMSecond;//Vedio Radar Differ Time\A3\ACUnit:ms
    DWORD        dwRadarSpeed;//Radar Speed
    BYTE         byRes[16];
} NET_DVR_ALARM_RADARINFO, *LPNET_DVR_ALARM_RADARINFO;

/************************************ACS begin*********************************/
#define MAX_FINGER_PRINT_LEN            768  //max finger print len
typedef struct tagNET_DVR_FINGER_PRINT_CFG
{
    DWORD       dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //card NO
    DWORD dwFingerPrintLen;     //fingerprint len
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //the card reader which finger print send to\A3\ACaccording to the values,0-not send\A3\AC1-send
    BYTE  byFingerPrintID;     //finger print ID\A3\AC[1,10]
    BYTE  byFingerType;       //finger type  0-normal\A3\AC1-stress
    BYTE  byRes1[30];
    BYTE  byFingerData[MAX_FINGER_PRINT_LEN];
    BYTE  byRes[64];
}NET_DVR_FINGER_PRINT_CFG,*LPNET_DVR_FINGER_PRINT_CFG;

#define ERROR_MSG_LEN      32
typedef struct tagNET_DVR_FINGER_PRINT_STATUS
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN];
    BYTE  byCardReaderRecvStatus[MAX_CARD_READER_NUM_512];  //Fingerprint reader state, press the bytes, 0 - failure, 1 -, 2 - the fingerprint module is not online, 3 - try again or poor quality of fingerprint, 4 - memory is full, 5 - existing the fingerprints, 6 - existing the fingerprint ID, illegal fingerprint ID, 7-8 - don't need to configure the fingerprint module
    BYTE  byFingerPrintID;     //finger print ID\A3\AC[1,10]
    BYTE  byFingerType;        //finger type  0-normal\A3\AC1-stress
    BYTE  byTotalStatus;  //
    BYTE  byRes1;
    BYTE  byErrorMsg[ERROR_MSG_LEN]; //Issued false information, when the byCardReaderRecvStatus is 5, said existing fingerprint matching card number
    DWORD dwCardReaderNo;  //Grain number card reader, can be used to return issued by mistake
    BYTE  byRes[24];
}NET_DVR_FINGER_PRINT_STATUS,*LPNET_DVR_FINGER_PRINT_STATUS;

typedef struct tagNET_DVR_FINGER_PRINT_INFO_COND
{
    DWORD       dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN];
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //which card reader to send\A3\ACaccording to the values
    DWORD dwFingerPrintNum; //the number send or get. if get,0xffffffff means all
    BYTE  byFingerPrintID;     //finger print ID\A3\AC[1,10],   0xff means all
    BYTE  byCallbackMode;     //
    BYTE  byRes1[26];
}NET_DVR_FINGER_PRINT_INFO_COND,*LPNET_DVR_FINGER_PRINT_INFO_COND;

typedef struct tagNET_DVR_FINGER_PRINT_BYCARD
{
    BYTE  byCardNo[ACS_CARD_NO_LEN];
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //be enable card reader\A3\ACaccording to the values
    BYTE  byFingerPrintID[MAX_FINGER_PRINT_NUM/*10*/];        //finger print ID\A3\ACaccording to the values\A3\AC0-not delete\A3\AC1-delete
    BYTE  byRes1[34];
}NET_DVR_FINGER_PRINT_BYCARD,*LPNET_DVR_FINGER_PRINT_BYCARD;

typedef struct tagNET_DVR_FINGER_PRINT_BYREADER
{
    DWORD dwCardReaderNo;
    BYTE  byClearAllCard;  //clear all card\A3\AC0-delete by card\A3\AC1-delete all card
    BYTE  byRes1[3];
    BYTE  byCardNo[ACS_CARD_NO_LEN];
    BYTE  byRes[548];
}NET_DVR_FINGER_PRINT_BYREADER,*LPNET_DVR_FINGER_PRINT_BYREADER;

typedef union tagNET_DVR_DEL_FINGER_PRINT_MODE
{
    BYTE   uLen[588];
    NET_DVR_FINGER_PRINT_BYCARD       struByCard;     //delete by card
    NET_DVR_FINGER_PRINT_BYREADER     struByReader;   //delete by reader
}NET_DVR_DEL_FINGER_PRINT_MODE,*LPNET_DVR_DEL_FINGER_PRINT_MODE;

typedef struct tagNET_DVR_FINGER_PRINT_INFO_CTRL
{
    DWORD       dwSize;
    BYTE  byMode;          //delete mode\A3\AC0-delete by card\A3\AC1-delete by reader
    BYTE  byRes1[3];
    NET_DVR_DEL_FINGER_PRINT_MODE struProcessMode;  //delete mode
    BYTE  byRes[64];
}NET_DVR_FINGER_PRINT_INFO_CTRL,*LPNET_DVR_FINGER_PRINT_INFO_CTRL;

typedef enum _ACS_DEV_SUBEVENT_ENUM_
{
    EVENT_ACS_HOST_ANTI_DISMANTLE = 0,
    EVENT_ACS_OFFLINE_ECENT_NEARLY_FULL,
    EVENT_ACS_NET_BROKEN,
    EVENT_ACS_NET_RESUME ,
    EVENT_ACS_LOW_BATTERY,
    EVENT_ACS_BATTERY_RESUME,
    EVENT_ACS_AC_OFF,
    EVENT_ACS_AC_RESUME,
    EVENT_ACS_SD_CARD_FULL,
    EVENT_ACS_LINKAGE_CAPTURE_PIC,
    EVENT_ACS_IMAGE_QUALITY_LOW,
    EVENT_ACS_FINGER_PRINT_QUALITY_LOW,
    EVENT_ACS_BATTERY_ELECTRIC_LOW,
    EVENT_ACS_BATTERY_ELECTRIC_RESUME,
    EVENT_ACS_FIRE_IMPORT_SHORT_CIRCUIT,
    EVENT_ACS_FIRE_IMPORT_BROKEN_CIRCUIT,
    EVENT_ACS_FIRE_IMPORT_RESUME,
    EVENT_ACS_MASTER_RS485_LOOPNODE_BROKEN,
    EVENT_ACS_MASTER_RS485_LOOPNODE_RESUME,
    EVENT_ACS_LOCAL_CONTROL_OFFLINE,
    EVENT_ACS_LOCAL_CONTROL_RESUME,
    EVENT_ACS_LOCAL_DOWNSIDE_RS485_LOOPNODE_BROKEN,
    EVENT_ACS_LOCAL_DOWNSIDE_RS485_LOOPNODE_RESUME
}ACS_DEV_SUBEVENT_ENUM;

typedef enum _ACS_ALARM_SUBEVENT_ENUM_
{
    EVENT_ACS_ALARMIN_SHORT_CIRCUIT = 0,
    EVENT_ACS_ALARMIN_BROKEN_CIRCUIT,
    EVENT_ACS_ALARMIN_EXCEPTION,
    EVENT_ACS_ALARMIN_RESUME,
    EVENT_ACS_CASE_SENSOR_ALARM,
    EVENT_ACS_CASE_SENSOR_RESUME
}ACS_ALARM_SUBEVENT_ENUM;

typedef enum _ACS_DOOR_SUBEVENT_ENUM_
{
    EVENT_ACS_LEADER_CARD_OPEN_BEGIN  = 0,
    EVENT_ACS_LEADER_CARD_OPEN_END,
    EVENT_ACS_ALWAYS_OPEN_BEGIN ,
    EVENT_ACS_ALWAYS_OPEN_END,
    EVENT_ACS_ALWAYS_CLOSE_BEGIN,
    EVENT_ACS_ALWAYS_CLOSE_END,
    EVENT_ACS_LOCK_OPEN,
    EVENT_ACS_LOCK_CLOSE,
    EVENT_ACS_DOOR_BUTTON_PRESS,
    EVENT_ACS_DOOR_BUTTON_RELEASE,
    EVENT_ACS_DOOR_OPEN_NORMAL,
    EVENT_ACS_DOOR_CLOSE_NORMAL ,
    EVENT_ACS_DOOR_OPEN_ABNORMAL,
    EVENT_ACS_DOOR_OPEN_TIMEOUT,
    EVENT_ACS_REMOTE_OPEN_DOOR,
    EVENT_ACS_REMOTE_CLOSE_DOOR,
    EVENT_ACS_REMOTE_ALWAYS_OPEN,
    EVENT_ACS_REMOTE_ALWAYS_CLOSE,
    EVENT_ACS_NOT_BELONG_MULTI_GROUP,
    EVENT_ACS_INVALID_MULTI_VERIFY_PERIOD,
    EVENT_ACS_MULTI_VERIFY_SUPER_RIGHT_FAIL,
    EVENT_ACS_MULTI_VERIFY_REMOTE_RIGHT_FAIL,
    EVENT_ACS_MULTI_VERIFY_SUCCESS,
    EVENT_ACS_MULTI_VERIFY_NEED_REMOTE_OPEN,
    EVENT_ACS_MULTI_VERIFY_SUPERPASSWD_VERIFY_SUCCESS,
    EVENT_ACS_MULTI_VERIFY_REPEAT_VERIFY_FAIL,
    EVENT_ACS_MULTI_VERIFY_TIMEOUT,
    EVENT_ACS_REMOTE_CAPTURE_PIC,
    EVENT_ACS_DOORBELL_RINGING,
    EVENT_ACS_SECURITY_MODULE_DESMANTLE_ALARM,
    EVENT_ACS_CALL_CENTER,
    EVENT_ACS_FIRSTCARD_AUTHORIZE_BEGIN,
    EVENT_ACS_FIRSTCARD_AUTHORIZE_END,
    EVENT_ACS_DOORLOCK_INPUT_SHORT_CIRCUIT,
    EVENT_ACS_DOORLOCK_INPUT_BROKEN_CIRCUIT,
    EVENT_ACS_DOORLOCK_INPUT_EXCEPTION,
    EVENT_ACS_DOORCONTACT_INPUT_SHORT_CIRCUIT,
    EVENT_ACS_DOORCONTACT_INPUT_BROKEN_CIRCUIT,
    EVENT_ACS_DOORCONTACT_INPUT_EXCEPTION,
    EVENT_ACS_OPENBUTTON_INPUT_SHORT_CIRCUIT,
    EVENT_ACS_OPENBUTTON_INPUT_BROKEN_CIRCUIT,
    EVENT_ACS_OPENBUTTON_INPUT_EXCEPTION,
    EVENT_ACS_DOORLOCK_OPEN_EXCEPTION,
    EVENT_ACS_DOORLOCK_OPEN_TIMEOUT,
    EVENT_ACS_FIRSTCARD_OPEN_WITHOUT_AUTHORIZE
}ACS_DOOR_SUBEVENT_ENUM;

typedef enum _ACS_CARD_READER_SUBEVENT_ENUM_
{
    EVENT_ACS_STRESS_ALARM = 0,
    EVENT_ACS_CARD_READER_DESMANTLE_ALARM,
    EVENT_ACS_LEGAL_CARD_PASS,
    EVENT_ACS_CARD_AND_PSW_PASS,
    EVENT_ACS_CARD_AND_PSW_FAIL,
    EVENT_ACS_CARD_AND_PSW_TIMEOUT,
    EVENT_ACS_CARD_MAX_AUTHENTICATE_FAIL,
    EVENT_ACS_CARD_NO_RIGHT,
    EVENT_ACS_CARD_INVALID_PERIOD,
    EVENT_ACS_CARD_OUT_OF_DATE,
    EVENT_ACS_INVALID_CARD,
    EVENT_ACS_ANTI_SNEAK_FAIL,
    EVENT_ACS_INTERLOCK_DOOR_NOT_CLOSE,
    EVENT_ACS_FINGERPRINT_COMPARE_PASS,
    EVENT_ACS_FINGERPRINT_COMPARE_FAIL,
    EVENT_ACS_CARD_FINGERPRINT_VERIFY_PASS,
    EVENT_ACS_CARD_FINGERPRINT_VERIFY_FAIL,
    EVENT_ACS_CARD_FINGERPRINT_VERIFY_TIMEOUT,
    EVENT_ACS_CARD_FINGERPRINT_PASSWD_VERIFY_PASS,
    EVENT_ACS_CARD_FINGERPRINT_PASSWD_VERIFY_FAIL,
    EVENT_ACS_CARD_FINGERPRINT_PASSWD_VERIFY_TIMEOUT,
    EVENT_ACS_FINGERPRINT_PASSWD_VERIFY_PASS,
    EVENT_ACS_FINGERPRINT_PASSWD_VERIFY_FAIL,
    EVENT_ACS_FINGERPRINT_PASSWD_VERIFY_TIMEOUT,
    EVENT_ACS_FINGERPRINT_INEXISTENCE,
    EVENT_ACS_FACE_VERIFY_PASS,
    EVENT_ACS_FACE_VERIFY_FAIL,
    EVENT_ACS_FACE_AND_FP_VERIFY_PASS,
    EVENT_ACS_FACE_AND_FP_VERIFY_FAIL,
    EVENT_ACS_FACE_AND_FP_VERIFY_TIMEOUT,
    EVENT_ACS_FACE_AND_PW_VERIFY_PASS,
    EVENT_ACS_FACE_AND_PW_VERIFY_FAIL,
    EVENT_ACS_FACE_AND_PW_VERIFY_TIMEOUT,
    EVENT_ACS_FACE_AND_CARD_VERIFY_PASS,
    EVENT_ACS_FACE_AND_CARD_VERIFY_FAIL,
    EVENT_ACS_FACE_AND_CARD_VERIFY_TIMEOUT,
    EVENT_ACS_FACE_AND_PW_AND_FP_VERIFY_PASS,
    EVENT_ACS_FACE_AND_PW_AND_FP_VERIFY_FAIL,
    EVENT_ACS_FACE_AND_PW_AND_FP_VERIFY_TIMEOUT,
    EVENT_ACS_FACE_AND_CARD_AND_FP_VERIFY_PASS,
    EVENT_ACS_FACE_AND_CARD_AND_FP_VERIFY_FAIL,
    EVENT_ACS_FACE_AND_CARD_AND_FP_VERIFY_TIMEOUT,
    EVENT_ACS_EMPLOYEENO_AND_FP_VERIFY_PASS,
    EVENT_ACS_EMPLOYEENO_AND_FP_VERIFY_FAIL,
    EVENT_ACS_EMPLOYEENO_AND_FP_VERIFY_TIMEOUT,
    EVENT_ACS_EMPLOYEENO_AND_FP_AND_PW_VERIFY_PASS,
    EVENT_ACS_EMPLOYEENO_AND_FP_AND_PW_VERIFY_FAIL,
    EVENT_ACS_EMPLOYEENO_AND_FP_AND_PW_VERIFY_TIMEOUT,
    EVENT_ACS_EMPLOYEENO_AND_FACE_VERIFY_PASS,
    EVENT_ACS_EMPLOYEENO_AND_FACE_VERIFY_FAIL,
    EVENT_ACS_EMPLOYEENO_AND_FACE_VERIFY_TIMEOUT,
    EVENT_ACS_FACE_NO_EXIST
}ACS_CARD_READER_SUBEVENT_ENUM;

typedef struct tagNET_DVR_EVENT_LINKAGE_INFO
{
    WORD          wMainEventType;                     //main event type\A3\AC0-device\A3\AC1-alarmin\A3\AC2-door\A3\AC3-card reader
    WORD          wSubEventType;                      //sub event type
    BYTE          byRes[28];
}NET_DVR_EVENT_LINKAGE_INFO,*LPNET_DVR_EVENT_LINKAGE_INFO;

typedef  union tagNET_DVR_EVETN_CARD_LINKAGE_UNION
{
    BYTE                           byCardNo[ACS_CARD_NO_LEN];
    NET_DVR_EVENT_LINKAGE_INFO  struEventLinkage;
}NET_DVR_EVETN_CARD_LINKAGE_UNION,*LPNET_DVR_EVETN_CARD_LINKAGE_UNION;

typedef struct tagNET_DVR_EVENT_CARD_LINKAGE_CFG
{
    DWORD            dwSize;
    BYTE              byProMode;                          //linkage type\A3\AC0-by event\A3\AC1-by card
    BYTE            byRes1[3];
    DWORD           dwEventSourceID;                    //event source ID\A3\ACwhen the main event is device ,it not use; when the main event is door ,it is the door No; when the main event is card reader ,it is the card reader No; when the main event is alarmin,it is the alarmin ID; 0xffffffff means all
    NET_DVR_EVETN_CARD_LINKAGE_UNION     uLinkageInfo;
    BYTE           byAlarmout[MAX_ALARMHOST_ALARMOUT_NUM];            //linkage alarmout NO\A3\ACaccording to the values\A3\AC0-not linkage\A3\AC1-linkage
    BYTE           byRes2[32];
    BYTE           byOpenDoor[MAX_DOOR_NUM_256];     //whether linkage open door,according to the values\A3\AC0-not linkage\A3\AC1-linkage
    BYTE           byCloseDoor[MAX_DOOR_NUM_256];    //whether linkage close door,according to the values\A3\AC0-not linkage\A3\AC1-linkage
    BYTE           byNormalOpen[MAX_DOOR_NUM_256];   //whether linkage normal open door,according to the values\A3\AC0-not linkage\A3\AC1-linkage
    BYTE           byNormalClose[MAX_DOOR_NUM_256];  //whether linkage normal close door,according to the values\A3\AC0-not linkage\A3\AC1-linkage
    BYTE           byMainDevBuzzer;                    //whether linkage main device buzzer, 0-not linkage\A3\AC1-linkage
    BYTE           byCapturePic;                    //whether linkage capture picture, 0-no, 1-yes
    BYTE           byRecordVideo;                   //whether linkage record video, 0-no, 1-yes
    BYTE           byRes3[29];
    BYTE           byReaderBuzzer[MAX_CARD_READER_NUM_512]; //linkage reader buzzer\A3\ACaccording to the values\A3\AC0-not linkage\A3\AC1-linkage
    BYTE           byRes[128];
}NET_DVR_EVENT_CARD_LINKAGE_CFG,*LPNET_DVR_EVENT_CARD_LINKAGE_CFG;

typedef struct tagNET_DVR_EVENT_LINKAGE_CARD_CFG_V50
{
    DWORD			dwSize;
    BYTE          	byProMode;                          //linkage type\A3\AC0-by event\A3\AC1-by card
    BYTE           byRes1[3];
    DWORD         dwEventSourceID;                    //event source ID\A3\ACwhen the main event is device ,it not use; when the main event is door ,it is the door No; when the main event is card reader ,it is the card reader No; when the main event is alarmin,it is the alarmin ID; 0xffffffff means all
    NET_DVR_EVETN_CARD_LINKAGE_UNION 	uLinkageInfo;  //Linkage mode parameters
    BYTE           byAlarmout[MAX_ALARMHOST_ALARMOUT_NUM];            //linkage alarmout NO\A3\ACaccording to the values\A3\AC0-not linkage\A3\AC1-linkage
    BYTE           byRes2[32];
    BYTE           byOpenDoor[MAX_DOOR_NUM_256];     //whether linkage open door,according to the values\A3\AC0-not linkage\A3\AC1-linkage
    BYTE           byCloseDoor[MAX_DOOR_NUM_256];    //whether linkage close door,according to the values\A3\AC0-not linkage\A3\AC1-linkage
    BYTE           byNormalOpen[MAX_DOOR_NUM_256];   //whether linkage normal open door,according to the values\A3\AC0-not linkage\A3\AC1-linkage
    BYTE           byNormalClose[MAX_DOOR_NUM_256];  //whether linkage normal close door,according to the values\A3\AC0-not linkage\A3\AC1-linkage
    BYTE           byMainDevBuzzer;                    //whether linkage main device buzzer, 0-not linkage\A3\AC1-linkage
    BYTE           byCapturePic;                    //whether linkage capture picture, 0-no, 1-yes
    BYTE           byRecordVideo;                   //whether linkage record video, 0-no, 1-yes
    BYTE           byRes3[29];
    BYTE           byReaderBuzzer[MAX_CARD_READER_NUM_512]; //linkage reader buzzer\A3\ACaccording to the values\A3\AC0-not linkage\A3\AC1-linkage
    BYTE           byAlarmOutClose[MAX_ALARMHOST_ALARMOUT_NUM];            //Associated alarm output shut down, in bytes, 0-not linkage\A3\AC1-linkage
    BYTE           byAlarmInSetup[MAX_ALARMHOST_ALARMIN_NUM];  //Associated slip protection, in bytes, 0-not linkage\A3\AC1-linkage
    BYTE           byAlarmInClose[MAX_ALARMHOST_ALARMIN_NUM];  //Removal associated protection zones, in bytes, 0-not linkage\A3\AC1-linkage
    BYTE           byRes[500];
}NET_DVR_EVENT_CARD_LINKAGE_CFG_V50, *LPNET_DVR_EVENT_CARD_LINKAGE_CFG_V50;

typedef struct tagNET_DVR_EVENT_CARD_LINKAGE_COND
{
    DWORD dwSize;
    DWORD dwEventID; //Event ID
    WORD wLocalControllerID; //On the controller serial number [1, 64]
    BYTE byRes[106];
}NET_DVR_EVENT_CARD_LINKAGE_COND, *LPNET_DVR_EVENT_CARD_LINKAGE_COND;


typedef struct tagNET_DVR_ANTI_SNEAK_HOST_INFO
{
    NET_DVR_ADDRESS   struDVRIP;
    BYTE   byIsStartAddr; //whether start addr\A3\AC0-no\A3\AC1-yes
    BYTE   byHostNo;      //host NO\A3\AC1-8
    BYTE   byRes[34];
}NET_DVR_ANTI_SNEAK_HOST_INFO,*LPNET_DVR_ANTI_SNEAK_HOST_INFO;

typedef struct tagNET_DVR_ANTI_SNEAK_HOST_READER_INFO
{
    BYTE  byAntiSnealHostNo;
    BYTE  byRes[5];
    WORD wFollowUpCardReader; //the card reader in the anti sneak host
}NET_DVR_ANTI_SNEAK_HOST_READER_INFO, *LPNET_DVR_ANTI_SNEAK_HOST_READER_INFO;

typedef struct tagNET_DVR_ANTI_SNEAK_MULTI_HOST_CFG
{
    DWORD       dwSize;
    BYTE byEnable; //whether join anti aneak\A3\AC1-join\A3\AC0-not join
    BYTE byRes1[3];
    NET_DVR_ANTI_SNEAK_HOST_INFO struSneakHost[MAX_SNEAK_PATH_NODE]; //the follow sneak host info
    NET_DVR_ANTI_SNEAK_HOST_READER_INFO struStartReader;  //start reader NO
    BYTE byRes2[128];
}NET_DVR_ANTI_SNEAK_MULTI_HOST_CFG, *LPNET_DVR_ANTI_SNEAK_MULTI_HOST_CFG;

typedef struct tagNET_DVR_ANTI_SNEAK_READER_CFG
{
    BYTE         byEnable;             //whether join anti aneak\A3\AC1-join\A3\AC0-not join
    BYTE          byAntiSnealHostNo;
    WORD         wReaderID;
    NET_DVR_ANTI_SNEAK_HOST_READER_INFO struSneakReaderInfo[MAX_SNEAK_PATH_NODE]; //the follow sneak reader info
    BYTE byRes2[8];
}NET_DVR_ANTI_SNEAK_READER_CFG, *LPNET_DVR_ANTI_SNEAK_READER_CFG;

typedef struct tagNET_DVR_ANTI_SNEAK_MULTI_HOST_READERS_CFG
{
    DWORD           dwSize;
    NET_DVR_ANTI_SNEAK_READER_CFG struReaderCfg[MAX_READER_ROUTE_NUM];
    BYTE            byRes[128];
}NET_DVR_ANTI_SNEAK_MULTI_HOST_READERS_CFG, *LPNET_DVR_ANTI_SNEAK_MULTI_HOST_READERS_CFG;

typedef struct tagNET_DVR_ACS_CFG
{
    DWORD           dwSize;
    BYTE            byRS485Backup;  //whether use RS485\A3\AC0-not use\A3\AC1-use
    BYTE            byShowCapPic;    //whether show capture picture\A3\AC0-no\A3\AC1-yes
    BYTE            byShowCardNo;    //whether show card number\A3\AC0-no\A3\AC1-yes
    BYTE            byShowUserInfo;  //whether shou user info\A3\AC0-no\A3\AC1-yes
    BYTE            byOverlayUserInfo;//whether overlay user info\A3\AC0-no\A3\AC1-yes
    BYTE            byVoicePrompt;  //whether voice prompt\A3\AC0-no\A3\AC1-yes
    BYTE             byUploadCapPic;     //whether upload capture picture\A3\AC0-no\A3\AC1-yes
    BYTE             bySaveCapPic;   //whether save capture picture\A3\AC0-no\A3\AC1-yes
    BYTE            byInputCardNo;  //whether input card NO by key\A3\AC0-no\A3\AC1-yes
    BYTE            byRes[503];
}NET_DVR_ACS_CFG, *LPNET_DVR_ACS_CFG;

typedef struct tagNET_DVR_PLATFORM_VERIFY_CFG
{
    DWORD       dwSize;
    DWORD        dwDoorNo; //Gate number
    BYTE        byResultType; //rtification result type, 0: illegal, 1: legal
    BYTE        byRes1[3];
    BYTE        byScreenDisplay[MAX_SCREEN_DISPLAY_LEN]; //LED display screen, used to display authentication information
    BYTE        byRes[300];                  // Keep byte
}NET_DVR_PLATFORM_VERIFY_CFG, *LPNET_DVR_PLATFORM_VERIFY_CFG;


typedef struct tagNET_DVR_CARD_PASSWD_CFG
{
    DWORD dwSize;
    BYTE byCardNo[ACS_CARD_NO_LEN];
    BYTE byCardPassword[CARD_PASSWORD_LEN];
    DWORD dwErrorCode; //the error cade when get\A3\AC0-success
    BYTE byCardValid; //whether card valid\A3\ACused when delete card,0-invalid\A3\AC1-valid
    BYTE byRes2[23];
}NET_DVR_CARD_PASSWD_CFG, *LPNET_DVR_CARD_PASSWD_CFG;

typedef struct tagNET_DVR_PERSON_STATISTICS_CFG
{
    DWORD dwSize;
    BYTE byEnableStatistics;  //Whether to open the number statistics, 0: don't open; 1: open;
    BYTE byEnableOfflineStatistics;  //Whether open offline number statistics, 0: don't open; 1: open;
    BYTE byRes[606];
}NET_DVR_PERSON_STATISTICS_CFG, *LPNET_DVR_PERSON_STATISTICS_CFG;

typedef struct tagNET_DVR_ACS_SCREEN_DISPLAY_CFG
{
    DWORD dwSize;
    DWORD dwFontSize; // font size
    DWORD dwRowSpacing; // line spacing, the unit: pixel;
    DWORD dwColumnSpacing;// column spacing, the unit: pixel;
    DWORD dwFirstRowPosition; // starting line position in which screen block, 0-0, 1:1/8:, 2-2/8, / 8, Deborah / 8, 5:5/8, the man / 8: and yet / 8;
    BYTE byDegree; // character display orientation Angle, 0-0 degrees (normal), 1-90 (edge);
    BYTE byScreenType;// screen type, 0 - DC48270RS043_01T, 1 - DC80480B070_03T;
    BYTE byRes[306];
}NET_DVR_ACS_SCREEN_DISPLAY_CFG, *LPNET_DVR_ACS_SCREEN_DISPLAY_CFG;

typedef struct tagNET_DVR_GATE_TIME_CFG
{
    DWORD dwSize;
    DWORD dwHoldOnALarmTime;  //Continuation of alarm buzzer time, unit of ms
    DWORD dwHoldOnGateOpenTime;  //Gate is received before the shutdown command to continue keeping open time, unit of ms
    DWORD dwPostponeIntrusionAlarmTime;  //Delay trigger into cheating alarm, the unit of ms
    DWORD dwNoLaneAccessTimeLimitTime;  //Channel received pass certification signal effectively, but no one to pass a timeout alarm time, unit s
    DWORD dwSafetyZoneStayTime;  //Channel signal received effective passage certification, passengers stranded after arrive safety channel timeout alarm time, unit s
    BYTE byRes[300];
}NET_DVR_GATE_TIME_CFG, *LPNET_DVR_GATE_TIME_CFG;


typedef struct tagNET_DVR_CARD_PASSWD_STATUS
{
    DWORD dwSize;
    BYTE byCardNo[ACS_CARD_NO_LEN]; //
    DWORD dwErrorCode; //the error cade when send\A3\AC0-success
    BYTE byRes2[24];
}NET_DVR_CARD_PASSWD_STATUS, *LPNET_DVR_CARD_PASSWD_STATUS;
/************************************ACS end*********************************/


/**********************Set vehicle two recognition tasks*************************/
typedef struct tagNET_DVR_VEHICLE_RECOG_COND
{
    DWORD  dwSize;
    DWORD  dwChannel;
    BYTE   byRes[64];
} NET_DVR_VEHICLE_RECOG_COND, *LPNET_DVR_VEHICLE_RECOG_COND;

typedef struct tagNET_DVR_VEHICLE_RECOG_CFG
{
    DWORD  dwSize;
    char   sDataIndex[DATA_INDEX_LEN];//Data Index
    WORD   wTaskNo;//Task No
    BYTE   byRes1[2];
    NET_VCA_RECT  struPlateRect;//Plate Rect
    char   sLicense[MAX_LICENSE_LEN/*16*/];//License
    DWORD  dwRecogOperate;//Recog Operate
    DWORD  dwDataUploadType; //Data Upload Type
    BYTE   byRes[131];
    BYTE   byPicDataType;//Picture Data Type
    char   sPicDataPath[256]; //Picture Data Path
}NET_DVR_VEHICLE_RECOG_CFG, *LPNET_DVR_VEHICLE_RECOG_CFG;
/**********************Set vehicle two recognition tasks*************************/

/**********************Get vehicle two recognition tasks*************************/
typedef struct tagNET_DVR_VEHICLE_RECOG_TASK_COND
{
    DWORD  dwSize;
    DWORD  dwChannel; //Channel
    char   sDataIndex[DATA_INDEX_LEN];//Data Index
    WORD   wTaskNo;//Task No
    BYTE   byTask;
    BYTE   byRes[125];
}NET_DVR_VEHICLE_RECOG_TASK_COND, *LPNET_DVR_VEHICLE_RECOG_TASK_COND;

typedef struct tagNET_DVR_VEHICLE_RECOG_TASK_INFO
{
    DWORD  dwSize;
    DWORD  dwChannel; //Channel
    char   sDataIndex[DATA_INDEX_LEN];//Data Index
    WORD   wTaskNo;//Task No
    WORD   wTaskProgress;//Task Progress
    BYTE   byTaskState;//Task State
    BYTE   byRes1[3];
    DWORD  dwRecogOperate;
    BYTE   byRes[128];
}NET_DVR_VEHICLE_RECOG_TASK_INFO, *LPNET_DVR_VEHICLE_RECOG_TASK_INFO;
/**********************Get vehicle two recognition tasks*************************/

/**********************Upload a secondary vehicle identification data Begin*************************/
typedef struct tagNET_DVR_VEHICLE_RECOG_RESULT
{
    DWORD dwSize;   //struct
//Serial number and data (upload data INTER_VEHICLE_RECOG_COND corresponding fields in sDataIndex)
    char   sDataIndex[DATA_INDEX_LEN];
//Tasking number and (upload data INTER_DVR_SETUPALARM_PARAM the field dwTaskNo corresponding field dwTaskNo simultaneously issued in the corresponding task structure INTER_VEHICLE_RECOG_COND)
    WORD  wTaskNo;
    BYTE   byRes[2];
    NET_VCA_RECT  struPlateRect;// plate location
    char  sLicense[MAX_LICENSE_LEN/*16*/];//License plate number
    BYTE  byVehicleType;    //Vehicle type, the reference:VTR_RESULT
    BYTE  byColorDepth;     //Body color shades, dark reference 0-, 1- light-colored
    BYTE  byColor;         //Body color, reference:VCR_CLR_CLASS
    BYTE  byVehicleLogoRecog; //Vehicle main brand
    BYTE  byVehicleSubLogoRecog; //Vehicle sub-brand
    BYTE  byPilotSafebelt;//0- represents the unknown, 1-not wearing a seatbelt , 2- seatbelt
    BYTE  byCopilotSafebelt;//0- represents the unknown, 1-not wearing a seatbelt , 2- seatbelt
    BYTE  byPilotSunVisor;//0- represents the unknown, do not open the visor 1-, 2- open visor
    BYTE  byCopilotSunVisor;//0- represents the unknown, do not open the visor 1-, 2- open visor
    BYTE  byVehicleModel;// Vehicle Model
    WORD  wVehicleLogoRecog;  //Vehicle main brand
    BYTE  byRes1[251];
    // 0- to upload data directly; 1- cloud storage server URL URL original picture data into the data, images length becomes URL length
    BYTE  byDataType;
    /*
Upload picture type information:
 bit0- vehicle Figure: 0 - do not upload, 1- upload;
 bit1- license plate Figure: 0 - do not upload, 1- upload;
 bit2- face sub-graph (main drive): 0 - do not upload, 1- upload;
 bit3- face sub-graphs (co-pilot): 0 - do not upload, 1- upload;
 bit4- belt Recognition (main drive): 0 - do not upload, 1- upload;
 bit5- belt Recognition (copilot): 0 - do not upload, 1- upload;
    */
    DWORD  dwPicType; //0: No picture information;: Vehicle Figure;: license plate diagram;
    BYTE    *pVehicleBuffer;    //Vehicle picture data pointer
    DWORD  dwVehicleBufferLen ;// Vehicle picture data length
    BYTE    *pPlateBuffer;    //License plate picture data pointer
    DWORD  dwPlateBufferLen ;// License plate picture data length
    BYTE    *pPilotFaceBuffer;    //Face subgraph (main drive) picture data pointer
    DWORD  dwPilotFaceBufferLen ;// Face subgraph (main drive) picture data length
    BYTE    *pCopilotFaceBuffer;    //Face subgraph (copilot) picture data pointer
    DWORD  dwCopilotFaceBufferLen ;// Face subgraph (copilot) picture data length
    BYTE    *pPilotSafebeltBuffer;    //Seatbelt identification (primary drive) picture data pointer
    DWORD  dwPilotSafebeltBufferLen ;// Seatbelt identification (primary drive) picture data length
    BYTE    *pCopilotSafebeltBuffer;// Seatbelt Recognition (copilot) picture data pointer
    DWORD  dwCopilotSafebeltBufferLen ;// Seatbelt Recognition (copilot) picture data length
    NET_VCA_RECT  struVehicleRect ;//Vehicle Rect
    NET_VCA_RECT  struPilotRect ;//Pilot Rect
    NET_VCA_RECT  struCopilotRect ;//Copilot Rect
    BYTE   Res2[80] ;
}NET_DVR_VEHICLE_RECOG_RESULT, *LPNET_DVR_VEHICLE_RECOG_RESULT;

/**********************Upload a secondary vehicle identification data End*************************/


/**********************video alarm host V2.0 begin*************************/

#define MAX_ZONE_LINKAGE_CHAN_NUM    4    /* zone linkage  max channel num*/

typedef struct tagNET_DVR_CENTER_SERVER_CFG_
{
    DWORD                    dwSize;
    BYTE                    byAddressType;    //0 - ipv4/ipv6\A3\AC1 - domain
    BYTE                    byRes1;
    WORD                    wServerPort;//server port
    union
    {
        struct
        {
            BYTE             szDomain[MAX_DOMAIN_NAME];
            BYTE             byRes1[80];
        }struDomain;//server domain
        struct
        {
            NET_DVR_IPADDR   struIp;
        }struAddrIP;//ip address
    }unionServer;
    WORD wInterval;    //alarm interval time,0-30s
    BYTE byRes[514];
}NET_DVR_CENTER_SERVER_CFG,*LPNET_DVR_CENTER_SERVER_CFG;

typedef struct tagNET_DVR_SINGLE_CHANNEL_LINKAGE_CFG_
{
    BYTE    byDDNSType;        //0 - invalid\A3\AC1 - IPServer\A3\AC2 - hiDDNS
    BYTE    byRes1;
    WORD    wDDNSPort;
    BYTE    byServerAddr[MAX_DOMAIN_NAME];
    BYTE    byDevName[MAX_DOMAIN_NAME];
    BYTE    byDevSerialNum[SERIALNO_LEN];
    BYTE    byAddressType;    //0 - ipv4/ipv6\A3\AC1 - domain
    BYTE    byRes2;
    WORD     wDevPort;
    union
    {
        struct
        {
            BYTE            szDomain[MAX_DOMAIN_NAME];
            BYTE            byRes2[80];
        }struDomain;                                    //domain
        struct
        {
            NET_DVR_IPADDR    struIp;
        }struAddrIP;                                    //IP address
    }unionDevAddr;//use IP address or domain according to byAddressType
    BYTE      sUserName[NAME_LEN/*32*/];
    BYTE    sPassword[PASSWD_LEN/*16*/];
    DWORD    dwChannel;    //linkaged channel
    BYTE    byRes3[32];
}NET_DVR_SINGLE_CHANNEL_LINKAGE_CFG,*LPNET_DVR_SINGLE_CHANNEL_LINKAGE_CFG;

typedef struct tagNET_DVR_REGION_CHANNEL_LINKAGE_CFG_
{
    DWORD    dwSize;
    NET_DVR_SINGLE_CHANNEL_LINKAGE_CFG struLinkChannels[MAX_ZONE_LINKAGE_CHAN_NUM];
    BYTE    byRes[64];
}NET_DVR_ZONE_CHANNEL_LINKAGE_CFG,*LPNET_DVR_ZONE_CHANNEL_LINKAGE_CFG;

typedef struct tagNET_DVR_LCD_ALARM
{
    DWORD dwSize;
    DWORD dwScreenID;    //screen id
    BYTE byOnOffLine;    //whether online\A3\AC0-offline\A3\AC1-online\A3\ACwhen Screen is on offline, the other parameter has no mean.
    BYTE byTempState;    //board temperature state, 0-normal, 1-exception
    BYTE byFanState;        //fan state, 0-close, 1-open
    BYTE byFanException;    //fan exception state, 0-no support, 1-normal, 2-exception
    BYTE byTemperature;    //board temperature, unit: .c
    BYTE byRes[27];
}NET_DVR_LCD_ALARM, *LPNET_DVR_LCD_ALARM;

/**********************video alarm host V2.0 end*************************/


//Sensor Info Upload
typedef struct tagNET_DVR_SENSOR_INFO_UPLOAD
{
    DWORD dwSize;
    NET_DVR_TIME_V30  struTime;
    char    szSensorName[MAX_SENSORNAME_LEN]; //Sensor Name
    char    szSensorChan[MAX_SENSORCHAN_LEN]; //Sensor Channel
    BYTE    byReboot; //0~ No Reboot,1~Reboot
    BYTE    byPowerSupply;// 0-No power supply\A3\AC1-Power supply
    BYTE    byStatusType;//Device status:0:normal\A1\A21\A3\BAabnormal\A1\A22\A1\A2alarm
    BYTE    bySensorType;//SensorType;SENSOR_TYPE
    float      fVoltageValue;//Voltage Value
    float    fCurrentValue;//Current Value
    float   fActualValue;//Actual Value
    char    szDescription[MAX_DESCRIPTION_LEN /* 32*/]; //Description
    BYTE    byRes1[128];
}NET_DVR_SENSOR_INFO_UPLOAD,*LPNET_DVR_SENSOR_INFO_UPLOAD;

//Capture Upload
typedef struct tagNET_DVR_CAPTURE_UPLOAD
{
    DWORD dwSize;
    NET_DVR_TIME_V30  struTime;
    DWORD    dwChannel;//Channel
    char    szDevName[MAX_DEVNAME_LEN_EX];
    DWORD   dwPicLen;//Picture Len
    BYTE    *pBuffer;    //Picture Buffer
    BYTE    byRes[124];
}NET_DVR_CAPTURE_UPLOAD,*LPNET_DVR_CAPTURE_UPLOAD;


//B10 V2.4
typedef struct  //
{
    BYTE byPort;   //
    BYTE byMasterSlaveProperty;   //master slave property in port  1-master  2-slave
    BYTE byPortEthernetType;  //\A3\AC1-fast port\A3\AC2-gigabit port
    BYTE byRes[9];
}NET_DVR_RING_PORT_PROPERTY, *LPNET_DVR_RING_PORT_PROPERTY;
typedef struct  //
{
    DWORD   dwSize;
    BYTE     byEnable;     //
    BYTE     byProtoType;  //1-optical transceiver network protocol(private)\A3\AC2-videoplatform network protocol\A3\A8private\A3\A9\A3\AC3-G8032 protocol\A3\A8public\A3\A9
    BYTE   byBandWidth;   //ring bandwidth\A3\AC1-fast\A3\AC2-gigabit
    BYTE     byRes1;        //
    NET_DVR_RING_PORT_PROPERTY struRingPort[PER_RING_PORT_NUM];  //ring port
    BYTE      byRes2[60];    //
}NET_DVR_NS_RING_CFG,  *LPNET_DVR_NS_RING_CFG;
typedef struct  //
{
    DWORD   dwSize;
    BYTE     byStatus;              //ring status\A3\AC1-normal 2-disconnect
    BYTE     byMasterSlaveProperty ; // 1-master  2-slave
    BYTE     byRes[62];            //
} NET_DVR_NS_RING_STATUS, *LPNET_DVR_NS_RING_STATUS;

typedef struct tagNET_DVR_DECSUBSYSTEMJIONSTATUS_V41
{
    BYTE        byJoinStatus;//
    BYTE        byJoinSubSystem;//
    BYTE        byJoinDispNum;//
    BYTE        byJoinSubWindowNum;//
    BYTE        byDecodeAbility;   //
    BYTE        byRes[15];
}NET_DVR_DECSUBSYSTEMJIONSTATUS_V41,LPNET_DVR_DECSUBSYSTEMJIONSTATUS_V41;

//Fire Detection Alarm
typedef struct tagNET_DVR_FIREDETECTION_ALARM
{
    DWORD   dwSize;
    DWORD     dwRelativeTime; //Relative Time
    DWORD    dwAbsTime; //Absolutely Time
    NET_VCA_DEV_INFO  struDevInfo;   //Device Info
    WORD    wPanPos;
    WORD    wTiltPos;
    WORD    wZoomPos;
    BYTE    byRes1[2];
    DWORD   dwPicDataLen;//Picture Date Len
    BYTE    *pBuffer;    //Picture Buffer
    NET_VCA_RECT struRect;
    NET_VCA_POINT struPoint;
    WORD    wFireMaxTemperature;
    WORD    wTargetDistance;
    BYTE    byStrategyType;
    BYTE    byAlarmSubType;
    BYTE    byPTZPosExEnable;
    BYTE    byRes2;
    NET_PTZ_INFO struPtzPosEx;
    DWORD   dwVisiblePicLen;
    BYTE    *pVisiblePicBuf;
    BYTE    *pSmokeBuf;
    WORD    wDevInfoIvmsChannelEx;
    BYTE    byRes[58];
} NET_DVR_FIREDETECTION_ALARM,*LPNET_DVR_FIREDETECTION_ALARM;

typedef struct tagNET_SDK_MANUALTHERM_BASICPARAM
{
    DWORD		dwSize;
    WORD      wDistance;//Distance (m) [0, 10000]
    BYTE 	    byRes1[2];
    float        fEmissivity;//emissivity
    BYTE 	    byRes[64];
}NET_SDK_MANUALTHERM_BASICPARAM, *LPNET_SDK_MANUALTHERM_BASICPARAM;

typedef struct tagNET_SDK_FIRESHIELDMASK_REGION
{
    DWORD		dwSize;
    BYTE      byMaskID;
    BYTE      byEnabled;
    BYTE      byShieldZoom;
    BYTE      byMaskType;
    BYTE      byRegionType;
    BYTE      byShowEnabled;
    BYTE 	    byRes1[2];
    char		   szMaskName[NAME_LEN/*32*/];
    NET_VCA_POLYGON struRegion;
    BYTE 	    byRes[32];
}NET_SDK_FIRESHIELDMASK_REGION, *LPNET_SDK_FIRESHIELDMASK_REGION;

#define MAX_FIRESHIELDMASK_REGION 24
typedef struct tagNET_SDK_FIRESHIELDMASK_CFG
{
    DWORD		dwSize;
    BYTE      byEnabled;
    BYTE 	    byRes1[3];
    NET_SDK_FIRESHIELDMASK_REGION struMaskRegion[MAX_FIRESHIELDMASK_REGION/*24*/];
    BYTE 	    byRes[256];
}NET_SDK_FIRESHIELDMASK_CFG, *LPNET_SDK_FIRESHIELDMASK_CFG;

typedef struct tagNET_SDK_SMOKESHIELDMASK_REGION
{
    DWORD		dwSize;
    BYTE      byMaskID;
    BYTE      byEnabled;
    BYTE      byShieldZoom;
    BYTE      byMaskType;
    BYTE      byRegionType;
    BYTE      byShowEnabled;
    BYTE 	    byRes1[2];
    char		   szMaskName[NAME_LEN/*32*/];
    NET_VCA_POLYGON struRegion;
    BYTE 	    byRes[32];
}NET_SDK_SMOKESHIELDMASK_REGION, *LPNET_SDK_SMOKESHIELDMASK_REGION;

#define MAX_SMOKESHIELDMASK_REGION 24
typedef struct tagNET_SDK_SMOKESHIELDMASK_CFG
{
    DWORD		dwSize;
    BYTE      byEnabled;
    BYTE 	    byRes1[3];
    NET_SDK_SMOKESHIELDMASK_REGION struMaskRegion[MAX_SMOKESHIELDMASK_REGION/*24*/];
    BYTE 	    byRes[256]; //
}NET_SDK_SMOKESHIELDMASK_CFG, *LPNET_SDK_SMOKESHIELDMASK_CFG;

typedef struct tagNET_SDK_AREASCAN_CFG
{
    DWORD		dwSize;
    BYTE      byEnabled;
    BYTE      byScanState;
    BYTE 	    byRes[259];
}NET_SDK_AREASCAN_CFG, *LPNET_SDK_AREASCAN_CFG;

typedef struct tagNET_SDK_FIRESHIELDMASK_COND
{
    DWORD		dwSize;
    DWORD	    dwChannel;
    BYTE        byRegionID;
    BYTE 	    byRes[127];
}NET_SDK_FIRESHIELDMASK_COND, *LPNET_SDK_FIRESHIELDMASK_COND;

typedef struct tagNET_SDK_SMOKESHIELDMASK_COND
{
    DWORD		dwSize;
    DWORD	    dwChannel;
    BYTE        byRegionID;
    BYTE 	    byRes[127];
}NET_SDK_SMOKESHIELDMASK_COND, *LPNET_SDK_SMOKESHIELDMASK_COND;

//Fire Detection
typedef struct tagNET_DVR_SMOKEDETECTION_CFG
{
    BYTE    byEnable;//
    BYTE    bySensitivity; //1~100--50
    BYTE    byRes[58];
}NET_DVR_SMOKEDETECTION_CFG, *LPNET_DVR_SMOKEDETECTION_CFG;

typedef	struct tagNET_DVR_ALARMSTRATEGY_PARAM
{
    BYTE   byStrategyType;
    BYTE   byRes[15];
}NET_DVR_ALARMSTRATEGY_PARAM, *LPNET_DVR_ALARMSTRATEGY_PARAM;

typedef    struct tagNET_DVR_FIREDETECTION_CFG
{
    DWORD	dwSize;
    BYTE	byEnabled;     //Enabled,0~Enable,1~disable
    BYTE    bySensitivity; //Sensitivity: 1~100 Default:5s
    BYTE    byFireComfirmTime;//Time : 0-120s  Default:5s
    BYTE    byFireRegionOverlay;//Fire Region Overlay.
    BYTE    byDetectionMode;
    BYTE    byFireFocusMode;
    BYTE    byFireZoomMode;   //Fire Zoom Mode
    BYTE    byFirezoomLevel; //Fire zoom Level
    BYTE    bySmokeFireEnabled;
    BYTE    byRes[47];
    NET_DVR_ALARMSTRATEGY_PARAM struAlarmStrategy;
    NET_DVR_SMOKEDETECTION_CFG struSmokeCfg;
}NET_DVR_FIREDETECTION_CFG,*LPNET_DVR_FIREDETECTION_CFG;

typedef  struct tagNET_DVR_THERMALPOWER_PARAM
{
    DWORD   dwSize;
    BYTE    byPowerSwitch;
    BYTE    byRes[123];
}NET_DVR_THERMALPOWER_PARAM, *LPNET_DVR_THERMALPOWER_PARAM;

typedef  struct tagNET_DVR_PTZABSOLUTEEX_CFG
{
    DWORD            dwSize;
    NET_PTZ_INFO     struPTZCtrl;
    DWORD            dwFocalLen;
    float            fHorizontalSpeed;//Horizontal Speed\A3\BA0.01-1000.00
    float            fVerticalSpeed;//Vertical Speed\A3\BA0.01-1000.00
    BYTE             byZoomType;// Zoom Type;0~ absoluteZoom\A3\AC1~ focalLen
    BYTE             byRes[123];
}NET_DVR_PTZABSOLUTEEX_CFG, *LPNET_DVR_PTZABSOLUTEEX_CFG;

typedef struct tagNET_DVR_SINGLESUBSYSTEMJOININFO_V41
{
    BYTE    bySubSystemType;
    BYTE    byConnectStatus;
    BYTE    byMatrixNum;
    BYTE    bySubSystemNum;
    NET_DVR_DECSUBSYSTEMJIONSTATUS_V41 struSubSystem[MAX_DECODECHANNUM];
    BYTE    byBindStatus;
    BYTE    bySlotNum ;
    BYTE    byUsedTrunk;
    BYTE    byRes[65];
}NET_DVR_SINGLESUBSYSTEMJOININFO_V41,LPNET_DVR_SINGLESUBSYSTEMJOININFO_V41;

typedef struct tagNET_DVR_ALLDECSUBSYSTEMJOININFO_V41
{
    DWORD dwSize;
    NET_DVR_SINGLESUBSYSTEMJOININFO_V41 struSingleSubSystemJoinInfo[MAX_SUBSYSTEM_NUM_V40];
    BYTE  byRes[48];
}NET_DVR_ALLDECSUBSYSTEMJOININFO_V41,*LPNET_DVR_ALLDECSUBSYSTEMJOININFO_V41;


#define  MAX_OPTICALFIBER_NUM  16
// typedef struct tagNET_DVR_SUBSYSTEM_ABILITY
// {
//     BYTE  bySubSystemType;
//     BYTE  byChanNum;
//     BYTE  byStartChan;
//     BYTE  bySlotNum ;
//     BYTE  byRes1[4];
//     union
//     {
//         BYTE byRes[200];
//         struct
//         {
//             BYTE byDecode;
//             BYTE byNeedPreAllocDec;
//             BYTE byVACType;
//             BYTE byRes[197];
//         }struVACSystemAbility;
//         struct
//         {
//             BYTE  byVGANums;
//             BYTE  byBNCNums;
//             BYTE  byHDMINums;
//             BYTE  byDVINums;
//             BYTE  byLayerNums ;
//             BYTE  bySpartan;
//             BYTE  byDecType;
//             BYTE  byOutputSwitch;
//             BYTE  bySDINums;
//             BYTE  byRes1[38];
//             BYTE  byDecoderType ;
//             BYTE  byRes2[152];
//         }struDecoderSystemAbility;
//         struct
//         {
//             BYTE  byCoderType;
//             BYTE  byOptical;
//             BYTE  byOpticalSubChan;
//             BYTE  bySupportAVSeparate;
//             BYTE  byRes[196];
//         }struCoderSystemAbility;
//         struct
//         {
//             WORD    wTrunkAbility;
//             BYTE    byOpticalFiberNum;
//             BYTE    byRes[197];
//         }struInputSystemAbility;
//         struct
//         {
//             WORD    wTrunkAbility;
//             BYTE    byOpticalFiberNum;
//             BYTE    byRes[197];
//         }struOutputSystemAbility;
//         struct
//         {
//             BYTE    by485Num;
//             BYTE    bySlotNum;
//             BYTE    byRes[198];
//         }struCodeSpitterSystemAbility;
//         struct
//         {
//             WORD    wAlarmInNums;
//             WORD    wAlarmOutNums;
//             BYTE  byAlarmBoxEnable[4][8];
//             BYTE  bySupportContact;
//             BYTE  byRes[163];
//         }struAlarmHostSystemAbility;
//         struct
//         {
//             BYTE  byOpticalFiberNum;
//             BYTE  byRes1[3];
//             WORD    wTrunkAbility[MAX_OPTICALFIBER_NUM/*16*/];
//             BYTE  byRes2[164];
//         }struInOutputSystemAbility;
//         struct
//         {
//             BYTE  bySupportRingProtocol;
//             BYTE  bySupportRingNums;
//             BYTE  bySupportPortNums;
//             BYTE  byRes[1];
//             DWORD dwPortSupportRingProto;
//             BYTE  byRes2[192];
//         } struFiberSwitchSystemAbility;
//     }struAbility;
// }NET_DVR_SUBSYSTEM_ABILITY, *LPNET_DVR_SUBSYSTEM_ABILITY;

typedef struct tagNET_DVR_VIDEOPLATFORM_ABILITY_V40
{
    DWORD   dwSize;
    BYTE    byCodeSubSystemNums;
    BYTE    byDecodeSubSystemNums;
    BYTE    bySupportNat;
    BYTE    byInputSubSystemNums;
    BYTE    byOutputSubSystemNums;
    BYTE    byCodeSpitterSubSystemNums;
    BYTE    byAlarmHostSubSystemNums;
    BYTE    bySupportBigScreenNum;
    BYTE    byVCASubSystemNums;
    BYTE    byV6SubSystemNums;
    BYTE    byV6DecoderSubSystemNums;
    BYTE    bySupportBigScreenX;
    BYTE    bySupportBigScreenY;
    BYTE    bySupportSceneNums;
    BYTE    byVcaSupportChanMode;
    BYTE    bySupportScreenNums;
    BYTE    bySupportLayerNums;
    BYTE    byNotSupportPreview;
    BYTE    byNotSupportStorage;
    BYTE    byUploadLogoMode;
    NET_DVR_SUBSYSTEM_ABILITY struSubSystemAbility[MAX_SUBSYSTEM_NUM_V40];
    BYTE    by485Nums;
    BYTE    by232Nums;
    BYTE    bySerieStartChan;
    BYTE    byScreenMode;
    BYTE    byDevVersion;
    BYTE    bySupportBaseMapNums;
    WORD    wBaseLengthX;
    WORD    wBaseLengthY;
    BYTE    bySupportPictureTrans;
    BYTE    bySupportPreAllocDec;
    BYTE    bySupportDecAutoManage;
    BYTE    byTranDevSubSystemNums;
    BYTE    byFiberSwitchNums;
    BYTE    byRes2[625];
}NET_DVR_VIDEOPLATFORM_ABILITY_V40, *LPNET_DVR_VIDEOPLATFORM_ABILITY_V40;

#define MAX_MASK_AREA_NUM                   8   //mask area num

typedef struct tagNET_DVR_AREA_MASK_CFG
{
    DWORD  dwSize;
    BYTE   byEnable;//enable mask   0-enable 1-yes
    BYTE   byMaskThick;  //0- Thin code, 1- code, 2- thick code, thin code block size is 8*8, in the code 16*16, thick 32*32 code.
    BYTE   byRes1[2];
    NET_VCA_RECT  struRegion[MAX_MASK_AREA_NUM];
    BYTE   byRes[64];
}NET_DVR_AREA_MASK_CFG, *LPNET_DVR_AREA_MASK_CFG;

typedef struct tagNET_DVR_RESOLUTION_SWITCH
{
    DWORD            dwSize;
    BYTE             byResolutionType;//0-all,1-20:9,2-20:6
    BYTE             byRes[127];
}NET_DVR_RESOLUTION_SWITCH, *LPNET_DVR_RESOLUTION_SWITCH;

typedef struct tagNET_DVR_AUDIO_DIACRITICAL_CFG
{
    DWORD  dwSize;
    BYTE   byEnable;
    char   byBassValue;   //High bass value, range of -12-12 value is large sound more fine, the smaller the contrary, 0- said the constant sound
    BYTE   byRes[62];
}NET_DVR_AUDIO_DIACRITICAL_CFG, *LPNET_DVR_AUDIO_DIACRITICAL_CFG;

typedef struct tagNET_DVR_WIFI_DHCP_ADDR_CFG  //WiFi mode DHCP range configuration
{
    DWORD       dwSize;
    NET_DVR_IPADDR   struStartAddr;
    NET_DVR_IPADDR   struEndAddr;
    BYTE        byRes[256];
}NET_DVR_WIFI_DHCP_ADDR_CFG, *LPNET_DVR_WIFI_DHCP_ADDR_CFG;


typedef struct tagNET_DVR_WIFI_CLIENT_INFO
{
    DWORD       dwSize;
    NET_DVR_IPADDR       struAddress;
    BYTE        byMACAddr [MACADDR_LEN];
    WORD        wConnSpeed;    //The connection speed   unit:KB
    BYTE        byRSSIValue;   //The received signal strength, the value is negative, transmission without assignment, the range of 0~-110dbm, the greater the value, the stronger the signal representative
    BYTE        byRes1;
    WORD        wBandwidth;     //band width  unitKB
    BYTE        byRes[32];
}NET_DVR_WIFI_CLIENT_INFO, *LPNET_DVR_WIFI_CLIENT_INFO;

typedef struct tagNET_DVR_MULTISTREAM_RELATION_CHAN_CFG
{
    DWORD       dwSize;
    DWORD       dwChannel;
    BYTE        byRes[64];
}NET_DVR_MULTISTREAM_RELATION_CHAN_CFG, *LPNET_DVR_MULTISTREAM_RELATION_CHAN_CFG;


//Indoor Device ID
typedef struct tagNET_DVR_INDOOR_UNIT_DEVICEID
{
    SHORT wFloorNumber;   //Floor No.
    WORD  wRoomNumber;    //Room No.
    WORD  wDevIndex;      //Device Index, 0-10
    BYTE  byRes[122];
}NET_DVR_INDOOR_UNIT_DEVICEID,*LPNET_DVR_INDOOR_UNIT_DEVICEID;

//Outdoor Device ID
typedef struct tagNET_DVR_OUTDOOR_UNIT_DEVICEID
{
    WORD wPeriod;  //period[0,9]
    WORD wBuildingNumber; //Building No.
    WORD wUnitNumber;  //Unit No.
    SHORT wFloorNumber;  //Floor No.
    WORD wDevIndex;     // Device Index, Start From 0
    BYTE byRes[118];
}NET_DVR_OUTDOOR_UNIT_DEVICEID,*LPNET_DVR_OUTDOOR_UNIT_DEVICEID;

//Outdoor Fence Device ID
typedef struct tagNET_DVR_OUTDOOR_FENCE_DEVICEID
{
    WORD wPeriod;  //period[0,9]
    WORD wDevIndex;  //Device Index ,Start From 0
    BYTE byRes[124];
}NET_DVR_OUTDOOR_FENCE_DEVICEID,*LPNET_DVR_OUTDOOR_FENCE_DEVICEID;

//manage Uint Device ID
typedef struct tagNET_DVR_MANAGE_UNIT_DEVICEID
{
    WORD wPeriod; //period[0,9]
    WORD wDevIndex;  //Device Index ,Start From 0
    BYTE byRes[124];
}NET_DVR_MANAGE_UNIT_DEVICEID,*LPNET_DVR_MANAGE_UNIT_DEVICEID;

typedef union tagNET_DVR_VIDEO_INTERCOM_UNIT_DEVICEID_UNION
{
    BYTE byLen[128] ;
    NET_DVR_INDOOR_UNIT_DEVICEID struIndoorUnit;   //Indoor
    NET_DVR_OUTDOOR_UNIT_DEVICEID struOutdoorUnit; //Outdoor
    NET_DVR_MANAGE_UNIT_DEVICEID struManageUnit; //manage unit
    NET_DVR_OUTDOOR_FENCE_DEVICEID struFenceUnit; //outdoor fence
    NET_DVR_OUTDOOR_UNIT_DEVICEID  struVillaOutdoorUnit;  //villa out door unit
}NET_DVR_VIDEO_INTERCOM_UNIT_DEVICEID_UNION,*LPNET_DVR_VIDEO_INTERCOM_UNIT_DEVICEID_UNION;


typedef struct tagNET_DVR_VIDEO_INTERCOM_DEVICEID_CFG
{
    DWORD dwSize;
    BYTE byUnitType;   //Device Type, 1-Outdoor, 2-manage,4-outdoor fence
    BYTE byIsAutoReg;  //auto register, 0-no, 1-yes
    BYTE byRes1[2];
    NET_DVR_VIDEO_INTERCOM_UNIT_DEVICEID_UNION uVideoIntercomUnit;
    BYTE byRes2[128];
}NET_DVR_VIDEO_INTERCOM_DEVICEID_CFG,*LPNET_DVR_VIDEO_INTERCOM_DEVICEID_CFG;


typedef enum tagPRIVILEGE_PASSWORD_TYPE_ENUM
{
    ENUM_PRIVILEGE_PASSWORD_ENGINEERING = 1,         //engineering
    ENUM_PRIVILEGE_PASSWORD_SETUPALARM = 2,         //set up alarm
    ENUM_PRIVILEGE_PASSWORD_HOUSEHOLDER_UNLOCK  = 3, //house holder unlock
    ENUM_PRIVILEGE_PASSWORD_ANTI_HIJACKING  = 4,      //anti-hijacking
}PRIVILEGE_PASSWORD_TYPE_ENUM;

typedef struct tagNET_DVR_PRIVILEGE_PASSWORD_CFG
{
    DWORD  dwSize;
    BYTE   byPwdType;                     // PRIVILEGE_PASSWORD_TYPE_ENUM
    BYTE   byRes1[3];
    BYTE   byOldPassword[PASSWD_LEN];   //old password
    BYTE   byNewPassword[PASSWD_LEN];   //new password
    BYTE   byRes2[128];
}NET_DVR_PRIVILEGE_PASSWORD_CFG,*LPNET_DVR_PRIVILEGE_PASSWORD_CFG;



typedef struct tagNET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG
{
    DWORD dwMaxMonitoringTime;     //Max Monitoring Time, [10,60]s
    DWORD dwMaxRingTime;         //Max Ring Time [15,60]s
    DWORD dwCallForwardingTime; //call forwarding time,[0,20]s
    BYTE  byRes[116];
}NET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG,*LPNET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG;

typedef struct tagNET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG
{
    DWORD dwMaxMessageTime;     //Max Message Time [30,60]s
    DWORD dwMaxTalkTime;         //Max Talk Time,[90,120]s
    BYTE  byRes[120];
}NET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG,*LPNET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG;


typedef struct tagNET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG
{
    DWORD dwMaxMonitoringTime;  //Max Monitoring Time, [10,60]s
    DWORD dwMaxRingTime;        //Max Ring Time [15,60]s
    DWORD dwMaxTalkTime;        //Max Talk Time,[90,120]s
    BYTE  byRes[116];
}NET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG,*LPNET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG;


typedef union tagNET_DVR_VIDEO_INTERCOM_OPERATION_TIME_UNION
{
    BYTE byLen[128];
    NET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG struIndoorUnit;
    NET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG struOutdoorUnit; //outdoor/out fence
    NET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG struManageUnit; //manage Unit
}NET_DVR_VIDEO_INTERCOM_OPERATION_TIME_UNION,*LPNET_DVR_VIDEO_INTERCOM_OPERATION_TIME_UNION;


typedef struct tagNET_DVR_VIDEO_INTERCOM_OPERATION_TIME_CFG
{
    DWORD dwSize;
    BYTE byUnitType; //Device Type, 1-Outdoor, 2-manage, 3-Indoor,4-outdoor fence
    BYTE byRes1[3];
    NET_DVR_VIDEO_INTERCOM_OPERATION_TIME_UNION uVideoIntercomUnit;
    BYTE byRes2[128];
}NET_DVR_VIDEO_INTERCOM_OPERATION_TIME_CFG,*LPNET_DVR_VIDEO_INTERCOM_OPERATION_TIME_CFG;


typedef struct tagNET_DVR_INDOOR_UNIT_RELATEDEV
{
    NET_DVR_IPADDR struOutdoorUnit;
    NET_DVR_IPADDR struManageUnit;
    NET_DVR_IPADDR struSIPServer;
    NET_DVR_IPADDR struAgainUnit;
    BYTE                 byOutDoorType;          //The main entrance Unit type, 0 retention, 1- unit door Unit, 2- villa door Unit
    BYTE              byOutInConnectMode;  //connect mode of outdoor device and indoor device\A3\BA1-in the same lan,2-in different lan\A3\BB
    BYTE              byIndoorConnectMode;  //connect mode of indoor devices\A3\BA1-wireless\A1\A22-wired\A3\BB
    BYTE            byRes1;
    NET_DVR_IPADDR  struIndoorUnit;
    BYTE           byRes[300];
}NET_DVR_INDOOR_UNIT_RELATEDEV,*LPNET_DVR_INDOOR_UNIT_RELATEDEV;


typedef struct tagNET_DVR_OUTDOOR_UNIT_RELATEDEV
{
    NET_DVR_IPADDR struMainOutdoorUnit;
    NET_DVR_IPADDR struManageUnit;
    NET_DVR_IPADDR struSIPServer;
    BYTE           byRes[592];
}NET_DVR_OUTDOOR_UNIT_RELATEDEV,*LPNET_DVR_OUTDOOR_UNIT_RELATEDEV;


typedef struct tagNET_DVR_AGAIN_RELATEDEV
{
    NET_DVR_IPADDR   struSIPServer;       //SIP IP
    NET_DVR_IPADDR   struCenterAddr;      //center IP
    WORD             wCenterPort;         //Center Port
    BYTE             byRes1[2];
    NET_DVR_IPADDR   struIndoorUnit; //indoor device IP
    BYTE             byRes[588];
}NET_DVR_AGAIN_RELATEDEV,*LPNET_DVR_AGAIN_RELATEDEV;

typedef struct tagNET_DVR_MANAGE_UNIT_RELATEDEV
{
    NET_DVR_IPADDR  struSIPServer;     //SIP server IP
    BYTE   byRes[880];
}NET_DVR_MANAGE_UNIT_RELATEDEV,*LPNET_DVR_MANAGE_UNIT_RELATEDEV;



typedef union tagNET_DVR_VIDEO_INTERCOM_UNIT_RELATEDEV_UNION
{
    DWORD dwRes[256] ;
    NET_DVR_INDOOR_UNIT_RELATEDEV struIndoorUnit;       //indoor uint
    NET_DVR_OUTDOOR_UNIT_RELATEDEV struMainOutdoorUnit; //outdoor/out fence
    NET_DVR_MANAGE_UNIT_RELATEDEV struManageUnit;           //manage Unit
    NET_DVR_OUTDOOR_UNIT_RELATEDEV  struVillaUnit;      //Villa Unit
    NET_DVR_AGAIN_RELATEDEV         struAgainUnit;      //again Unit
}NET_DVR_VIDEO_INTERCOM_UNIT_RELATEDEV_UNION,*LPNET_DVR_VIDEO_INTERCOM_UNIT_RELATEDEV_UNION;


typedef struct tagNET_DVR_VIDEO_INTERCOM_RELATEDEV_CFG
{
    DWORD dwSize;
    BYTE byUnitType;                 //Device Type, 1-Outdoor, 2-manage, 3-Indoor,4-outdoor fence
    BYTE byRes1[3];
    NET_DVR_VIDEO_INTERCOM_UNIT_RELATEDEV_UNION uVideoIntercomUnit;
    BYTE byRes2[128];
}NET_DVR_VIDEO_INTERCOM_RELATEDEV_CFG,*LPNET_DVR_VIDEO_INTERCOM_RELATEDEV_CFG;

typedef struct tagNET_DVR_PANORAMIC_LINKAGE
{
    DWORD   dwSize;
    DWORD   dwChannel;
    BYTE  byType;
    BYTE  byRes1[3];
    BYTE        byMACAddr[MACADDR_LEN];
    BYTE      byRes2[2];
    NET_DVR_IPADDR   struDevIP;
    DWORD    dwPicLen;
    char      *pPicBuff;
    BYTE       byRes[128];
}NET_DVR_PANORAMIC_LINKAGE, *LPNET_DVR_PANORAMIC_LINKAGE;

typedef struct tagNET_DVR_CONTROL_GATEWAY
{
    DWORD dwSize;
    DWORD dwGatewayIndex;             //Gateway Index, Start From 1
    BYTE   byCommand; //command,0-close door 1-open door
    BYTE     byLockType; //lock type\A3\AC0-normal,1-smart lock
    WORD	wLockID; //lock ID
    BYTE   byControlSrc[NAME_LEN];
    BYTE  byControlType; //open door type\A3\AC1-monitor\A3\AC2-calling
    BYTE  byRes3[3];
    BYTE  byPassword[PASSWD_LEN];       //password\A3\ACneed byLockType=1
    BYTE  byRes2[108];
}NET_DVR_CONTROL_GATEWAY,*LPNET_DVR_CONTROL_GATEWAY;



typedef struct tagNET_DVR_NOTICE_PIC
{
    BYTE*  pPicData;
    DWORD dwPicDataLen;
    BYTE   byRes[32];
}NET_DVR_NOTICE_PIC,*LPNET_DVR_NOTICE_PIC;


typedef struct tagNET_DVR_NOTICE_DATA
{
    DWORD dwSize;
    NET_DVR_TIME_EX struTime;   //notice time
    BYTE   byNoticeNumber[MAX_NOTICE_NUMBER_LEN];     //Notice Number
    BYTE   byNoticeTheme[MAX_NOTICE_THEME_LEN];        //Notice Theme
    BYTE   byNoticeDetail[MAX_NOTICE_DETAIL_LEN];   //Notice Detail
    BYTE   byLevel;                                 //level, 1-Advertising information; 2- property information; 3- alarm information
    BYTE   byPicNum;
    BYTE   byRes1[2];
    NET_DVR_NOTICE_PIC struNoticePic[MAX_NOTICE_PIC_NUM];
    BYTE   byRes2[128];
}NET_DVR_NOTICE_DATA,*LPNET_DVR_NOTICE_DATA;


typedef struct tagNET_DVR_OPERATION_AUTH
{
    DWORD dwSize;
    BYTE   byPassword[PASSWD_LEN];
    BYTE   byRes[128];
}NET_DVR_OPERATION_AUTH,*LPNET_DVR_OPERATION_AUTH;


typedef enum tagUNLOCK_TYPE_ENUM
{
    ENUM_UNLOCK_PASSWORD = 1,     //password unlock
    ENUM_UNLOCK_HIJACKING  = 2, //hijacking unlock
    ENUM_UNLOCK_CARD = 3,         //card unlock
    ENUM_UNLOCK_HOUSEHOLDER  = 4,     //house holder unlock
    ENUM_UNLOCK_CENTER_PLATFORM = 5 //Center unlock
}UNLOCK_TYPE_ENUM;



// typedef enum tagALARM_ZONE_TYPE_ENUM
// {
//     ENUM_ALARM_ZONE_SMOKE = 1,         //Smoke
//     ENUM_ALARM_ZONE_GAS  = 2,          //GAS
//     ENUM_ALARM_ZONE_INFRARED = 3,     //Infrared
//     ENUM_ALARM_ZONE_MAGNETIC  = 4,     //magnetic
//     ENUM_ALARM_ZONE_MANUAL = 5         //manual
// }ALARM_ZONE_TYPE_ENUM;


typedef struct tagNET_DVR_UNLOCK_RECORD_INFO
{
    BYTE   byUnlockType;
    BYTE   byRes1[3];
    BYTE   byControlSrc[NAME_LEN]; //Control Src, Credit card unlocking card number, in other cases as the equipment number
    DWORD  dwPicDataLen;
    BYTE*  pImage;
    BYTE   byRes[212];
}NET_DVR_UNLOCK_RECORD_INFO,*LPNET_DVR_UNLOCK_RECORD_INFO;


typedef struct tagNET_DVR_NOTICEDATA_RECEIPT_INFO
{
    BYTE   byNoticeNumber[MAX_NOTICE_NUMBER_LEN]; //Notice Number
    BYTE   byRes[224];
}NET_DVR_NOTICEDATA_RECEIPT_INFO,*LPNET_DVR_NOTICEDATA_RECEIPT_INFO;



typedef union tagNET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON
{
    BYTE byLen[256];
    NET_DVR_UNLOCK_RECORD_INFO struUnlockRecord;             //Unlock Record
    NET_DVR_NOTICEDATA_RECEIPT_INFO struNoticedataReceipt;     //Noticedata Receipt
}NET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON,*LPNET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON;


//
typedef struct tagNET_DVR_VIDEO_INTERCOM_EVENT
{
    DWORD dwSize;
    NET_DVR_TIME_EX struTime;
    BYTE   byDevNumber[MAX_DEV_NUMBER_LEN]; //Device No.
    BYTE   byEventType; //Event Type, 1-Unlock Record,2-Noticedata Receipt
    BYTE   byRes1[3];
    NET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON uEventInfo;
    BYTE  byRes2[256];
}NET_DVR_VIDEO_INTERCOM_EVENT,*LPNET_DVR_VIDEO_INTERCOM_EVENT;


typedef struct tagNET_DVR_ZONE_ALARM_INFO
{
    BYTE   byZoneName[NAME_LEN];     //Zone Name
    DWORD  dwZonendex;                 //Zone Index
    BYTE   byZoneType;                 //Zone Type, See ALARM_ZONE_TYPE_ENUM
    BYTE   byRes[219];
}NET_DVR_ZONE_ALARM_INFO,*LPNET_DVR_ZONE_ALARM_INFO;

typedef union tagNET_DVR_VIDEO_INTERCOM_ALARM_INFO_UNION
{
    BYTE byLen[256];
    NET_DVR_ZONE_ALARM_INFO struZoneAlarm;
}NET_DVR_VIDEO_INTERCOM_ALARM_INFO_UNION,*LPNET_DVR_VIDEO_INTERCOM_ALARM_INFO_UNION;



typedef struct tagNET_DVR_VIDEO_INTERCOM_ALARM
{
    DWORD dwSize;
    NET_DVR_TIME_EX struTime;                 //Alarm Time
    BYTE  byDevNumber[MAX_DEV_NUMBER_LEN];     //Device No.
    BYTE  byAlarmType;                         //Alarm type
    BYTE  byRes1[3];
    NET_DVR_VIDEO_INTERCOM_ALARM_INFO_UNION uAlarmInfo;
    BYTE  byRes2[256];
}NET_DVR_VIDEO_INTERCOM_ALARM,*LPNET_DVR_VIDEO_INTERCOM_ALARM;


typedef struct tagNET_DVR_PEOPLE_REGION
{
    BYTE byID;
    BYTE byNumber;
    BYTE byDressType;
    BYTE byRes;
    NET_VCA_RECT  struRegion;
    DWORD  dwPicLen;
    char*  pPicBuffer;
    BYTE byRes1[24];
}NET_DVR_PEOPLE_REGION,*LPNET_DVR_PEOPLE_REGION;

typedef struct tagNET_DVR_PEOPLE_DETECTION_RESULT
{
    DWORD     dwSize;
    DWORD     dwRelativeTime;
    DWORD    dwAbsTime;
    NET_VCA_DEV_INFO  struDevInfo;
    NET_DVR_PEOPLE_REGION  struPeopleRegion[MAX_PEOPLE_DETECTION_NUM/*8*/];
    BYTE  byPeopleAlarmType;
    BYTE  byRes[255];
}NET_DVR_PEOPLE_DETECTION_RESULT,*LPNET_DVR_PEOPLE_DETECTION_RESULT;

typedef    struct tagNET_DVR_SUPPLEMENTLIGHT
{
    BYTE        byEnable;
    BYTE          byMode;
    BYTE        byHighBeamBrightness;
    BYTE        byLowBeamBrightness;
    NET_DVR_SCHEDULE_DAYTIME  struSchedTime;
    WORD        wFilteringTime;
    BYTE        byRes[62];
}NET_DVR_SUPPLEMENTLIGHT,*LPNET_DVR_SUPPLEMENTLIGHT;

typedef    struct tagNET_DVR_EXTERNALDEVICE
{
    DWORD        dwSize;
    NET_DVR_SUPPLEMENTLIGHT struSupplementLight;
    BYTE        byRes[512];
}NET_DVR_EXTERNALDEVICE,*LPNET_DVR_EXTERNALDEVICE;
typedef	struct tagNET_DVR_TEMPERATURE_TRIGGER_COND
{
    DWORD     dwSize;
    DWORD     dwChan;
    DWORD     dwPreset;
    BYTE      byRes[256];
}NET_DVR_TEMPERATURE_TRIGGER_COND, *LPNET_DVR_TEMPERATURE_TRIGGER_COND;
typedef    struct tagNET_DVR_BUILTIN_SUPPLEMENTLIGHT
{
    DWORD        dwSize;
    BYTE          byMode;
    BYTE        byBrightnessLimit;
    BYTE        byRes[6];
    NET_DVR_SCHEDULE_DAYTIME  struSchedTime;
    BYTE        byRes1[256];
}NET_DVR_BUILTIN_SUPPLEMENTLIGHT,*LPNET_DVR_BUILTIN_SUPPLEMENTLIGHT;


typedef struct tagNET_DVR_OIS_CFG
{
    DWORD		dwSize;
    BYTE		byMode;
    BYTE        byOISLevel;
    BYTE        byOISSensitivity;
    BYTE		byRes[125];
}NET_DVR_OIS_CFG, *LPNET_DVR_OIS_CFG;

typedef struct tagNET_DVR_MACFILTER_CFG
{
    DWORD      dwSize;
    BYTE       byEnabled;  //0-N\A3\AC1-Y
    BYTE       byPermissionType; //0-F\A3\AC1-P
    BYTE       byRes1[2];
    BYTE       szMacAddress[MAC_ADDRESS_NUM][MACADDR_LEN];
    BYTE       byRes[128];
}NET_DVR_MACFILTER_CFG, *LPNET_DVR_MACFILTER_CFG;

typedef	struct tagNET_DVR_EAGLEFOCUSING_SENCE
{
    BYTE    byRuleType;
    BYTE    byRes1[3];
    NET_VCA_POLYGON struRegion;
    BYTE    byRes[128];
}NET_DVR_EAGLEFOCUSING_SENCE, *LPNET_DVR_EAGLEFOCUSING_SENCE;

typedef struct tagNET_DVR_EAGLEFOCUSING_CALCFG
{
    DWORD   dwSize;
    BYTE    byEnabled;//0-N\A3\AC1-Y
    BYTE    byRes1[3];
    NET_DVR_EAGLEFOCUSING_SENCE struEagleFoucsing[MAX_SENCE_NUM/*16*/];
    BYTE   byRes[512];
}NET_DVR_EAGLEFOCUSING_CALCFG, *LPNET_DVR_EAGLEFOCUSING_CALCFG;

typedef struct tagNET_DVR_EAGLEFOCUSING_CTRL
{
    DWORD    dwSize;
    BYTE     byEnable;
    BYTE     byRes[511];
}NET_DVR_EAGLEFOCUSING_CTRL, *LPNET_DVR_EAGLEFOCUSING_CTRL;

typedef struct tagNET_DVR_SMARTCALIBRATION_REGION
{
    BYTE        byRuleID;//Rule ID
    BYTE		byMode;//0-default Mode,1-pix Mode,2-actual Mode
    BYTE        byStrategy;// 0-area,1-widthHeight (<!---,if mode == pix Mode -->)
    BYTE        byPriority;//Priority 0-default, 1-low\A3\AC2-mid\A3\AC3-high
    NET_VCA_POLYGON struMaxTargetSize;//Max Target Size
    NET_VCA_POLYGON struMinTargetSize;//Min Target Size
}NET_DVR_SMARTCALIBRATION_REGION, *LPNET_DVR_SMARTCALIBRATION_REGION;

typedef struct tagNET_DVR_SMARTCALIBRATION_CFG
{
    DWORD		dwSize;
    /* SmartType:
    0-linedetection,
    1-fielddetection,
    2-regionEntrance,
    3-regionExiting,
    4-loitering,
    5-rapidMove,
    6-parking,
    7-unattendedBaggage,
    8-attendedBaggage
    */
    BYTE		bySmartType;//VCA Type
    BYTE        byRes[3];
    NET_DVR_SMARTCALIBRATION_REGION strRegion[RULE_REGION_MAX/*128*/];
    BYTE		byRes1[128];
}NET_DVR_SMARTCALIBRATION_CFG, *LPNET_DVR_SMARTCALIBRATION_CFG;


typedef struct tagNET_DVR_SMARTCALIBRATION_COND
{
    DWORD		dwSize;
    /* SmartType:
    0-linedetection,
    1-fielddetection,
    2-regionEntrance,
    3-regionExiting,
    4-loitering,
    5-rapidMove,
    6-parking,
    7-unattendedBaggage,
    8-attendedBaggage
    */
    BYTE		bySmartType;//VCA Type
    BYTE        byRes[3];
    DWORD		dwChannel;//Channel
    BYTE		byRes1[128];
}NET_DVR_SMARTCALIBRATION_COND, *LPNET_DVR_SMARTCALIBRATION_COND;

typedef struct tagNET_DVR_SMARTCALIBRATION_REGION_CFG
{
    DWORD		dwSize;
    NET_DVR_SMARTCALIBRATION_REGION strRegion[RULE_REGION_MAX/*128*/];
    BYTE		byRes1[128];
}NET_DVR_SMARTCALIBRATION_REGION_CFG, *LPNET_DVR_SMARTCALIBRATION_REGION_CFG;

typedef	struct tagNET_DVR_OSD_BATTERY_POWER_CFG
{
    DWORD dwSize;
    NET_VCA_POINT  struOSDBatteryPower;
    BYTE   byOSDBatteryPower;
    BYTE    byRes[63];
}NET_DVR_OSD_BATTERY_POWER_CFG, *LPNET_DVR_OSD_BATTERY_POWER_CFG;

typedef struct tagNET_DVR_VIDEO_INTERCOM_IOIN_CFG
{
    DWORD   dwSize;
    BYTE    byIOUseType;             //Use Type, 0- forbidden, 1-The door open button, 2-Door status, 0xff-Sel-define
    BYTE    byRes[63];
}NET_DVR_VIDEO_INTERCOM_IOIN_CFG, *LPNET_DVR_VIDEO_INTERCOM_IOIN_CFG;

typedef struct tagNET_DVR_VIDEO_INTERCOM_IOOUT_CFG
{
    DWORD   dwSize;
    BYTE    byIOUseType;             //Use Type, 0-forbidden, 1-Electric lock, 0xff-Sel-define
    BYTE    byRes[63];
}NET_DVR_VIDEO_INTERCOM_IOOUT_CFG, *LPNET_DVR_VIDEO_INTERCOM_IOOUT_CFG;

typedef struct tagNET_DVR_ELEVATORCONTROL_CFG
{
    DWORD   dwSize;
    BYTE    byEnable;                   //enabled , 0-no, 1-yes
    BYTE    byRes1;
    BYTE    byInterfaceType;             //Interface Type, 0-no, 1-RS485,2-Network
    BYTE    byRS485Protocol;             //RS485 , 0-Unknown, 1-private, 0xff-Sel-define, When the byInterfaceType value is 1 effective
    BYTE    byNetworkType;              //Network, 0-Unknown, 1-private, 0xff-Sel-define, When the byInterfaceType value is 2  effective
    BYTE    byRes[63];
}NET_DVR_ELEVATORCONTROL_CFG, *LPNET_DVR_ELEVATORCONTROL_CFG;

typedef struct tagNET_DVR_ELEVATORCONTROL_CFG_V40
{
    DWORD   dwSize;
    BYTE    byEnable;                   //enabled , 0-no, 1-yes
    BYTE    byRes1;
    BYTE    byInterfaceType;             //Interface Type, 0-no, 1-RS485,2-Network
    BYTE    byRS485Protocol;             //RS485 , 0-Unknown, 1-private, 0xff-Sel-define, When the byInterfaceType value is 1 effective
    BYTE    byNetworkType;              //Network, 0-Unknown, 1-private, 0xff-Sel-define, When the byInterfaceType value is 2  effective
    BYTE    byRes2;
    WORD    wServerPort;                //Ladder control server port number, when the card protocol type for the 1- private effective
    NET_DVR_IPADDR    struServerIP;        //Server IP when the card protocol type for the 1- private effective
    BYTE    byRes[256];
}NET_DVR_ELEVATORCONTROL_CFG_V40, *LPNET_DVR_ELEVATORCONTROL_CFG_V40;

typedef struct tagNET_DVR_VIDEOINTERCOM_STREAM
{
    DWORD dwSize;
    BYTE  byVisDevID[MAX_NAMELEN];         //VIS Dev ID
    BYTE  byDeviceName[NAME_LEN];          //Device Name
    BYTE  bySourceType;                    //Source Type, 0-Meaningless, 1-IPC\A1\A22-DVR/DVS/NVR\A1\A23-outdoor\A1\A24-out fence\A1\A25-again device
    BYTE  byRes[255];
}NET_DVR_VIDEOINTERCOM_STREAM, LPNET_DVR_VIDEOINTERCOM_STREAM;



typedef struct tagNET_DVR_VIS_DEV_INFO
{
    DWORD   dwSize;
    BYTE    szDevNumber[MAX_DEV_NUMBER_LEN];        //Device No.
    BYTE    byRes[64];
}NET_DVR_VIS_DEV_INFO,*LPNET_DVR_VIS_DEV_INFO;

typedef struct tagNET_DVR_VIS_REGISTER_INFO
{
    DWORD       dwSize;
    DWORD       dwID;
    BYTE        szDevNumber[MAX_DEV_NUMBER_LEN];    //Device No.
    BYTE        byMACAddr[MACADDR_LEN];             //mac addr
    BYTE        byRes1[2];
    BYTE        sSerialNumber[SERIALNO_LEN];        //Serial No.
    NET_DVR_IPADDR   struDevIP;
    NET_DVR_TIME_EX struRegisterTime;               //Register Time
    BYTE        byRegisterType;                     //RegisterType, 0-res\A1\A21-outdoor, 2-manage Unit\A1\A23-Indoor\A1\A24-out fence\A1\A25-Villa door\A1\A26-Two confirmation \A1\A27-8700\A1\A28-4200
    BYTE        byRes[127];
}NET_DVR_VIS_REGISTER_INFO,*LPNET_DVR_VIS_REGISTER_INFO;


typedef  struct  tagNET_DVR_SENSOR_VALUE
{
    float   fMinValue; //Min Value
    float   fMaxValue; //Max Value
    BYTE    byRes[8];
}NET_DVR_SENSOR_VALUE, *LPNET_DVR_SENSOR_VALUE;

typedef  struct  tagNET_DVR_HISTORICAL_QUERY_PARAM //Historical Query Param
{
    NET_DVR_TIME_V30 struStartTime;//Start Time
    NET_DVR_TIME_V30 struEndTime;//End Time
    NET_DVR_SENSOR_VALUE struVoltageValue; //Voltage Value; Unit: V
    NET_DVR_SENSOR_VALUE struCurrentValue; //Current Value; Unit: mA
    NET_DVR_SENSOR_VALUE struTemperatureValue;//Temperature Value\A3\ACUnit: \A1\E6
    NET_DVR_SENSOR_VALUE struHumidityValue;//Humidity Value
    BYTE   bySwitchStatus;//Switch Status\A3\AC 0~Close\A3\AC1~Open
    BYTE   bySensorStatus; //Sensor Status\A3\BB
    BYTE   byRes[66];
}NET_DVR_HISTORICAL_QUERY_PARAM, *LPNET_DVR_HISTORICAL_QUERY_PARAM;

typedef  struct  tagNET_DVR_SENSOR_COND
{
    DWORD  dwSize;
    BYTE   byQueryType; //Query Type
    BYTE   byDeviceType; //Device Type
    BYTE   byDeviceID; //Device ID
    BYTE   byRes1;
    NET_DVR_HISTORICAL_QUERY_PARAM struHistoricalQueryParam; //Historical Query Param
    BYTE   byRes[64];
}NET_DVR_SENSOR_COND,*LPNET_DVR_SENSOR_COND;

typedef  struct  tagNET_DVR_SENSOR_CFG
{
    DWORD  dwSize;
    BYTE   byEnable; //Enable
    BYTE   byDeviceType; //Device Type
    BYTE   byDeviceID; //Device ID
    BYTE   byRes1;
    NET_DVR_TIME_V30 struTime;//Time
    BYTE   byIsFirst; //Is First
    BYTE   byIsSwitchOn; //Is SwitchOn
    BYTE   bySensorStatus; //Sensor Status
    BYTE   bySensorType; //Sensor Type
    float  fVoltage; //Voltage
    float  fCurrent; //Current
    float  fTemperatureValue;//Temperature Value
    float  fHumidityValue;//Humidity Value
    BYTE   bySensorName[SENSORNAME_LEN/*32*/]; //Sensor Name
    BYTE   byDescription[MAX_SENSORDESCR_LEN/*64*/]; //Description
    BYTE   byRes[256];
}NET_DVR_SENSOR_CFG,*LPNET_DVR_SENSOR_CFG;

typedef    struct tagNET_DVR_SENSOR_SWITCH_COND
{
    DWORD     dwSize;
    BYTE     byDeviceType; //Device Type
    BYTE     byDeviceID; //Device ID
    BYTE     bySwitch; //Switch
    BYTE     byRes[125];
}NET_DVR_SENSOR_SWITCH_COND,*LPNET_DVR_SENSOR_SWITCH_COND;

typedef struct tagNET_DVR_GB28181_SERVICE_CFG
{
    DWORD  dwSize;
    BYTE   byServerID[DEV_ID_LEN];  //SIP Server ID\A3\BB
    WORD   wPort;                   //SIP Port
    BYTE   byRes1[2];
    BYTE   byAuthPasswd[PASSWD_LEN];
    DWORD  dwRegisterValid;           //Survival period, unit: s, default: 3600
    BYTE   byMaxHeartbeatTimeOut;    //The maximum heartbeat timeout, default: 3
    BYTE   byAutoAddIpc;            //Whether to enable the automatic add IPC, 0- disable, the 1- enable
    BYTE   byAuthPasswdEx[MAX_PASSWD_LEN_EX];
    BYTE   byRes[190];
}NET_DVR_GB28181_SERVICE_CFG,*LPNET_DVR_GB28181_SERVICE_CFG;

typedef    struct    tagNET_DVR_ACTIVATECFG
{
    DWORD   dwSize;    //struct size
    BYTE    sPassword[PASSWD_LEN];    //activate password
    BYTE    byRes[108];
}NET_DVR_ACTIVATECFG,*LPNET_DVR_ACTIVATECFG;

typedef struct tagNET_DVR_IPDEVICE_ACTIVATE_CFG
{
    DWORD       dwSize;    //struct size
    BYTE        byMode;    //0-activate by channel,1-activate by address
    BYTE        bySelfDefinePassword;//whether self-define password,0-no,1-yes
    BYTE        sPassword[PASSWD_LEN];//self-define password
    BYTE        sUserName[NAME_LEN];//username
    BYTE        byRes[78];
    union
    {
        BYTE        byLen[512];//union size
        struct
        {
            DWORD       dwChannelNo;//channel number
            BYTE        byRes[508];
        }struChannelInfo;//channel information
        struct
        {
            NET_DVR_IPADDR   struIp;//IP address
            WORD    wPort;//port
            BYTE    sProtocolDesc[DESC_LEN];//protocol type
            BYTE    byMacAddr[MACADDR_LEN];//mac address
            BYTE    byRes[344];
        }struAddrInfo;//IP address get from NET_DVR_SADPINFO
    }unActivateDeviceInfo;
}NET_DVR_IPDEVICE_ACTIVATE_CFG,*LPNET_DVR_IPDEVICE_ACTIVATE_CFG;

typedef struct tagNET_DVR_DIGITAL_CHANNEL_SECURITY_STATUS_
{
    DWORD  dwSize;
    BYTE   byDigitalChanPasswordStatus[MAX_CHANNUM_V30*4];//0-invalid,1-IPC not activate,2-risk password,3-weak password,4-medium password,5-strong password;byDigitalChanPasswordStatus[0]--the first digital channel
    BYTE   byRes[1140];
}NET_DVR_DIGITAL_CHANNEL_SECURITY_STATUS, *LPNET_DVR_DIGITAL_CHANNEL_SECURITY_STATUS;

typedef struct tagNET_DVR_LLI_PARAM
{
    float fSec;//Seconds [0.000,60.000]
    BYTE byDegree;//Degree :Latitude[0,90] Longitude[0,180]
    BYTE byMinute;//Minute[0,59]
    BYTE byRes[6];
}NET_DVR_LLI_PARAM, *LPNET_DVR_LLI_PARAM;

typedef struct tagNET_DVR_LLPOS_PARAM
{
    BYTE   byLatitudeType;
    BYTE   byLongitudeType;
    BYTE   byRes1[2];
    NET_DVR_LLI_PARAM    struLatitude;
    NET_DVR_LLI_PARAM    struLongitude;
    BYTE   byRes[16];
}NET_DVR_LLPOS_PARAM, *LPNET_DVR_LLPOS_PARAM;

typedef struct tagNET_DVR_SMOKEDETECTION_ALARM
{
    NET_PTZ_INFO struPTZPos;
    NET_PTZ_INFO struThermalPTZPos;
    NET_DVR_LLPOS_PARAM struLLPos;
    NET_VCA_RECT  struSmokePos;
    BYTE   byRes[256];
}NET_DVR_SMOKEDETECTION_ALARM, *LPNET_DVR_SMOKEDETECTION_ALARM;

//Sensor Info
typedef struct tagNET_DVR_SENSOR_PARAM
{
    BYTE        bySensorType;//SensorType:0-CCD,1-CMOS
    BYTE        byRes[31];
    float       fHorWidth;//Horizontal Width
    float       fVerWidth;//Vertical Width
    float       fFold;//Fold
}NET_DVR_SENSOR_PARAM,*LPNET_DVR_SENSOR_PARAM;

//PTZ Param
typedef struct
{
    float   fPanPos;//Pan Pos
    float   fTiltPos;//Tilt Pos
    float   fZoomPos;//Zoom Pos
    BYTE    byRes[16] ;
}NET_DVR_PTZPOS_PARAM, *LPNET_DVR_PTZPOS_PARAM;

//GIS Info
typedef struct tagNET_DVR_GIS_UPLOADINFO
{
    DWORD   dwSize;
    DWORD     dwRelativeTime; //Relative Time
    DWORD    dwAbsTime; //Abs Time
    NET_VCA_DEV_INFO    struDevInfo;//Device Info
    float   fAzimuth;//Azimuth
    BYTE    byLatitudeType;//Latitude Type,0-North latitude, 1-South latitude
    BYTE    byLongitudeType;//Longitude Type\A3\AC0-east\A3\AC1-West
    BYTE    byRes1[2] ;
    NET_DVR_LLI_PARAM    struLatitude;     /*Latitude*/
    NET_DVR_LLI_PARAM    struLongitude; /*Longitude*/
    float   fHorizontalValue;//Horizontal Value
    float   fVerticalValue;//Vertical Value
    float   fVisibleRadius;//Visible Radius
    float   fMaxViewRadius;//Max View Radius
    NET_DVR_SENSOR_PARAM  struSensorParam;//Sensor Info
    NET_DVR_PTZPOS_PARAM  struPtzPos; //ptz
    BYTE  byRes[256];
}NET_DVR_GIS_UPLOADINFO,*LPNET_DVR_GIS_UPLOADINFO;

//prevent damage
typedef struct  tagNET_DVR_VANDALPROOF_ALARM
{
    DWORD        dwSize;
    DWORD         dwRelativeTime; //Relative Time
    DWORD        dwAbsTime; //Abs Time
    NET_VCA_DEV_INFO    struDevInfo;//Device Info
    BYTE  byRes[256];
}NET_DVR_VANDALPROOF_ALARM,*LPNET_DVR_VANDALPROOF_ALARM;

//Centralized Ctrl
typedef    struct tagNET_DVR_CENTRALIZEDCTRL_CFG
{
    DWORD        dwSize;
    BYTE        byEnable;
    BYTE        byLatitudeType;//Latitude Type,0-North latitude, 1-South latitude
    BYTE        byLongitudeType;//Longitude Type\A3\AC0-east\A3\AC1-West
    BYTE        byRes1;
    NET_DVR_LLI_PARAM    struLatitude;     /*Latitude*/
    NET_DVR_LLI_PARAM    struLongitude; /*Longitude*/
    DWORD       dwTimeOut;//Time Out
    BYTE        byControlType;//Control Type
    BYTE        byRes[127];
}NET_DVR_CENTRALIZEDCTRL_CFG,*LPNET_DVR_CENTRALIZEDCTRL_CFG;

//Gis Info
typedef struct tagNET_DVR_GIS_INFO
{
    DWORD  dwSize;
    float  fAzimuth;//Azimuth
    float  fHorizontalValue;//Horizontal Value
    float  fVerticalValue;//Vertical Value
    float  fVisibleRadius;//Visible Radius
    float  fMaxViewRadius;//Max View Radius
    BYTE   byLatitudeType;//Latitude Type,0-North latitude, 1-South latitude
    BYTE   byLongitudeType;//Longitude Type\A3\AC0-east\A3\AC1-West
    BYTE byPTZPosExEnable;
    BYTE byRes1;
    NET_DVR_LLI_PARAM      struLatitude;     /*Latitude*/
    NET_DVR_LLI_PARAM      struLongitude; /*Longitude*/
    NET_DVR_PTZPOS_PARAM  struPtzPos; //ptz
    NET_DVR_SENSOR_PARAM  struSensorParam;//Sensor Info
    NET_PTZ_INFO struPtzPosEx;
    float   fMinHorizontalValue;
    float   fMaxHorizontalValue;
    float   fMinVerticalValue;
    float   fMaxVerticalValue;
    BYTE  byRes[220];
}NET_DVR_GIS_INFO,*LPNET_DVR_GIS_INFO;

//Equipment cruise mode
typedef	struct tagNET_DVR_CRUISE_PARAM
{
    DWORD    dwSize;
    BYTE    byCruiseMode;// cruise mode,0~continuous ,1~reset point
    BYTE    byRes[123];
}NET_DVR_CRUISE_PARAM, *LPNET_DVR_CRUISE_PARAM;

//Equipment environmental temperature and humidity information structure
typedef struct tagNET_DVR_TEMP_HUMI_INFO
{
    DWORD    dwSize;
    NET_DVR_TIME_V30  	struCurrentTime; // current time
    float        fTemperature;//Equipment environment temperature, accurate to two decimal places, (-273-1000 degrees c)
    float        fHumidity;// Equipment environment humidity, accurate to two decimal places. The unit is: %
    BYTE       byRes[256];
}NET_DVR_TEMP_HUMI_INFO, *LPNET_DVR_TEMP_HUMI_INFO;

typedef struct tagNET_SDK_POINT_THERMOMETRY
{
    float        fPointTemperature;/*Point temperature measuring the current temperature */
    NET_VCA_POINT  struPoint;//Point temperature measurement coordinates
    BYTE       byRes[20];
}NET_SDK_POINT_THERMOMETRY, *LPNET_SDK_POINT_THERMOMETRY;


typedef struct tagNET_SDK_REGION_THERMOMETRY
{
    float        	fMaxTemperature;//highest temperature
    float        	fMinTemperature;//lowest temperature
    float        	fAverageTemperature;//average temperature
    float        	fTemperatureDiff;//temperature difference
    NET_VCA_POLYGON struRegion;
    BYTE       byRes[20];
}NET_SDK_REGION_THERMOMETRY, *LPNET_SDK_REGION_THERMOMETRY;

typedef	struct tagNET_SDK_MANUALTHERM_RULE
{
    BYTE       byRuleID;//Rule ID 0 - said invalid, starting from 1
    BYTE       byEnable;
    BYTE       byRes1[2];
    char		 szRuleName[NAME_LEN/*32*/];//Rule name
    BYTE       byRuleCalibType;//Rules calibration type
    BYTE       byRes2[3];
    NET_SDK_POINT_THERMOMETRY struPointTherm;//Point temperature measurement
    NET_SDK_REGION_THERMOMETRY struRegionTherm; //Regional temperature measurement
    BYTE      byRes[512];
}NET_SDK_MANUALTHERM_RULE, *LPNET_SDK_MANUALTHERM_RULE;

typedef	struct tagNET_SDK_MANUAL_THERMOMETRY
{
    DWORD		dwSize;
    DWORD		dwChannel;
    DWORD  	dwRelativeTime; // relative time scale (read-only)
    DWORD    dwAbsTime;	  // absolute time scale (read-only)
    BYTE       byThermometryUnit;//Temperature measurement unit: 0 (\A1\E6), 1 (\A8H), 2 (K)
    BYTE       byDataType;//State of data types: 0 - testing, 1 - start, 2 - end (read-only)
    BYTE      byRes1[6];
    NET_SDK_MANUALTHERM_RULE struRuleInfo;
    BYTE      byRes[512];
}NET_SDK_MANUAL_THERMOMETRY, *LPNET_SDK_MANUAL_THERMOMETRY;

//Vandalproof Alarm Cfg
typedef    struct tagNET_DVR_VANDALPROOFALARM_CFG
{
    DWORD    dwSize;
    BYTE    bySensitivity;
    BYTE    byUploadEnabled;//Upload Enabled
    BYTE    byVoiceWarningEnabled;//Voice Warning Enabled
    BYTE    byEnable;
    BYTE    byRes[124];
}NET_DVR_VANDALPROOFALARM_CFG,*LPNET_DVR_VANDALPROOFALARM_CFG;

typedef    struct tagNET_DVR_AZIMUTHINFO
{
    DWORD        dwSize;
    float       fDegree;// azimuth degree (accurate to two decimal places)
    BYTE        byAzimuth;//azimuth info (0-northeast,1-northwest,2-southeast,3-southwest,4-east,5-west,6-south,7-north)
    BYTE        byRes[127];
}NET_DVR_AZIMUTHINFO,*LPNET_DVR_AZIMUTHINFO;

//Compass Cond
typedef    struct tagNET_DVR_COMPASS_COND
{
    DWORD        dwSize;
    DWORD        dwChannel;//Channel
    BYTE        byRes[128];
}NET_DVR_COMPASS_COND,*LPNET_DVR_COMPASS_COND;

typedef    struct tagNET_DVR_POSITION_CFG
{
    DWORD     dwSize;
    BYTE     bySoftWorkMode;//Work Mode 0-auto\A3\AC1-manual
    BYTE     byRes[127];
}NET_DVR_POSITION_CFG,*LPNET_DVR_POSITION_CFG;

typedef    struct tagNET_DVR_STREAMING_COND
{
    DWORD        dwSize;
    DWORD        dwChannel;
    BYTE        byStreamType;
    BYTE        byRes[127];
}NET_DVR_STREAMING_COND,*LPNET_DVR_STREAMING_COND;

//Satellite positioning Cfg
typedef    struct tagNET_DVR_SATELLITETIME_CFG
{
    DWORD        dwSize;
    BYTE        byEnable;//Enable
    BYTE        byRes;
    WORD        wTimeInterval;//Time Interval (s)
    BYTE        byRes1[124];
}NET_DVR_SATELLITETIME_CFG,*LPNET_DVR_SATELLITETIME_CFG;

//Vehicle Weight
typedef struct  tagNET_DVR_VEHICLE_WEIGHT_RESULT_
{
    BYTE      byIsOverWeight;         //Whether overweight
    BYTE      byAxleNum;              //Axle Num
    BYTE      byRes[2];
    float     fOverWeight;           //OverWeight
    float     fWeight;               //Vehice Weight
    float     fLimitWeight;          //Limit Weight
    float     fAxleLen;              //Axle Len
    char      sDevDescInfo[MAX_DEVDESC_LEN/*64*/]; //Device description information
    BYTE      byRes2[64];
}NET_DVR_VEHICLE_WEIGHT_RESULT, *LPNET_DVR_VEHICLE_WEIGHT_RESULT;

// Plate Result V50
typedef struct tagNET_DVR_PLATE_RESULT_V50
{
    DWORD   dwSize;        //Structure size
    DWORD   dwMatchNo;  //Matched Serial Number. (consisting of the vehicle serial number, data type and lane number)
    BYTE    byGroupNum;    //Amount of the picture groups (the amount of pictures captured when one vehicle passing by. The data can be used for the Time Delay Matching.)
    BYTE    byPicNo;    //Continuous captured pictures serial number. (indicating the complete of the receiving.)
    BYTE    bySecondCam;    //Whether set the second camera to snapshot (e.g. prospect camera of far and near scene capture, rear camera of front and rear capture\A3\A9
    BYTE    byFeaturePicNo; //electric alarm of running red light, which picture taken to be close-up, 0xff- not take
    BYTE    byDriveChan;    //Triggering lane No.
    BYTE    byVehicleType;     //Vehicle type,refer to VTR_RESULT
    BYTE    byDetSceneID;//Detecting Scene ID[1,4],
    BYTE    byVehicleAttribute;// 0- no additional attributes, 1- standard yellow cars (banner), 2- dangerous goods vehicle
    WORD    wIllegalType;       //Rules broken type adopts the international standard definition
    BYTE    byIllegalSubType[8];   //Rules broken sub-type
    BYTE    byPostPicNo;    //The captured picture number to be traffic mount picture when the rule is broken,0xff- not take
    BYTE    byChanIndex;        //Camera No. (reserved)
    WORD    wSpeedLimit;        //Speed upper limit(valid when overspeed)
    BYTE    byRes2[2];
    NET_DVR_PLATE_INFO  struPlateInfo;     //Plate info. structure
    NET_DVR_VEHICLE_INFO struVehicleInfo;    //Vehicle info
    BYTE    byMonitoringSiteID[48];        //Camera No.
    BYTE    byDeviceID[48];                //Device No.
    BYTE    byDir;            //Monitoring direction; 1- Up, 2- Down, 3- Bi-directional, 4- Westward, 5- Northward, 6-Eastward, 7-Southward, 8-Other directio
    BYTE    byDetectType;    //Detecting methods: 1- Triggered by induction coil, 2- Triggered by video, 3- Triggered by multi-frame detection, 4-Triggered by radar.
    BYTE    byRelaLaneDirectionType;//ITC_RELA_LANE_DIRECTION_TYPE
    BYTE    byRes3;
    DWORD   dwCustomIllegalType; //Custom Illegal Type
    BYTE    byRes4[9];
    BYTE    byPilotSafebelt;//Pilot Safe belt
    BYTE    byCopilotSafebelt;//Copilot Safe belt
    BYTE    byPilotSunVisor;//Pilot Sun Visor
    BYTE    byCopilotSunVisor;//Copilot Sun Visor
    BYTE    byPilotCall;// Pilot Call
    //The 0-open, 1-close(dedicated to the historical data based on black and white list matching, whether to open a sign of success)
    BYTE    byBarrierGateCtrlType;
    BYTE    byAlarmDataType;//0-RealTime Data\A3\AC1-Historical Data
    NET_DVR_TIME_V30  struSnapFirstPicTime;//End time (MS) (captured the first picture time.)
    DWORD   dwIllegalTime;//Illegal duration (MS) = captured the last picture time - to capture the first picture of the time
    DWORD   dwPicNum;        //The picture count (different with picGroupNum, represent the picture count attached by this information, picture info defined by struVehicleInfoEx
    NET_ITS_PICTURE_INFO struPicInfo[6];         //Picture info, check picture, at most 6 pictures at one time
    NET_DVR_VEHICLE_WEIGHT_RESULT struWeightResult; //Vehicle Weight
    BYTE     byRes[256];
}NET_DVR_PLATE_RESULT_V50, *LPNET_DVR_PLATE_RESULT_V50;

typedef struct _NET_DVR_NORMAL_SCHEDTIME_
{
    NET_DVR_SCHEDTIME struTime;
    BYTE byAlarmType;//0-out arm\A3\AC1-stay arm\A3\AC2-immedately arm\A3\AC3-disarm
    BYTE byRes[3];
}NET_DVR_NORMAL_SCHEDTIME,*LPNET_DVR_NORMAL_SCHEDTIME;


typedef struct tagNET_DVR_SUBSYSTEM_ALARM
{
    DWORD dwSize;
    NET_DVR_NORMAL_SCHEDTIME struNormalSchedtime[MAX_DAYS][MAX_TIMESEGMENT_V30];
    BYTE byNormalSchedTimeOn;
    BYTE byMandatoryAlarm;//0-unforced arm\A3\AC1-forced arm
    BYTE byRes[254];
}NET_DVR_SUBSYSTEM_ALARM,*LPNET_DVR_SUBSYSTEM_ALARM;

#define MAX_WHITELIST_PHONE_NUM      16

typedef struct _NET_DVR_ALARM_PHONECFG
{
    DWORD    dwSize;
    BYTE    byEnable; //0-disable\A3\AC1-enable
    BYTE    byRes1[3];
    BYTE    byPhoneNumber[MAX_PHONE_NUM/*32*/];
    DWORD    dwArmRight;
    DWORD    dwDisArmRight;
    DWORD    dwClearAlarmRight;
    BYTE    byZoneReport[MAX_ALARMHOST_ALARMIN_NUM/*512*/];
    DWORD    dwNonZoneReport;
    BYTE    byIntervalTime;
    BYTE    byRes2;
    WORD    wDefineIntervalTime;
    BYTE    byRes3[128];
}NET_DVR_ALARM_PHONECFG, *LPNET_DVR_ALARM_PHONECFG;

typedef struct tagNET_DVR_MODULE_INFO
{
    DWORD    dwSize;
    BYTE    byModuleType;    //1-Keyboard\A3\AC2-trigger\A3\AC3-zone
    BYTE    byKeyBoardType;    //1-LCD,2-LED
    BYTE    byTriggerType;    //1--local trigger\A3\AC 2--4 trigger\A3\AC3--8 trigger\A3\AC4--single trigger\A3\AC5--32 trigger
    BYTE    byZoneType;        //1--local zone\A3\AC2--single zone\A3\AC3--double zone\A3\AC4--8 zone\A3\AC5--8 sensor zone\A3\AC 6-1Zone&Trigger
    WORD    wModuleAddress;    //0~255\A3\AC0xFFFF--invalid
    BYTE    byRes2[2];
    char    sModelInfo[32];
    char    sDeviceVersionInfo[32];
    BYTE    byRes[128];
}NET_DVR_MODULE_INFO,*LPNET_DVR_MODULE_INFO;

typedef struct tagNET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40
{
    BYTE                       byEnable;
    BYTE                       byRes1[3];
    NET_DVR_SCHEDDATE          struDate;
    NET_DVR_OUTPUT_SCHEDULE    struOutputSchedule[MAX_TIMESEGMENT_V30/*8*/];
    BYTE                       byTriggerIndex[MAX_ALARMHOST_ALARMOUT_NUM];
    BYTE                       byRes2[64];
}NET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40,*LPNET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40;

typedef struct tagNET_DVR_OUTPUT_SCHEDULE_RULECFG_V40
{
    DWORD  dwSize;
    NET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40 struOutputRule[MAX_RULE_NUM/*8*/];
    BYTE   byRes[64];
}NET_DVR_OUTPUT_SCHEDULE_RULECFG_V40,*LPNET_DVR_OUTPUT_SCHEDULE_RULECFG_V40;

typedef struct tagNET_DVR_ONE_OUTPUT_SCH_RULECFG_V40
{
    DWORD        dwSize;
    NET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40 struOutputRule;
    BYTE        byRes[256];
}NET_DVR_ONE_OUTPUT_SCH_RULECFG_V40,*LPNET_DVR_ONE_OUTPUT_SCH_RULECFG_V40;

typedef struct tagNET_DVR_ALARM_CAPTRUE_CFG
{
    DWORD        dwSize;
    BYTE        byBeforeAlarmPic;
    BYTE        byAfterAlarmPic;
    WORD          wInterval;
    BYTE        byResolution;//1-CIF\A3\AC2-2CIF\A3\AC3-4CIF\A3\AC4-QCIF\A3\AC5-WD1\A3\AC6-VGA,7-XVGA\A3\AC8-720P\A3\AC9-1080P
    BYTE           byRes[63];
}NET_DVR_ALARM_CAPTRUE_CFG, *LPNET_DVR_ALARM_CAPTRUE_CFG;

#define PRIOR_SCHEDTIME            30

typedef struct _NET_DVR_PRIOR_SCHEDTIME_
{
    DWORD    dwSize;
    NET_DVR_SCHEDDATE struData;
    NET_DVR_NORMAL_SCHEDTIME struOneDayTime[8];
    BYTE    byEnable;
    BYTE    byRes1[3];
    BYTE    bySubSystem[32];
    BYTE    byMandatoryAlarm;
    BYTE    byRes[63];
}NET_DVR_PRIOR_SCHEDTIME,*LPNET_DVR_PRIOR_SCHEDTIME;

typedef struct tagNET_DVR_TAMPER_ALARMIN_PARAM
{
    DWORD   dwSize;
    BYTE    byTamperType;
    BYTE    byUploadAlarmRecoveryReport;
    BYTE    byRes1[2];
    BYTE    byAssociateAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM];
    BYTE    byAssociateSirenOut[8];
    BYTE    byTamperResistor;//0-invalid 1-2.2 \A3\AC2--3.3, 3-4.7 \A3\AC4-5.6 \A3\AC 5-8.2 \A3\AC0xff-manual
    BYTE    byRes2[3];
    float    fTamperResistorManual;
    BYTE    byRes3[36];
}NET_DVR_TAMPER_ALARMIN_PARAM, *LPNET_DVR_TAMPER_ALARMIN_PARAM;

typedef struct tagNET_DVR_REMOTECONTROLLER_PERMISSION_CFG
{
    DWORD    dwSize;
    BYTE    byEnable;
    BYTE    byRes1;
    WORD    wRemoteCtrllerID;//start from 1
    BYTE    sDevSn[16];
    BYTE    byArmRight;
    BYTE    byDisArmRight;
    BYTE    byArmReportRight;
    BYTE    byDisArmReportRight;
    BYTE    byClearAlarmRight;
    BYTE    bySubSystemID;       /* 1~8 */
    BYTE    byKeyboardAddr;
    BYTE    byRes2[65];
}NET_DVR_REMOTECONTROLLER_PERMISSION_CFG, *LPNET_DVR_REMOTECONTROLLER_PERMISSION_CFG;


typedef struct tagNET_DVR_KEYBOARD_CFG
{
    DWORD    dwSize;
    BYTE    byEnableLock;    //enable keyborad alarm  0-disable\A3\AC1-enable
    BYTE    byErrorTimes;    //enter error password times, then lock the keyborad
    WORD    wLockTime;        //lock time,sencond
    BYTE    byRes[128];
}NET_DVR_KEYBOARD_CFG, *LPNET_DVR_KEYBOARD_CFG;

typedef struct tagNET_DVR_ALARMHOST_WIRELESS_BUSINESS_COND
{
    DWORD    dwSize;
    BYTE    byCommOperatorNum[NAME_LEN/*32*/];//communication operator munber
    BYTE    byQueryCode[16];
    BYTE    byBusinessType;//0-fare,1-flow
    BYTE    byRes[35];
}NET_DVR_ALARMHOST_WIRELESS_BUSINESS_COND, *LPNET_DVR_ALARMHOST_WIRELESS_BUSINESS_COND;

typedef struct tagNET_DVR_ALARMHOST_WIRELESS_BUSINESS_INFO
{
    DWORD    dwSize;
    BYTE    by3GBusiness[1024];//3G business message
    BYTE    byRes[32];
}NET_DVR_ALARMHOST_WIRELESS_BUSINESS_INFO, *LPNET_DVR_ALARMHOST_WIRELESS_BUSINESS_INFO;

typedef struct tagNET_DVR_PREVIEW_DELAY_CFG
{
    DWORD    dwSize;
    WORD    wdelayTime;//delay preview time\A3\ACunit:second
    BYTE    byRes[130];
}NET_DVR_PREVIEW_DELAY_CFG, *LPNET_DVR_PREVIEW_DELAY_CFG;

typedef struct tagNET_DVR_AUXILIARY_DEV_UPGRADE_PARAM
{
    DWORD	dwSize;
    DWORD	dwDevNo;
    BYTE	byDevType;	//0-keyboard, 1- movement,2-net module
    BYTE	byRes[131];
}NET_DVR_AUXILIARY_DEV_UPGRADE_PARAM,*LPNET_DVR_AUXILIARY_DEV_UPGRADE_PARAM;

typedef struct tagNET_DVR_CALL_ROOM_CFG
{
    DWORD    dwSize;
    SHORT   nFloorNumber;    //floor number
    WORD    wRoomNumber;    //rom number
    BYTE    byManageCenter;    //whether call manage center
    BYTE    byRes[127];
}NET_DVR_CALL_ROOM_CFG,*LPNET_DVR_CALL_ROOM_CFG;

typedef struct tagNET_DVR_VIDEO_CALL_COND
{
    DWORD    dwSize;
    BYTE    byRes[128];
}NET_DVR_VIDEO_CALL_COND,*LPNET_DVR_VIDEO_CALL_COND;

typedef struct tagNET_DVR_VIDEO_CALL_PARAM
{
    DWORD    dwSize;
    DWORD   dwCmdType;      //Signaling type 0- to cancel the call, answer the call 1- 2- refused to local incoming call 3- called 4- the end of the call bell timeout 5-end call 6-device is calling 7-client is call 8-indoor not online
    WORD wPeriod;  //
    WORD wBuildingNumber; //
    WORD wUnitNumber;  //
    SHORT wFloorNumber;  //
    WORD  wRoomNumber;    //
    BYTE    byRes[118];
}NET_DVR_VIDEO_CALL_PARAM,*LPNET_DVR_VIDEO_CALL_PARAM;


typedef struct tagNET_DVR_INQUEST_CASE_INFO
{
    DWORD    dwSize;
    BYTE    sCaseNo[INQUEST_CASE_NO_LEN];
    BYTE    sCaseName[INQUEST_CASE_NAME_LEN];
    BYTE    sCustomInfo1[CUSTOM_INFO_LEN];
    BYTE    sCustomInfo2[CUSTOM_INFO_LEN];
    BYTE    sCustomInfo3[CUSTOM_INFO_LEN];
    BYTE    byShowCaseInfoTime; /* 1~60s*/
    BYTE    byShowCaseInfo;    //0-not\A3\AC1-display
    BYTE    byPosition;        //0-up-left\A3\AC1-bottom-left
    BYTE    byRes[257];
}NET_DVR_INQUEST_CASE_INFO, *LPNET_DVR_INQUEST_CASE_INFO;

typedef struct tagNET_DVR_CASE_INFO_CTRL_PARA
{
    DWORD    dwSize;
    DWORD    dwChannel;
    BYTE    byShowCaseInfoTime;
    BYTE    byRes[131];
}NET_DVR_CASE_INFO_CTRL_PARAM, *LPNET_DVR_CASE_INFO_CTRL_PARA;

typedef struct tagNET_DVR_INQUEST_USER_RIGHT_CFG
{
    DWORD    dwSize;
    BYTE    byLocalRight[MAX_RIGHT];
    BYTE    byRemoteRight[MAX_RIGHT];
    BYTE    byNetAudioRight[MAX_CHANNUM_V40];
    BYTE    byRes[512*9];
}NET_DVR_INQUEST_USER_RIGHT_CFG, *LPNET_DVR_INQUEST_USER_RIGHT_CFG;

typedef struct tagNET_DVR_INQUEST_MIX_AUDIOIN_CFG
{
    DWORD    dwSize;
    BYTE    byEnable;    //0-disable\A3\AC1-enable
    BYTE    byRes1[3];
    DWORD    dwMixCnt;
    BYTE    bySrcChan[MAX_MIX_CHAN_NUM];
    BYTE    byLineIn[MAX_LINE_IN_CHAN_NUM];
    BYTE    byMic[MAX_MIC_CHAN_NUM];
    BYTE    byMixAudioDelay;    //0-63
    BYTE    byRes2[127];
}NET_DVR_INQUEST_MIX_AUDIOIN_CFG, *LPNET_DVR_INQUEST_MIX_AUDIOIN_CFG;

//*************************************************************
typedef struct tagNET_DVR_FACECAPTURE_STATISTICS_COND
{
    DWORD dwSize;
    DWORD   dwChannel;
    NET_DVR_TIME_EX   struStartTime;
    BYTE   byReportType;//report Type\A3\BA1-day\A3\AC2-week\A3\AC3-month\A3\AC4-year
    BYTE   byStatType;//stat Type\A3\BABit0-age\A3\ACBit1-sex\A3\ACBit2-number of people
    BYTE   byEnableProgramStatistics; //According to the statistics show, 0 - no, 1 - is
    BYTE   byRes1;
    DWORD  dwPlayScheduleNo; //According to the statistics show the related schedule number
    BYTE   byRes[120];
}NET_DVR_FACECAPTURE_STATISTICS_COND,*LPNET_DVR_FACECAPTURE_STATISTICS_COND;

typedef struct tagNET_DVR_AGEGROUP_PARAM_
{
    DWORD   dwTeenage;
    DWORD    dwYouth;
    DWORD    dwMidLife;
    DWORD    dwElderly;
    BYTE   byRes[64];
}NET_DVR_AGEGROUP_PARAM,*LPNET_DVR_AGEGROUP_PARAM;

typedef struct tagNET_DVR_SEXGROUP_PARAM_
{
    DWORD   dwMale;
    DWORD    dwFemale;
    BYTE   byRes[64];
}NET_DVR_SEXGROUP_PARAM,*LPNET_DVR_SEXGROUP_PARAM;

typedef struct tagNET_DVR_FACECAPTURE_STATISTICS_RESULT_
{
    DWORD dwSize;
    NET_DVR_TIME_EX   struStartTime;
    NET_DVR_TIME_EX   struEndTime;
    BYTE   byStatType;//stat Type\A3\BABit0-age\A3\ACBit1-sex\A3\ACBit2-number of people
    BYTE   byRes[7];
    DWORD  dwPeopleNum;
    NET_DVR_AGEGROUP_PARAM  struAgeGroupParam;
    NET_DVR_SEXGROUP_PARAM  struSexGroupParam;
    NET_DVR_PROGRAM_INFO struProgramInfo;        //program info
    BYTE   byRes1[76];
}NET_DVR_FACECAPTURE_STATISTICS_RESULT,*LPNET_DVR_FACECAPTURE_STATISTICS_RESULT;

//Traffic Data Query Cond
typedef struct tagNET_DVR_TRAFFIC_DATA_QUERY_COND_
{
    DWORD  dwSize;
    DWORD  dwQueryCond;//Query Cond
    DWORD  dwChannel;//Channel
    NET_DVR_TIME_V30 struStartTime;//Start Time
    NET_DVR_TIME_V30 struEndTime;//End Time
    char   sLicense[MAX_LICENSE_LEN/*16*/];//sLicense
    DWORD  dwPlateType;//Plate Type
    DWORD  dwPlateColor;//Plate Color
    DWORD  dwVehicleColor;//Vehicle Color
    DWORD  dwVehicleType;//Vehicle Type
    DWORD  dwIllegalType;//Illegal Type
    DWORD  dwEventType;//Event Type
    DWORD  dwForensiceType;// Forensice Type
    WORD   wVehicleLogoRecog;  //Vehicle Logo Recog
    BYTE   byLaneNo;//Lane No
    BYTE   byDirection;//Direction
    WORD   wMinSpeed;//Min Speed
    WORD   wMaxSpeed;//Max Speed
    BYTE   byDataType;//Data Type
    BYTE   byExecuteCtrl;//Execute Ctrl
    BYTE   byRes[254];
}NET_DVR_TRAFFIC_DATA_QUERY_COND,*LPNET_DVR_TRAFFIC_DATA_QUERY_COND;

//Traffic Picture Param
typedef struct tagNET_DVR_TRAFFIC_PICTURE_PARAM_
{
    NET_DVR_TIME_V30     struRelativeTime; //Relative Time
    NET_DVR_TIME_V30    struAbsTime;  //Abs Time
    char szPicName[PICTURE_NAME_LEN/*64*/];//Pictrue Name
    BYTE  byPicType;//Pictrue Type
    BYTE  byRes[63];
}NET_DVR_TRAFFIC_PICTURE_PARAM,*LPNET_DVR_TRAFFIC_PICTURE_PARAM;

//Traffic Data Query
typedef struct tagNET_DVR_TRAFFIC_DATA_QUERY_RESULT_
{
    DWORD  dwSize;
    DWORD  dwChannel;//Channel\A3\A8[1~32]\A3\A9
    char   sLicense[MAX_LICENSE_LEN/*16*/];
    DWORD  dwPlateType;//Plate Type
    DWORD  dwPlateColor;//Plate Color
    DWORD  dwVehicleColor;//Vehicle Color
    DWORD  dwVehicleType;//Vehicle Type
    DWORD  dwIllegalType;//Illegal Type
    DWORD  dwEventType;//Event Type
    DWORD  dwForensiceType;//Forensice Type
    WORD   wVehicleLogoRecog;  //Vehicle Logo Recog
    BYTE   byLaneNo;//Lane No
    BYTE   byDirection;//Direction
    WORD   wSpeed;//Speed
    BYTE   byDataType;//Data Type
    BYTE   byRes[253];
    NET_DVR_TRAFFIC_PICTURE_PARAM struTrafficPic[MAX_TRAFFIC_PICTURE_NUM/*8*/];
}NET_DVR_TRAFFIC_DATA_QUERY_RESULT,*LPNET_DVR_TRAFFIC_DATA_QUERY_RESULT;

//Traffic Flow Query Cond
typedef struct tagNET_DVR_TRAFFIC_FLOW_QUERY_COND_
{
    DWORD  dwSize;
    DWORD  dwQueryCond;//Query Cond
    DWORD  dwChannel;//Channel
    DWORD  dwResChan[10];//Res Chan
    NET_DVR_TIME_V30 struStartTime;//Start Time
    NET_DVR_TIME_V30 struEndTime;//End Time
    BYTE   byLaneNo;//Lane No
    BYTE   byRes[255];
}NET_DVR_TRAFFIC_FLOW_QUERY_COND,*LPNET_DVR_TRAFFIC_FLOW_QUERY_COND;

//Traffic Flow Query
typedef struct tagNET_DVR_TRAFFIC_FLOW_QUERY_RESULT_
{
    DWORD  dwSize;
    NET_DVR_TIME_V30 struStartTime;//Start Time
    NET_DVR_TIME_V30 struEndTime;//End Time
    DWORD  dwChannel;//Channel
    DWORD  dwFlow;//Flow
    BYTE   byLaneNo;//Lane No
    BYTE   byRes[511];
}NET_DVR_TRAFFIC_FLOW_QUERY_RESULT,*LPNET_DVR_TRAFFIC_FLOW_QUERY_RESULT;


typedef struct tagNET_DVR_PIC_INFO
{
    BYTE   byPicType;        //picture Type,0-jpg
    BYTE   byRes1[3];
    DWORD  dwPicWidth;       //picture width
    DWORD  dwPicHeight;      //picture height
    DWORD  dwPicDataLen;     //pic Data length
    char*  byPicDataBuff;
    BYTE   byRes2[32];
}NET_DVR_PIC_INFO,*LPNET_DVR_PIC_INFO;

typedef struct tagNET_DVR_VCA_RULE_COLOR_CFG
{
    DWORD       dwSize;
    BYTE       byEnable;       //Enabled  0-disable, 1-enable
    BYTE       byRuleID;       //Rule ID
    BYTE       byColorBlockNo;  //color block no. ,Start From 1
    BYTE       byRes1;
    NET_DVR_PIC_INFO  struPicInfo;  //picture color info
    BYTE     byRes[64];
}NET_DVR_VCA_RULE_COLOR_CFG,*LPNET_DVR_VCA_RULE_COLOR_CFG;

typedef struct tagNET_DVR_VCA_RULE_COLOR_COND
{
    DWORD        dwSize;
    DWORD       dwChannel;      //Channel No
    BYTE        byRuleID;       //Relate ID
    BYTE        byRes[127];
}NET_DVR_VCA_RULE_COLOR_COND,*LPNET_DVR_VCA_RULE_COLOR_COND;

typedef struct tagNET_DVR_SWITCH_LAMP_CFG
{
    DWORD        dwSize;
    BYTE        byEnable;
    BYTE        byTriggerMode;
    BYTE        byUploadPic;
    BYTE        byRes1;
    DWORD       dwTimeInterval;
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;
    BYTE        byRelRecordChan[MAX_IVMS_IP_CHANNEL];
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//Alarm Time
    BYTE        byRes[256];
}NET_DVR_SWITCH_LAMP_CFG,*LPNET_DVR_SWITCH_LAMP_CFG;

typedef struct tagNET_DVR_SWITCH_LAMP_ALARM
{
    DWORD                dwSize;
    NET_VCA_DEV_INFO    struDevInfo;        //Device Info
    NET_DVR_TIME_EX     struTime;           //Alarm Time
    BYTE                byLampStatus;       //Lamp Status 0-closed  1-opened
    BYTE                byRes1[3];
    DWORD               dwPicDataLen;
    char*               pPicData;
    BYTE                byRes[64];
}NET_DVR_SWITCH_LAMP_ALARM,*LPNET_DVR_SWITCH_LAMP_ALARM;

typedef struct tagNET_DVR_RS485_CASCADE_CFG
{
    DWORD    dwSize;
    BYTE    byDevAddr;    //0-master device\A3\AC1-15 slave device
    BYTE    byRes[131];
}NET_DVR_RS485_CASCADE_CFG,*LPNET_DVR_RS485_CASCADE_CFG;

//Private Protocol Cfg
typedef struct tagNET_DVR_PRIVATE_PROTOCOL_CFG
{
    DWORD          dwSize;
    NET_DVR_IPADDR     struIP; //IP
    WORD          wPort;//Port
    BYTE         byRes[2];
    DWORD        dwInterval;//Intercal
    BYTE         byServerType;//Server Type
    BYTE         byEcryptedSMSEnable;//Ecrypted SMS Enable
    BYTE         byAlgorithm;//Algorithm
    BYTE         byAcauisitionMode;//The acquisition mode, 0 - basic information, 1 - virtual identity information, 2 - basic information + virtual identity information
    DWORD        dwDistanceLimit;//Distance limit, the unit: m
    BYTE         byRes1[216];
    char         szIndexCode[MAX_INDEX_CODE_LEN];
    DWORD        dwSecretKeyLen;//Secret Key Len
    char         szSecretKey[MAX_SECRETKEY_LEN/*512*/];//Secret Key
}NET_DVR_PRIVATE_PROTOCOL_CFG,*LPNET_DVR_PRIVATE_PROTOCOL_CFG;

//Debug CMD
typedef struct tagNET_DVR_DEBUG_CMD
{
    DWORD     dwSize;
    char  szDebugCMD[MAX_DEBUGCMD_LEN/*1024*/];
    BYTE  byRes[400];
}NET_DVR_DEBUG_CMD,*LPNET_DVR_DEBUG_CMD;

//Debug Info
typedef struct tagNET_DVR_DEBUG_INFO
{
    DWORD     dwSize;
    char  szDebugInfo[MAX_DEBUGINFO_LEN/*1400*/];
    BYTE  byRes[32];
}NET_DVR_DEBUG_INFO,*LPNET_DVR_DEBUG_INFO;



#define MAX_SSID_LEN    32   //SSID len
#define MAX_WS_PASSWD_LEN    64   //passwd len
typedef    struct tagNET_DVR_WIRELESSSERVER
{
    DWORD        dwSize;
    BYTE        byWLanShare;//whether use wlan share, 0-close\A3\AC1-open
    BYTE        byBroadcastSSID;//whether use SSID broadcast 0-close\A3\AC1-open
    BYTE        bySecurityMode;//security mode, 0- not-encrypted\A3\AC1-WPA\A3\AC2-WPA2(now only support 2)
    BYTE        byAlgorithmType; //algorithm type 1-TKIP\A3\AC2-AES
    char        szSSID[MAX_SSID_LEN/*32*/];//ssid
    char        szPassWord[MAX_WS_PASSWD_LEN/*64*/]; //passwd
    BYTE        byDefaultPassword;//whether default password 0-no\A3\AC1-yes
    BYTE        byRes[255];
}NET_DVR_WIRELESSSERVER,*LPNET_DVR_WIRELESSSERVER;

typedef    struct tagNET_DVR_CONNECTDEV_COND
{
    DWORD       dwSize;
    DWORD        dwChannel;
    BYTE        byRes[128];
}NET_DVR_CONNECTDEV_COND,*LPNET_DVR_CONNECTDEV_COND;

typedef    struct tagNET_DVR_CONNECTDEV_CFG
{
    DWORD       dwSize;
    BYTE        byID;//serial number
    BYTE        byRes[1];
    BYTE        byMACAddr[MACADDR_LEN/*6*/];    //mac address
    NET_DVR_IPADDR    struDVRIP;//DVR ip
    NET_DVR_TIME  struConnectTime;// connect time
    BYTE        byRes1[256];
}NET_DVR_CONNECTDEV_CFG,*LPNET_DVR_CONNECTDEV_CFG;

#define MAX_SIGNAL_JOINT_NUM       64  //max signal joint scale
typedef struct tagNET_DVR_SIGNAL_JOINT_CFG
{
    DWORD    dwSize;
    BYTE  sCamName[NAME_LEN] ;  //joint signal name
    BYTE  byEnable;               //enabled\A3\AC0-disabled,!0-enabled
    BYTE  byCamMode ;            //joint signal type,NET_DVR_CAM_JOINT
    BYTE  byRows ;               //row number
    BYTE  byColumns ;            //column number
    DWORD dwSignalNo[MAX_SIGNAL_JOINT_NUM]; //signal No.,former byRows* byColumns items are valid
    DWORD dwJointNo;           //joint No., read only
    DWORD dwSignalNoJoint;      //joint signal No.,read only
    BYTE  byRes[64];
} NET_DVR_SIGNAL_JOINT_CFG, *LPNET_DVR_SIGNAL_JOINT_CFG;

typedef struct  tagNET_DVR_SIGNAL_CUTPARAM
{
    DWORD    dwSize;
    DWORD    dwSignalNo;     //signal No.
    DWORD     dwCutTop;      //top pixels,0-restore
    DWORD      dwCutBottom;   //bottom pixels,0-restore
    DWORD      dwCutLeft;     //left pixels,0-restore
    DWORD      dwCutRight;    //right pixels,0-restore
    BYTE     byRes2[32];
} NET_DVR_SIGNAL_CUTPARAM, *LPNET_DVR_SIGNAL_CUTPARAM;

typedef struct tagNET_DVR_WALL_RELATION_CFG
{
    DWORD dwSize;
    BYTE  byEnable;           //enable relation,0-disabled,
    BYTE  byRealWallNo ;  	  //real wall No.
    BYTE  byRes[14] ;
}NET_DVR_WALL_RELATION_CFG, *LPNET_DVR_WALL_RELATION_CFG;


typedef struct tagNET_DVR_INPUTSTREAMCFG_V40
{
    DWORD        dwSize ;
    BYTE        byValid ;     //0-invalid,!0-valid
    BYTE        byCamMode ;//reference to NET_DVR_CAM_MODE
    WORD        wInputNo ; //input signal No.
    BYTE        sCamName[NAME_LEN] ; //signal name
    NET_DVR_VIDEOEFFECT     struVideoEffect ;//video effect parameters
    NET_DVR_PU_STREAM_CFG    struPuStream ;    //ip signal configurations
    WORD        wBoardNum ;      //sub board No.,read only
    WORD        wInputIdxOnBoard ; //index of signal in sub board,read only
    DWORD    dwResolution ;//resolution
    BYTE    byVideoFormat ;//video format, reference to VIDEO_STANDARD
    BYTE    byStatus;    //signal status,0-invalid, 1-signal normal, 2-no signal, 3-exception
    BYTE    sGroupName[NAME_LEN/*32*/];    //signal group name
    BYTE    byJointMatrix ;            //relate matrix,0-not related,1-related,valid when signal type is NET_DVR_CAM_BNC or NET_DVR_CAM_VGA or NET_DVR_CAM_DVI or NET_DVR_CAM_HDMI
    BYTE    byJointNo ;         //joint No.,read only
    BYTE    byColorMode;      //color mode, 0-self define, 1-sharp, 2-normal, 3-soft,struVideoEffect is valid when color mode is self define
    BYTE    byScreenServer; //related to screen server\A3\AC0-not related\A3\AC1-related
    BYTE   byRes1[2];
    DWORD	dwInputSignalNo; //input signal No.\A3\A8new\A3\A9
    BYTE	byRes[120];
}NET_DVR_INPUTSTREAMCFG_V40, *LPNET_DVR_INPUTSTREAMCFG_V40 ;

typedef struct  tagNET_DVR_INPUTSTREAM_PTZCFG_PARAM
{
    DWORD    dwSize;
    WORD     wPTZProtocol;  //PTZ control protocol
    BYTE     byRes[34];
}NET_DVR_INPUTSTREAM_PTZCFG_PARAM, *LPNET_DVR_INPUTSTREAM_PTZCFG_PARAM;

typedef struct tagNET_DVR_GIS_SERVER_INFO
{
    BYTE  byUserName[NAME_LEN];
    BYTE  byPassword[PASSWD_LEN];
    NET_DVR_IPADDR struServerIP;     //GIS server IP address
    WORD  wPort;    //GIS server port
    BYTE  byRes[30];
}NET_DVR_GIS_SERVER_INFO, *LPNET_DVR_GIS_SERVER_INFO;

typedef struct tagNET_DVR_BASEMAP_CONTROL_CFG_V40
{
    DWORD dwSize;
    BYTE  byEnable;        //whether show base map,1-show,0-hide
    BYTE  byBaseMapType;    //base map type,1-picture,2-virtual screen,3-GIS
    BYTE  byRes1[2];
    DWORD dwBaseMapNo;     /*base map No. ,Base map type 1:picture No;Basemap type 2:virtual screen input No.(1byte:video platform No.
    +1byte:sub board No.+1byte:input No.+1byte:0)*/
    NET_DVR_GIS_SERVER_INFO struGisServer;    //GIS server information,valid when base map type is GIS
    BYTE  byRes2[64];
}NET_DVR_BASEMAP_CONTROL_CFG_V40,*LPNET_DVR_BASEMAP_CONTROL_CFG_V40;


typedef struct tagNET_DVR_VIDEO_IMG_DB_CFG
{
    DWORD        dwSize;
    INT64       i64Capacity;
    INT64        i64UsedSpace;
    INT64        i64AvailableSpace;
    BYTE          byRes[256];
}NET_DVR_VIDEO_IMG_DB_CFG, *LPNET_DVR_VIDEO_IMG_DB_CFG;

typedef struct tagNET_DVR_FILE_QUERY_INFO
{
    DWORD        dwSize;
    INT64       i64FileLen;
    BYTE          byRes[256];
}NET_DVR_FILE_QUERY_INFO, *LPNET_DVR_FILE_QUERY_INFO;

typedef struct tagNET_DVR_FILE_INFO_IN
{
    char        szFileID[MAX_FILE_ID_LEN];
    BYTE        byRes[256];
}NET_DVR_FILE_INFO_IN, *LPNET_DVR_FILE_INFO_IN;



typedef struct tagNET_DVR_UPLOAD_DB_IN
{
    INT64    i64FileLen;
    BYTE    byContinueUpload;
    BYTE       byRes[255];
}NET_DVR_UPLOAD_DB_IN, *LPNET_DVR_UPLOAD_DB_IN;


typedef struct tagNET_DVR_UPLOAD_DB_OUT
{
    char    szFileID[MAX_FILE_ID_LEN];
    BYTE    byRes[256];
}NET_DVR_UPLOAD_DB_OUT, *LPNET_DVR_UPLOAD_DB_OUT;



typedef struct tagNET_DVR_SEND_PARAM_IN
{
    BYTE    *pSendData;
    DWORD    dwSendDataLen;
    NET_DVR_TIME_V30    struTime;
    BYTE    byPicType;  //1-jpg,2-bmp,3-png,4-SWF,5-GIF
    BYTE    byRes1[3];
    DWORD   dwPicMangeNo;
    BYTE    sPicName[NAME_LEN];
    DWORD   dwPicDisplayTime;
    BYTE    byRes[200];
}NET_DVR_SEND_PARAM_IN, *LPNET_DVR_SEND_PARAM_IN;



typedef struct tagNET_DVR_DOWNLOAD_QOS
{
    DWORD    dwMaxSpeed;  //kbps
    BYTE    byRes[256];
}NET_DVR_DOWNLOAD_QOS, *LPNET_DVR_DOWNLOAD_QOS;

typedef struct tagNET_DOWNLOAD_CB_INFO
{
    DWORD         dwType;
    BYTE         *pData;
    DWORD         dwDataLen;
    void*       pFileInfo;
    DWORD       dwFileInfoLen;
    BYTE        byRes[120];
}NET_DOWNLOAD_CB_INFO, *LPNET_DOWNLOAD_CB_INFO;

typedef BOOL (*DOWNLOAD_DATA_CB)( LONG lHandle, NET_DOWNLOAD_CB_INFO *pCBInfo, void *pUserData);

typedef struct tagNET_DVR_DOWNLOAD_CB_PARAM
{
    DOWNLOAD_DATA_CB     fnDownloadDataCB;
    void                 *pUserData;
    INT64                i64Offset;
    BYTE                   byRes[256];
}NET_DVR_DOWNLOAD_CB_PARAM, *LPNET_DVR_DOWNLOAD_CB_PARAM;

//Film Mode Cfg
typedef struct tagNET_DVR_FILM_MODE_CFG
{
    DWORD   dwSize;
    BYTE    byScreenType;     //Screen Type
    BYTE    byRes[255];
}NET_DVR_FILM_MODE_CFG, *LPNET_DVR_FILM_MODE_CFG;

//Directed Strategy Cfg
typedef struct tagNET_DVR_DIRECTED_STRATEGY_CFG
{
    DWORD    dwSize;
    BYTE     byDirectedStrategyType; //Directed Strategy Type
    BYTE     byRes[255];
}NET_DVR_DIRECTED_STRATEGY_CFG, *LPNET_DVR_DIRECTED_STRATEGY_CFG;

//Frame
typedef struct NET_DVR_FRAME
{
    BYTE     byFrameWide; //Frame Wide
    BYTE     byRed;   //Red
    BYTE     byGreen; //Green
    BYTE     byBlue;  //Blue
    BYTE     byRes[256];
}NET_DVR_FRAME, *LPNET_DVR_FRAME;

//Frame Cfg
typedef struct tagNET_DVR_FRAME_CFG
{
    DWORD           dwSize;
    NET_DVR_FRAME    struTopFrame;    //Top Frame
    NET_DVR_FRAME    struBottomFrame;//Bottom Frame
    NET_DVR_FRAME    struLeftFrame;    //Left Frame
    NET_DVR_FRAME    struRightFrame;    //Right Frame
    BYTE            byFrameEnable;  //Frame Enable
    BYTE            byRes[256];
}NET_DVR_FRAME_CFG, *LPNET_DVR_FRAME_CFG;

//Frame Cond
typedef struct tagNET_DVR_FRAME_COND
{
    DWORD           dwSize;
    DWORD           dwPicNo;//picture No.
    BYTE            byRes[256];
}NET_DVR_FRAME_COND, *LPNET_DVR_FRAME_COND;

//Audio Effective Cfg
typedef struct tagNET_DVR_AUDIO_EFFECTIVE_CFG
{
    DWORD       dwSize;
    DWORD       dwCheckDelay;    //Check Delay
    BYTE        byThreshold;     //Threshold [0,100]
    BYTE        byVolumePercent;//Volume [0,100]
    BYTE        byPriority;     //Priority [0\A3\AC100]
    BYTE        byRes[301];
}NET_DVR_AUDIO_EFFECTIVE_CFG, *LPNET_DVR_AUDIO_EFFECTIVE_CFG;

//Record Video Cfg
typedef struct tagNET_DVR_RECORD_VIDEO_CFG
{
    DWORD       dwSize;
    BYTE        byExportType;         //Export Type;0-MP4 1-AVI
    BYTE        byRes[255];
} NET_DVR_RECORD_VIDEO_CFG, *LPNET_DVR_RECORD_VIDEO_CFG;

//RTMP Cond
typedef struct tagNET_DVR_RTMP_COND
{
    DWORD            dwSize;
    DWORD            dwChannel;
    BYTE             byStreamType;  //Stream Type
    BYTE             byRes[303];
}NET_DVR_RTMP_COND, *LPNET_DVR_RTMP_COND;

//RTMP Cfg
typedef struct tagNET_DVR_RTMP_CFG
{
    DWORD       dwSize;
    BYTE        byEnable;                        //Enable
    BYTE         byRes1[3];
    DWORD       dwPacketLen;                     //Packet Len
    char        szURL[RTMP_URL_LEN];            //RTMP URL
    BYTE         byRes[256];
}NET_DVR_RTMP_CFG, *LPNET_DVR_RTMP_CFG;

//File release
typedef  struct  tagNET_DVR_RECORDING_PUBLISH_FILE_CFG
{
    DWORD   dwSize;
    BYTE    byFileID[MAX_ID_LEN_128/*128*/];  //File ID
    NET_DVR_TIME_EX  struStartTime;  //Start Time
    NET_DVR_TIME_EX  struEndTime;   //End Time
    BYTE    byCmdType;  //Cmd Type
    BYTE   byRes[255];
}NET_DVR_RECORDING_PUBLISH_FILE_CFG, *LPNET_DVR_RECORDING_PUBLISH_FILE_CFG;

//File release Progress Cond
typedef struct tagNET_DVR_PUBLISH_PROGRESS_COND
{
    DWORD            dwSize;
    DWORD            dwChannel;
    BYTE             byFileID[MAX_ID_LEN_128/*128*/];  //File ID
    BYTE             byRes[256];
}NET_DVR_PUBLISH_PROGRESS_COND, *LPNET_DVR_PUBLISH_PROGRESS_COND;

//File release Progress Cfg
typedef struct tagNET_DVR_PUBLISH_PROGRESS_CFG
{
    DWORD    dwSize;
    BYTE     byPublishPercent;     //Publish Percent
    BYTE     byPublishStatus;     //Publish Status
    BYTE     byRes[302];
}NET_DVR_PUBLISH_PROGRESS_CFG, *LPNET_DVR_PUBLISH_PROGRESS_CFG;

//Delete  BackGround Picture
typedef  struct  tagNET_DVR_BACKGROUND_PIC_COND
{
    DWORD    dwSize;
    char     szFileID[MAX_ID_LEN_128/*128*/];        //File ID
    BYTE     byRes[256];
}NET_DVR_BACKGROUND_PIC_COND, *LPNET_DVR_BACKGROUND_PIC_COND;

//BackGround Picture Cfg
typedef struct tagNET_DVR_BACKGROUND_PIC_CFG
{
    DWORD    dwSize;
    DWORD     dwPicSize;  //BackGround Picture Size
    DWORD     dwPicType;   //Picture Type\A3\ACYUV:0 JPEG:1
    WORD     wPicWidth;   //Picture Width
    WORD     wPicHeight;    //Picture Height
    BYTE          byPicName[MAX_PIC_NAME_LEN/*128*/];
    BYTE         byRes[128];
}NET_DVR_BACKGROUND_PIC_CFG,*LPNET_DVR_BACKGROUND_PIC_CFG;

//BackGround Picture Info
typedef struct tagNET_DVR_BACKGROUND_PIC_INFO
{
    DWORD   dwSize;
    BYTE    byEnable;             //Enable
    BYTE    byRes1[3];
    BYTE    byPicID[MAX_ID_LEN_128/*128*/];
    BYTE    byRes[300];
}NET_DVR_BACKGROUND_PIC_INFO,*LPNET_DVR_BACKGROUND_PIC_INFO;

//Updata BackGround Picture Praram
typedef struct tagNET_DVR_BACKGROUND_PIC_PRARAM
{
    DWORD       dwSize;
    DWORD        dwChannel; //Channel
    DWORD        dwPicSize;  //Picture Size
    WORD        wPicWidth;   //Picture Width
    WORD           wPicHeight;    //Picture Height
    char          szPicName[MAX_PIC_NAME_LEN/*128*/];   //Picture Name
    BYTE        byPicType;   //Picture Type\A3\ACYUV:0 JPEG:1
    BYTE        byRes[303];
}NET_DVR_BACKGROUND_PIC_PRARAM,*LPNET_DVR_BACKGROUND_PIC_PRARAM;

//Low Power
typedef    struct tagNET_DVR_LOWPOWER
{
    DWORD        dwSize;
    BYTE          byMode;//Mode 0-Manual, 1- timing
    BYTE        byEnabled;//Enabled
    BYTE        byRes[6];
    NET_DVR_SCHEDULE_DAYTIME  struSchedTime;//Time interval
    BYTE        byRes1[256];
}NET_DVR_LOWPOWER,*LPNET_DVR_LOWPOWER;

//Zoom linkage
typedef    struct tagNET_DVR_ZOOMLINKAGE
{
    DWORD        dwSize;
    BYTE          byEnable;//Enable 0-disable\A3\AC1-Enable
    BYTE       byRes[255];
}NET_DVR_ZOOMLINKAGE,*LPNET_DVR_ZOOMLINKAGE;

typedef struct tagNET_DVR_ONLINEUPGRADE_STATUS
{
    DWORD   dwSize;
    BYTE    byUpgradeStatus;//0-not upgrading,1-upgrading,2-upgrade success,3-language mismatch,4-write falsh error,5-package type mismatch,6-package version mismatch,
    //7-network error,8-upgrade server error,9-read package error,10-no package,11-package error,12-no memory,0xff-unknown error
    BYTE    byProgress; //progress,0~100
    BYTE    byRes[250];
}NET_DVR_ONLINEUPGRADE_STATUS,*LPNET_DVR_ONLINEUPGRADE_STATUS;

typedef    struct tagNET_DVR_FIRMWARECODE_COND
{
    DWORD  dwSize;
    DWORD  dwStartIndex;    //start index
    DWORD  dwMaxNum;    //max number once search
    BYTE   byRes[52];
}NET_DVR_FIRMWARECODE_COND,*LPNET_DVR_FIRMWARECODE_COND;

typedef    struct    tagNET_DVR_FIRMWARECODE
{
    WORD  wIndex;
    WORD  wCodeLen;    //firmware code length
    BYTE  byCode[MAX_IDCODE_LEN];//firmware code
    BYTE  byVersion[MAX_VERSIIN_LEN];//firmware version
    BYTE  byRes[12];
}NET_DVR_FIRMWARECODE,*LPNET_DVR_FIRMWARECODE;

typedef    struct    tagNET_DVR_FIRMWARECODE_LIST
{
    DWORD  dwSize;
    DWORD  dwValidCodeNum;    //valid firmware code number
    NET_DVR_FIRMWARECODE  struCode[MAX_IDCODE_NUM];
    BYTE   byRes[64];
}NET_DVR_FIRMWARECODE_LIST,*LPNET_DVR_FIRMWARECODE_LIST;

typedef struct tagNET_DVR_ONLINEUPGRADE_SERVER
{
    DWORD  dwSize;
    BYTE   byConnectStatus;    //0-not connected,1-connected
    BYTE   byRes[1019];
}NET_DVR_ONLINEUPGRADE_SERVER,*LPNET_DVR_ONLINEUPGRADE_SERVER;

typedef struct tagNET_DVR_ONLINEUPGRADE_VERSION_COND
{
    DWORD  dwSize;
    BYTE   byCheckFromSvr; //check from server,0-no,1-yes
    BYTE   byRes[59];
}NET_DVR_ONLINEUPGRADE_VERSION_COND,*LPNET_DVR_ONLINEUPGRADE_VERSION_COND;

typedef struct tagNET_DVR_ONLINEUPGRADE_VERSION_RET
{
    DWORD  dwSize;
    BYTE   byNewVersionAvailable;  //new version available,0-no,1-yes
    BYTE   byNewVersion[MAX_VERSIIN_LEN];  //new version
    BYTE   byChangeLog[SDK_LEN_2048];  //new version change log
    BYTE   byRes[971];
}NET_DVR_ONLINEUPGRADE_VERSION_RET,*LPNET_DVR_ONLINEUPGRADE_VERSION_RET;

typedef struct tagNET_DVR_RECOMMEN_VERSION_COND
{
    DWORD  dwSize;
    BYTE   byFirmwareCode[MAX_IDCODE_LEN];
    BYTE   byFirmwareVersion[MAX_VERSIIN_LEN];
    BYTE   byRes[60];
}NET_DVR_RECOMMEN_VERSION_COND,*LPNET_DVR_RECOMMEN_VERSION_COND;

typedef struct tagNET_DVR_RECOMMEN_VERSION_RET
{
    DWORD  dwSize;
    BYTE   byRecommenUpgrade;  //recommen upgrade,0-no,1-yes
    BYTE   byRes[123];
}NET_DVR_RECOMMEN_VERSION_RET,*LPNET_DVR_RECOMMEN_VERSION_RET;

//Thscreen Cfg
typedef    struct tagNET_DVR_THSCREEN
{
    DWORD  dwSize;
    BYTE   byEnable;//Enable
    BYTE   byTHOSDDisplay;//OSD Display
    BYTE   byRes[2];
    NET_VCA_POINT   struTHOSDPoint;//OSD Point
    BYTE   byTimingMode;//Timing Mode
    BYTE   byRes1;
    WORD   wInterval;//Interval; [1,10080]m
    BYTE   byRes2[254];
}NET_DVR_THSCREEN,*LPNET_DVR_THSCREEN;

typedef    struct tagNET_DVR_SENSOR_ADJUSTMENT
{
    DWORD        dwSize;
    BYTE     byType;//Adjustment mode\A3\BA0-UpDown\A3\AC1-LeftRight\A3\AC2-rotation\A3\AC3-fieldAngle\A3\AC4-RGB
    BYTE     bySensorNo;//Sensor No[1,8]
    BYTE     byRes[2];
    int    iAdjustMentRange;//AdjustMent Range [-100,100] rotation[-30,30] fieldAngle[-10,10]
    BYTE     byR;//RGB para\A3\ACR\A3\A8red\A3\A9\A3\AC0-255
    BYTE     byG;//RGB para\A3\ACG\A3\A8green\A3\A9\A3\AC0-255
    BYTE     byB;//RGB para\A3\ACB\A3\A8blue\A3\A9\A3\AC0-255
    BYTE     byRes1[125];
}NET_DVR_SENSOR_ADJUSTMENT,*LPNET_DVR_SENSOR_ADJUSTMENT;

typedef    struct tagNET_DVR_SENSOR_ADJUSTMENT_INFO
{
    DWORD        dwSize;
    int      iPan;//UpDown
    int      iTilt;//LeftRight
    int      iRotation;//rotation
    int      iFieldAngle;//fieldAngle
    BYTE     byRes[128];
}NET_DVR_SENSOR_ADJUSTMENT_INFO,*LPNET_DVR_SENSOR_ADJUSTMENT_INFO;

typedef    struct tagNET_DVR_SENSOR_RESET
{
    DWORD        dwSize;
    BYTE     bySensorNo;//Sensor No[1,8]
    BYTE     byRes[127];
}NET_DVR_SENSOR_RESET,*LPNET_DVR_SENSOR_RESET;

typedef    struct tagNET_DVR_PANORAMAIMAGE
{
    DWORD    dwSize;
    BYTE     byFusionMode;//mode\A3\BA0-original\A3\AC1-panorama
    BYTE     byRes[127];
}NET_DVR_PANORAMAIMAGE,*LPNET_DVR_PANORAMAIMAGE;

typedef struct tagNET_DVR_RELOCATE_INFO
{
    DWORD        dwSize;
    BYTE        byTakeOverAddr[MAX_DOMAIN_NAME/*64*/];
    WORD        wPort;
    BYTE        byRes[254] ;
}NET_DVR_RELOCATE_INFO, *LPNET_DVR_RELOCATE_INFO;

typedef struct tagNET_DVR_POINT
{
    DWORD dwX;
    DWORD dwY;
}NET_DVR_POINT, *LPNET_DVR_POINT;

typedef struct tagNET_DVR_CONFERENCE_REGION
{
    DWORD dwSize;
    BYTE byEnabled;
    BYTE byRes1[3];
    NET_DVR_POINT struRegion[RECT_POINT_NUM];
    DWORD dwOutputWidth;
    DWORD dwOutputHeight;
    BYTE byRes2[32];
}NET_DVR_CONFERENCE_REGION, *LPNET_DVR_CONFERENCE_REGION;

typedef struct tagNET_DVR_TERMINAL_CALL_CFG
{
    DWORD dwSize;
    BYTE  byAnswerType;
    BYTE  byProtocolType;
    BYTE  byRes[30];
}NET_DVR_TERMINAL_CALL_CFG, *LPNET_DVR_TERMINAL_CALL_CFG;

typedef struct tagNET_DVR_TERMINAL_CALL_INFO
{
    BYTE byTermianlURL[MAX_URL_LEN];
    DWORD dwCallRate;//32~6144Kbps
    BYTE  byRes[124];
}NET_DVR_TERMINAL_CALL_INFO, *LPNET_DVR_TERMINAL_CALL_INFO;

typedef struct tagNET_DVR_TERMINAL_AUDIO_CTRL
{
    BYTE byMute;
    BYTE byVolume;
    BYTE byAudioInputDisabled;
    BYTE byAudioInputVolume;
    BYTE byRes[636];
}NET_DVR_TERMINAL_AUDIO_CTRL, *LPNET_DVR_TERMINAL_AUDIO_CTRL;

typedef struct tagNET_DVR_HOWLING_SUPPRESSION
{
    BYTE    byEnabled;
    BYTE    byHsSensibility;
    BYTE    byHsMode;
    BYTE    byRes1;
    DWORD dwHsTime;
    BYTE    byRes2[16];
}NET_DVR_HOWLING_SUPPRESSION, *LPNET_DVR_HOWLING_SUPPRESSION;

typedef struct tagNET_DVR_TERMINAL_INPUT_AUDIO
{
    DWORD dwChannel;
    BYTE   byGainType;
    BYTE   byEnableSimulate;
    BYTE   byVolumeSimulate;
    BYTE   byEnableDigital;
    BYTE   byVolumeDigital;
    BYTE   byRes1[3];
    NET_DVR_HOWLING_SUPPRESSION struHsParam;
    BYTE   byRes[604];
}NET_DVR_TERMINAL_INPUT_AUDIO, *LPNET_DVR_TERMINAL_INPUT_AUDIO;


typedef union tagNET_DVR_TERMINAL_DETAIL_CTRL_PARAM
{
    BYTE byRes[640];
    NET_DVR_TERMINAL_CALL_INFO struCallInfo;
    NET_DVR_TERMINAL_AUDIO_CTRL struAudioCtrl;
    NET_DVR_TERMINAL_INPUT_AUDIO struInputAudio;
}NET_DVR_TERMINAL_DETAIL_CTRL_PARAM, *LPNET_DVR_TERMINAL_DETAIL_CTRL_PARAM;

typedef struct tagNET_DVR_TERMINAL_CTRL_PARAM
{
    DWORD dwSize;
    BYTE byOperateType;
    BYTE byRes1[3];
    NET_DVR_TERMINAL_DETAIL_CTRL_PARAM struCtrlParam;
    BYTE byRes2[32];
}NET_DVR_TERMINAL_CTRL_PARAM, *LPNET_DVR_TERMINAL_CTRL_PARAM;


typedef struct tagNET_DVR_POS_INFO_OVERLAY
{
    DWORD   dwSize;
    BYTE    byPosInfoOverlayEnable;// Pos superposition of information code flow control, 0 - don't stack, 1 - stack
    BYTE    byOverlayType;//0-inOut\A1\A2OUT\A3\AC1-inOutPassIdHeight
    BYTE    byRes[126];
}NET_DVR_POS_INFO_OVERLAY, *LPNET_DVR_POS_INFO_OVERLAY;


typedef struct tagNET_DVR_CAMERA_WORK_MODE
{
    DWORD dwSize;
    BYTE  byWorkMode;//Working mode, 0 to normal mode, 1 - factory calibration model
    BYTE  byPreviewImageMode;//Preview image pattern, 0 - left eye image, 1 - in the right eye image, 2 - or so superimposed images
    BYTE byRes[126];
}NET_DVR_CAMERA_WORK_MODE, *LPNET_DVR_CAMERA_WORK_MODE;

typedef struct tagNET_DVR_SETUP_CALIB_COND
{
    DWORD dwSize;
    BYTE  byCalibrateType;//1 calibration type, 0 - without the need for automatic calibration, 2 - manual calibration
    BYTE  byRes1[3];
    float fTiltAngle;//Pitching Angle, unit: degree; Pitching Angle default: 0; Pitching Angle range: 0-180 degrees, effective when byCalibrateType is 2
    float fHeelAngle;//Tilt Angle, the unit: degree; Default: 0 slope Angle; Angle range: - 90-90 degrees, effective when byCalibrateType is 2
    float fHeight;//Height, height unit: cm long; Range of height default value is 300 cm, height: 200-500 cm, effective when byCalibrateType is 2
    NET_VCA_POLYGON struAutoCalibPolygon;//Automatic calibration area, effective when byCalibrateType is 1
    BYTE byRes[128];
}NET_DVR_SETUP_CALIB_COND, *LPNET_DVR_SETUP_CALIB_COND;

typedef struct tagNET_DVR_SETUP_CALIB_RESULT
{
    DWORD dwSize;
    BYTE  byCalibrateType;//1 calibration type, 0 - without the need for automatic calibration, 2 - manual calibration
    BYTE  byRes1[3];
    float fTiltAngle;//Pitching Angle, unit: degree; Pitching Angle default: 0; Pitching Angle range: 0-180 degrees, effective when byCalibrateType is 2
    float fHeelAngle;//Tilt Angle, the unit: degree; Default: 0 slope Angle; Angle range: - 90-90 degrees, effective when byCalibrateType is 2
    float fHeight;//Height, height unit: cm long; Range of height default value is 300 cm, height: 200-500 cm, effective when byCalibrateType is 2
    NET_VCA_POLYGON struCountPolygon;//Count area
    NET_DVR_PDC_ENTER_DIRECTION  struEnterDirection; // Direction of flow to
    NET_VCA_LINE  struLine;//detection line
    BYTE byRes[128];
}NET_DVR_SETUP_CALIB_RESULT, *LPNET_DVR_SETUP_CALIB_RESULT;

typedef struct tagNET_DVR_CALL_QUERY_COND
{
    DWORD dwSize;
    BYTE bySearchID[MAX_SEARCH_ID_LEN];
    NET_DVR_TIME struStartTime;
    NET_DVR_TIME struEndTime;
    BYTE byCallType;
    BYTE byRes1[3];
    DWORD dwMaxResults;
    DWORD dwSearchPos;
    BYTE byRes2[32];
}NET_DVR_CALL_QUERY_COND, *LPNET_DVR_CALL_QUERY_COND;

typedef struct tagNET_DVR_CALL_QUERY_SINGLE
{
    DWORD dwSize;
    BYTE byCallType;
    BYTE byRes1[3];
    BYTE byTerminalName[TERMINAL_NAME_LEN];
    BYTE byAddressURL[MAX_URL_LEN];
    NET_DVR_TIME struStartTime;
    NET_DVR_TIME struEndTime;
    BYTE byRes2[32];
}NET_DVR_CALL_QUERY_SINGLE, *LPNET_DVR_CALL_QUERY_SINGLE;


typedef enum tagCALL_QUERY_RESULT_STATUS
{
    CALL_QUERY_RESULT_OK = 0,
    CALL_QUERY_RESULT_FAIL,
    CALL_QUERY_RESULT_MORE,
    CALL_QUERY_RESULT_NOMATCH,
    CALL_QUERY_RESULT_PARAMERROR,
    CALL_QUERY_RESULT_INVALIDTIME,
    CALL_QUERY_RESULT_TIMEOUT,
}CALL_QUERY_RESULT_STATUS;

typedef struct tagNET_DVR_CALL_QUERY_RESULT
{
    DWORD dwSize;
    BYTE bySearchID[MAX_SEARCH_ID_LEN];
    BYTE   byStatus;
    BYTE   byRes[3];
    DWORD dwCount;
    BYTE *pResults;
    BYTE byRes2[32];
}NET_DVR_CALL_QUERY_RESULT, *LPNET_DVR_CALL_QUERY_RESULT;

typedef struct tagNET_DVR_CONFERENCE_CALL_INFO
{
    BYTE byConferenceID[MAX_ID_LEN];
    BYTE byConferenceName[NAME_LEN];
    NET_DVR_TIME struStartTime;
    NET_DVR_TIME struEndTime;
    BYTE byRes[512];
}NET_DVR_CONFERENCE_CALL_INFO, *LPNET_DVR_CONFERENCE_CALL_INFO;

typedef union tagNET_DVR_CALL_INFO
{
    BYTE byRes[640];
    NET_DVR_TERMINAL_CALL_INFO struTerminalCallInfo;
    NET_DVR_CONFERENCE_CALL_INFO struConferenceCallInfo;
}NET_DVR_CALL_INFO, *LPNET_DVR_CALL_INFO;

typedef struct tagNET_DVR_CONFERENCE_CALL_ALARM
{
    DWORD dwSize;
    BYTE  byAlarmType;
    BYTE  byCallType;
    BYTE  byAutoAnswer;
    BYTE  byCallStatusSwitch;
    NET_DVR_CALL_INFO struCallInfo;
    BYTE  byRes2[32];
}NET_DVR_CONFERENCE_CALL_ALARM, *LPNET_DVR_CONFERENCE_CALL_ALARM;

typedef struct tagNET_DVR_TERMINAL_INPUT_CFG
{
    DWORD dwSize;
    DWORD dwInputNo;
    BYTE  byRes[32];
}NET_DVR_TERMINAL_INPUT_CFG, *LPNET_DVR_TERMINAL_INPUT_CFG;

typedef struct tagNET_DVR_AUDIO_STATUS
{
    BYTE byMute;
    BYTE byVolume;
    BYTE byAudioInputDisabled;
    BYTE byAudioInputVolume;
    BYTE byRes[32];
}NET_DVR_AUDIO_STATUS, *LPNET_DVR_AUDIO_STATUS;

typedef struct tagNET_DVR_TERMINAL_CONFERENCE_STATUS
{
    DWORD dwSize;
    BYTE byConferenceState;
    BYTE byConferenceType;
    BYTE byDualStreamEnabled;
    BYTE byMicPowerEnabled;
    DWORD dwInputNo;
    NET_DVR_CALL_INFO struCallInfo;
    NET_DVR_AUDIO_STATUS struAudioStatus;
    BYTE byRes2[32];
}NET_DVR_TERMINAL_CONFERENCE_STATUS, *LPNET_DVR_TERMINAL_CONFERENCE_STATUS;

typedef struct tagNET_DVR_WIN_ROAM_SWITCH_CFG
{
    DWORD dwSize;
    BYTE  byEnableRoam;
    BYTE  byRes[31];
}NET_DVR_WIN_ROAM_SWITCH_CFG,*LPNET_DVR_WIN_ROAM_SWITCH_CFG;

typedef struct tagNET_DVR_LED_OUTPUT_CFG
{
    DWORD dwSize;
    BYTE  byEnableZoom;       //zoom enable, 0-disable, 1-enable
    BYTE  byAutoCutBlackEdge; //auto cut black edge enable, 0-disable, 1-enable
    BYTE  byRes1[2];
    WORD  wLEDWidth;          //resolution width
    WORD  wLEDHeight;         //resolution height
    DWORD dwRefreshRate;      //refresh rate
    DWORD dwInputNO;          //related input number
    BYTE  byRes2[32];
}NET_DVR_LED_OUTPUT_CFG, *LPNET_DVR_LED_OUTPUT_CFG;

typedef struct tagNET_DVR_LED_OUTPUT_PORT_CFG
{
    DWORD dwSize;
    BYTE  byEnabled;    //enable, 0-disable, 1-enable
    BYTE  byRes1[3];
    DWORD dwPortNum;    //port number
    DWORD dwPortNo[MAX_OUTPUT_PORT_NUM]; //port list
    BYTE  byRes2[64];
}NET_DVR_LED_OUTPUT_PORT_CFG, *LPNET_DVR_LED_OUTPUT_PORT_CFG;

typedef struct tagNET_DVR_LINE_COLUMN_INFO
{
    WORD wLine;   //row number
    WORD wColumn; //column number
}NET_DVR_LINE_COLUMN_INFO, *LPNET_DVR_LINE_COLUMN_INFO;

typedef struct tagNET_DVR_LED_DISPLAY_AREA
{
    DWORD   dwSize;
    NET_DVR_LINE_COLUMN_INFO struLCInfo; //the starting position of the display area (receive card row and column number)
    WORD    wWidth;         //the number of horizontal receive card
    WORD    wHeight;        //the number of vertical receive card
    WORD     wRecvCardWidth; //receive card width
    WORD    wRecvCardHeigt; //receive card height
    BYTE    byRes[32];
}NET_DVR_LED_DISPLAY_AREA, *LPNET_DVR_LED_DISPLAY_AREA;

typedef struct tagNET_DVR_LED_RECV_CARD_INFO
{
    NET_DVR_LINE_COLUMN_INFO struPos; //receive card position
    WORD wRecvCardWidth;              //receive card width
    WORD wRecvCardHeigt;              //receive card height
}NET_DVR_LED_RECV_CARD_INFO, *LPNET_DVR_LED_RECV_CARD_INFO;

typedef struct tagNET_DVR_LED_PORT_BACKUP
{
    BYTE byEnabled;      //backup enable, 0-disable, 1-enable
    BYTE byPortMode;  //port mode, 1-main, 2-backup
    BYTE byRes1[2];
    DWORD dwPairPort; //pair port
    BYTE byRes2[16];
}NET_DVR_LED_PORT_BACKUP, *LPNET_DVR_LED_PORT_BACKUP;

typedef struct tagNET_DVR_LED_PORT_CFG
{
    DWORD dwSize;
    BYTE byEnabled; //port enable, 0-disable, 1-enable
    BYTE byRes1[3];
    NET_DVR_LED_PORT_BACKUP struLedPortBackup; //port backup parameters
    DWORD dwRecvCardNum; //the number of receive card connected to this card
    NET_DVR_LED_RECV_CARD_INFO struRecvCard[MAX_SINGLE_PORT_RECVCARD_NUM]; //the receiving card information
    DWORD dwPortNo; //the port number, access to all ports parameters effectively
    BYTE byRes2[64];
}NET_DVR_LED_PORT_CFG, *LPNET_DVR_LED_PORT_CFG;

typedef struct tagNET_DVR_LED_DISPLAY_CFG
{
    DWORD dwSize;
    NET_DVR_COLOR_TEMPERATURE_CFG struColorTemp; //color temperature parameters
    NET_DVR_VIDEO_OUT_CFG struVoutCfg; //display parameters
    BYTE byRes[32];
}NET_DVR_LED_DISPLAY_CFG, *LPNET_DVR_LED_DISPLAY_CFG;

typedef struct tagNET_DVR_LED_TEST_SIGNAL_CFG
{
    DWORD dwSize;
    BYTE byEnabled;        //Whether to enable the test signal, 0 - is not enabled, 1 - to enable
    BYTE bySignalType;    //Test signal type, 1 - striped, 2 - corrugated, 3 - lattice striped, 4 - box, 5 - horizontal and vertical gray-scale consortium, 6 - board, 0xff - custom color
    BYTE byRes1[2];
    NET_DVR_RGB_COLOR struSignalColor; //signal color, when test signal type is 0xff, it is available
    BYTE byRes[32];
}NET_DVR_LED_TEST_SIGNAL_CFG, *LPNET_DVR_LED_TEST_SIGNAL_CFG;

typedef struct tagNET_DVR_LED_NOSIGNAL_CFG
{
    DWORD dwSize;
    BYTE byNoSignalMode; //no signal display mode, 1 - black screen, 2 - display manufacturer LOGO, 3 - display a custom image
    BYTE byRes[63];
}NET_DVR_LED_NOSIGNAL_CFG, *LPNET_DVR_LED_NOSIGNAL_CFG;

typedef struct tagNET_DVR_LED_INPUT_CFG
{
    DWORD dwSize;
    DWORD dwResolutionWidth;    //Wide input resolution, read-only
    DWORD dwResolutionHeight;    //Input high resolution, read-only
    DWORD dwRefreshRate;        //The input signal refresh rate, read-only
    NET_DVR_SCREEN_VGA_CFG struVgaCfg; //VGA signal parameters, VGA input is adjustable
    BYTE  byRes[32];
}NET_DVR_LED_INPUT_CFG, *LPNET_DVR_LED_INPUT_CFG;

typedef struct tagNET_DVR_LED_RECV_CARD_CFG_COND
{
    DWORD dwSize;
    DWORD dwOutputNo; //Output numbering
    NET_DVR_LINE_COLUMN_INFO struPosStart; //Receiving card starting position
    NET_DVR_LINE_COLUMN_INFO struPosEnd;   //Receiving end position
    BYTE byRes[32];
}NET_DVR_LED_RECV_CARD_CFG_COND, *LPNET_DVR_LED_RECV_CARD_CFG_COND;

typedef struct tagNET_DVR_LED_GAMMA_CFG
{
    DWORD dwSize;
    WORD wGammaValue[MAX_GAMMA_X_VALUE];    //GAMMA table Y values, each element value of 0-65535
    BYTE byRes[128];
}NET_DVR_LED_GAMMA_CFG, *LPNET_DVR_LED_GAMMA_CFG;

typedef struct tagNET_DVR_LED_CLOCK_CFG
{
    DWORD dwDclkRate;       //Transmission DCLK clock frequency, the actual value multiplied 10, unit: MHz, actual value range 1.0 - 31.3
    DWORD dwGclkRate;       //GCLK refresh the clock frequency, the actual value multiplied 10 units: MHz, actual value range 1.0 - 31.3
    DWORD dwGclkCountNum;  //300ns GCLK count
    BYTE  byDclkDutyRatio; //DCLK clock duty cycle, value: 25, 50, 75
    BYTE  byDclkPhase;       //DCLK phase, values: 0, 1, 2, 3
    BYTE  byGclkNum;       //Number of effective GCLK refresh line 1, range 0-255
    BYTE  byRes[17];
}NET_DVR_LED_CLOCK_CFG, *LPNET_DVR_LED_CLOCK_CFG;

typedef struct tagNET_DVR_LED_RECV_CFG
{
    DWORD dwSize;
    NET_DVR_LED_CLOCK_CFG struClockCfg;    //The clock related parameters
    BYTE byGrayLevel;               //The clock related parameters to gray-scale, values, 13, 14
    BYTE byRefreshRate;               //The refresh rate, a value of 1-6
    BYTE byLineScanNum;               //The number of line scan, 0-255
    BYTE byRefreshCompleteGrayNum; //Refresh the full number of gray-scale, 0-255
    DWORD dwHBlank;                   //Row blanking time, unit: GCLK clock number, value of 1-65535
    DWORD dwAfterglowCtrl;           //Light control over time, the unit: GCLK clock number, value of 1-65535
    DWORD dwLineFeedTime;           //Break time, the unit: GCLK clock number, value of 1-65535
    BYTE byRes[128];
}NET_DVR_LED_RECV_CFG, *LPNET_DVR_LED_RECV_CFG;

typedef struct tagNET_DVR_LED_REGISTOR_VALUE
{
    BYTE byChip1High;        //chip 1 high byte
    BYTE byChip1Low;        //chip 1 low byte
    BYTE byChip2High;        //chip 2 high byte
    BYTE byChip2Low;        //chip 2 low byte
    BYTE byChip3High;        //chip 3 high byte
    BYTE byChip3Low;        //chip 3 low byte
    BYTE byRes[10];
}NET_DVR_LED_REGISTOR_VALUE, *LPNET_DVR_LED_REGISTOR_VALUE;

typedef struct tagNET_DVR_LED_RECV_REGISTOR
{
    BYTE byEliminateGhostShadowLevel;    //The ghost to eliminate class, 0 to 5
    BYTE byEliminateShadowy;            //Dull by the first sweep to eliminate class, 0-15
    BYTE byGrayEqualize1;                //Low ash color compensation 1, 0 to 3
    BYTE byGrayEqualize2;                //Low ash color compensation 2, 0 to 15
    BYTE byEnableGrayUniformity;        //Low ash uniformity of ascension is open, 0 - close, 1 - to open
    BYTE byDisableHGrayStripes;            //Low ash horizontal stripes eliminate whether open, 0 - close, 1 - to open
    BYTE byGhostShadowEnhancedMode1;    //The ghost to eliminate enhanced mode 1 is open, 0 - close, 1 - to open
    BYTE byGhostShadowEnhancedMode2;    //The ghost to eliminate enhanced mode 2 is open, 0 - close, 1 - to open
    BYTE byClearBadPoint;                //Get rid of the bad point can make, 0 - can not make, 1 - can make
    BYTE byEnableSelfDefineRegistor;    //Whether to enable custom register values, 0 - disable, 1 - enable
    BYTE byRes1[2];
    NET_DVR_LED_REGISTOR_VALUE struRegistorValue; //The custom register parameters
    BYTE byRes[32];
}NET_DVR_LED_RECV_REGISTOR, *LPNET_DVR_LED_RECV_REGISTOR;

typedef struct tagNET_DVR_LED_RECV_ADVANCED_CFG
{
    DWORD dwSize;
    NET_DVR_LED_RECV_REGISTOR struFirstRegistor;    //The first group to receive card advanced parameters, custom register values for red chip register values
    NET_DVR_LED_RECV_REGISTOR struSecondRegistor;    //The second group receiving card advanced parameters, the custom value for the green chip registers values
    NET_DVR_LED_RECV_REGISTOR struThirdRegistor;    //The third group received card advanced parameters, the custom value for blue chip registers values
    BYTE byRes2[64];
}NET_DVR_LED_RECV_ADVANCED_CFG,*LPNET_DVR_LED_RECV_ADVANCED_CFG;

typedef struct tagNET_DVR_LED_CHECK_COND
{
    DWORD dwSize;
    DWORD dwOutputNo;   //output no
    BYTE  byRes[32];
}NET_DVR_LED_CHECK_COND, *LPNET_DVR_LED_CHECK_COND;


enum  ADDR_QUERY_TYPE
{
    QUERYSVR_BY_COUNTRYID = 0,    //query by country id
    QUERYSVR_BY_SERVERTYPE = 1, //not use
    QUERYDEV_BY_NICKNAME_DDNS = 2, //query device info from ddns by nickname
    QUERYDEV_BY_SERIAL_DDNS = 3,    //query device info from ddns by serial no.
    CHECKDEV_BY_NICKNAME_DDNS = 4,//check device info from ddns by nickname
    CHECKDEV_BY_SERIAL_DDNS = 5,    //check device info from ddns by serial no.
    QUERYDEV_BY_NICKNAME_IPSERVER = 6, //query device info from ipserver by nickname
    QUERYDEV_BY_SERIAL_IPSERVER = 7    //query device info from ipserver by serial no.
};
#define    CLIENT_VERSION_LEN    64
//condition struct for QUERYSVR_BY_COUNTRYID
typedef struct tagNET_DVR_QUERY_COUNTRYID_COND
{
    WORD    wCountryID;    //country id
    char    szSvrAddr[MAX_DOMAIN_NAME];//center server address
    char    szClientVersion[CLIENT_VERSION_LEN];//client version,eg:iVMS4500 V4.0.0.0 build20150112
    BYTE    byRes[382];
}NET_DVR_QUERY_COUNTRYID_COND,*LPNET_DVR_QUERY_COUNTRYID_COND;
//result struct for QUERYSVR_BY_COUNTRYID
typedef struct tagNET_DVR_QUERY_COUNTRYID_RET
{
    char    szResolveSvrAddr[MAX_DOMAIN_NAME];//resolve server address
    char    szAlarmSvrAddr[MAX_DOMAIN_NAME];//alarm server address
    BYTE    byRes[1024];
}NET_DVR_QUERY_COUNTRYID_RET,*LPNET_DVR_QUERY_COUNTRYID_RET;

typedef struct tagNET_DVR_QUERY_SERVERTYPE_COND
{
    WORD    wSvrType;
    char    szSvrAddr[MAX_DOMAIN_NAME];
    char    szClientVersion[CLIENT_VERSION_LEN];
    BYTE    byRes[382];
}NET_DVR_QUERY_SERVERTYPE_COND, *LPNET_DVR_QUERY_SERVERTYPE_COND;

typedef struct tagNET_DVR_QUERY_SERVERTYPE_RET
{
    char    szSvrAddr[MAX_DOMAIN_NAME];
    WORD    wSvrPort;
    BYTE    byRes[446];
}NET_DVR_QUERY_SERVERTYPE_RET, *LPNET_DVR_QUERY_SERVERTYPE_RET;

//condition struct for QUERYDEV_BY_NICKNAME_DDNS/QUERYDEV_BY_SERIAL_DDNS/CHECKDEV_BY_NICKNAME_DDNS/CHECKDEV_BY_SERIAL_DDNS
typedef struct tagNET_DVR_QUERY_DDNS_COND
{
    char    szResolveSvrAddr[MAX_DOMAIN_NAME];//resolve server address
    char    szDevNickName[MAX_DOMAIN_NAME];    //device nickname
    char    szDevSerial[SERIALNO_LEN];    //device serial no.
    char    szClientVersion[CLIENT_VERSION_LEN];//client version,eg:iVMS4500 V4.0.0.0 build20150112
    BYTE    byRes[272];
}NET_DVR_QUERY_DDNS_COND,*LPNET_DVR_QUERY_DDNS_COND;
#define SDK_MAX_IP_LEN 48
//result struct for QUERYDEV_BY_NICKNAME_DDNS/QUERYDEV_BY_SERIAL_DDNS
typedef struct tagNET_DVR_QUERY_DDNS_RET
{
    char    szDevIP[SDK_MAX_IP_LEN];    //device address
    WORD    wCmdPort;        //commad port(sdk port)
    WORD    wHttpPort;        //http port
    BYTE    byRes[460];
}NET_DVR_QUERY_DDNS_RET,*LPNET_DVR_QUERY_DDNS_RET;
//result struct for CHECKDEV_BY_NICKNAME_DDNS/CHECKDEV_BY_SERIAL_DDNS
typedef struct tagNET_DVR_CHECK_DDNS_RET
{
    BYTE    byDevStatus;        //device status,0-normal,1-can not find,2-offline,3-not in current area
    BYTE    byRes1;
    NET_DVR_QUERY_DDNS_RET    struQueryRet;    //address information
    WORD    wRegionID;        //device register area no.[1-United States,2-south america,3-asia,4-china,5-europe,6-other]
    BYTE    byRes2[508];
}NET_DVR_CHECK_DDNS_RET,*LPNET_DVR_CHECK_DDNS_RET;

//condition struct of query from ipserver
typedef struct tagNET_DVR_QUERY_IPSERVER_COND
{
    char    szResolveSvrAddr[MAX_DOMAIN_NAME];//resolve server address
    WORD    wResolveSvrPort;    //resolve server port
    char    szDevNickName[MAX_DOMAIN_NAME];    //device nick name
    char    szDevSerial[SERIALNO_LEN];    //device serial no.
    BYTE    byRes[334];        //
}NET_DVR_QUERY_IPSERVER_COND,*LPNET_DVR_QUERY_IPSERVER_COND;

//result struct of query from ipserver
typedef struct tagNET_DVR_QUERY_IPSERVER_RET
{
    char    szDevIP[SDK_MAX_IP_LEN];    //device ip address
    WORD    wCmdPort;        //command port
    BYTE    byRes[462];
}NET_DVR_QUERY_IPSERVER_RET,*LPNET_DVR_QUERY_IPSERVER_RET;

typedef struct tagNET_DVR_CURRENT_VALID_PORT
{
    DWORD  dwSize;
    WORD   wHTTPPort;
    BYTE   byRes[122];
}NET_DVR_CURRENT_VALID_PORT,*LPNET_DVR_CURRENT_VALID_PORT;

typedef struct tagNET_DVR_AUDIO_CHANNEL
{
    DWORD  dwChannelNum;                //voicetalk channel
    BYTE   byres[32];
}NET_DVR_AUDIO_CHANNEL, *LPNET_DVR_AUDIO_CHANNEL;

//Stream Encryption Cond
typedef    struct tagNET_DVR_STREAMENCRYPTION_COND
{
    DWORD     dwSize;
    DWORD   dwChan;  //Channel
    BYTE     byRes[128];
}NET_DVR_STREAMENCRYPTION_COND, *LPNET_DVR_STREAMENCRYPTION_COND;

//Stream Encryption Cfg
typedef    struct tagNET_DVR_STREAMENCRYPTION_CFG
{
    DWORD     dwSize;
    BYTE    byEnable;  //Enable
    BYTE       byRes[255];
}NET_DVR_STREAMENCRYPTION_CFG, *LPNET_DVR_STREAMENCRYPTION_CFG;

//Revise GPS Cfg
typedef    struct tagNET_DVR_REVISE_GPS_CFG
{
    DWORD    dwSize;
    BYTE    byLatitudeType;//Latitude Type,0-North latitude, 1-South latitude
    BYTE    byLongitudeType;//Longitude Type\A3\AC0-east\A3\AC1-West
    BYTE    byMode;//Mode Type 0-default,1-auto\A3\AC2-manual
    BYTE    byRes;
    NET_DVR_LLI_PARAM      struLatitude;     /*Latitude*/
    NET_DVR_LLI_PARAM      struLongitude; /*Longitude*/
    BYTE    byRes1[300];
}NET_DVR_REVISE_GPS_CFG, *LPNET_DVR_REVISE_GPS_CFG;

typedef    struct tagNET_DVR_PDC_RECOMMEND
{
    DWORD       dwSize;
    WORD      wWidth;//Recommend Value[0, 1000]
    BYTE      byRes[126];
}NET_DVR_PDC_RECOMMEND,*LPNET_DVR_PDC_RECOMMEND;

typedef    struct tagNET_DVR_FLASHSTORAGE_REMOVE
{
    DWORD      dwSize;
    DWORD    dwChannel;
    BYTE     byPDCRemoveEnable;//0-false\A3\AC1-true
    BYTE     byRes[127];
}NET_DVR_FLASHSTORAGE_REMOVE,*LPNET_DVR_FLASHSTORAGE_REMOVE;

typedef struct tagNET_DVR_SCREENZOOM
{
    DWORD dwSize;
    DWORD dwScreenNum;
    NET_DVR_POINT_FRAME struPointFrame;
    BYTE  byLayer;
    BYTE  byRes[11];
}NET_DVR_SCREENZOOM, *LPNET_DVR_SCREENZOOM;

/********************************DS-TME4XX Control machine development Begin****************************/
typedef struct tagNET_DVR_PARKING_CARD
{
    DWORD  dwSize;
    DWORD  dwChannel;//The default is 1 (subsequent compatible multichannel device)
    char  szCardNo[MAX_CARDNO_LEN/*48*/];//Card No
    BYTE  byCardType;//Card Type 0-The temporary card
    BYTE  byCardStatus;//Card Status
    BYTE  byChargeRuleID;//Charge Rule ID
    BYTE  byDelete;//Whether to delete, 0-not delete\A3\AC1-delete
    NET_DVR_TIME_V30 struStartTime;//Start Time
    NET_DVR_TIME_V30 struEndTime;//End Time
    BYTE  byRes[128];
}NET_DVR_PARKING_CARD,*LPNET_DVR_PARKING_CARD;

//Entrance card information upload
typedef struct tagNET_DVR_GATE_CARDINFO
{
    DWORD     dwSize;
    NET_VCA_DEV_INFO struDevInfo;
    DWORD dwRelativeTime; //Relative Time
    DWORD dwAbsTime; //Abs Time
    char    szCardNo[MAX_CARDNO_LEN/*48*/];//Card No
    char    szPassVehicleID[MAX_VEHICLE_ID_LEN];//Unique identifier
    char    szInVehicleID[MAX_VEHICLE_ID_LEN];//Uniquely identifies the export of the entrance
    NET_DVR_TIME_V30  struSwipeTime;//Credit card time
    NET_DVR_TIME_V30  struCardTime;//Card storage time, namely the admission time to write, only on the export of ballot boxes useful, with 0 indicating no admission time
    BYTE    byLetPass;//Import and export clearance mode: 0- does not release (when CardType = = tickets) need to charge, 1- release, 2-The center charges release
    BYTE     byCardType;//Card type 0- fixed card, 1-  temporary card, 2- tickets
    BYTE    byRes[126];
}NET_DVR_GATE_CARDINFO, *LPNET_DVR_GATE_CARDINFO;

//Gate Charge Info(COMM_GATE_CHARGEINFO_UPLOAD)
typedef struct tagNET_DVR_GATE_CHARGEINFO
{
    DWORD dwSize;
    NET_VCA_DEV_INFO struDevInfo;
    DWORD dwRelativeTime; //Relative Time
    DWORD dwAbsTime; //Abs Time
    char  sLicense[MAX_LICENSE_LEN];        //License
    char  szCardNo[48];
    NET_DVR_TIME_V30 struEntranceTime;
    NET_DVR_TIME_V30 struDepartureTime;
    char  szDepartureID[32];  //Departure ID
    char  szEntranceID[32];  //Entrance ID
    DWORD dwTotalCost;   //Total Cost
    char  szOperateName[32]; //Operate Name
    BYTE  byChargeRuleId; //Charge Rule Id
    BYTE  byVehicleType;//Vehicle Type
    BYTE  byRes[127];
}NET_DVR_GATE_CHARGEINFO,*LPNET_DVR_GATE_CHARGEINFO;

//Parking card control structure
typedef struct tagNET_DVR_PARKING_CARD_CTRL_PARAM
{
    DWORD  dwSize;
    DWORD  dwChannel; //Channel
    BYTE  byCardType;//Card Type 0-The temporary card
    BYTE  byDeleteALL;//Whether to delete all 0-not delete\A3\AC1-delete
    BYTE  byRes[62];
}NET_DVR_PARKING_CARD_CTRL_PARAM,*LPNET_DVR_PARKING_CARD_CTRL_PARAM;

//TME Vehicle Result
typedef struct tagNET_DVR_TME_VEHICLE_RESULT_
{
    DWORD   dwSize;
    WORD    wLaneid; //Lane ID;1\A1\AB32
    BYTE    byCamLaneId; //Camera Lane ID;1\A1\AB16
    BYTE    byRes1;
    DWORD   dwChanIndex; //Channel Index
    NET_DVR_PLATE_INFO  struPlateInfo; //Plate Info
    NET_DVR_VEHICLE_INFO struVehicleInfo; //Vehicle Info
    BYTE    byMonitoringSiteID[48]; //Monitoring Site ID
    BYTE    byDeviceID[48]; //Device ID
    BYTE    byDir;     //Monitoring direction
    BYTE    byRes2;
    WORD    wBackList; //Back List
    DWORD   dwPicNum; //Pictruce Number
    NET_ITS_PICTURE_INFO struPicInfo[4];  //Pictruce Info
    BYTE    byPassVehicleID[32];    //Vehicle ID
    BYTE    byCardNo[48]; // Card No
    BYTE    bySwipeTime[32];//Swipe Time
    DWORD   dwCharge;      //Charge
    BYTE    byHistory;     //History
    BYTE    byLetPass;     //Let Pass
    BYTE    byRes3[186];
} NET_DVR_TME_VEHICLE_RESULT, *LPNET_DVR_TME_VEHICLE_RESULT;

//Parking Vehicle Info
typedef struct tagNET_DVR_PARKING_VEHICLE
{
    DWORD   dwSize;
    DWORD   dwChannel;//Channel
    char    szLicense[MAX_LICENSE_LEN/*16*/];//License
    char    szRelateCardNo[MAX_CARDNO_LEN/*48*/];//Card No
    NET_DVR_TIME_V30 struStartTime;//Start Time
    NET_DVR_TIME_V30 struEndTime;//End Time
    BYTE    byVehicleType;//Vehicle Type
    BYTE    byPlateColor;//Plate Color
    BYTE    byRes[126];
}NET_DVR_PARKING_VEHICLE,*LPNET_DVR_PARKING_VEHICLE;

//The amount of payment information
typedef    struct tagNET_DVR_CHARGEACCOUNT_CFG
{
    DWORD   dwSize;
    float   fAccount;//Account
    BYTE    byRes[128];
}NET_DVR_CHARGEACCOUNT_CFG,*LPNET_DVR_CHARGEACCOUNT_CFG;

//PXMultiCtrl Configuration
typedef    struct tagNET_DVR_PXMULTICTRL_CFG
{
    DWORD        dwSize;
    DWORD        dwMultiChansWaitTime;//Wait Time\A3\A81~300s\A3\A9
    BYTE         byMultiChansCapEnabled;//Enabled
    BYTE        byRes[127];
}NET_DVR_PXMULTICTRL_CFG,*LPNET_DVR_PXMULTICTRL_CFG;

//PX Offline Cfg
typedef    struct tagNET_DVR_PXOFFLINE_CFG
{
    DWORD   dwSize;
    BYTE    byEnabled;//Enabled
    BYTE    byChargeEnabled;//Charge Enabled
    BYTE    byAlarmEnabled;//Alarm Enabled
    BYTE    byRecordSource;//Record Source
    DWORD   dwTimeWait;//Time Wait\A3\A81-300s\A3\A9
    /**
    realeaseMode&(0x1<<0) Fixed the car.
    realeaseMode&(0x1<<1) Release of fixed card
    realeaseMode&(0x1<<2) Temporary vehicle release
    realeaseMode&(0x1<<3) The temporary card
    realeaseMode&(0x1<<4) No license plate
    realeaseMode&(0x1<<5) Fixed vehicle if free will automatically release
    realeaseMode&(0x1<<6) If the temporary car free automatic release
    */
    DWORD   dwRealeaseMode; //Realease Mode
    BYTE    byVehCardmatch;//Car line card
    BYTE    bySingleInSingleOut;//Single In Single Out
    BYTE    byRes[126];
}NET_DVR_PXOFFLINE_CFG,*LPNET_DVR_PXOFFLINE_CFG;

typedef    struct tagNET_DVR_PARKINGSAPCE_CFG
{
    DWORD    dwSize;
    DWORD     dwTotalParkingLot;//The total number of parking spaces
    DWORD    dwCurrParkingLot;//The remaining number of parking spaces
    BYTE    byRes[128];
}NET_DVR_PARKINGSAPCE_CFG,*LPNET_DVR_PARKINGSAPCE_CFG;

typedef    struct tagNET_DVR_PAPERCHARGEINFO_CFG
{
    DWORD   dwSize;
    char    szBarCode[LEN_16];//Bar Code
    char    szLicense[MAX_LICENSE_LEN]; //License
    char    szVehicleInTime[LEN_32];//Vehicle In Time\A3\A8YYYY-MM-DD HH:MM:SS\A3\A9
    char    szPaymentTime[LEN_32];//Payment Time\A3\A8YYYY-MM-DD HH:MM:SS\A3\A9
    float   fPaymentAmount;//Payment Amount
    DWORD   dwPaymentOutFailureTime;//Payment Out Failure Time
    BYTE    byVehicleOutEnabled; //Vehicle Out Enabled
    BYTE    byRes[128];
}NET_DVR_PAPERCHARGEINFO_CFG,*LPNET_DVR_PAPERCHARGEINFO_CFG;

//parking Paper parameters
typedef    struct tagNET_DVR_ILLEGALCARDFILTERING_CFG
{
    DWORD   dwSize;
    char    sLEDDefaultInfo[MAX_LED_INFO_LEN/*512*/]; // LED Default Info
    BYTE    byillegalCardFilteringEnabled;//Illegal Card Filtering Enabled
    BYTE    bySendCardSensingCoilEnabled;//Send Card Sensing Coil Enabled
    BYTE    byWiegendSensingCoilEnabled;//Wiegend Sensing Coil Enabled
    BYTE    byGateSwitchEnabled; //Gate Switch Enabled
    BYTE    byVerifyKeyWriteCardEnabled;//Verify Key Write Card Enabled
    BYTE    byNoplateTakeCardEnabled;// No plate Take Card Enabled
    BYTE    byRes[126];
}NET_DVR_ILLEGALCARDFILTERING_CFG,*LPNET_DVR_ILLEGALCARDFILTERING_CFG;

//Entrance Vehicle Card Cond
typedef struct tagNET_DVR_TME_CHARGERULE_COND
{
    DWORD   dwSize;
    DWORD   dwChannel;  //channel
    char    szCardNo[32];//Card No
    BYTE    byRes[128];
}NET_DVR_TME_CHARGERULE_COND, *LPNET_DVR_TME_CHARGERULE_COND;

//LED Display Cfg
typedef    struct tagNET_DVR_LEDDISPLAY_CFG
{
    DWORD   dwSize;
    char    sDisplayInfo[MAX_LED_INFO_LEN/*512*/]; // LED Display Info
    BYTE    byDisplayMode;//Display Mode
    BYTE    bySpeedType;//Speed Type
    BYTE    byShowPlateEnable;//Show Plate Enable\A3\AC0~disable\A3\AC1~enable
    BYTE    byRes1;
    DWORD   dwShowTime;//Show Time\A3\AC1~60s
    BYTE    byRes[128];
}NET_DVR_LEDDISPLAY_CFG,*LPNET_DVR_LEDDISPLAY_CFG;

//Voice BroadCast Cfg
typedef    struct tagNET_DVR_VOICEBROADCAST_CFG
{
    DWORD        dwSize;
    char        sInfo[MAX_VOICE_INFO_LEN/*128*/]; //Voice BroadCast Info
    BYTE        byRes[128];
}NET_DVR_VOICEBROADCAST_CFG,*LPNET_DVR_VOICEBROADCAST_CFG;

//Prper Print Format Cfg
typedef    struct tagNET_DVR_PAPERPRINTFORMAT_CFG
{
    DWORD        dwSize;
    char        sTitleInfo[MAX_LITLE_INFO_LEN/*64*/]; //Title Info
    char        sCustomInfo[MAX_CUSTOM_INFO_LEN/*64*/]; //Custom Info
    char        sPhoneNum[MAX_PHONE_NUM_LEN/*16*/];//Phone Num
    BYTE        byPrintInTimeEnabled; //Print InTime Enabled
    BYTE        byRes[127];
}NET_DVR_PAPERPRINTFORMAT_CFG,*LPNET_DVR_PAPERPRINTFORMAT_CFG;


//Lock Gate Time Cfg
typedef    struct tagNET_DVR_LOCKGATE_TIME_CFG
{
    char        sBeginTime[LEN_32];//Begin Time\A3\A8HH:MM:SS\A3\A9
    char        sEndTime[LEN_32];//End Time\A3\A8HH:MM:SS\A3\A9
    BYTE        byRes[64];
}NET_DVR_LOCKGATE_TIME_CFG,*LPNET_DVR_LOCKGATE_TIME_CFG;

//Lock Gate Cfg
typedef    struct tagNET_DVR_LOCKGATE_CFG
{
    DWORD        dwSize;
    NET_DVR_LOCKGATE_TIME_CFG struTime[4]; //Lock Gate Time Cfg
    BYTE        byRes[128];
}NET_DVR_LOCKGATE_CFG,*LPNET_DVR_LOCKGATE_CFG;

//Parking Data State Info
typedef struct NET_DVR_PARKING_DATASTATE_INFO
{
    DWORD   dwSize;
    char    szAppSerialNum [MAX_APP_SERIALNUM_LEN/*32*/];//App Serial Num
    DWORD   dwParkingNum; //Parking Num
    DWORD   dwUpdataSerialNum; //Updata Serial Num
    BYTE    byRes[256];
} NET_DVR_PARKING_DATASTATE_INFO,*LPNET_DVR_PARKING_DATASTATE_INFO;

//EPTZ parameter
typedef    struct tagNET_DVR_EPTZ_CFG
{
    DWORD dwSize;
    BYTE    byEnableEPTZ;        //whether enable EPTZ
    BYTE    byRes[503];
}NET_DVR_EPTZ_CFG, *LPNET_DVR_EPTZ_CFG;

//center point parameter
typedef    struct tagNET_DVR_CENTER_POINT_CFG
{
    DWORD dwSize;
    NET_VCA_POLYGON struRegion;
    BYTE    byRes[512];
}NET_DVR_CENTER_POINT_CFG, *LPNET_DVR_CENTER_POINT_CFG;

/********************************DS-TME4XXControl machine development End****************************/

//info publish upgrade
typedef struct tagNET_DVR_PUBLISH_UPGRADE_COND
{
    DWORD dwSize;
    DWORD dwUpgradeType;    //Upgrade type, 1 - according to the terminal upgrade, upgrade 2 - according to the terminal groups
    DWORD dwTerminalNum;    //Upgrade of terminal format, according to the terminal when upgrading effectively
    DWORD *pTerminalNo;     //Need to upgrade the terminal number, according to the terminal when upgrading effectively
    DWORD dwGroupNo;        //Terminal groups, according to the terminal set is upgrading effectively
    BYTE  byRes[32];
}NET_DVR_PUBLISH_UPGRADE_COND, *LPNET_DVR_PUBLISH_UPGRADE_COND;

typedef struct tagNET_DVR_SUB_UPGRADE_PROGRESS
{
    DWORD dwTerminalNo; //ternmal num
    DWORD dwProgress;   //progress\A3\AC0-100\A3\AC101 denote exception,
}NET_DVR_SUB_UPGRADE_PROGRESS, *LPNET_DVR_SUB_UPGRADE_PROGRESS;

typedef struct tagNET_DVR_UPGRADE_PROGRESS_RESULT
{
    DWORD  dwSize;
    DWORD  dwMainProgress;      //main progress\A3\AC0-100\A3\ACAccording to the schedule for the whole set is gain schedule release schedule, according to the terminal when get progress for a single terminal schedule release schedule
    DWORD  dwSubProgressNum;    //sub progress num
    LPNET_DVR_SUB_UPGRADE_PROGRESS  lpStruSubProgress; //Each terminal schedule release schedule, according to the set of access available at the time,dwSubProgressNum NET_DVR_SUB_SCHEDULE_PROGRESS
    BYTE   byRes[32];
}NET_DVR_UPGRADE_PROGRESS_RESULT, *LPNET_DVR_UPGRADE_PROGRESS_RESULT;



//WEP Key
typedef struct tagNET_DVR_WEP_KEY_CFG
{
    char   csWEPKey[WEP_KEY_MAX_SIZE/*32*/];//WEP Key\A3\AC
    BYTE    byRes[64];
}NET_DVR_WEP_KEY_CFG, *LPNET_DVR_WEP_KEY_CFG;


//WEP
typedef struct tagNET_DVR_WEP_CFG
{
    BYTE   byAuthenticationType;//Authentication Type
    BYTE   byDefaultTransmitKeyIndex;//Default Transmit Key Index\A3\AC1~4
    BYTE   byWepKeyLenType;//Wep Key Length Type\A3\BB0~   64 bit\A3\AC1~  128 bit\A1\A3
    BYTE   byKeyType;// Key Type\A3\BB0~   ASCII\A3\AC1~  Hex\A1\A3
    NET_DVR_WEP_KEY_CFG struWEPKeyCfg[WEP_KEY_MAX_NUM/*4*/];// WEP Key\A1\A3
    BYTE   byRes[128];
}NET_DVR_WEP_CFG, *LPNET_DVR_WEP_CFG;

//WPA
typedef struct tagNET_DVR_WPA_CFG
{
    BYTE   byAlgorithmType; //Algorithm Type\A3\BB0~TKIP, 1~AES, 2~TKIP/AES
    BYTE   byWPAKeyLen;// WPA Key Length\A3\AC8~63
    BYTE   byDefaultPassword;//Default Password
    BYTE   byRes1;
    char   csSharedKey[WPA_KEY_MAX_SIZE/*64*/];//Shared Key
    BYTE   byRes[128];
}NET_DVR_WPA_CFG, *LPNET_DVR_WPA_CFG;


typedef struct tagNET_DVR_WIRELESS_SECURITY_CFG
{
    BYTE   bySecurityMode; //Security Mode\A3\BB0~Disable,1~WEP,2~WPA-personal, 3~WPA2-personal
    NET_DVR_WEP_CFG  struWEPCfg; //WEP
    NET_DVR_WPA_CFG  struWPACfg; //WPA
    BYTE    byRes[256];
} NET_DVR_WIRELESS_SECURITY_CFG,*LPNET_DVR_WIRELESS_SECURITY_CFG;

//wifi Cfg (Full Version)
typedef struct tagNET_DVR_WIRELESSSERVER_FULLVERSION_CFG
{
    DWORD    dwSize;
    BYTE    byWifiAPEnabled;    // Wifi AP
    BYTE    byBroadcastEnabled; //Broadcast
    BYTE    byWlanShareEnabled; //WlanShare
    BYTE    byDHCPEnabled;  // DHCP
    BYTE    bySSID[IW_ESSID_MAX_SIZE]; //SSID
    BYTE    byRes1[11];
    BYTE    byIPType;  //IP Type, 0-IPv4,1-IPv6
    NET_DVR_IPADDR    struIPAddr; // IP Address
    NET_DVR_IPADDR    struIPMask; // IP Mask
    NET_DVR_IPADDR    struGatewayIPMask; // Gateway IP Mask
    NET_DVR_IPADDR    struStartIPAddrPool;  //Start IP Address Pool
    NET_DVR_IPADDR    struEndIPAddrPool;  //End IP Address Pool
    NET_DVR_IPADDR    struDNSServerIpAddr[MAX_DNS_SERVER_NUM]; //DNS Server Ip Address
    NET_DVR_WIRELESS_SECURITY_CFG struWirelessSecurityCfg; // Wireless Security
    BYTE    byRes[256];
}NET_DVR_WIRELESSSERVER_FULLVERSION_CFG, *LPNET_DVR_WIRELESSSERVER_FULLVERSION_CFG;

typedef struct tagNET_DVR_OPTICAL_DEV_CHAN_INFO
{
    DWORD dwChannel;    //Channel No., 0 is invalid
    BYTE byChannelName[NAME_LEN]; //Channel name
    BYTE bySignal;  //Signal state,0-no signal,1-signal,read only
    BYTE bySignalType;  //Signal type,1-SD,2-HD,read only
    BYTE byRes[10];
}NET_DVR_OPTICAL_DEV_CHAN_INFO, *LPNET_DVR_OPTICAL_DEV_CHAN_INFO;

typedef struct tagNET_DVR_OPTICAL_DEV_NODE
{
    BYTE  byValid;    //0-invalid,1-valid
    BYTE  byRes1[3];
    DWORD dwDevNo;    //Optical device No.
    BYTE  byDevName[NAME_LEN];   //Optical device name
    BYTE  byDevID[MAX_ID_LEN];   //Optical device ID
    NET_DVR_OPTICAL_DEV_CHAN_INFO struChannel[MAX_CHANNUM]; //Optical device channel information
    BYTE  byRes2[32];
}NET_DVR_OPTICAL_DEV_NODE, *LPNET_DVR_OPTICAL_DEV_NODE;

#define MAX_OPTICAL_DEV_NODE 32     //Max node optical device number

typedef struct tagNET_DVR_OPTICAL_PORT_INFO
{
    DWORD dwSize;
    BYTE  byValid;   //Signal state,0-no signal,1-signal
    BYTE  byLinkType;    //Link type,1-ring network,2-chain network,read only
    BYTE  byPortWorkMode;    //Port work mode,0-invalid,1-main port,2-auxiliary port,valid for ring network,read only
    BYTE  byRes1[1];
    DWORD dwPairPort;    //Pair port No.,valid for ring network
    NET_DVR_OPTICAL_DEV_NODE struDevInfo[MAX_OPTICAL_DEV_NODE]; //Optical device information
    BYTE  byRes2[32];
}NET_DVR_OPTICAL_PORT_INFO, *LPNET_DVR_OPTICAL_PORT_INFO;

typedef struct tagNET_DVR_OPTICAL_CHAN_RELATE_CFG
{
    DWORD dwSize;
    BYTE  byEnable;    //weather relate input,0-no,!0-yes
    BYTE  byRes1[3];
    DWORD dwDevNo;    //Optical device No.
    DWORD dwOpticalPort;  //Optical port No.
    BYTE  byDevID[MAX_ID_LEN];   //OPtical device No.
    DWORD dwInputChanNo;  //Optical device input channel No.
    BYTE  byRes2[64];
}NET_DVR_OPTICAL_CHAN_RELATE_CFG, *LPNET_DVR_OPTICAL_CHAN_RELATE_CFG;

//optical fiber LLDP parameter
typedef struct tagNET_DVR_LLDP_PORT_CFG
{
    BYTE byCardNo;      //card No.
    BYTE byPortNo;      //port No.
    BYTE byEnabledTx;   //send LLDP packet enable, 0-disable, 1-enable
    BYTE byEnabledRx;   //receive LLDP packet enable, 0-disable, 1-enable
    BYTE byRes[12];
}NET_DVR_LLDP_PORT_CFG, *LPNET_DVR_LLDP_PORT_CFG;

typedef struct tagNET_DVR_LLDP_CFG
{
    DWORD dwSize;
    BYTE  byEnabled;    //LLDP enable, 0-disable, 1-enable
    BYTE  byRes1[3];
    DWORD dwHoldTime;   //hold time, unit:s
    DWORD dwReiniTime;  //reinitialize time, unit:s
    DWORD dwPacketTime; //packet time, unit:s
    NET_DVR_LLDP_PORT_CFG struLLDPPortCfg[MAX_PORT_NUM]; //port LLDP parameter
    BYTE  byRes2[32];
}NET_DVR_LLDP_CFG, *LPNET_DVR_LLDP_CFG;

//optical fiber basic parameter
typedef struct tagNET_DVR_CARD_PORT_INFO
{
    DWORD dwPortNo;              //port No., 0-invalid
    BYTE  byPortName[NAME_LEN];  //port name
    BYTE  byWorkMode;            //working mode, 1-ACCESS, 2-TRUNK, 3-HYPRID
    BYTE  byBandWidth;           //bandwidth, 1-100M, 2-1G, 3-10G
    BYTE  byPortType;            //port type, 1-electricity, 2-optical, 3-multiplex
    BYTE  byRes[13];
}NET_DVR_CARD_PORT_INFO, *LPNET_DVR_CARD_PORT_INFO;

typedef struct tagNET_DVR_NETMGR_CARD_INFO
{
    BYTE  byTypeName[NAME_LEN];           //type name
    BYTE  bySerialNo[SERIALNO_LEN];       //serial No.
    BYTE  bySoftwareVersion[VERSION_LEN]; //software version
    NET_DVR_IPADDR struIPAddr;            //IP
    DWORD dwSlotNo;                          //main slot No.
    BYTE  byStructureType;                //structure type, 1-2U, 2-4U
    BYTE  byRes1[3];
    NET_DVR_CARD_PORT_INFO struNetPortInfo[MAX_SINGLE_CARD_PORT_NO]; //net port information
    BYTE  byRes2[32];
}NET_DVR_NETMGR_CARD_INFO, *LPNET_DVR_NETMGR_CARD_INFO;

typedef struct tagNET_DVR_FUNC_CARD_INFO
{
    DWORD dwCardNo;                       //card No, start from 1
    BYTE  byTypeName[NAME_LEN];           //type name
    BYTE  bySerialNo[SERIALNO_LEN];       //serial No.
    BYTE  bySoftwareVersion[VERSION_LEN]; //software version
    DWORD dwMainSlot;                     //main slot No., start from 1
    BYTE  byStructureType;                //structure type, 1-2U, 2-4U
    BYTE  byRes1[3];
    NET_DVR_CARD_PORT_INFO struFuncPortInfo[MAX_SINGLE_CARD_PORT_NO]; //port information
    BYTE  byRes2[32];
}NET_DVR_FUNC_CARD_INFO, *LPNET_DVR_FUNC_CARD_INFO;

typedef struct tagNET_DVR_FIBER_CONVERT_BASIC
{
    DWORD dwSize;
    BYTE  byPowerType; //power type, 1-single, 2-double
    BYTE  byRes1[3];
    DWORD dwSlotNum;   //main slot No.
    NET_DVR_NETMGR_CARD_INFO struNetCardInfo;                     //net management card information
    NET_DVR_FUNC_CARD_INFO   struFuncCardInfo[MAX_FUNC_CARD_NUM]; //function card information
    BYTE  byRes2[64];
}NET_DVR_FIBER_CONVERT_BASIC, *LPNET_DVR_FIBER_CONVERT_BASIC;

//optical fiber work status parameter
typedef struct tagNET_DVR_CARD_PORT_STATE
{
    BYTE  byValid;                 //valid, 0-invalid, 1-valid
    BYTE  byPortType;            //port type, 1-electricity, 2-optical, 3-multiplex
    BYTE  byLinkState;           //connection status, 0-disconnected\A3\AC1-connected
    BYTE  byRes1;
    DWORD dwSendBytes;           //send bytes
    DWORD dwRecvBytes;           //receive bytes
    DWORD dwRecvLostPackets;     //lost packets
    DWORD dwRecvCrcErrPackets;   //CRC error packets
    DWORD dwRecvFragmentPackets; //receive fragments, conflict, and too short byte packets
    BYTE  byRes2[16];
}NET_DVR_CARD_PORT_STATE, *LPNET_DVR_CARD_PORT_STATE;

typedef struct tagNET_DVR_NET_CARD_STATE
{
    NET_DVR_CARD_PORT_STATE struNetPortState[MAX_SINGLE_CARD_PORT_NO];    //port status
    BYTE byRes[64];
}NET_DVR_NET_CARD_STATE, *LPNET_DVR_NET_CARD_STATE;

typedef struct tagNET_DVR_FUNC_CARD_STATE
{
    BYTE  byEnabled; //valid, 0-invalid, 1-valid
    BYTE  byRes1[3];
    DWORD dwCardNo;  //card No.
    NET_DVR_CARD_PORT_STATE struFuncCardPortState[MAX_SINGLE_CARD_PORT_NO];
    BYTE  byRes[32];
}NET_DVR_FUNC_CARD_STATE, *LPNET_DVR_FUNC_CARD_STATE;

typedef struct tagNET_DVR_FIBER_CONVERT_STATE
{
    DWORD dwSize;
    NET_DVR_NET_CARD_STATE struNetCardState;                      //net management card status
    NET_DVR_FUNC_CARD_STATE struFuncCardState[MAX_FUNC_CARD_NUM]; //function card status
    BYTE  byRes[32];
}NET_DVR_FIBER_CONVERT_STATE, *LPNET_DVR_FIBER_CONVERT_STATE;

//optical fiber topology parameter
typedef struct tagNET_DVR_FC_PORT_TOPOLOGY
{
    DWORD dwPortNo;                 //port No., 0-invalid
    BYTE  byPortType;               //port type, 1-electricity, 2-optical, 3-multiplex
    BYTE  byLocalWorkMode;          //local working mode, 1-ACCESS, 2-TRUNK, 3-HYPRID
    BYTE  byLocalBandWidth;         //local bandwidth, 1-100M, 2-1G, 3-10G
    BYTE  byRes1[1];
    BYTE  byPeerTypeName[NAME_LEN]; //peer type name
    BYTE  byPeerMac[MACADDR_LEN];   //peer MAC address
    DWORD dwPeerPortNo;             //peer port No.
    BYTE  byPeerWorkMode;           //peer working mode, 1-ACCESS, 2-TRUNK, 3-HYPRID
    BYTE  byPeerBandWidth;          //peer bandwidth, 1-100M, 2-1G, 3-10G
    BYTE  byRes2[30];
}NET_DVR_FC_PORT_TOPOLOGY, *LPNET_DVR_FC_PORT_TOPOLOGY;

typedef struct tagNET_DVR_FC_CARD_TOPOLOGY
{
    BYTE  byEnable;                    //valid, 0-invalid, 1-valid
    BYTE  byRes1[3];
    DWORD dwCardNo;                 //card No, 0-net management card, non-zero-function card
    DWORD dwSlotNum;                //used slots
    BYTE  byTypeName[NAME_LEN];        //type name
    BYTE  byLocalMac[MACADDR_LEN];  //local MAC address
    NET_DVR_FC_PORT_TOPOLOGY struFCPortTopology[MAX_SINGLE_CARD_PORT_NO]; //port topology information
    BYTE  byRes[32];
}NET_DVR_FC_CARD_TOPOLOGY, *LPNET_DVR_FC_CARD_TOPOLOGY;

typedef struct tagNET_DVR_FIBER_CONVERT_TOPOLOGY
{
    DWORD dwSize;
    NET_DVR_FC_CARD_TOPOLOGY struFCCardTopology[MAX_FC_CARD_NUM];
    BYTE byRes[64];
}NET_DVR_FIBER_CONVERT_TOPOLOGY, *LPNET_DVR_FIBER_CONVERT_TOPOLOGY;

//optical fiber port remarks parameter
typedef struct tagNET_DVR_FC_COND
{
    DWORD dwSize;
    DWORD dwSlotNo; //slot No.
    DWORD dwPortNo; //port No.
    BYTE  byRes[32];
}NET_DVR_FC_COND, *LPNET_DVR_FC_COND;

typedef struct tagNET_DVR_FC_PORT_REMARKS
{
    DWORD dwSize;
    BYTE  byLocalRemarks[MAX_REMARKS_LEN]; //local port remarks information
    BYTE  byPeerRemarks[MAX_REMARKS_LEN];  //peer port remarks information
    BYTE  byRes[32];
}NET_DVR_FC_PORT_REMARKS, *LPNET_DVR_FC_PORT_REMARKS;

typedef enum _EN_FIBER_CONVERT_ALARM
{
    FC_OPTICAL_PORT_LOST = 1,
    FC_ELECTRICAL_PORT_LOST,
    FC_FUNC_CARD_LOST,
}EN_FIBER_CONVERT_ALARM;

typedef enum _EN_FIBER_CONVERT_NOTIFICATION
{
    FC_OPTICAL_PORT_CONNECTED = 1,
    FC_ELECTRICAL_PORT_CONNECTED,
    FC_FUNC_CARD_INSERT,
}EN_FIBER_CONVERT_NOTIFICATION;

typedef struct tagNET_DVR_FIBER_CONVERT_ALARM
{
    DWORD dwSize;
    DWORD dwEventType;  //event type, 1-alarm, 2-notice
    DWORD dwEvent;      //event, when event type is alarm, please refer EN_FIBER_CONVERT_ALARM, otherwise refer EN_FIBER_CONVERT_NOTIFICATION
    BYTE bySlotNum;     //slot No.
    BYTE byCardType;    //card type, 1-net management card, 2-function card
    BYTE byPortNo;      //port No., start from 1
    BYTE byRes1[33];
}NET_DVR_FIBER_CONVERT_ALARM, *LPNET_DVR_FIBER_CONVERT_ALARM;

typedef  struct tagNET_DVR_START_FILE_TO_CLOUD_COND
{
    DWORD    dwSize;
    BYTE    aCameraID[MAX_CAMERAID_LEN];    //camera ID
    DWORD      dwPoolID;   //storage pool ID
    DWORD      dwRepPoolID;
    WORD      wReplication;
    BYTE       byRes [178];
}NET_DVR_START_FILE_TO_CLOUD_COND,*LPNET_DVR_START_FILE_TO_CLOUD_COND;

typedef  struct     tagNET_DVR_START_PICTURE_FROM_CLOUD_COND
{
    DWORD       dwSize;
    BYTE        aCameraID[MAX_CAMERAID_LEN];    //camera ID
    NET_DVR_TIME_V30    struBeginTime;  //start time
    NET_DVR_TIME_V30    struEndTime;    //stop time
    DWORD   dwPicType;  //picture type
    //bit0-JPG
    //bit1-BMP
    //bit2-PNG
    BYTE    byRes1[3];
    BYTE    byZoomType;    //0-no zoom,1-by scale,2-by quality,3-by resolution
    union
    {
        BYTE    uLen[32];
        struct
        {
            BYTE        byScale;         //1~99
        }struScale;
        struct
        {
            BYTE        byQuality;    //1~99
        }struQuality;
        struct
        {
            DWORD       dwWidth;
            DWORD       dwHeight;
        }struResolution;
    }uZoomParam;
    DOWNLOAD_DATA_CB    fnDownloadFileCallBack;    //picture data callback
    void*   pUser;    //user data pointer
    BYTE    byRes [372];
}NET_DVR_START_PICTURE_FROM_CLOUD_COND,*LPNET_DVR_START_PICTURE_FROM_CLOUD_COND;

typedef     struct    tagNET_DVR_START_PICTURE_FROM_CLOUD_RET
{
    DWORD       dwSize;
    DWORD       dwFileCount;    //file count
    BYTE        byRes[120];
}NET_DVR_START_PICTURE_FROM_CLOUD_RET,*LPNET_DVR_START_PICTURE_FROM_CLOUD_RET;

typedef  struct
{
    DWORD       dwSize;
    NET_DVR_TIME_V30    struTime;    //picture time
    DWORD       dwPicLen;    //picture kength
    BYTE        byPicType;    //picture type,1-jpg,2-bmp,3-png
    BYTE        byRes[107];
}NET_DVR_PICTURE_FROM_CLOUD_RET,*LPNET_DVR_PICTURE_FROM_CLOUD_RET;

typedef struct tagNET_DVR_ACS_EXTERNAL_DEV_CFG
{
    DWORD dwSize;
    BYTE byIDCardUpMode;  //ID card upload mode\A3\AC0\A3\BAup card number\A3\BB1\A3\BAup all info
    BYTE byRes1;
    BYTE byCardVerifyMode; //Credit card authentication mode, 0: remote center certification; 1: client platform authentication
    BYTE byACSDevType;//Id card reader, equipment type, 1:2: IC card reader, 3: qr code reader, 4: fingerprint reader, 5: character screen + qr code reader, 6: recipient, 7: character screen, 8: fingerprint head, 9: voice module
    BYTE byDoorMode; //access mode\A3\AC0\A3\BAin door\A3\AC1\A3\BAout door
    BYTE byRes2;
    WORD wDevDetailType; //1-iDR210\A3\AC2-IDM10\A3\BB
    BYTE byRes[300];
}NET_DVR_ACS_EXTERNAL_DEV_CFG, *LPNET_DVR_ACS_EXTERNAL_DEV_CFG;

typedef struct tagNET_DVR_PERSONNEL_CHANNEL_CFG
{
    DWORD dwSize;
    BYTE byInMode;            //in mode\A3\AC0-controlled\A3\BB1-forbid\A3\BB2-freedom\A3\BB
    BYTE byOutMode;         //out mode\A3\AC0-controlled\A3\BB1-forbid\A3\BB2-freedom\A3\BB
    BYTE byWorkMode;        //work mode\A3\AC0-urgent\A3\BB1-repair\A3\BB2-normal Close\A3\BB3-normal Open\A3\BB
    BYTE byRes[301];
}NET_DVR_PERSONNEL_CHANNEL_CFG, *LPNET_DVR_PERSONNEL_CHANNEL_CFG;

#define MAX_ID_NUM_LEN                  32
#define MAX_ID_NAME_LEN                 128
#define MAX_ID_ADDR_LEN                 280
#define MAX_ID_ISSUING_AUTHORITY_LEN    128

typedef struct tagNET_DVR_ID_CARD_INFO
{
    DWORD  dwSize;
    BYTE  byName[MAX_ID_NAME_LEN];
    NET_DVR_DATE struBirth;
    BYTE byAddr[MAX_ID_ADDR_LEN];
    BYTE byIDNum[MAX_ID_NUM_LEN];
    BYTE byIssuingAuthority[MAX_ID_ISSUING_AUTHORITY_LEN];
    NET_DVR_DATE struStartDate;
    NET_DVR_DATE struEndDate;
    BYTE byTermOfValidity;
    BYTE   bySex;
    BYTE  byNation;
    BYTE byRes[101];
}NET_DVR_ID_CARD_INFO, *LPNET_DVR_ID_CARD_INFO;

typedef struct tagNET_DVR_ID_CARD_INFO_ALARM
{
    DWORD  dwSize;
    NET_DVR_ID_CARD_INFO    struIDCardCfg;
    DWORD dwMajor;
    DWORD dwMinor;
    NET_DVR_TIME_V30  struSwipeTime;
    BYTE    byNetUser[MAX_NAMELEN];
    NET_DVR_IPADDR    struRemoteHostAddr;
    DWORD dwCardReaderNo;
    DWORD dwDoorNo;
    DWORD dwPicDataLen;
    char    *pPicData;
    BYTE byCardType;
    BYTE byRes[207];
}NET_DVR_ID_CARD_INFO_ALARM, *LPNET_DVR_ID_CARD_INFO_ALARM;

typedef struct tagNET_DVR_PASSNUM_INFO_ALARM
{
    DWORD  dwSize;
    DWORD  dwAccessChannel;
    NET_DVR_TIME_V30  struSwipeTime;
    BYTE    byNetUser[MAX_NAMELEN];
    NET_DVR_IPADDR    struRemoteHostAddr;
    DWORD    dwEntryTimes;    //entry times
    DWORD    dwExitTimes;        //exit times
    DWORD    dwTotalTimes;        //total times\A3\BB
    BYTE byRes[300];
}NET_DVR_PASSNUM_INFO_ALARM, *LPNET_DVR_PASSNUM_INFO_ALARM;

typedef struct tagNET_DVR_ONLINEUSER_COND
{
    DWORD   dwSize;
    DWORD  dwChannel;
    BYTE   byRes [128];
}NET_DVR_ONLINEUSER_COND,*LPNET_DVR_ONLINEUSER_COND;

typedef struct tagNET_DVR_ONLINEUSER_CFG
{
    DWORD   dwSize;
    BYTE   byID;
    BYTE   byUserType;
    BYTE   byDataType;//Data Type
    BYTE   byRes;
    NET_DVR_IPADDR  struIpAddr;
    NET_DVR_TIME_V30  struLoginTime;
    char   szUserName[NAME_LEN/*32*/];
    BYTE   byRes1[128];
}NET_DVR_ONLINEUSER_CFG,*LPNET_DVR_ONLINEUSER_CFG;

//Storage Detection State
typedef    struct tagNET_DVR_STORAGE_DETECTION
{
    DWORD    dwSize;
    BYTE    byHealthState;//Health State
    BYTE    bySDCardState;//SDcard State
    WORD    wAbnormalPowerLoss;//Abnormal Power Loss
    WORD    wBadBlocks;//Bad Blocks
    BYTE    byRemainingLife; //SD Card Remaining Life; 0~100%
    BYTE    byRes[125];
}NET_DVR_STORAGE_DETECTION,*LPNET_DVR_STORAGE_DETECTION;

//Storge Detection Alarm
typedef struct tagNET_DVR_STORAGE_DETECTION_ALARM
{
    DWORD   dwSize;
    DWORD     dwRelativeTime; //Relative Time
    DWORD    dwAbsTime; //Abs Time
    NET_VCA_DEV_INFO  struDevInfo;   //Device Info
    DWORD   dwCardID;   //Card ID
    WORD    wAbnormalPowerLoss;//Abnormal Power Loss
    WORD    wBadBlocks;//Bad Blocks
    BYTE    byHealthState;//Health State
    BYTE    byRes1[3];
    float   fResidualLife; //SD card Residual Life0~100%
    BYTE    byRes[118];
}NET_DVR_STORAGE_DETECTION_ALARM,*LPNET_DVR_STORAGE_DETECTION_ALARM;

//Storage Rwloack
typedef    struct tagNET_DVR_STORAGE_RWLOCK
{
    DWORD   dwSize;
    BYTE    byEnabled;//Enable
    BYTE    byRes[3];
    char    szPassWD[PASSWD_LEN/*16*/]; //New Password
    char    szOriginalPassWD[PASSWD_LEN/*16*/]; //Original Password
    BYTE    byRes1[128];
}NET_DVR_STORAGE_RWLOCK,*LPNET_DVR_STORAGE_RWLOCK;

//Storage Unloack
typedef    struct tagNET_DVR_STORAGE_UNLOCK
{
    DWORD   dwSize;
    char    szPassWD[PASSWD_LEN/*16*/]; //Password
    BYTE    byRes1[128];
}NET_DVR_STORAGE_UNLOCK,*LPNET_DVR_STORAGE_UNLOCK;

typedef    struct tagNET_DVR_PTZTRACKSTATUS
{
    DWORD        dwSize;
    BYTE          byID;//ID (the of the field byLinkageType is effective).
    BYTE      byLinkageType;//Linkage action 0- not linkage, 1- linkage ball machine equipment tracking
    BYTE      byRes[254];
}NET_DVR_PTZTRACKSTATUS,*LPNET_DVR_PTZTRACKSTATUS;

#define MAX_PROXY_COUNT 32

typedef struct tagNET_DVR_SOCKS_PROXY_PARA
{
    BYTE  byIP[129];
    BYTE  byAuthType;
    WORD  wPort;
    BYTE  byRes2[64];
}NET_DVR_SOCKS_PROXY_PARA, *LPNET_DVR_SOCKS_PROXY_PARA;

typedef struct tagNET_DVR_SOCKS_PROXYS
{
    NET_DVR_SOCKS_PROXY_PARA struProxy[MAX_PROXY_COUNT];
}NET_DVR_SOCKS_PROXYS, *LPNET_DVR_SOCKS_PROXYS;

typedef struct tagNET_DVR_GET_FIGURE_COND
{
    DWORD                     dwLength;
    DWORD                    dwChannel;
    NET_DVR_TIME_V30        struTimePoint;
    BYTE  byID[STREAM_ID_LEN/*32*/];
    BYTE  					byRes[32];
}NET_DVR_GET_FIGURE_COND, *LPNET_DVR_GET_FIGURE_COND;

typedef struct tagNET_DVR_FIGURE_INFO
{
    DWORD   dwPicLen;     //picture length
    char     *pPicBuf;     //picture data
}NET_DVR_FIGURE_INFO, *LPNET_DVR_FIGURE_INFO;

//Manual Ranging
typedef    struct tagNET_DVR_MANUALRANGING_CFG
{
    DWORD        dwSize;
    BYTE        byEnabled;  //Enabled
    BYTE        byRes[127];
}NET_DVR_MANUALRANGING_CFG,*LPNET_DVR_MANUALRANGING_CFG;

typedef struct tagNET_DVR_VIDEO_INTERCOM_ALARM_CFG
{
    DWORD           dwSize;
    BYTE           byDoorNotCloseAlarm;
    BYTE            byRes[603];
}NET_DVR_VIDEO_INTERCOM_ALARM_CFG, *LPNET_DVR_VIDEO_INTERCOM_ALARM_CFG;

typedef struct tagNET_DVR_PACKET_INFO_EX
{
    WORD     wWidth;         //width
    WORD     wHeight;        //height
    DWORD    dwTimeStamp;    //lower time stamp
    DWORD    dwTimeStampHigh;//higher time stamp
    DWORD    dwYear;            //year
    DWORD    dwMonth;         //month
    DWORD    dwDay;           //day
    DWORD    dwHour;          //hour
    DWORD    dwMinute;        //minute
    DWORD    dwSecond;        //second
    DWORD    dwMillisecond;   //millisecond
    DWORD    dwFrameNum;     //frame num
    DWORD    dwFrameRate;    //frame rate
    DWORD    dwFlag;         //flag E
    DWORD    dwFilePos;      //file pos
    DWORD     dwPacketType;    //packet type:0 -file head\A3\AC1 -video I frame\A3\AC2- video B frame\A3\AC 3- video P frame\A3\AC 10- audio packet\A3\AC 11- private packet
    DWORD     dwPacketSize;   //packet size
    unsigned char*    pPacketBuffer;  //packet buffer
    BYTE     byRes1[4];
    DWORD    dwPacketMode;   // Packet Mode:0-Res\A3\AC1-FU_A
    BYTE     byRes2[16];
    DWORD    dwReserved[6];    //reserved[0] Private data type
    //reserved[1] Private bare data high address
    //reserved[2]Private bare data low address
    //reserved[3] Private bare data length
    //reserved[4] Private frame / packet time interval \ \ time stamp
    //reserved[5].bitIs a deep P frame\A3\ACdeepP\A3\BA1\A3\ACnot deepP\A3\BA0;     lizhonghu 20150203
}NET_DVR_PACKET_INFO_EX, *LPNET_DVR_PACKET_INFO_EX;

typedef BOOL (* DEV_WORK_STATE_CB)(void* pUserdata, int iUserID, LPNET_DVR_WORKSTATE_V40 lpWorkState);

typedef struct tagNetDVRCheckDevState
{
    DWORD				dwTimeout;
    DEV_WORK_STATE_CB	fnStateCB;
    void*				pUserData;
    BYTE				byRes[60];
}NET_DVR_CHECK_DEV_STATE,*LPNET_DVR_CHECK_DEV_STATE;

#define COURSE_NAME_LEN_128                128
#define INSTRUCTOR_NAME_LEN_64            64
#define MAX_UUID_LEN            64

typedef    struct tagNET_DVR_COURSE_LIST_COND
{
    DWORD                    dwSize;
    NET_DVR_TIME_V30        struStartTime; //course start time
    NET_DVR_TIME_V30        struEndTime; //course end time
    BYTE                       byCourseName[COURSE_NAME_LEN_128];
    BYTE                       byInstructorName[INSTRUCTOR_NAME_LEN_64];
    BYTE                   byCourseType; //course type,0-all,1-manual
    BYTE                    byRes[603];
}NET_DVR_COURSE_LIST_COND,*LPNET_DVR_COURSE_LIST_COND;

typedef struct  tagNET_DVR_COURSE_CFG
{
    DWORD            dwSize;
    NET_DVR_TIME_V30        struStartTime;
    NET_DVR_TIME_V30        struEndTime;
    BYTE            byCourseName[COURSE_NAME_LEN_128];
    BYTE            byInstructorName[INSTRUCTOR_NAME_LEN_64];
    BYTE            byCourseDescription[COURSE_DESCRIPTION_LEN /*256*/];
    BYTE            byRecUUID[MAX_UUID_LEN/*64*/];  //course UUID
    BYTE           byCourseType;//course type,0-all,1-manual
    BYTE            byRes[303];
}NET_DVR_COURSE_CFG, *LPNET_DVR_COURSE_CFG;

typedef struct tagNET_DVR_RECORD_STATUS
{
    DWORD       dwSize;
    BYTE        byRecUUID[MAX_UUID_LEN/*64*/];
    BYTE        byRecordStatus;         //record status,0-pause,1-shield,2-recording,3-idle
    BYTE     byRes[603];
}NET_DVR_RECORD_STATUS, *LPNET_DVR_RECORD_STATUS;

typedef struct tagNET_DVR_MANUAL_CURRICULUM_CFG
{
    DWORD       dwSize;
    BYTE        byRecUUID[MAX_UUID_LEN/*64*/];
    BYTE           byCourseName[COURSE_NAME_LEN_128];
    BYTE           byInstructorName[INSTRUCTOR_NAME_LEN_64];
    BYTE        byCourseDescription[COURSE_DESCRIPTION_LEN /*256*/];
    BYTE        byCmdType;            //cmd type\A3\AC0-startRecord 1-stopRecord 2-pauseRecord 3-continueRecord,4-startShield\A3\AC5-stopShield
    BYTE         byRes[303];
}NET_DVR_MANUAL_CURRICULUM_CFG, *LPNET_DVR_MANUAL_CURRICULUM_CFG;

typedef struct tagNET_DVR_IMAGE_DIFF_DETECTION_CFG
{
    DWORD       dwSize;
    NET_VCA_POLYGON struRegion;
    BYTE       byEnabled;
    BYTE        byThreshold;             //[0,100]
    BYTE         bySensitivity;        //[0,100]
    BYTE     byRes[301];
}NET_DVR_IMAGE_DIFF_DETECTION_CFG, *LPNET_DVR_IMAGE_DIFF_DETECTION_CFG;

typedef struct tagNET_DVR_RECORDING_PUBLISH_FILE_COND
{
    DWORD            dwSize;
    DWORD            dwChannel;
    BYTE             byFileID[MAX_ID_LEN_128/*128*/];
    BYTE             byRes[300];
}NET_DVR_RECORDING_PUBLISH_FILE_COND, *LPNET_DVR_RECORDING_PUBLISH_FILE_COND;


typedef struct tagNET_DVR_RECORDING_PUBLISH_FILE_INFO
{
    DWORD            dwSize;
    NET_DVR_TIME_V30        struStartTime;
    NET_DVR_TIME_V30        struEndTime;
    BYTE            byCourseName[COURSE_NAME_LEN_128];
    BYTE            byInstructorName[INSTRUCTOR_NAME_LEN_64];
    BYTE            byCourseDescription[COURSE_DESCRIPTION_LEN /*256*/];
    BYTE     byRes[300];
}NET_DVR_RECORDING_PUBLISH_FILE_INFO, *LPNET_DVR_RECORDING_PUBLISH_FILE_INFO;

//Screen interactive
typedef struct tagNET_DVR_SCREEN_POINT
{
    WORD wX;
    WORD wY;
}NET_DVR_SCREEN_POINT,*LPNET_DVR_SCREEN_POINT;

typedef struct tagNET_DVR_MOUSE_PARAM
{
    BYTE byMouseEvent;
    BYTE byRes1[3];
    NET_DVR_SCREEN_POINT struMousePoint;
    BYTE byRes2[8];
}NET_DVR_MOUSE_PARAM, *LPNET_DVR_MOUSE_PARAM;

typedef struct tagNET_DVR_MARK_PARAM
{
    BYTE byMarkEvent;
    BYTE byMarkTool;
    BYTE byLineWidth;
    BYTE byMouseEvent;
    NET_DVR_RGB_COLOR struColor;
    NET_DVR_SCREEN_POINT struPoint;
    BYTE byRes[4];
}NET_DVR_MARK_PARAM, *LPNET_DVR_MARK_PARAM;

typedef struct tagNET_DVR_KEYBOARD_PARM
{
    DWORD dwKeyValue;
    BYTE  byRes[12];
}NET_DVR_KEYBOARD_PARAM, *LPNET_DVR_KEYBOARD_PARAM;

typedef struct tagNET_DVR_PPT_PARAM
{
    BYTE  byPPTAction;
    BYTE  byRes1[3];
    NET_DVR_SCREEN_POINT struPoint;
    DWORD dwPPTNo;
    BYTE  byRes2[4];
}NET_DVR_PPT_PARAM, *LPNET_DVR_PPT_PARAM;

typedef struct tagNET_DVR_REMOTE_CTRL_PARAM
{
    BYTE byRemoteCtrlCmd;
    BYTE byRes1[3];
    DWORD dwCtrlParam;
    BYTE byRes2[8];
}NET_DVR_REMOTE_CTRL_PARAM, *LPNET_DVR_REMOTE_CTRL_PARAM;

typedef struct tagNET_DVR_SPOTLIGHT_PARAM
{
    BYTE  byCmd;
    BYTE  byRes1[3];
    NET_DVR_SCREEN_POINT struPoint;
    DWORD dwRadius;
    BYTE  byRes2[4];
} NET_DVR_SPOTLIGHT_PARAM, *LPNET_DVR_SPOTLIGHT_PARAM;

typedef struct tagNET_DVR_TOUCHPAD_PARAM
{
    BYTE byMouseEvent;
    BYTE byRes1[3];
    int iXDisplacement;
    int iYDisplacement;
    BYTE byRes2[4];
}NET_DVR_TOUCHPAD_PARAM, *LPNET_DVR_TOUCHPAD_PARAM;

typedef struct tagNET_DVR_MEDIA_LIST_PARAM
{
    BYTE byOperateCmd;
    BYTE byRes[15];
}NET_DVR_MEDIA_LIST_PARAM, *LPNET_DVR_MEDIA_LIST_PARAM;

typedef union tagNET_DVR_SCREEN_CTRL_PARAM
{
    NET_DVR_MOUSE_PARAM struMouseParam;
    NET_DVR_MARK_PARAM struMarkParam;
    NET_DVR_KEYBOARD_PARAM struKeyboardInfo;
    NET_DVR_PPT_PARAM struPPTParam;
    NET_DVR_REMOTE_CTRL_PARAM struRemoteCtrlParam;
    NET_DVR_SPOTLIGHT_PARAM struSpotLight;
    NET_DVR_TOUCHPAD_PARAM struTouchPadParam;
    NET_DVR_MEDIA_LIST_PARAM struMediaListParam;
    BYTE byRes[16];
}NET_DVR_SCREEN_CTRL_PARAM, *LPNET_DVR_SCREEN_CTRL_PARAM;

typedef struct tagNET_DVR_SCREEN_CTRL_CMD
{
    DWORD dwSize;
    BYTE  byCmdType;
    BYTE  byRes1[3];
    NET_DVR_SCREEN_CTRL_PARAM struScreenCtrlParam;
}NET_DVR_SCREEN_CTRL_CMD, *LPNET_DVR_SCREEN_CTRL_CMD;

typedef struct tagNET_DVR_FILE_RESPONSE_PARAM
{
    BYTE byFileState;
    BYTE byRes1[3];
    DWORD dwErrorFileIndex;
    BYTE byRes2[24];
} NET_DVR_FILE_RESPONSE_PARAM, *LPNET_DVR_FILE_RESPONSE_PARAM;

typedef struct tagNET_DVR_PPT_RESPONSE_PARAM
{
    BYTE  byCurrentState;
    BYTE  byRes1[3];
    DWORD dwCurrentPage;
    DWORD dwFileIndex;
    DWORD dwTotalPageNum;
    BYTE  byRes2[16];
}NET_DVR_PPT_RESPONSE_PARAM, *LPNET_DVR_PPT_RESPONSE_PARAM;

typedef union tagNET_DVR_SCREEN_RESPONSE_PARAM
{
    BYTE byRes[32];
    NET_DVR_PPT_RESPONSE_PARAM  struPPTParam;
    NET_DVR_FILE_RESPONSE_PARAM    struFileParam;
}NET_DVR_SCREEN_RESPONSE_PARAM,*LPNET_DVR_SCREEN_RESPONSE_PARAM;

typedef struct tagNET_DVR_SCREEN_RESPONSE_CMD
{
    DWORD dwSize;
    BYTE  byResponseCmd;
    BYTE  byRes1[3];
    NET_DVR_SCREEN_RESPONSE_PARAM struResonseParam;
    BYTE  byRes2[16];
}NET_DVR_SCREEN_RESPONSE_CMD, *LPNET_DVR_SCREEN_RESPONSE_CMD;

typedef struct tagNET_DVR_SCREEN_FILE_COND
{
    DWORD dwSize;
    BYTE  byFileType;
    BYTE  byRes[127];
}NET_DVR_SCREEN_FILE_COND, *LPNET_DVR_SCREEN_FILE_COND;

typedef struct tagNET_DVR_SCREEN_FILE_INFO
{
    DWORD dwSize;
    DWORD dwFileIndex;
    BYTE  byFileType;
    BYTE  byPictureFormat;
    BYTE  byVideoFormat;
    BYTE  byRes1;
    BYTE  byFileName[NET_SDK_MAX_FILE_PATH];
    DWORD dwFileSize;
    DWORD dwPPTPage;
    BYTE  byRes2[64];
}NET_DVR_SCREEN_FILE_INFO, *LPNET_DVR_SCREEN_FILE_INFO;

typedef struct tagNET_DVR_SCREEN_CONFIG
{
    DWORD dwSize;
    BYTE  byVolume;
    BYTE  byContrast;
    BYTE  byBrightness;
    BYTE  byScreenShowEnabled;
    BYTE  byScreenLocked;
    BYTE  byBlackScreenEnabled;
    BYTE  byRes[30];
}NET_DVR_SCREEN_CONFIG, *LPNET_DVR_SCREEN_CONFIG;

typedef struct tagNET_DVR_SCREEM_FILE_UPLOAD_PARAM
{
    DWORD dwSize;
    BYTE  byFileType;
    BYTE  byPictureFormat;
    BYTE  byVideoFormat;
    BYTE  byRes1;
    BYTE  byFileName[NET_SDK_MAX_FILE_PATH];
    BYTE  byRes2[64];
}NET_DVR_SCREEM_FILE_UPLOAD_PARAM, *LPNET_DVR_SCREEM_FILE_UPLOAD_PARAM;

typedef struct tagNET_DVR_SCREEM_FILE_DOWNLOAD_PARAM
{
    DWORD dwSize;
    DWORD dwFileIndex;
    DWORD dwPPTPageNo;
    BYTE  byRes2[64];
}NET_DVR_SCREEM_FILE_DOWNLOAD_PARAM, *LPNET_DVR_SCREEM_FILE_DOWNLOAD_PARAM;

typedef struct tagNET_DVR_SUB_SCHEDULE_PROGRESS
{
    DWORD dwTerminalNo; //terminal num
    DWORD dwProgress;   //terminal schedule publish progress\A3\AC0-100\A3\AC101 denote exception,,102 denote terminal storm not enough
}NET_DVR_SUB_SCHEDULE_PROGRESS, *LPNET_DVR_SUB_SCHEDULE_PROGRESS;

typedef struct tagNET_DVR_SCHEDULE_PROGRESS_RESULT
{
    DWORD  dwSize;
    DWORD  dwMainProgress;      //main progress\A3\AC0-100\A3\ACAccording to the schedule for the whole set is gain schedule release schedule, according to the terminal when get progress for a single terminal schedule release schedule
    DWORD  dwSubProgressNum;    //Get effective when schedule number, according to the group, said group under various terminal schedule number
    LPNET_DVR_SUB_SCHEDULE_PROGRESS  lpStruSubProgress; //Each terminal schedule release schedule, according to the set of access available at the time,dwSubProgressNum NET_DVR_SUB_SCHEDULE_PROGRESS
    BYTE   byRes[32];
}NET_DVR_SCHEDULE_PROGRESS_RESULT, *LPNET_DVR_SCHEDULE_PROGRESS_RESULT;

//info publish server schedule progress
typedef struct tagNET_DVR_SCHEDULE_PROGRESS_COND
{
    DWORD dwSize;
    DWORD dwScheduleNo;     //schedule num
    BYTE  byProgressType;   //progress type\A3\AC1-by group\A3\AC2-by termal
    BYTE  byRes1[3];
    DWORD dwGroupNo;        //termal num\A3\ACvalid when byProgressType = 1
    DWORD dwTerminalNo;     //termal num\A3\ACvalid when byProgressType = 2
    BYTE  byRes2[32];
}NET_DVR_SCHEDULE_PROGRESS_COND, *LPNET_DVR_SCHEDULE_PROGRESS_COND;

typedef struct tagNET_DVR_INSERTPLAY_PROGRESS_COND
{
    DWORD dwSize;
    BYTE   byInsertType;    //insert play type\A3\AC1-material\A3\AC2-program
    BYTE   byRes3[3];
    DWORD dwInsertNo;      //material no ,when byInsertType = 0,program no when byInsetType = 1
    BYTE  byProgressType;   //progress type\A3\AC1-by group\A3\AC2-by termal
    BYTE  byRes1[3];
    DWORD dwGroupNo;        //termal num\A3\ACvalid when byProgressType = 1
    DWORD dwTerminalNo;     //termal num\A3\ACvalid when byProgressType = 2
    BYTE  byRes2[32];
}NET_DVR_INSERTPLAY_PROGRESS_COND, *LPNET_DVR_INSERTPLAY_PROGRESS_COND;

typedef struct tagNET_DVR_SUB_INSERTPLAY_PROGRESS
{
    DWORD dwTerminalNo; //terminal no
    DWORD dwProgress;   //terminal insert play progress\A3\AC0-100\A3\AC101 denote exception,,102 denote terminal storm not enough
}NET_DVR_SUB_INSERTPLAY_PROGRESS, *LPNET_DVR_SUB_INSERTPLAY_PROGRESS;

typedef struct tagNET_DVR_INSERTPLAY_PROGRESS_RESULT
{
    DWORD  dwSize;
    DWORD  dwMainProgress;      //main progress\A3\AC0-100
    DWORD  dwSubProgressNum;    //sub progress num\A3\ACis valid when get group
    LPNET_DVR_SUB_INSERTPLAY_PROGRESS  lpStruSubProgress;
    BYTE   byRes[32];
}NET_DVR_INSERTPLAY_PROGRESS_RESULT, *LPNET_DVR_INSERTPLAY_PROGRESS_RESULT;

//TME Voice Cfg
typedef    struct tagNET_DVR_TMEVOICE_CFG
{
    DWORD      dwSize;
    BYTE       byVoiceSpeed;//Voice Speed 0~100
    BYTE       byVoicePitch; //Voice Pitch 0~100
    BYTE       byVoiceVolum; //Voice Volum0~100
    BYTE       byVoicePlateEnable;//Voice Plate Enable ,0~disable\A3\AC1~enable
    /*Voice Role\A3\BB
    3  = Xiaoyan (female, Chinese)
    51 = Jiu Xu (male, Chinese)
    52 = Duo Xu (male, Chinese)
    53 = Xiaoping (female, Chinese)
    54 = Donald Duck (male, Chinese)
    55 = Baby Xu (child, Chinese)
    */
    DWORD     dwVoiceRole; //Voice Role
    char      sInfo[MAX_TMEVOICE_LEN/*64*/]; //Info
    char      sFileName[MAX_TMEVOICE_LEN/*64*/]; //File name
    BYTE      byRes[64];
}NET_DVR_TMEVOICE_CFG,*LPNET_DVR_TMEVOICE_CFG;

//input board configuration
typedef struct tagNET_DVR_INPUT_BOARD_CFG
{
    DWORD    dwSize;
    DWORD    dwSlotNo;           //slot No.
    BYTE    byFullFrameEnable;  //full frame display enable
    BYTE    byRes[3];           //four bytes align
    BYTE    byRes1[64];         //reserved
}NET_DVR_INPUT_BOARD_CFG, *LPNET_DVR_INPUT_BOARD_CFG;

typedef struct tagNET_DVR_INPUT_BOARD_CFG_LIST
{
    DWORD    dwSize;
    NET_DVR_INPUT_BOARD_CFG struBoardList[MAX_NUM_INPUT_BOARD]; //input board configuration list
}NET_DVR_INPUT_BOARD_CFG_LIST, *LPNET_DVR_INPUT_BOARD_CFG_LIST;


//Get encryption device information Condition structure
typedef struct _NET_DVR_ENCRYPT_DEVICE_COND
{
    DWORD  dwSize;     //structure size
    DWORD  dwChannel;     //channel
    BYTE   byAlgorithm; //Algorithm\A3\AC0-Res\A3\AC1-RSA,2-SM2
    BYTE   byModelLen; //Model Len\A3\AC0-Res\A3\AC1-1024 bit,2-2048 bit,3-256 bit
    BYTE   byCERTSaveLocation; //CERT Save Location\A3\AC0-Res\A3\AC1-encrypt chip ,2-device
    BYTE   byRes[29];
}NET_DVR_ENCRYPT_DEVICE_COND, *LPNET_DVR_ENCRYPT_DEVICE_COND;
//Get encryption device information structure
typedef struct _NET_DVR_ENCRYPT_DEVICE_INFO
{
    DWORD  dwSize;     //structure size
    BYTE   byAlgorithm; //Algorithm\A3\AC0-Res\A3\AC1-RSA,2-SM2
    BYTE   byModelLen; //Model Len\A3\AC0-Res\A3\AC1-1024 bit,2-2048 bit,3-256 bit
    BYTE   byRes1[30];  //Res
    DWORD  dwPublicKeyLen;        //PublicKey Len
    char   szPublicKey[MAX_PUBLIC_KEY_LEN];       //Public Key
    char   szChipSerialNumber[CHIP_SERIALNO_LEN];   //Chip Serial Number
    char   szDeviceID[ENCRYPT_DEV_ID_LEN];     //device ID
    BYTE   byRes2[128];
}NET_DVR_ENCRYPT_DEVICE_INFO, *LPNET_DVR_ENCRYPT_DEVICE_INFO;
//Encrypt cert param structure
typedef struct _NET_DVR_ENCRYPT_CERT_PARAM
{
    DWORD dwSize;
    WORD wCertType; //Cert Type\A3\AC0-CA root cert\A3\AC1-sign cert,3-encrypt cert\A3\AC4- SM2 secret key pair
    BYTE byRes1[2]; //Res
    DWORD dwCertLen; //Cert Len
    BYTE  byRes2[32];
    char* pCertBuf;  //Cert Buf
}NET_DVR_ENCRYPT_CERT_PARAM, *LPNET_DVR_ENCRYPT_CERT_PARAM;


#define MAX_RING_NAME_LEN_128                128    //
typedef struct tagNET_DVR_RING_UPLOAD_CFG
{
    DWORD        dwSize;
    DWORD        dwRingID; //ring ID\A3\AC[1,8]
    BYTE     byRingName[MAX_RING_NAME_LEN_128/*128*/];   //
    DWORD     dwRingSize;   //
    BYTE        byRingType;   //ring type\A3\AC0-wav
    BYTE        byRes[363];
}NET_DVR_RING_UPLOAD_CFG,*LPNET_DVR_RING_UPLOAD_CFG;

typedef struct tagNET_DVR_RING_SEARCH_COND
{
    DWORD        dwSize;
    DWORD        dwRingID; //ring ID
    BYTE        byRes[300];
}NET_DVR_RING_SEARCH_COND,*LPNET_DVR_RING_SEARCH_COND;

typedef struct tagNET_DVR_RING_SEARCH_CFG
{
    DWORD        dwSize;
    DWORD        dwRingID; //
    BYTE     byRingName[MAX_RING_NAME_LEN_128/*128*/];   //
    DWORD     dwRingSize;   //
    BYTE        byRingType;   //
    BYTE        byRes[303];
}NET_DVR_RING_SEARCH_CFG,*LPNET_DVR_RING_SEARCH_CFG;


//Alarm Ctrl Cfg
typedef struct tagNET_DVR_ALARMCTRL_CFG
{
    DWORD   dwSize;
    BYTE    byListenPicUploadEnabled;//Listen Pictrue Upload Enabled
    BYTE    byRes [259];
}NET_DVR_ALARMCTRL_CFG,*LPNET_DVR_ALARMCTRL_CFG;

typedef struct tagNET_DVR_VEHICLEFLOW_COND
{
    DWORD dwSize;
    DWORD dwChannel;
    BYTE   byLane;
    BYTE   byRes1[3];
    NET_DVR_TIME_V30 struStartTime;
    NET_DVR_TIME_V30 struEndTime;
    BYTE   byRes[256];
}NET_DVR_VEHICLEFLOW_COND, *LPNET_DVR_VEHICLEFLOW_COND;

typedef struct tagNET_DVR_VEHICLEFLOW_INFO
{
    DWORD dwVehicleFlowValue;
    BYTE   byRes[64];
}NET_DVR_VEHICLEFLOW_INFO, *LPNET_DVR_VEHICLEFLOW_INFO;

typedef struct tagNET_DVR_VEHICLEFLOW_CFG
{
    DWORD dwSize;
    NET_DVR_VEHICLEFLOW_INFO struVehFlow[MAX_VEHICLEFLOW_INFO/*24*/];
    BYTE   byRes[512];
}NET_DVR_VEHICLEFLOW_CFG, *LPNET_DVR_VEHICLEFLOW_CFG;

typedef struct tagNET_DVR_IPADDR_FILTER_COND
{
    DWORD dwSize;
    DWORD dwChannel;//Channel
    BYTE  byRes[64];
}NET_DVR_IPADDR_FILTER_COND, *LPNET_DVR_IPADDR_FILTER_COND;

typedef	struct tagNET_DVR_TEMPHUMSENSOR
{
    DWORD      dwSize;
    BYTE        byEnable;
    BYTE  		 byCtrlMode;
    BYTE        byTemperatureValue;//
    BYTE        byHumidityValue;//
    BYTE        byFanSwitch;//
    BYTE        byThermometryUnit;//unit:(\A1\E6),1-(\A8H),2-(K)
    BYTE        byRes[62];
}NET_DVR_TEMPHUMSENSOR, *LPNET_DVR_TEMPHUMSENSOR;

//PostRadar Speed Cfg
typedef struct tagNET_DVR_POSTRADARSPEED_CFG
{
    DWORD   dwSize;
    BYTE    byLaneType; //Lane Type
    BYTE    byRes1[3];
    DWORD   dwInterval; //Interval\A3\ACUnit\A3\BAms
    DWORD   dwSignSpeed;//Sign Speed\A3\ACUnit:km/h
    DWORD   dwSpeedLimit;//Speed Limit\A3\ACUnit:km/h
    DWORD   dwBigCarSignSpeed;//Big Car Sign Speed\A3\ACUnit:km/h
    DWORD   dwBigCarSpeedLimit;//Big Car Spee dLimit\A3\ACUnit:km/h
    DWORD   dwLowSpeedLimit;// Low Speed Limit\A3\ACUnit:km/h
    DWORD   dwBigCarLowSpeedLimit;// Big Car Low Spee dLimit\A3\ACUnit:km/h
    BYTE    byCheckPostEnabled; //Check Post Enabled
    BYTE    byOverSpeedEnabled; //Over Speed Enabled
    BYTE    byRes[246];
}NET_DVR_POSTRADARSPEED_CFG, *LPNET_DVR_POSTRADARSPEED_CFG;

//PostRadar Speed Param
typedef struct tagNET_DVR_POSTRADARPARAM_CFG
{
    DWORD   dwSize;
    BYTE    bySoftWareVersion[32];//Soft Ware Version
    BYTE    byID; //ID
    BYTE    byWorkMode; //Work Mode
    BYTE    bySpeedType; //Speed Type
    BYTE    byDirectionFilter; //Direction Filter
    DWORD   dwAngleCorrect;//Angle Correct[0,70]
    DWORD   dwSensitivity;// Sensitivity[11,240]
    DWORD   dwSpeedLowLimit;// Speed Low Limit[1,150km/h]
    DWORD   dwTrigDistance;// Trig Distance[0,40m]
    BYTE    byRes[256];
}NET_DVR_POSTRADARPARAM_CFG, *LPNET_DVR_POSTRADARPARAM_CFG;

typedef struct tagNET_DVR_CLOUD_URL_COND
{
    DWORD   dwSize;
    BYTE    byType;     //cloud type:0-reversed\A3\AC1- OneDrive  2-GoogleDrive 3-DropBox
    BYTE    byRes[63];
}NET_DVR_CLOUD_URL_COND, *LPNET_DVR_CLOUD_URL_COND;

typedef struct tagNET_DVR_CLOUD_URL
{
    DWORD   dwSize;
    char    szURL[256]; //cloud storage url
    BYTE    byRes[256];
}NET_DVR_CLOUD_URL, *LPNET_DVR_CLOUD_URL;

typedef struct tagNET_DVR_CLOUD_CFG
{
    DWORD   dwSize;
    BYTE    byEnable;    //0-disable\A3\AC1-enable
    BYTE    byType;        //cloud type 0-reverse\A3\AC1- OneDrive  2-GoogleDrive 3-DropBox
    BYTE    byStatus;    //status\A3\ACread only 0-reverse 1-online 2-offline
    BYTE    byRes1;
    char    szAuthCode[CODE_LEN]; //authcode
    char    szAlias[ALIAS_LEN];    //alias\A3\ACread only
    INT64   i64TotalCapability;            //total capacity\A3\ACread only (MB)
    INT64   i64UsedSpace;                //used capacity\A3\ACread only (MB)
    BYTE    byRes2[256];
}NET_DVR_CLOUD_CFG,*LPNET_DVR_CLOUD_CFG;

typedef struct tagNET_DVR_CLOUD_UPLOADSTRATEGY_COND
{
    DWORD    dwSize;
    DWORD    dwChannel;    //channel
    BYTE    byRes[254];
}NET_DVR_CLOUD_UPLOADSTRATEGY_COND, *LPNET_DVR_CLOUD_UPLOADSTRATEGY_COND;

typedef struct tagNET_DVR_CLOUD_UPLOADSTRATEGY
{
    DWORD    dwSize;
    BYTE    byStrategyType;    //strategy type:0-nonsense\A3\AC1-record\A3\AC2-picture
    BYTE    byRes1[3];
    DWORD    dwRecordType;    //it is useful when byStrategyType is 1\A3\ACposition representation
    /*0x00: nonsense*/
    /*0x01: all event*/
    /*0x02: motion*/
    /*0x04: alarm*/
    /*0x08: VCA*/
    BYTE    byRes[256];
}NET_DVR_CLOUD_UPLOADSTRATEGY, *LPNET_DVR_CLOUD_UPLOADSTRATEGY;


typedef  struct tagNET_DVR_RECORD_CHECK_COND
{
    DWORD    dwSize;
    NET_DVR_STREAM_INFO    struStreamInfo;
    BYTE   byCheckType;        //check type,0--check integrity,1--check integrity & lost record segment
    BYTE   byRes1[3];
    NET_DVR_TIME_EX struBeginTime;
    NET_DVR_TIME_EX struEndTime;
    BYTE   byRes[128];
}NET_DVR_RECORD_CHECK_COND, *LPNET_DVR_RECORD_CHECK_COND;

typedef  struct tagNET_DVR_RECORD_CHECK_RET
{
    DWORD    dwSize;
    BYTE   byRecordNotComplete;    //check integrity\A3\AC0--complete,1-- not complete
    BYTE   byRes1[3];
    NET_DVR_TIME_EX struBeginTime;    //when byCheckType=1 and byRecordNotComplete=1,this param effective
    NET_DVR_TIME_EX struEndTime;    //when byCheckType=1 and byRecordNotComplete=1,this param effective
    BYTE   byRes[128];
}NET_DVR_RECORD_CHECK_RET, *LPNET_DVR_RECORD_CHECK_RET;

typedef  struct tagNET_DVR_ADD_RECORD_PASSBACK_MANUAL_COND
{
    DWORD    dwSize;
    NET_DVR_STREAM_INFO    struStreamInfo;
    BYTE   byRes[128];
}NET_DVR_ADD_RECORD_PASSBACK_MANUAL_COND, *LPNET_DVR_ADD_RECORD_PASSBACK_MANUAL_COND;

typedef  struct tagNET_DVR_ADD_RECORD_PASSBACK_MANUAL_CFG
{
    DWORD    dwSize;
    NET_DVR_TIME_EX struBeginTime;
    NET_DVR_TIME_EX struEndTime;
    BYTE   byRes[128];
}NET_DVR_ADD_RECORD_PASSBACK_MANUAL_CFG, *LPNET_DVR_ADD_RECORD_PASSBACK_MANUAL_CFG;

typedef  struct tagNET_DVR_RECORD_PASSBACK_TASK_CFG
{
    DWORD	dwSize;
    DWORD dwTaskID;		//task ID
    BYTE   byRes[160];
}NET_DVR_RECORD_PASSBACK_TASK_CFG, *LPNET_DVR_RECORD_PASSBACK_TASK_CFG;

typedef struct tagNET_DVR_RECORD_PASSBACK_MANUAL_COND
{
    DWORD	dwSize;
    BYTE	byType;		//check type,0--get all surplus task\A3\AC1--get all surplus task by stream id, 2--get all task\A3\AC3--get all task by stream id, 4--get task by task id
    BYTE    byTimeSegmentQuety; //enable time limit\A3\AC0-disable\A3\AC1-enable
    BYTE    byRes1[2];
    NET_DVR_STREAM_INFO	struStreamInfo;	//stream ID
    NET_DVR_TIME_EX struBeginTime;      //start time\A3\ACvalid when byTimeSegmentQuety is enable
    NET_DVR_TIME_EX struEndTime;        //end time\A3\ACvalid when byTimeSegmentQuety is enable
    DWORD dwTaskID;		//task ID, is effective only when byType equal to 4
    BYTE	byRes[108];
}NET_DVR_RECORD_PASSBACK_MANUAL_COND, *LPNET_DVR_RECORD_PASSBACK_MANUAL_COND;


typedef struct tagNET_DVR_RECORD_PASSBACK_MANUAL_TASK_RET
{
    DWORD		dwSize;
    NET_DVR_STREAM_INFO	struStreamInfo;	//stream ID
    DWORD		dwTaskID;		//task ID
    NET_DVR_TIME_EX	struStartTime;
    NET_DVR_TIME_EX	struStopTime;
    BYTE		byTaskStatus;	//task status\A3\AC0--unexecuted\A3\AC1--pausing\A3\AC2--executed, 3--executting, 4--failed
    BYTE		byRes1[3];
    NET_DVR_TIME_EX	struExecuteStartTime;	//effect when byTaskStatus=1 0r 2
    NET_DVR_TIME_EX	struExecuteStopTime;	//effect when byTaskStatus=1 0r 2
    BYTE		byRes[128];
}NET_DVR_RECORD_PASSBACK_MANUAL_TASK_RET, *LPNET_DVR_RECORD_PASSBACK_MANUAL_TASK_RET;

typedef struct tagNET_DVR_RECORD_PASSBACK_MANUAL_CTRL
{
    DWORD    dwSize;
    BYTE    byControlType;    //control type,0--pause all task\A3\AC1--restore all task
    BYTE    byRes[131];
}NET_DVR_RECORD_PASSBACK_MANUAL_CTRL, *LPNET_DVR_RECORD_PASSBACK_MANUAL_CTRL;

typedef struct tagNET_DVR_DEL_RECORD_PASSBACK_MANUAL_COND
{
    DWORD    dwSize;
    BYTE    byDelType;    //delete type,0--delete by task id\A3\AC1--delete by stream id\A3\AC2--delete all task
    BYTE    byRes[131];
}NET_DVR_DEL_RECORD_PASSBACK_MANUAL_COND, *LPNET_DVR_DEL_RECORD_PASSBACK_MANUAL_COND;

typedef struct tagNET_DVR_DEL_RECORD_PASSBACK_MANUAL_CFG
{
    DWORD    dwSize;
    DWORD    dwTaskID;
    NET_DVR_STREAM_INFO    struStreamInfo;
    BYTE    byRes[128];
}NET_DVR_DEL_RECORD_PASSBACK_MANUAL_CFG, *LPNET_DVR_DEL_RECORD_PASSBACK_MANUAL_CFG;

typedef struct tagNET_DVR_PASSBACK_DAY
{
    BYTE    byAllDay;
    BYTE    byRes[3];
}NET_DVR_PASSBACK_DAY, *LPNET_DVR_PASSBACK_DAY;

typedef struct tagNET_DVR_PASSBACK_SCHED
{
    NET_DVR_SCHEDTIME    struPassBackTime;
    BYTE        byRes[4];
}NET_DVR_PASSBACK_SCHED, *LPNET_DVR_PASSBACK_SCHED;

typedef struct tagNET_DVR_RECORD_PASSBACK_SCH_CFG_
{
    DWORD    dwSize;
    BYTE    byEnable;        //0--disable\A3\AC1--enable
    BYTE    byPassBackWeek;    //0--no\A3\AC1--yes
    BYTE    byRes1[2];
    NET_DVR_PASSBACK_DAY    struPassBackDay[MAX_DAYS];
    NET_DVR_PASSBACK_SCHED    struPassBackSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    BYTE   byRes[128];
}NET_DVR_RECORD_PASSBACK_SCH_CFG, *LPNET_DVR_RECORD_PASSBACK_SCH_CFG;

//Back history record planning parameters
typedef struct tagNET_DVR_RECORD_PASSBACK_HISTORY_PLAN_CFG_
{
    DWORD	dwSize;
    BYTE	byEnable;		//0--disable\A3\AC1--enable
    BYTE	byRes1[3];
    NET_DVR_PASSBACK_DAY		struPassBackDay[MAX_DAYS];
    NET_DVR_PASSBACK_SCHED	struPassBackSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    BYTE   byRes[256];
}NET_DVR_RECORD_PASSBACK_HISTORY_PLAN_CFG, *LPNET_DVR_RECORD_PASSBACK_HISTORY_PLAN_CFG;

typedef struct tagNET_DVR_DEV_STORAGE_CFG
{
    DWORD    dwSize;
    DWORD    dwCapacityTotal;        //read only,eg: 102400MB
    DWORD    dwFreeSpaceTotal;        //read only,MB
    DWORD    dwLockedRecordSpace;    //read only,MB
    DWORD    dwUnLockedSpace;        //read only,MB
    BYTE    byRes[512];
}NET_DVR_DEV_STORAGE_CFG, *LPNET_DVR_DEV_STORAGE_CFG;

//One key configuration CVR (V50)
typedef struct tagNET_DVR_ONE_KEY_CFG_V50
{
    DWORD   dwSize;
    BYTE    byRaidType;   //RAID type\A3\BA0-raid5,1-raid6,2-raid95\A3\A8Vraid\A3\A9,3-Single plate model
    BYTE    bySpareRaidProportion;   //Hot spare disk: the proportion of raid (array) , 0--\A3\A80:1\A3\A9, 1--\A3\A81 : 1\A3\A9, 2--\A3\A81 : 2\A3\A9, 3--\A3\A81 : 3\A3\A9, 4--\A3\A81 : 4\A3\A9, 5--\A3\A81 : 5\A3\A9, 6--\A3\A81 : 6\A3\A9,7--\A3\A86:1\A3\A9,8--\A3\A85:1\A3\A9,9--\A3\A84:1\A3\A9,10--\A3\A83:1\A3\A9,11--\A3\A82:1\A3\A9
    BYTE    byPicQuota;   //Image volume ratio: the range of 0 ~ 100
    BYTE    byRes[257];
}NET_DVR_ONE_KEY_CFG_V50, *LPNET_DVR_ONE_KEY_CFG_V50;

typedef	struct tagNET_DVR_REC_PASSBACK_BASIC_CFG
{
    DWORD		dwSize;
    DWORD 	dwStartTime;    //Detection window start time
    DWORD 	dwStopTime;    //Detection window stop time
    WORD    wMaxTotalConcurrenceNum;   //Concurrent posts back because limit, is aimed at encoder, not the article back task
    WORD    wMaxDvrConcurrenceNum;     //A single DVR concurrent back channel number limit
    BYTE    byRes[256];
}NET_DVR_REC_PASSBACK_BASIC_CFG, *LPNET_DVR_REC_PASSBACK_BASIC_CFG;

typedef struct tagNET_DVR_ONLINE_USER_INFO_
{
    DWORD    dwSize;
    WORD    wOnlineUserCount;
    BYTE   byRes[514];
}NET_DVR_ONLINE_USER_INFO, *LPNET_DVR_ONLINE_USER_INFO;

typedef struct tagNET_DVR_RECORD_SEGMENT_COND_
{
    DWORD        dwSize;
    NET_DVR_STREAM_INFO    struStreanInfo;
    NET_DVR_TIME_EX    struStartTime;
    NET_DVR_TIME_EX    struStopTime;
    BYTE        byRes[256];
}NET_DVR_RECORD_SEGMENT_COND, *LPNET_DVR_RECORD_SEGMENT_COND;

typedef struct tagNET_DVR_RECORD_SEGMENT_RET_
{
    DWORD    dwSize;
    DWORD    dwRecordTotalSize;    //all record size , MB
    BYTE    byRes[256];
}NET_DVR_RECORD_SEGMENT_RET, *LPNET_DVR_RECORD_SEGMENT_RET;
typedef struct tagNET_DVR_ACCESSORY_CARD_INFO
{
    DWORD  dwSize;
    BYTE    szAccessoryCardInfo[MAX_ACCESSORY_CARD/*256*/];//Accessories plate (intelligent board and control board) model information
    BYTE    byRes[512];
}NET_DVR_ACCESSORY_CARD_INFO, *LPNET_DVR_ACCESSORY_CARD_INFO;
//search info cond struct
typedef struct tagNET_DVR_SEARCH_INFO_COND
{
    DWORD                   dwSize;
    BYTE                    byCommand;    //command\A3\AC0-personal\A3\AC1-everyone
    BYTE                    byRes1[3];
    DWORD                   dwEmployeeNo; //employee number (it is effective when command is 0-personal)
    BYTE                    byName[NAME_LEN];   //name (it is effective when command is 0-personal)
    NET_DVR_TIME_V30        struStartTime;      //start time
    NET_DVR_TIME_V30        struEndTime;        //end time
    BYTE                    byRes[128];
}NET_DVR_SEARCH_INFO_COND, *LPNET_DVR_SEARCH_INFO_COND;

//get schedule info
typedef struct tagNET_DVR_SCHEDULE_CHOICE
{
    BYTE                    byScheduleType;	    //schedule type\A3\AC0-no class\A1\A21-ordinary class\A1\A22-working class
    BYTE                    byScheduleNo;       //schedule number
    BYTE                    byRes[14];
}NET_DVR_SCHEDULE_CHOICE, *LPNET_DVR_SCHEDULE_CHOICE;

//schedule plan struct
typedef struct tagNET_DVR_SCHEDULE_PLAN
{
    DWORD                   dwSize;
    BYTE                    bySchedulePlanNo;   //schedule plan number
    BYTE                    bySchedulePlanType; //schedule plan type\A3\AC0-personal\A1\A21-department
    BYTE                    byEnable;           //enable
    BYTE                    byRes1;
    NET_DVR_SCHEDULE_CHOICE struScheduleChoice[DAYS_A_WEEK];  //schedule choice
    NET_DVR_TIME_V30        struStartTime;      //start time
    NET_DVR_TIME_V30        struEndTime;        //end time
    BYTE                    byHolidayNo;        //holiday number
    BYTE                    byRes[63];
}NET_DVR_SCHEDULE_PLAN, *LPNET_DVR_SCHEDULE_PLAN;
//  B20 V1.5
typedef struct tagNET_DVR_DISPINPUT_CFG
{
    DWORD  dwSize;
    DWORD  dwDispInputNo;
    DWORD  dwEDIDFileNo;
    BYTE   byRes[32];
}NET_DVR_DISPINPUT_CFG, *LPNET_DVR_DISPINPUT_CFG;

//get schedule info
typedef struct tagNET_DVR_SCHEDULE_INFO_CFG
{
    DWORD                  dwSize;
    DWORD                  dwEmployeeNo;        //employee number
    BYTE                   byName[NAME_LEN];    //name
    BYTE                   byDepartmentName[NAME_LEN];   //department name
    NET_DVR_SCHEDULE_PLAN  struSchedulePlan;    //schedule plan
    BYTE                   byRes[128];
}NET_DVR_SCHEDULE_INFO_CFG, *LPNET_DVR_SCHEDULE_INFO_CFG;

//get attendance suammary info
typedef struct tagNET_DVR_ATTENDANCE_SUMMARY_CFG
{
    DWORD                 dwSize;
    DWORD                 dwEmployeeNo; //employee number
    BYTE                  byName[NAME_LEN];  //name
    BYTE                  byDepartmentName[NAME_LEN];  //department name
    DWORD                 dwWorkStandard;    //work standard minutes
    DWORD                 dwWorkActual; //work actual minutes
    DWORD                 dwLateTimes;  //late times
    DWORD                 dwLateMinutes;//late minutes
    DWORD                 dwLeaveEarlyTimes;    //leave early times
    DWORD                 dwLeaveEarlyMinutes;  //leave early minutes
    DWORD                 dwOvertimeStandard;   //over time standard minutes
    DWORD                 dwOvertimeActual;     //over time actual minutes
    DWORD                 dwAttendanceStandard; //attendance standard days
    DWORD                 dwAttendanceActual;   //attendance actual days
    DWORD                 dwAbsentDays;         //absent days
    BYTE                  byRes[128];
}NET_DVR_ATTENDANCE_SUMMARY_CFG, *LPNET_DVR_ATTENDANCE_SUMMARY_CFG;

//get attendance record info
typedef struct tagNET_DVR_ATTENDANCE_RECORD_CFG
{
    DWORD                 dwSize;
    DWORD                 dwEmployeeNo; //employee number
    BYTE                  byName[NAME_LEN];     //name
    BYTE                  byDepartmentName[NAME_LEN];  //department name
    NET_DVR_TIME_V30      struAttendanceTime;   //attendance time
    BYTE                  byRes[128];
}NET_DVR_ATTENDANCE_RECORD_CFG, *LPNET_DVR_ATTENDANCE_RECORD_CFG;

//attendance time
typedef struct tagNET_DVR_ATTENDANCE_TIME
{
    NET_DVR_TIME_V30      struOnDutyTime;   //on duty time
    NET_DVR_TIME_V30      struOffDutyTime;  //off duty time
}NET_DVR_ATTENDANCE_TIME, *LPNET_DVR_ATTENDANCE_TIME;

//get abnormal time
typedef struct tagNET_DVR_ABNORMAL_CFG
{
    DWORD                 dwSize;
    DWORD                 dwEmployeeNo;     //employee number
    BYTE                  byName[NAME_LEN]; //name
    BYTE                  byDepartmentName[NAME_LEN];  //department name
    NET_DVR_ATTENDANCE_TIME struAttendanceTime[ABNORMAL_INFO_NUM]; //attendance time
    DWORD                 dwLateMinutes;    //late minutes
    DWORD                 dwLeaveEarlyMinutes; //leave early minutes
    DWORD                 dwAbsenceMinutes; //absence minutes
    DWORD                 dwTotalMinutes;   //total minutes
    BYTE                  byRes[128];
}NET_DVR_ABNORMAL_CFG, *LPNET_DVR_ABNORMAL_CFG;

typedef struct tagNET_DVR_CARD_CFG_V50
{
    DWORD dwSize;
    DWORD dwModifyParamType;
    // the card parameter need to modify, valid when set card parameter, use by bit, every bit means a kind of parameter, 1 means modify, 0 means not
    // #define CARD_PARAM_CARD_VALID       0x00000001 //card valid parameter
    // #define CARD_PARAM_VALID            0x00000002  //valid period parameter
    // #define CARD_PARAM_CARD_TYPE        0x00000004  //card type parameter
    // #define CARD_PARAM_DOOR_RIGHT       0x00000008  //door right parameter
    // #define CARD_PARAM_LEADER_CARD      0x00000010  //leader card parameter
    // #define CARD_PARAM_SWIPE_NUM        0x00000020  //max swipe time parameter
    // #define CARD_PARAM_GROUP            0x00000040  //belong group parameter
    // #define CARD_PARAM_PASSWORD         0x00000080  //card password parameter
    // #define CARD_PARAM_RIGHT_PLAN       0x00000100  //card right plan parameter
    // #define CARD_PARAM_SWIPED_NUM       0x00000200  //has swiped card time parameter
    BYTE byCardNo[ACS_CARD_NO_LEN]; //card No
    BYTE byCardValid; //whether is a vaild card\A3\AC0-invalid\A3\AC1-valid(use to delete card, 0 means delete card when setting, it will be 1 when getting)
    BYTE byCardType; //card type \A3\AC1-ordinary card\A3\AC2-disable card\A3\AC3-black list card, 4-patrol card\A3\AC5-stress card\A3\AC6-super card\A3\AC7-client card\A3\AC8-remove card, default ordinary card
    BYTE byLeaderCard; //whether is leader card, 0-no, 1-yes
    BYTE byRes1;
    BYTE byDoorRight[MAX_DOOR_NUM_256]; //door right , accord to bit, 1-has right 0-no right, from low bit to high bit means door 1-N have right
    NET_DVR_VALID_PERIOD_CFG struValid; //valid period parameter
    BYTE  byBelongGroup[MAX_GROUP_NUM_128]; //Subordinate to the group, in bytes, 1 - belongs to, 0 - does not belong to
    BYTE byCardPassword[CARD_PASSWORD_LEN]; //card password
    WORD wCardRightPlan[MAX_DOOR_NUM_256][MAX_CARD_RIGHT_PLAN_NUM]; //card right plan, value is from plan template No. use or method when same door has different plan template
    DWORD dwMaxSwipeTime; //max card time, 0 means infinite time
    DWORD dwSwipeTime; //has swiped card
    WORD wRoomNumber;  //room number
    SHORT wFloorNumber;   //floor number
    DWORD dwEmployeeNo;   //employee no
    BYTE byName[NAME_LEN];   //name
    WORD wDepartmentNo;   //department no
    WORD wSchedulePlanNo;   //schedule plan no
    BYTE bySchedulePlanType;  //schedule plan type\A3\BA0-no mean\A1\A21-personal\A1\A22-department
    BYTE byRes2[119];
}NET_DVR_CARD_CFG_V50, *LPNET_DVR_CARD_CFG_V50;

typedef  struct tagNET_DVR_CAPTURE_FINGERPRINT_COND
{
    DWORD  dwSize;
    BYTE   byFingerPrintPicType;    //pic type\A3\BA0-no sense
    BYTE   byRes[127];
}NET_DVR_CAPTURE_FINGERPRINT_COND, *LPNET_DVR_CAPTURE_FINGERPRINT_COND;

typedef  struct tagNET_DVR_CAPTURE_FINGERPRINT_CFG
{
    DWORD dwSize;
    DWORD dwFingerPrintDataSize;    //finger print data size
    BYTE  byFingerData[MAX_FINGER_PRINT_LEN];        //finger data
    DWORD dwFingerPrintPicSize;    //finger print pic size
    char* pFingerPrintPicBuffer;       //finger print pic buffer
    BYTE  byRes[64];
}NET_DVR_CAPTURE_FINGERPRINT_CFG, *LPNET_DVR_CAPTURE_FINGERPRINT_CFG;

typedef struct tagNET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_SEND
{
    DWORD   dwSize;
    NET_DVR_STREAM_INFO struStreamInfo; //stream id
    BYTE    byRes[128];
}NET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_SEND, *LPNET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_SEND;

typedef struct tagNET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_RET
{
    DWORD   dwSize;
    NET_DVR_STREAM_INFO struStreamInfo; //stream id
    BYTE    byExecutable;           //0-cannot passback\A3\AC1-passback
    BYTE    byUnexecutableReason;   //reason, 0-need wait\A3\AC1-cannot connect\A3\AC2-stream id invalid\A3\AC3-CVR abnormal\A3\AC4-no video, 5-username or password error, 6-front top device incompatible, 7-other reasons
    BYTE    byRes[254];
}NET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_RET, *LPNET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_RET;

typedef struct tagNET_DVR_STREAM_MEDIA_CFG
{
    DWORD   dwSize;
    BYTE    sUrl[MAX_URL_LEN];
    BYTE    byRes[512];
}NET_DVR_STREAM_MEDIA_CFG, *LPNET_DVR_STREAM_MEDIA_CFG;

//Ship detection a single zone configuration
typedef struct tagNET_DVR_SHIPSDETECTION_REGION_CFG
{
    BYTE    byRuleID;
    BYTE    byEnable;     //Can make
    BYTE  bySensitivity;  //Parameter sensitivity, range [1,100]
    BYTE    byFrameOverlayEnabled;//Whether the video overlay test box
    BYTE   byRes[36];
    NET_ITC_POLYGON struPolygon; //Trigger zone
    NET_VCA_LINE struTriggerLine;  //Trigger line
}NET_DVR_SHIPSDETECTION_REGION_CFG, *LPNET_DVR_SHIPSDETECTION_REGION_CFG;

typedef struct tagNET_DVR_SHIPSDETECTION_CFG
{
    DWORD dwSize;
    BYTE    byEnable;//Can make
    BYTE   byRes1[3];
    float    fLookDownUpAngle;//Equipment pitch Angle, accurate to one decimal places
    float    fHorizontalHeight;//Equipment level, accurate to one decimal places
    NET_DVR_SHIPSDETECTION_REGION_CFG struShipsDetectionRegion[MAX_SHIPSDETE_REGION_NUM];//Ship detection a single zone configuration
    BYTE   byRes[256];
}NET_DVR_SHIPSDETECTION_CFG, *LPNET_DVR_SHIPSDETECTION_CFG;


typedef    struct tagNET_DVR_THERMOMETRY_BASICPARAM
{
    DWORD      dwSize;
    BYTE      byEnabled;  //Enabled\A3\BA0- Disable\A3\AC1- Enable
    BYTE      byStreamOverlay; //Stream Overlay\A3\BA0- No\A3\AC1- Yes
    BYTE      byPictureOverlay;//Picture Overlay\A3\BA0- No\A3\AC1- Yes
    BYTE      byThermometryRange;//Thermometry Range,0-Default,1-(-20~150),2-(0~550)
    BYTE      byThermometryUnit;//Thermometry Unit: 0-\A3\A8\A1\A3\AC1-\A3\A8\A8H\A3\A9\A3\AC2-(K)\A1\A3
    BYTE      byRes[127];
}NET_DVR_THERMOMETRY_BASICPARAM, *LPNET_DVR_THERMOMETRY_BASICPARAM;

typedef    struct tagNET_DVR_THERMOMETRY_COND
{
    DWORD        dwSize;
    DWORD        dwChannel;
    WORD        wPresetNo;
    BYTE        byRes[62];
}NET_DVR_THERMOMETRY_COND, *LPNET_DVR_THERMOMETRY_COND;


typedef    struct tagNET_DVR_THERMOMETRY_PRESETINFO_PARAM
{
    BYTE    byEnabled;  //Enabled
    BYTE    byRuleID;//Rule ID
    WORD    wDistance;//Distance(m)
    float   fEmissivity;//Emissivity
    BYTE    byRes[3];
    BYTE    byReflectiveEnabled;//Reflective Enabled
    float   fReflectiveTemperature;//Reflective Temperature
    char    szRuleName[NAME_LEN/*32*/];//Rule Name
    BYTE    byRes1[63];
    BYTE    byRuleCalibType;//Rule Calib Type
    NET_VCA_POINT struPoint;//Point
    NET_VCA_POLYGON struRegion;//Region
}NET_DVR_THERMOMETRY_PRESETINFO_PARAM, *LPNET_DVR_THERMOMETRY_PRESETINFO_PARAM;

typedef    struct tagNET_DVR_THERMOMETRY_PRESETINFO
{
    DWORD        dwSize;
    WORD        wPresetNo;
    BYTE        byRes[2];
    NET_DVR_THERMOMETRY_PRESETINFO_PARAM struPresetInfo[MAX_THERMOMETRY_REGION_NUM/*40*/];
}NET_DVR_THERMOMETRY_PRESETINFO, *LPNET_DVR_THERMOMETRY_PRESETINFO;

typedef    struct tagNET_DVR_THERMOMETRY_ALARMRULE_PARAM
{
    BYTE      byEnable;
    BYTE      byRuleID;//Rule ID
    BYTE      byRule;//Rule
    BYTE      byRes;
    char      szRuleName[NAME_LEN];//Rule Name
    float      fAlert;//Alert
    float      fAlarm;//Alarm
    float      fThreshold;//Threshold
    BYTE      byRes1[64];
}NET_DVR_THERMOMETRY_ALARMRULE_PARAM, *LPNET_DVR_THERMOMETRY_ALARMRULE_PARAM;

typedef    struct tagNET_DVR_THERMOMETRY_ALARMRULE
{
    DWORD        dwSize;
    NET_DVR_THERMOMETRY_ALARMRULE_PARAM  struThermometryAlarmRuleParam[THERMOMETRY_ALARMRULE_NUM];
    BYTE        byRes[128];
}NET_DVR_THERMOMETRY_ALARMRULE, *LPNET_DVR_THERMOMETRY_ALARMRULE;


typedef    struct tagNET_DVR_THERMOMETRY_DIFFCOMPARISON_PARAM
{
    BYTE       byEnable;
    BYTE       byRuleID;//Rule ID
    BYTE       byAlarmID1;
    BYTE       byAlarmID2;
    BYTE       byRule;//Alarm temperature comparison method 0- high temperature is greater than, 1- high temperature is less than, 2- low temperature is greater than, 3- low temperature is less than, 4- average temperature is greater than, 5- average temperature is less than, 6- temperature difference is greater than, 7- temperature difference is less than
    BYTE       byRes[3];
    float      fTemperatureDiff;//Temperature Difference
    BYTE       byRes1[32];
}NET_DVR_THERMOMETRY_DIFFCOMPARISON_PARAM, *LPNET_DVR_THERMOMETRY_DIFFCOMPARISON_PARAM;

typedef    struct tagNET_DVR_THERMOMETRY_DIFFCOMPARISON
{
    DWORD        dwSize;
    NET_DVR_THERMOMETRY_DIFFCOMPARISON_PARAM  struDiffComparison[MAX_THERMOMETRY_DIFFCOMPARISON_NUM/*8*/];
    BYTE        byRes[64];
}NET_DVR_THERMOMETRY_DIFFCOMPARISON, *LPNET_DVR_THERMOMETRY_DIFFCOMPARISON;


//Realtime Thermometry Cond
typedef struct tagNET_DVR_REALTIME_THERMOMETRY_COND
{
    DWORD        dwSize;
    DWORD        dwChan;
    BYTE        byRuleID;
    BYTE        byRes[63];
}NET_DVR_REALTIME_THERMOMETRY_COND, *LPNET_DVR_REALTIME_THERMOMETRY_COND;

typedef struct tagNET_DVR_POINT_THERM_CFG
{
    float        fTemperature;//Temperature
    NET_VCA_POINT struPoint;//Point
    BYTE        byRes[120];
}NET_DVR_POINT_THERM_CFG, *LPNET_DVR_POINT_THERM_CFG;

typedef struct tagNET_DVR_LINEPOLYGON_THERM_CFG
{
    float       fMaxTemperature;//Max Temperature
    float        fMinTemperature;//Min Temperature
    float       fAverageTemperature;//Average Temperature
    float        fTemperatureDiff;//Temperature Difference
    NET_VCA_POLYGON struRegion;//Region
    BYTE        byRes[32];
}NET_DVR_LINEPOLYGON_THERM_CFG, *LPNET_DVR_LINEPOLYGON_THERM_CFG;

typedef struct tagNET_DVR_THERMOMETRY_UPLOAD
{
    DWORD       dwSize;
    DWORD       dwRelativeTime;     //Relative Time
    DWORD       dwAbsTime;            //AbsTime
    char        szRuleName[NAME_LEN/*32*/];//Rule Name
    BYTE        byRuleID;//Rule ID
    BYTE        byRuleCalibType;//Rule Calibration Type 0-Point\A3\AC1-Region
    WORD        wPresetNo; //Preset No
    NET_DVR_POINT_THERM_CFG struPointThermCfg;
    NET_DVR_LINEPOLYGON_THERM_CFG struLinePolygonThermCfg;
    BYTE        byThermometryUnit;//Thermometry Unit
    BYTE        byDataType;
    BYTE        byRes[126];
}NET_DVR_THERMOMETRY_UPLOAD, *LPNET_DVR_THERMOMETRY_UPLOAD;

//Thermometry Alarm
typedef struct tagNET_DVR_THERMOMETRY_ALARM
{
    DWORD   dwSize;
    DWORD   dwChannel;//Channel
    BYTE    byRuleID;//Rule ID
    BYTE    byThermometryUnit;//Thermometry Unit: 0-\A3\A8\A1\A3\AC1-\A3\A8\A8H\A3\A9\A3\AC2-(K)
    WORD    wPresetNo; //Preset No.
    NET_PTZ_INFO  struPtzInfo;//ptz
    BYTE    byAlarmLevel;//0-Advance Alarm 1-Alarm
    BYTE    byAlarmType;/*Alarm Type 0-Max Temperature 1-Min Temperature 2-Average Temperature 3-Temperature Difference*/
    BYTE    byAlarmRule;//0-Greater than\A3\AC1-Less than
    BYTE    byRuleCalibType;//Regular calibration type 0-Point\A3\AC1-Region, 2-Line
    NET_VCA_POINT struPoint;//Point
    NET_VCA_POLYGON struRegion;//Region
    float   fRuleTemperature;/*Rule Temperature */
    float   fCurrTemperature;/*current Temperature  */
    DWORD   dwPicLen;//Picture Len
    DWORD   dwThermalPicLen;//Thermal Picture Len
    DWORD   dwThermalInfoLen;//Thermal Info Len
    char*   pPicBuff;//Picture
    char*   pThermalPicBuff;//Thermal Picture
    char*   pThermalInfoBuff;//Thermal Info
    NET_VCA_POINT struHighestPoint;//Highest Point
    BYTE    byRes[60];
}NET_DVR_THERMOMETRY_ALARM, *LPNET_DVR_THERMOMETRY_ALARM;


//Thermometry Difference Alarm
typedef struct tagNET_DVR_THERMOMETRY_DIFF_ALARM
{
    DWORD   dwSize;
    DWORD   dwChannel;//Channel
    BYTE    byAlarmID1;//AlarmID1
    BYTE    byAlarmID2;//AlarmID2
    WORD    wPresetNo; //Preset No.
    BYTE    byAlarmLevel;//0-Advance Alarm 1-Alarm
    BYTE    byAlarmType;//Alarm Type 0-Max Temperature 1-Min Temperature 2-Average Temperature 3-Temperature Difference
    BYTE    byAlarmRule;//0-Greater than\A3\AC1-Less than
    BYTE    byRuleCalibType;//Regular calibration type 0-Point\A3\AC1-Region
    NET_VCA_POINT struPoint[2];//Point
    NET_VCA_POLYGON struRegion[2];//Region
    float   fRuleTemperatureDiff;//Rule Temperature
    float   fCurTemperatureDiff;//current Temperature
    NET_PTZ_INFO  struPtzInfo;//ptz
    DWORD   dwPicLen;//Picture Len
    DWORD   dwThermalPicLen;//Thermal Picture Len
    DWORD   dwThermalInfoLen;//Thermal Info Len
    char*   pPicBuff;//Picture
    char*   pThermalPicBuff;//Thermal Picture
    char*   pThermalInfoBuff;//Thermal Info
    BYTE    byThermometryUnit;//Thermometry Unit: 0-\A3\A8\A1\A3\AC1-\A3\A8\A8H\A3\A9\A3\AC2-(K)
    BYTE    byRes[63];
}NET_DVR_THERMOMETRY_DIFF_ALARM, *LPNET_DVR_THERMOMETRY_DIFF_ALARM;

typedef  struct  //Conditions of structure
{
    DWORD   dwSize;
    DWORD  dwChannel;//Channel number (front-end default is 1)
    BYTE   byRes[128];
}NET_DVR_SHIPSCOUNT_COND, *LPNET_DVR_SHIPSCOUNT_COND;


//get ships counting information structure
typedef struct tagNET_DVR_SHIPSCOUNT_CFG
{
    DWORD dwSize;
    DWORD dwUpShipsCount; //Number of uplink ships
    DWORD dwDownShipsCount; //Number of downward ships
    DWORD dwLeftShipsCount; //Number of ships left
    DWORD dwRightShipsCount; //Another ship number
    DWORD dwTotalCount;//The relative timing counting equipment side began to count
    DWORD dwRelativeTime; //Relative Time
    DWORD dwAbsTime; //Counting equipment side began to count the absolute time scale
    BYTE   byDataType;//State of data types: 0 - tests, 1 -, 2 - end
    BYTE   byRes[255];
}NET_DVR_SHIPSCOUNT_CFG, *LPNET_DVR_SHIPSCOUNT_CFG;


//Ships Info
typedef struct tagNET_DVR_SHIPSINFO
{
    float     fShipsLength; //Ships Length
    float     fShipsHeight; //Ships Height
    float     fShipsWidth;  //Ships Width
    float     fShipsSpeed;  //Ships Speed
    BYTE      byShipsDirection;//Ships Direction
    BYTE      byShipsDetState;//Ship detection; 0~ across the detection line, 1~the bow, 2~ the stern
    BYTE      byRes[62];
    NET_VCA_POLYGON  struShipsRect; //Ships Rect
} NET_DVR_SHIPSINFO, *LPNET_DVR_SHIPSINFO;

//Ships Dectction Alarm
typedef struct tagNET_DVR_SHIPSDETECTION_ALARM
{
    DWORD   dwSize;
    NET_VCA_DEV_INFO  struDevInfo;   //Device Info
    DWORD   dwRelativeTime; //Relative Time
    DWORD   dwAbsTime; //Abs Time
    BYTE    byShipsNum; //Ships Num
    BYTE    byShipsNumHead;//Ships Num\A3\BB(The bow number of detected ships)
    BYTE    byShipsNumEnd; //Ships Num\A3\BB(The stern number of detected ships)
    BYTE    byRes1;
    NET_DVR_SHIPSINFO struShipInfo[MAX_SHIPS_NUM/*20*/];//Ship Info
    DWORD   dwPicLen;//Picture Length
    DWORD   dwThermalPicLen;//Thermal Picture Length
    BYTE*   pPicBuffer;    //Picture Buffer
    BYTE*   pThermalPicBuffer;          //Thermal Picture Buffer
    WORD    wDevInfoIvmsChannelEx;      //NET_VCA_DEV_INFO->byIvmsChannel
    BYTE    byRes[254];
}NET_DVR_SHIPSDETECTION_ALARM, *LPNET_DVR_SHIPSDETECTION_ALARM;

typedef struct tagNET_DVR_BAREDATAOVERLAY_CFG
{
    DWORD   dwSize;
    BYTE    byEnable;//Enable
    BYTE    byIntervalTime;// Interval Time
    BYTE    byRes[258];
}NET_DVR_BAREDATAOVERLAY_CFG, *LPNET_DVR_BAREDATAOVERLAY_CFG;

//Thermometry Trigger Cond
typedef    struct tagNET_DVR_THERMOMETRY_TRIGGER_COND
{
    DWORD    dwSize;
    DWORD    dwChan;//Channel
    DWORD    dwPreset;//Preset(currently does not support)
    BYTE     byRes[256];
}NET_DVR_THERMOMETRY_TRIGGER_COND, *LPNET_DVR_THERMOMETRY_TRIGGER_COND;

//terminal register GK info
typedef struct tagNET_DVR_TERMINAL_GK_CFG
{
    DWORD dwSize;
    BYTE  byEnable; //enable
    BYTE  byRegisterState;    //register status\A3\AC0-not\A3\AC1-yes\A3\ACreadly only
    BYTE  byRes1[2];
    NET_DVR_IPADDR struGKIP; //GK IP
    WORD wGKPort; //GK port
    BYTE byRes2[2];
    BYTE byRegisterName[REGISTER_NAME_LEN]; //terminal register gk name
    BYTE byPassword[PASSWD_LEN];	//terminal password
    BYTE byRes3[16];
}NET_DVR_TERMINAL_GK_CFG, *LPNET_DVR_TERMINAL_GK_CFG;


typedef    struct tagNET_DVR_MANUALDEICING_CFG
{
    DWORD        dwSize;
    BYTE        byEnabled; //Manual Deicing
    BYTE        byRes[127];
}NET_DVR_MANUALDEICING_CFG, *LPNET_DVR_MANUALDEICING_CFG;
typedef struct tagNET_DVR_POS_HIDDEN_INFORMATION
{
    char szKeyWord[KEY_WORD_NUM/*3*/][KEY_WORD_LEN/*128*/];
    BYTE    byRes[128];
}NET_DVR_POS_HIDDEN_INFORMATION, *LPNET_DVR_POS_HIDDEN_INFORMATION;

typedef struct tagNET_DVR_HIDDEN_INFORMATION_CFG
{
    DWORD  dwSize;
    BYTE   byFuncType;//0-Pos
    BYTE   Res1[3];
    NET_DVR_POS_HIDDEN_INFORMATION struPosInfo;
    BYTE    byRes[1024];
}NET_DVR_HIDDEN_INFORMATION_CFG, *LPNET_DVR_HIDDEN_INFORMATION_CFG;

//led controler
typedef struct tagNET_DVR_INPUT_SOURCE_TEXT_COND
{
    DWORD    dwSize;
    DWORD    dwInputSourceNo;
    DWORD    dwTextNo;
    BYTE    byRes[32];
}NET_DVR_INPUT_SOURCE_TEXT_COND, *LPNET_DVR_INPUT_SOURCE_TEXT_COND;

typedef struct tagNET_DVR_INPUT_SOURCE_TEXT
{
    DWORD        dwSize;
    DWORD        dwTextNo;
    BYTE        byEnable;
    BYTE        byFontSize;
    BYTE        byBkGroudMode;
    BYTE        byRes[1];
    DWORD        dwXPosition;
    DWORD        dwYPosition;
    NET_DVR_RGB_COLOR struForegroudColor;
    NET_DVR_RGB_COLOR struBackgroudColor;
    BYTE        byTextContent[MAX_LEN_TEXT_CONTENT];
    BYTE        byRes1[64];
}NET_DVR_INPUT_SOURCE_TEXT, *LPNET_DVR_INPUT_SOURCE_TEXT;

typedef struct tagNET_DVR_INPUT_SOURCE_TEXT_LIST
{
    DWORD    dwSize;
    NET_DVR_INPUT_SOURCE_TEXT struTextList[MAX_NUM_INPUT_SOURCE_TEXT];
    BYTE    byRes[64];
}NET_DVR_INPUT_SOURCE_TEXT_LIST, *LPNET_DVR_INPUT_SOURCE_TEXT_LIST;

typedef struct  tagNET_DVR_INPUT_SOURCE_RESOLUTION
{
    DWORD  dwSize;
    DWORD  dwInputSignalNo;
    BYTE  byEnabled;
    BYTE  byRes;
    WORD  wImageWidth;
    WORD  wImageHeight;
    WORD  wRefreshRate;
    BYTE  byColorDepth;
    BYTE  byScanType;
    BYTE  byRes1[62];
}NET_DVR_INPUT_SOURCE_RESOLUTION, *LPNET_DVR_INPUT_SOURCE_RESOLUTION;

typedef struct tagNET_DVR_INPUT_SOURCE_RESOLUTION_LIST
{
    DWORD  dwSize;
    DWORD  dwInputSignalCnt;
    LPNET_DVR_INPUT_SOURCE_RESOLUTION  lpstruBuffer;
    DWORD  dwBufferSize;
    BYTE   byRes[32];
}NET_DVR_INPUT_SOURCE_RESOLUTION_LIST, *LPNET_DVR_INPUT_SOURCE_RESOLUTION_LIST;

typedef struct tagNET_DVR_LED_AREA_COND
{
    DWORD dwSize;
    DWORD dwVideoWallNo;
    DWORD dwLEDAreaNo;
    BYTE   byRes[32];
}NET_DVR_LED_AREA_COND, *LPNET_DVR_LED_AREA_COND;

typedef struct tagNET_DVR_LED_AREA_INFO
{
    DWORD dwSize;
    DWORD dwLEDAreaNo;
    NET_DVR_RECTCFG_EX struRect;
    DWORD dwaOutputNo[MAX_NUM_OUTPUT_CHANNEL];
    BYTE   byRes[32];
}NET_DVR_LED_AREA_INFO, *LPNET_DVR_LED_AREA_INFO;

typedef struct tagNET_DVR_LED_AREA_INFO_LIST
{
    DWORD dwSize;
    DWORD dwLEDAreaNum;
    LPNET_DVR_LED_AREA_INFO lpstruBuffer;
    DWORD dwBufferSize;
    BYTE   byRes[32];
}NET_DVR_LED_AREA_INFO_LIST, *LPNET_DVR_LED_AREA_INFO_LIST;

//call waiting struct
typedef struct tagNET_DVR_CALL_WAITTING_CFG
{
    DWORD   dwSize;    //struct size
    BYTE    byEnable;    //0--disable\A3\AC1--enable
    BYTE    byRes1;
    WORD    wWaitTime;//wait time(s)
    BYTE    byRes[512];
}NET_DVR_CALL_WAITTING_CFG, *LPNET_DVR_CALL_WAITTING_CFG;

//alarm lamp struct
typedef struct tagNET_DVR_ALARM_LAMP_CFG
{
    DWORD   dwSize;    //struct size
    BYTE    byEnable;    //0--disable\A3\AC1--enable
    BYTE    byRes1;
    WORD   wFlashDuration;//flash duration time(s)
    WORD   wFlashIntervalTime;//flash interval time(s)
    BYTE    byRes[510];
}NET_DVR_ALARM_LAMP_CFG, *LPNET_DVR_ALARM_LAMP_CFG;

//voice promption struct
typedef struct tagNET_DVR_VOICE_PROMPTION_CFG
{
    DWORD   dwSize;    //struct size
    BYTE    byEnable;    //0--disable\A3\AC1--enable
    BYTE    byRes1[3];
    BYTE    byCenterBusyFile[NAME_LEN];//center busy file name
    BYTE    byRefusedFile[NAME_LEN];//refused file name
    BYTE    byHangUpFile[NAME_LEN];//hang up file name
    BYTE    byCallWaittingFile[NAME_LEN];//call waitting file name
    BYTE    byRes[512];
}NET_DVR_VOICE_PROMPTION_CFG, *LPNET_DVR_VOICE_PROMPTION_CFG;

//emergence alarm rsp configure
typedef struct tagNET_DVR_EMERGENCE_ALARM_RSP_CTRL_CFG
{
    DWORD   dwSize;        //struct size
    BYTE    byCommand;    //command\A3\AC0--centerbusy\A3\AC1--refuse
    BYTE    byRes[511];
}NET_DVR_EMERGENCE_ALARM_RSP_CTRL_CFG, *LPNET_DVR_EMERGENCE_ALARM_RSP_CTRL_CFG;

///////////*net parameter config_V50/////////////
typedef struct _tagNET_DVR_ALARMHOST_NETPARAM_V50
{
    DWORD     dwSize;
    NET_DVR_IPADDR  struIP;
    WORD     wPort;
    BYTE    byAddressType;
    BYTE    byEnable; //0-not use,1-use
    BYTE    byDomainName[MAX_DOMAIN_NAME/*64*/];
    BYTE    byReportProtocol;        //1-private 2-NAL2300
    BYTE    byDevID[ACCOUNTNUM_LEN_32/*32*/];
    BYTE    byRes2[64];
} NET_DVR_ALARMHOST_NETPARAM_V50, *LPNET_DVR_ALARMHOST_NETPARAM_V50;

typedef struct _tagNET_DVR_ALARMHOST_NETCFG_V50
{
    DWORD dwSize;
    NET_DVR_ALARMHOST_NETPARAM_V50   struNetCenter[MAX_CENTERNUM];
    BYTE        byRes1[128];
} NET_DVR_ALARMHOST_NETCFG_V50, *LPNET_DVR_ALARMHOST_NETCFG_V50;
//system pack type
typedef enum tagSTREAM_TYPE{
    STREAM_PS = 0x1,   //PS pack
    STREAM_3GPP = 0x2,   //3GP pack
}STREAM_TYPE;
typedef enum tagNET_SDK_INIT_CFG_TYPE
{
    NET_SDK_INIT_CFG_TYPE_CHECK_MODULE_COM = 0,
    NET_SDK_INIT_CFG_ABILITY = 1,
    NET_SDK_INIT_CFG_SDK_PATH = 2  //com path
}NET_SDK_INIT_CFG_TYPE;


typedef struct tagNET_DVR_INIT_CHECK_MODULE_COM
{
    BYTE byEnable;
    BYTE byRes[255];
}NET_DVR_INIT_CHECK_MODULE_COM, *LPNET_DVR_INIT_CHECK_MODULE_COM;
typedef enum _INIT_CFG_MAX_NUM
{
    INIT_CFG_NUM_2048 = 2048,   // 2048
    INIT_CFG_NUM_5120 = 5120,   //5120
    INIT_CFG_NUM_10240 = 10240,   // 10240
    INIT_CFG_NUM_15360 = 15360,   // 15360
    INIT_CFG_NUM_20480 = 20480,   // 20480
}INIT_CFG_MAX_NUM;

typedef struct tagNET_DVR_INIT_CFG_ABILITY
{
    INIT_CFG_MAX_NUM    enumMaxLoginUsersNum;
    INIT_CFG_MAX_NUM   enumMaxAlarmNum;
    BYTE    byRes[64];
}NET_DVR_INIT_CFG_ABILITY, *LPNET_DVR_INIT_CFG_ABILITY;

typedef struct tagNET_DVR_LOCAL_SDK_PATH
{
    char sPath[NET_SDK_MAX_FILE_PATH];//sdk path
    BYTE byRes[128];
}NET_DVR_LOCAL_SDK_PATH, *LPNET_DVR_LOCAL_SDK_PATH;

typedef struct tagNET_DVR_SDKMEMPOOL_CFG
{
    BYTE byRes[256];
}NET_DVR_SDKMEMPOOL_CFG, *LPNET_DVR_SDKMEMPOOL_CFG;

typedef struct tagNET_DVR_DEC_RESOURCE_LIST
{
    DWORD dwSize;
    BYTE  byDecStatus[MAX_SUBSYSTEM_NUM_V40/*120*/];
    BYTE  byRes[32];
}NET_DVR_DEC_RESOURCE_LIST, *LPNET_DVR_DEC_RESOURCE_LIST;

typedef struct tagNET_DVR_DEC_APPLICANT_INFO
{
    DWORD dwSize;
    DWORD dwDecResource;
    DWORD  dwChannel;
    NET_DVR_IPADDR  struIP;
    WORD  wPort;
    BYTE  byRes[18];
}NET_DVR_DEC_APPLICANT_INFO, *LPNET_DVR_DEC_APPLICANT_INFO;

typedef struct tagNET_DVR_DEC_RESOURCE_INFO
{
    DWORD dwSize;
    DWORD dwSlotNum;
    NET_DVR_IPADDR struIP;
    WORD  wPort;
    BYTE  byRes1[2];
    DWORD dwDecChan;
    BYTE  sUserName[NAME_LEN];
    BYTE  sPassword[PASSWD_LEN];
    BYTE  byRes2[32];
}NET_DVR_DEC_RESOURCE_INFO, *LPNET_DVR_DEC_RESOURCE_INFO;

typedef struct tagNET_DVR_DEC_CHAN_COND
{
    DWORD dwSize;
    DWORD dwSlotNum;
    DWORD dwDecChan;
    BYTE  byRes[16];
}NET_DVR_DEC_CHAN_COND, *LPNET_DVR_DEC_CHAN_COND;

typedef struct tagNET_DVR_DEC_YUV_CFG
{
    DWORD dwSize;
    BYTE  byEnable;
    BYTE  byRes1[3];
    DWORD dwYUVAddress[3];
    WORD  wWidth;
    WORD  wHeight;
    BYTE  byEnableAudio;
    BYTE  byRes2[3];
    DWORD dwAudioAddr;
    BYTE  byRes3[16];
}NET_DVR_DEC_YUV_CFG, *LPNET_DVR_DEC_YUV_CFG;

typedef struct tagNET_DVR_UPLOAD_VIDEO_INFO
{
    DWORD   dwSize;
    DWORD   dwVideoMangeNo;
    BYTE    byVideoType;
    BYTE    byRes1[3];
    BYTE    sVideoName[NAME_LEN];
    NET_DVR_TIME_V30 struTime;
    BYTE 	byRes[132];
} NET_DVR_UPLOAD_VIDEO_INFO, *LPNET_DVR_UPLOAD_VIDEO_INFO;

typedef struct tagNET_DVR_DEVICE_FILE_INFO
{
    DWORD   dwSize;
    BYTE	sFileName[NAME_LEN];
    DWORD	dwManageNo;
    NET_DVR_TIME_EX  struTime;
    BYTE	byUsed;
    BYTE	byRes[127];
} NET_DVR_DEVICE_FILE_INFO, *LPNET_DVR_DEVICE_FILE_INFO;

typedef struct  tagNET_DVR_PLAY_ITEM
{
    DWORD	dwSize;
    BYTE	byItemType;
    BYTE	byRes[3];
    DWORD	dwPlayManageNo;
    DWORD	dwPlayPicTime;
    BYTE    byRes2[64];
} NET_DVR_PLAY_ITEM, *LPNET_DVR_PLAY_ITEM;

typedef struct tagNET_DVR_DEVICE_PLAYLIST
{
    DWORD	dwSize;
    BYTE    byEnable;
    BYTE    byPlayType;
    BYTE    byVaildItemNum;
    BYTE    byRes[1];
    NET_DVR_PLAY_ITEM struPlayItem[PLAYLIST_ITEM_NUM];
    BYTE     byPlaylistName[PLAYLIST_NAME_LEN];
    DWORD   dwPlaylistNo;
    BYTE     byRes2[128];
} NET_DVR_DEVICE_PLAYLIST, *LPNET_DVR_DEVICE_PLAYLIST;
typedef struct tagNET_DVR_PLAYLIST_ITEM_CTRL
{
    DWORD	dwSize;
    BYTE	byCtrlType;
    BYTE	byPlayIndex;
    NET_DVR_PLAY_ITEM struPlayItem;
    BYTE   byNewPlayIndex;
    BYTE   byRes[63];
}NET_DVR_PLAYLIST_ITEM_CTRL, *LPNET_DVR_PLAYLIST_ITEM_CTRL;

typedef struct tagNET_DVR_PLAN_ITEM
{
    NET_DVR_PLAY_ITEM struPlanPlayItem;
    NET_DVR_TIME_SEGMENT struTimeSegment;
    BYTE  byRes[16];
} NET_DVR_PLAN_ITEM, *LPNET_DVR_PLAN_ITEM;

typedef struct tagNET_DVR_PLAYPLAN_CFG
{
    DWORD	dwSize;
    BYTE	byEnable;
    BYTE    byPlanMode;
    BYTE	byRes[2];
    NET_DVR_PLAN_ITEM struPlanItem[MAX_DAYS][MAX_TIMESEGMENT_V30];
    DWORD	dwPlayPlanNo;
    BYTE	byPlayPlanName[NAME_LEN];
    BYTE	byRes2[32];
} NET_DVR_PLAYPLAN_CFG, *LPNET_DVR_PLAYPLAN_CFG;
typedef struct tagNET_DVR_WINDOW_PLAYPLAN_CFG
{
    DWORD dwSize;
    BYTE byEnable;
    BYTE byRes[3];
    DWORD dwPlayPlanNo;
    BYTE byRes2[32];
} NET_DVR_WINDOW_PLAYPLAN_CFG, *LPNET_DVR_WINDOW_PLAYPLAN_CFG;

typedef struct tagNET_DVR_DEV_PLAYCTRL
{
    DWORD   dwSize;
    BYTE    byControlType;
    BYTE    byRes[131];
} NET_DVR_DEV_PLAYCTRL, *LPNET_DVR_DEV_PLAYCTRL;

typedef union tagNET_DVR_PLAYITEM_INFO
{
    struct
    {
        DWORD  dwPlayItem;
        BYTE    byPlayItemName[NAME_LEN];
        BYTE    byRes2[8];
    } struPlayItem;
    struct
    {
        DWORD  dwPlaylistNo;
        BYTE    byPlaylistName[NAME_LEN];
        WORD   wPlayIndex;
        BYTE    byPlayType;
        BYTE    byRes[3];
        DWORD  dwPlayItem;
        BYTE    byPlayItemName[NAME_LEN];
        BYTE    byRes2[16];
    } struPlaylistItem;
    struct
    {
        DWORD  dwPlayPlanNo;
        NET_DVR_TIME_SEGMENT struTime;
        BYTE    byPlayType;
        BYTE    byRes[3];
        DWORD  dwPlaylistNo;
        BYTE    byPlaylistName[NAME_LEN];
        DWORD  dwPlayItem;
        BYTE    byPlayItemName[NAME_LEN];
        WORD   wPlayIndex;
        BYTE    byRes2[18];
    } struPlayPlanItem;
}NET_DVR_PLAYITEM_INFO, *LPNET_DVR_PLAYITEM_INFO;
typedef struct tagNET_DVR_PLAYING_INFO
{
    DWORD	dwSize;
    BYTE    byPlayWay;
    BYTE    byCurPlayType;
    BYTE    byPlayState;
    BYTE    byAudioState;
    NET_DVR_PLAYITEM_INFO  struPlayItemInfo;
    BYTE    byRes2[16];
} NET_DVR_PLAYING_INFO, *LPNET_DVR_PLAYING_INFO;

typedef struct tagNET_DVR_FUSION_SCALE
{
    DWORD dwSize;
    WORD wWidth;
    WORD wHeight;
    BYTE byRes[32];
}NET_DVR_FUSION_SCALE, *LPNET_DVR_FUSION_SCALE;

typedef struct tagNET_DVR_FUSION_CFG
{
    DWORD dwSize;
    BYTE byFusion;
    BYTE byUseHistoryMap;
    BYTE byRes[30];
}NET_DVR_FUSION_CFG, *LPNET_DVR_FUSION_CFG;

typedef struct tagNET_DVR_DISPINPUT_CFG_LIST
{
    DWORD  dwSize;
    DWORD  dwDispInputNum;
    LPNET_DVR_DISPINPUT_CFG lpstruBuffer;
    DWORD  dwBufferSize;
    BYTE   byRes[32];
}NET_DVR_DISPINPUT_CFG_LIST, *LPNET_DVR_DISPINPUT_CFG_LIST;

typedef struct tagNET_DVR_RES_INFO
{
    DWORD dwImageWidth;
    DWORD dwImageHeight;
}NET_DVR_RES_INFO, *LPNET_DVR_RES_INFO;

typedef struct tagNET_DVR_VS_INPUT_CHAN_INIT
{
    DWORD dwSize;
    DWORD dwVSInputChan;
    DWORD dwResNums;
    NET_DVR_RES_INFO struResList[MAX_RES_NUM_ONE_VS_INPUT_CHAN];
    BYTE byRes[32];
}NET_DVR_VS_INPUT_CHAN_INIT, *LPNET_DVR_VS_INPUT_CHAN_INIT;

typedef struct tagNET_DVR_VS_INPUT_CHAN_INIT_LIST
{
    DWORD dwSize;
    NET_DVR_VS_INPUT_CHAN_INIT struChanList[MAX_VS_INPUT_CHAN_NUM];
    BYTE byRes[32];
}NET_DVR_VS_INPUT_CHAN_INIT_LIST, *LPNET_DVR_VS_INPUT_CHAN_INIT_LIST;

typedef struct tagNET_DVR_VS_INPUT_CHAN_CFG
{
    DWORD dwSize;
    DWORD dwVSInputChan;
    NET_DVR_RES_INFO struResolutin;
    BYTE byRes[64];
}NET_DVR_VS_INPUT_CHAN_CFG, *LPNET_DVR_VS_INPUT_CHAN_CFG;

typedef struct tagNET_DVR_VS_NETSRC_CFG
{
    DWORD dwSize;
    DWORD dwVSInputChan;
    BYTE byDispUrl[MAX_URL_LEN];
    BYTE byRes[128];
}NET_DVR_VS_NETSRC_CFG, *LPNET_DVR_VS_NETSRC_CFG;

typedef struct tagNET_DVR_EDID_FILE_INFO
{
    DWORD   dwSize;
    DWORD   dwEDIDFileNo;
    BYTE    byFileName[FILE_NAME_LEN];
    BYTE    byRes[32];
}NET_DVR_EDID_FILE_INFO, *LPNET_DVR_EDID_FILE_INFO;

typedef struct tagNET_DVR_EDID_FILE_INFO_LIST
{
    DWORD   dwSize;
    DWORD   dwEDIDFileNum;
    LPNET_DVR_EDID_FILE_INFO lpstruBuffer;
    DWORD   dwBufferSize;
    BYTE    byRes[32];
}NET_DVR_EDID_FILE_INFO_LIST, *LPNET_DVR_EDID_FILE_INFO_LIST;

typedef struct tagNET_DVR_OSD_INFO
{
    BYTE byEnabled;
    BYTE byEnabledFlash;
    BYTE byFontSize;
    BYTE byTransparent;
    NET_DVR_RGB_COLOR struColor;
    WORD wCoordinateX;
    WORD wCoordinateY;
    BYTE byContent[MAX_LEN_OSD_CONTENT];
    BYTE byRes[32];
}NET_DVR_OSD_INFO, *LPNET_DVR_OSD_INFO;

typedef struct tagNET_DVR_SUBWND_DECODE_OSD
{
    DWORD dwSize;
    DWORD dwSubWndNo;
    DWORD dwOSDNums;
    NET_DVR_OSD_INFO struOSDList[MAX_NUM_OSD_ONE_SUBWND];
    BYTE byRes[32];
}NET_DVR_SUBWND_DECODE_OSD, *LPNET_DVR_SUBWND_DECODE_OSD;

typedef struct tagNET_DVR_SUBWND_DECODE_OSD_LIST
{
    DWORD dwSize;
    NET_DVR_SUBWND_DECODE_OSD struSubWndList[MAX_NUM_SPLIT_WND];
    BYTE byRes[32];
}NET_DVR_SUBWND_DECODE_OSD_LIST, *LPNET_DVR_SUBWND_DECODE_OSD_LIST;

typedef struct tagNET_DVR_DECODE_CHANNEL_OSD
{
    DWORD dwSize;
    NET_DVR_OSD_INFO struOSDInfo[MAX_NUM_OSD];
    BYTE byRes[32];
}NET_DVR_DECODE_CHANNEL_OSD, *LPNET_DVR_DECODE_CHANNEL_OSD;

typedef	struct tagNET_DVR_THERMINTELL_PARAM
{
    DWORD   dwSize;
    BYTE    byIntellType;  //Intell Type,0~thermometryAndSmart\A3\AC1~shipsDetection\A3\AC2~fireDetection
    BYTE    byRes[127];
}NET_DVR_THERMINTELL_PARAM, *LPNET_DVR_THERMINTELL_PARAM;

//Export GUID File
typedef struct tagNET_DVR_GUID_FILE_EXPORT
{
    DWORD   dwSize;
    char    sLoginPassWord[NET_SDK_MAX_LOGIN_PASSWORD_LEN/*128*/];    //user login password
    BYTE    byRes[128];
}NET_DVR_GUID_FILE_EXPORT, *LPNET_DVR_GUID_FILE_EXPORT;

//user login password check
typedef struct tagNET_DVR_LOGIN_PASSWORDCFG
{
    DWORD   dwSize;
    char    sLoginPassWord[NET_SDK_MAX_LOGIN_PASSWORD_LEN/*128*/];    //user login password
    BYTE    byRes[256];
}NET_DVR_LOGIN_PASSWORDCFG, *LPNET_DVR_LOGIN_PASSWORDCFG;

//single security question config
typedef struct tagNET_DVR_SINGLE_SECURITY_QUESTION_CFG
{
    DWORD   dwSize;
    DWORD   dwId;//index
    char    sAnswer[NET_SDK_MAX_ANSWER_LEN/*256*/];//answer
    BYTE    byMark;//mark  0-no 1-yes
    BYTE    byRes[127];
}NET_DVR_SINGLE_SECURITY_QUESTION_CFG, *LPNET_DVR_SINGLE_SECURITY_QUESTION_CFG;

//security question config
typedef struct tagNET_DVR_SECURITY_QUESTION_CFG
{
    DWORD   dwSize;
    NET_DVR_SINGLE_SECURITY_QUESTION_CFG  struSecurityQuestion[NET_SDK_MAX_QUESTION_LIST_LEN/*32*/];//security question list
    char    sLoginPassWord[NET_SDK_MAX_LOGIN_PASSWORD_LEN/*128*/];//admin passwd
    BYTE    byRes[512];
}NET_DVR_SECURITY_QUESTION_CFG, *LPNET_DVR_SECURITY_QUESTION_CFG;

typedef struct tagNET_DVR_GUID_FILE_STATUS_INFO
{
    DWORD   dwSize;
    BYTE    byLockStatus;
    BYTE    byPasswd;
    BYTE    byRetryNum;
    BYTE    byRes1;
    DWORD   dwLockTime;
    BYTE    byRes[128];
}NET_DVR_GUID_FILE_STATUS_INFO, *LPNET_DVR_GUID_FILE_STATUS_INFO;

NET_DVR_API BOOL __stdcall NET_DVR_Init();
NET_DVR_API BOOL __stdcall NET_DVR_Cleanup();

//NET_DVR_SetDVRMessage extension
#ifdef _WIN32
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessage(UINT nMessage,HWND hWnd);
NET_DVR_API BOOL __stdcall NET_DVR_SetExceptionCallBack_V30(UINT nMessage, HWND hWnd, void (CALLBACK* fExceptionCallBack)(DWORD dwType, LONG lUserID, LONG lHandle, void *pUser), void *pUser);
#elif defined(__linux__) || defined(__APPLE__)
NET_DVR_API BOOL __stdcall NET_DVR_SetExceptionCallBack_V30(UINT reserved1, void* reserved2, void (CALLBACK* fExceptionCallBack)(DWORD dwType, LONG lUserID, LONG lHandle, void *pUser), void *pUser);
/*Linux*/
#if defined(__linux__)
NET_DVR_API BOOL NET_DVR_DrawAreaInit(INITINFO InitInfo, DWORD iUseSDL = 1);
NET_DVR_API BOOL NET_DVR_DrawAreaRelease();
#endif
#endif

NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessCallBack(BOOL (CALLBACK *fMessCallBack)(LONG lCommand,char *sDVRIP,char *pBuf,DWORD dwBufLen));
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessCallBack_EX(BOOL (CALLBACK *fMessCallBack_EX)(LONG lCommand,LONG lUserID,char *pBuf,DWORD dwBufLen));
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessCallBack_NEW(BOOL (CALLBACK *fMessCallBack_NEW)(LONG lCommand,char *sDVRIP,char *pBuf,DWORD dwBufLen, WORD dwLinkDVRPort));
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessageCallBack(BOOL (CALLBACK *fMessageCallBack)(LONG lCommand,char *sDVRIP,char *pBuf,DWORD dwBufLen, DWORD dwUser), DWORD dwUser);
typedef void (CALLBACK *MSGCallBack)(LONG lCommand, NET_DVR_ALARMER *pAlarmer, char *pAlarmInfo, DWORD dwBufLen, void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessageCallBack_V30(MSGCallBack fMessageCallBack, void* pUser);
typedef BOOL(CALLBACK *MSGCallBack_V31)(LONG lCommand, NET_DVR_ALARMER *pAlarmer, char *pAlarmInfo, DWORD dwBufLen, void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessageCallBack_V31(MSGCallBack_V31 fMessageCallBack, void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessageCallBack_V50(int iIndex, MSGCallBack fMessageCallBack, void* pUser);

NET_DVR_API BOOL __stdcall NET_DVR_SetConnectTime(DWORD dwWaitTime = 3000, DWORD dwTryTimes = 3);
NET_DVR_API BOOL __stdcall NET_DVR_SetReconnect(DWORD dwInterval = 30000, BOOL bEnableRecon = TRUE);
NET_DVR_API DWORD __stdcall NET_DVR_GetSDKVersion();
NET_DVR_API DWORD __stdcall NET_DVR_GetSDKBuildVersion();
NET_DVR_API int __stdcall NET_DVR_IsSupport();
NET_DVR_API BOOL __stdcall NET_DVR_StartListen(char *sLocalIP,WORD wLocalPort);
NET_DVR_API BOOL __stdcall NET_DVR_StopListen();

NET_DVR_API LONG __stdcall NET_DVR_StartListen_V30(char *sLocalIP, WORD wLocalPort, MSGCallBack DataCallback, void* pUserData = NULL);
NET_DVR_API BOOL __stdcall NET_DVR_StopListen_V30(LONG lListenHandle);
NET_DVR_API LONG __stdcall NET_DVR_StartRecvNakedDataListen(NAKED_DATA_TYPE type, LPNET_DVR_NAKED_DATA_PARAM pParams);
NET_DVR_API BOOL __stdcall NET_DVR_StopRecvNakedDataListen(LONG lNakedDataRecvHandle);
typedef void(CALLBACK * NAKEDDAtACALLBACK)(DWORD typeInfo, char *pInfo, DWORD dwInfoLen,DWORD dwIPLen, void* pUser);
NET_DVR_API BOOL __stdcall  NET_DVR_SetNakedDataRecvCallBack(LONG lNakedDataRecvHandle, void(CALLBACK *fNakedDataCallBack)(DWORD dwTypeInfo, NET_DVR_NAKED_DATA_INFO *pStruNakedDataInfo, char *pInfo, DWORD dwInfoLen, void* pUser), void* pUser);


NET_DVR_API LONG __stdcall NET_DVR_Login(char *sDVRIP,WORD wDVRPort,char *sUserName,char *sPassword,LPNET_DVR_DEVICEINFO lpDeviceInfo);
NET_DVR_API LONG __stdcall NET_DVR_Login_V30(char *sDVRIP, WORD wDVRPort, char *sUserName, char *sPassword, LPNET_DVR_DEVICEINFO_V30 lpDeviceInfo);
NET_DVR_API LONG __stdcall NET_DVR_Login_V40(LPNET_DVR_USER_LOGIN_INFO pLoginInfo,LPNET_DVR_DEVICEINFO_V40 lpDeviceInfo);

NET_DVR_API BOOL __stdcall NET_DVR_Login_Check(char *sDVRIP, WORD wDVRPort, char *sUserName, char *sPassword, LPNET_DVR_DEVICEINFO_V30 lpDeviceInfo);
NET_DVR_API BOOL __stdcall NET_DVR_Logout(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_Logout_V30(LONG lUserID);
NET_DVR_API DWORD __stdcall NET_DVR_GetLastError();
NET_DVR_API char* __stdcall NET_DVR_GetErrorMsg(LONG *pErrorNo = NULL);
NET_DVR_API BOOL __stdcall NET_DVR_SetShowMode(DWORD dwShowType,COLORREF colorKey);
NET_DVR_API BOOL __stdcall NET_DVR_GetDVRIPByResolveSvr(char *sServerIP, WORD wServerPort, BYTE *sDVRName,WORD wDVRNameLen,BYTE *sDVRSerialNumber,WORD wDVRSerialLen,char* sGetIP);
NET_DVR_API BOOL  __stdcall NET_DVR_GetDVRIPByResolveSvr_EX(char *sServerIP, WORD wServerPort, BYTE *sDVRName, WORD wDVRNameLen, BYTE *sDVRSerialNumber, WORD wDVRSerialLen, char* sGetIP, DWORD *dwPort);

//Preview releated interface
typedef void (CALLBACK *REALDATACALLBACK) (LONG lPlayHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void* pUser);
NET_DVR_API LONG __stdcall NET_DVR_PlayDirect(char *sDVRIP, char *sUserName, char *sPassword, \
                                              LPNET_DVR_CLIENTINFO lpClientInfo, void(CALLBACK *fRealDataCallBack_V30) (LONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void* pUser) = NULL, void* pUser = NULL, BOOL bBlocked = FALSE);
NET_DVR_API LONG __stdcall NET_DVR_RealPlay(LONG lUserID,LPNET_DVR_CLIENTINFO lpClientInfo);
NET_DVR_API LONG __stdcall NET_DVR_RealPlay_V30(LONG lUserID, LPNET_DVR_CLIENTINFO lpClientInfo, void(CALLBACK *fRealDataCallBack_V30) (LONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void* pUser) = NULL, void* pUser = NULL, BOOL bBlocked = FALSE);
typedef void (CALLBACK *REALDATACALLBACK) (LONG lPlayHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void* pUser);

NET_DVR_API LONG __stdcall NET_DVR_RealPlay_V40(LONG lUserID, LPNET_DVR_PREVIEWINFO lpPreviewInfo, REALDATACALLBACK fRealDataCallBack_V30 = NULL, void* pUser = NULL);

NET_DVR_API BOOL __stdcall NET_DVR_StopRealPlay(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_StopPlayDirect(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_RigisterDrawFun(LONG lRealHandle,void (CALLBACK* fDrawFun)(LONG lRealHandle,HDC hDc,DWORD dwUser),DWORD dwUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPlayerBufNumber(LONG lRealHandle,DWORD dwBufNum);
NET_DVR_API BOOL __stdcall NET_DVR_ThrowBFrame(LONG lRealHandle,DWORD dwNum);
NET_DVR_API BOOL __stdcall NET_DVR_SetAudioMode(DWORD dwMode);
NET_DVR_API BOOL __stdcall NET_DVR_OpenSound(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_CloseSound();
NET_DVR_API BOOL __stdcall NET_DVR_OpenSoundShare(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_CloseSoundShare(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_Volume(LONG lRealHandle,WORD wVolume);
NET_DVR_API BOOL __stdcall NET_DVR_SaveRealData(LONG lRealHandle,char *sFileName);
NET_DVR_API BOOL __stdcall NET_DVR_StopSaveRealData(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetRealDataCallBack(LONG lRealHandle,void(CALLBACK *fRealDataCallBack) (LONG lRealHandle, DWORD dwDataType, BYTE *pBuffer,DWORD dwBufSize,DWORD dwUser),DWORD dwUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetStandardDataCallBack(LONG lRealHandle,void(CALLBACK *fStdDataCallBack) (LONG lRealHandle, DWORD dwDataType, BYTE *pBuffer,DWORD dwBufSize,DWORD dwUser),DWORD dwUser);
NET_DVR_API BOOL __stdcall NET_DVR_CapturePicture(LONG lRealHandle,char *sPicFileName);//bmp
NET_DVR_API BOOL __stdcall NET_DVR_SetCapturePictureMode(DWORD dwCaptureMode);


//Make I frame
NET_DVR_API BOOL __stdcall NET_DVR_MakeKeyFrame(LONG lUserID, LONG lChannel);//main stream
NET_DVR_API BOOL __stdcall NET_DVR_MakeKeyFrameSub(LONG lUserID, LONG lChannel);//sub stream

//PTZ control releated interface
NET_DVR_API BOOL __stdcall NET_DVR_PTZControl(LONG lRealHandle,DWORD dwPTZCommand,DWORD dwStop);
NET_DVR_API BOOL __stdcall NET_DVR_PTZControl_Other(LONG lUserID,LONG lChannel,DWORD dwPTZCommand,DWORD dwStop);
NET_DVR_API BOOL __stdcall NET_DVR_TransPTZ(LONG lRealHandle,char *pPTZCodeBuf,DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_TransPTZ_Other(LONG lUserID,LONG lChannel,char *pPTZCodeBuf,DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_PTZPreset(LONG lRealHandle,DWORD dwPTZPresetCmd,DWORD dwPresetIndex);
NET_DVR_API BOOL __stdcall NET_DVR_PTZPreset_Other(LONG lUserID,LONG lChannel,DWORD dwPTZPresetCmd,DWORD dwPresetIndex);
NET_DVR_API BOOL __stdcall NET_DVR_TransPTZ_EX(LONG lRealHandle,char *pPTZCodeBuf,DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_PTZControl_EX(LONG lRealHandle,DWORD dwPTZCommand,DWORD dwStop);
NET_DVR_API BOOL __stdcall NET_DVR_PTZPreset_EX(LONG lRealHandle,DWORD dwPTZPresetCmd,DWORD dwPresetIndex);
NET_DVR_API BOOL __stdcall NET_DVR_PTZCruise(LONG lRealHandle,DWORD dwPTZCruiseCmd,BYTE byCruiseRoute, BYTE byCruisePoint, WORD wInput);
NET_DVR_API BOOL __stdcall NET_DVR_PTZCruise_Other(LONG lUserID,LONG lChannel,DWORD dwPTZCruiseCmd,BYTE byCruiseRoute, BYTE byCruisePoint, WORD wInput);
NET_DVR_API BOOL __stdcall NET_DVR_PTZCruise_EX(LONG lRealHandle,DWORD dwPTZCruiseCmd,BYTE byCruiseRoute, BYTE byCruisePoint, WORD wInput);
NET_DVR_API BOOL __stdcall NET_DVR_PTZTrack(LONG lRealHandle, DWORD dwPTZTrackCmd);
NET_DVR_API BOOL __stdcall NET_DVR_PTZTrack_Other(LONG lUserID, LONG lChannel, DWORD dwPTZTrackCmd);
NET_DVR_API BOOL __stdcall NET_DVR_PTZTrack_EX(LONG lRealHandle, DWORD dwPTZTrackCmd);
NET_DVR_API BOOL __stdcall NET_DVR_PTZControlWithSpeed(LONG lRealHandle, DWORD dwPTZCommand, DWORD dwStop, DWORD dwSpeed);
NET_DVR_API BOOL __stdcall NET_DVR_PTZControlWithSpeed_Other(LONG lUserID, LONG lChannel, DWORD dwPTZCommand, DWORD dwStop, DWORD dwSpeed);
NET_DVR_API BOOL __stdcall NET_DVR_PTZControlWithSpeed_EX(LONG lRealHandle, DWORD dwPTZCommand, DWORD dwStop, DWORD dwSpeed);
NET_DVR_API BOOL __stdcall NET_DVR_GetPTZCruise(LONG lUserID,LONG lChannel,LONG lCruiseRoute, LPNET_DVR_CRUISE_RET lpCruiseRet);


//File search and playback
NET_DVR_API LONG __stdcall NET_DVR_FindFile(LONG lUserID,LONG lChannel,DWORD dwFileType, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime);
NET_DVR_API LONG __stdcall NET_DVR_FindNextFile(LONG lFindHandle,LPNET_DVR_FIND_DATA lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindClose(LONG lFindHandle);
NET_DVR_API LONG __stdcall NET_DVR_FindNextFile_V30(LONG lFindHandle, LPNET_DVR_FINDDATA_V30 lpFindData);
NET_DVR_API LONG __stdcall NET_DVR_FindNextFile_V40(LONG lFindHandle, LPNET_DVR_FINDDATA_V40 lpFindData);
NET_DVR_API LONG __stdcall NET_DVR_FindFile_V30(LONG lUserID, LPNET_DVR_FILECOND pFindCond);
NET_DVR_API BOOL __stdcall NET_DVR_FindClose_V30(LONG lFindHandle);

NET_DVR_API BOOL __stdcall NET_DVR_LockFileByName(LONG lUserID, char *sLockFileName);
NET_DVR_API BOOL __stdcall NET_DVR_UnlockFileByName(LONG lUserID, char *sUnlockFileName);
NET_DVR_API BOOL __stdcall NET_DVR_LockFileByNameV40(LONG lUserID, BOOL bLock, const NET_DVR_LOCK_FILE_BY_NAME_PARA *lpLockFilePara);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackByName(LONG lUserID,char *sPlayBackFileName, HWND hWnd);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackByTime(LONG lUserID,LONG lChannel, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime, HWND hWnd);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackReverseByName(LONG lUserID, char *sPlayBackFileName, HWND hWnd);

NET_DVR_API BOOL __stdcall NET_DVR_PlayBackControl(LONG lPlayHandle,DWORD dwControlCode,DWORD dwInValue,DWORD *LPOutValue);
NET_DVR_API BOOL __stdcall NET_DVR_StopPlayBack(LONG lPlayHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetPlayDataCallBack(LONG lPlayHandle,void(CALLBACK *fPlayDataCallBack) (LONG lPlayHandle, DWORD dwDataType, BYTE *pBuffer,DWORD dwBufSize,DWORD dwUser),DWORD dwUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPlayBackESCallBack(LONG lPlayHandle, void (CALLBACK *fPlayESCallBack)(LONG lPlayHandle, NET_DVR_PACKET_INFO_EX *struPackInfo,  void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPlayDataCallBack_V40(LONG lPlayHandle,void(CALLBACK *fPlayDataCallBack_V40) (LONG lPlayHandle, DWORD dwDataType, BYTE *pBuffer,DWORD dwBufSize,void *pUser),void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_PlayBackSaveData(LONG lPlayHandle,char *sFileName);
NET_DVR_API BOOL __stdcall NET_DVR_StopPlayBackSave(LONG lPlayHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetPlayBackOsdTime(LONG lPlayHandle, LPNET_DVR_TIME lpOsdTime);
NET_DVR_API BOOL __stdcall NET_DVR_PlayBackCaptureFile(LONG lPlayHandle,char *sFileName);
NET_DVR_API LONG __stdcall NET_DVR_GetFileByName(LONG lUserID,char *sDVRFileName,char *sSavedFileName);
NET_DVR_API LONG __stdcall NET_DVR_GetFileByTime(LONG lUserID,LONG lChannel, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime, char *sSavedFileName);
NET_DVR_API BOOL __stdcall NET_DVR_StopGetFile(LONG lFileHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetDownloadPos(LONG lFileHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetPlayBackPos(LONG lPlayHandle);

//Upgrade
NET_DVR_API LONG __stdcall NET_DVR_AdapterUpgrade(LONG lUserID, char *sFileName);
NET_DVR_API LONG __stdcall NET_DVR_Upgrade(LONG lUserID, char *sFileName);
NET_DVR_API LONG __stdcall NET_DVR_VcalibUpgrade(LONG lUserID, LONG lChannel, char const *sFileName);
NET_DVR_API LONG __stdcall NET_DVR_GetUpgradeState(LONG lUpgradeHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetUpgradeProgress(LONG lUpgradeHandle);
NET_DVR_API BOOL __stdcall NET_DVR_CloseUpgradeHandle(LONG lUpgradeHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetNetworkEnvironment(DWORD dwEnvironmentLevel);
//Remote format disk
NET_DVR_API LONG __stdcall NET_DVR_FormatDisk(LONG lUserID,LONG lDiskNumber);
NET_DVR_API BOOL __stdcall NET_DVR_GetFormatProgress(LONG lFormatHandle, LONG *pCurrentFormatDisk,LONG *pCurrentDiskPos,LONG *pFormatStatic);
NET_DVR_API BOOL __stdcall NET_DVR_CloseFormatHandle(LONG lFormatHandle);
//Alarm
NET_DVR_API LONG __stdcall NET_DVR_SetupAlarmChan(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_CloseAlarmChan(LONG lAlarmHandle);
NET_DVR_API LONG __stdcall NET_DVR_SetupAlarmChan_V30(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_CloseAlarmChan_V30(LONG lAlarmHandle);
//Voice talk
NET_DVR_API LONG __stdcall NET_DVR_StartVoiceCom(LONG lUserID, void(CALLBACK *fVoiceDataCallBack)(LONG lVoiceComHandle, char *pRecvDataBuffer, DWORD dwBufSize, BYTE byAudioFlag, DWORD dwUser), DWORD dwUser);
NET_DVR_API LONG __stdcall NET_DVR_StartVoiceCom_V30(LONG lUserID, DWORD dwVoiceChan, BOOL bNeedCBNoEncData, void(CALLBACK *fVoiceDataCallBack)(LONG lVoiceComHandle, char *pRecvDataBuffer, DWORD dwBufSize, BYTE byAudioFlag, void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetVoiceComClientVolume(LONG lVoiceComHandle, WORD wVolume);
NET_DVR_API BOOL __stdcall NET_DVR_StopVoiceCom(LONG lVoiceComHandle);
//Forward Voice
NET_DVR_API LONG __stdcall NET_DVR_StartVoiceCom_MR(LONG lUserID, void(CALLBACK *fVoiceDataCallBack)(LONG lVoiceComHandle, char *pRecvDataBuffer, DWORD dwBufSize, BYTE byAudioFlag, DWORD dwUser), DWORD dwUser);
NET_DVR_API LONG __stdcall NET_DVR_StartVoiceCom_MR_V30(LONG lUserID, DWORD dwVoiceChan, void(CALLBACK *fVoiceDataCallBack)(LONG lVoiceComHandle, char *pRecvDataBuffer, DWORD dwBufSize, BYTE byAudioFlag, void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_VoiceComSendData(LONG lVoiceComHandle, char *pSendBuf, DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetCurrentAudioCompress(LONG lUserID, LPNET_DVR_COMPRESSION_AUDIO lpCompressAudio);
//Voice broadcast
NET_DVR_API BOOL __stdcall NET_DVR_ClientAudioStart();
NET_DVR_API BOOL __stdcall NET_DVR_ClientAudioStart_V30(void(CALLBACK *fVoiceDataCallBack)(char *pRecvDataBuffer, DWORD dwBufSize, void * pUser), void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_ClientAudioStop();
NET_DVR_API BOOL __stdcall NET_DVR_AddDVR(LONG lUserID);
NET_DVR_API LONG __stdcall NET_DVR_AddDVR_V30(LONG lUserID, DWORD dwVoiceChan);
NET_DVR_API BOOL __stdcall NET_DVR_DelDVR(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_DelDVR_V30(LONG lVoiceHandle);
////////////////////////////////////////////////////////////
//Transparent Channel
NET_DVR_API LONG __stdcall NET_DVR_SerialStart(LONG lUserID,LONG lSerialPort,void(CALLBACK *fSerialDataCallBack)(LONG lSerialHandle,char *pRecvDataBuffer,DWORD dwBufSize,DWORD dwUser),DWORD dwUser);
//If RS485 is used as transparent channel,  please specify the channel No. And different channels can have different RS485 parameters
NET_DVR_API LONG __stdcall NET_DVR_SerialStart_V40(LONG lUserID,void* lpInBuffer, LONG dwInBufferSize, void(CALLBACK *fSerialDataCallBack)(LONG lSerialHandle, LONG lCHannel, char *pRecvDataBuffer, DWORD dwBufSize, void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SerialSend(LONG lSerialHandle, LONG lChannel, char *pSendBuf,DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_SerialStop(LONG lSerialHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SendTo232Port(LONG lUserID, char *pSendBuf, DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_SendToSerialPort(LONG lUserID, DWORD dwSerialPort, DWORD dwSerialIndex, char *pSendBuf, DWORD dwBufSize);

//Decoding nBitrate = 16000
NET_DVR_API void* __stdcall NET_DVR_InitG722Decoder(int nBitrate = 16000);
NET_DVR_API void __stdcall NET_DVR_ReleaseG722Decoder(void *pDecHandle);
NET_DVR_API BOOL __stdcall NET_DVR_DecodeG722Frame(void *pDecHandle, BYTE* pInBuffer, BYTE* pOutBuffer);
//Encoding
NET_DVR_API void* __stdcall NET_DVR_InitG722Encoder();
NET_DVR_API BOOL __stdcall NET_DVR_EncodeG722Frame(void *pEncodeHandle,BYTE* pInBuffer, BYTE* pOutBuffer);
NET_DVR_API void __stdcall NET_DVR_ReleaseG722Encoder(void *pEncodeHandle);

//Decoding
NET_DVR_API void* __stdcall NET_DVR_InitG726Decoder(void** pDecMoudle);
NET_DVR_API void __stdcall NET_DVR_ReleaseG726Decoder(void *pDecHandle);
NET_DVR_API BOOL __stdcall NET_DVR_DecodeG726Frame(void *pDecMoudle, BYTE* pInBuffer, BYTE* pOutBuffer, BYTE byReset);
//Encoding
NET_DVR_API void* __stdcall NET_DVR_InitG726Encoder(void** pEncMoudle);
NET_DVR_API BOOL __stdcall NET_DVR_EncodeG726Frame(void *pEncMoudle,BYTE* pInBuffer, BYTE* pOutBuffer, BYTE byReset);
NET_DVR_API void __stdcall NET_DVR_ReleaseG726Encoder(void *pEncHandle);
//Control the local preview remotely
NET_DVR_API BOOL __stdcall NET_DVR_ClickKey(LONG lUserID, LONG lKeyIndex);
//Control the manual record remotely
NET_DVR_API BOOL __stdcall NET_DVR_StartDVRRecord(LONG lUserID,LONG lChannel,LONG lRecordType);
NET_DVR_API BOOL __stdcall NET_DVR_StopDVRRecord(LONG lUserID,LONG lChannel);
//Decoding Card
NET_DVR_API BOOL __stdcall NET_DVR_InitDevice_Card(long *pDeviceTotalChan);
NET_DVR_API BOOL __stdcall NET_DVR_ReleaseDevice_Card();
NET_DVR_API BOOL __stdcall NET_DVR_InitDDraw_Card(HWND hParent,COLORREF colorKey);
NET_DVR_API BOOL __stdcall NET_DVR_ReleaseDDraw_Card();
NET_DVR_API LONG __stdcall NET_DVR_RealPlay_Card(LONG lUserID,LPNET_DVR_CARDINFO lpCardInfo,long lChannelNum);
NET_DVR_API BOOL __stdcall NET_DVR_ResetPara_Card(LONG lRealHandle,LPNET_DVR_DISPLAY_PARA lpDisplayPara);
NET_DVR_API BOOL __stdcall NET_DVR_RefreshSurface_Card();
NET_DVR_API BOOL __stdcall NET_DVR_ClearSurface_Card();
NET_DVR_API BOOL __stdcall NET_DVR_RestoreSurface_Card();
NET_DVR_API BOOL __stdcall NET_DVR_OpenSound_Card(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_CloseSound_Card(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetVolume_Card(LONG lRealHandle,WORD wVolume);
NET_DVR_API BOOL __stdcall NET_DVR_AudioPreview_Card(LONG lRealHandle,BOOL bEnable);
NET_DVR_API LONG __stdcall NET_DVR_GetCardLastError_Card();
NET_DVR_API HANDLE __stdcall NET_DVR_GetChanHandle_Card(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_CapturePicture_Card(LONG lRealHandle, char *sPicFileName);
//NET_DVR_GetSerialNum_Card is invalid,  Call GetBoardDetail instead.
NET_DVR_API BOOL __stdcall NET_DVR_GetSerialNum_Card(long lChannelNum,DWORD *pDeviceSerialNo);
//Log
NET_DVR_API LONG __stdcall NET_DVR_FindDVRLog(LONG lUserID, LONG lSelectMode, DWORD dwMajorType,DWORD dwMinorType, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime);
NET_DVR_API LONG __stdcall NET_DVR_FindNextLog(LONG lLogHandle, LPNET_DVR_LOG lpLogData);
NET_DVR_API BOOL __stdcall NET_DVR_FindLogClose(LONG lLogHandle);
NET_DVR_API LONG __stdcall NET_DVR_FindDVRLog_V30(LONG lUserID, LONG lSelectMode, DWORD dwMajorType,DWORD dwMinorType, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime, BOOL bOnlySmart = FALSE);
NET_DVR_API LONG __stdcall NET_DVR_FindNextLog_V30(LONG lLogHandle, LPNET_DVR_LOG_V30 lpLogData);
NET_DVR_API BOOL __stdcall NET_DVR_FindLogClose_V30(LONG lLogHandle);
// Alarmhost log
NET_DVR_API LONG __stdcall NET_DVR_FindAlarmHostLog(LONG lUserID, LONG lSelectMode, NET_DVR_ALARMHOST_SEARCH_LOG_PARAM *lpSearchParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextAlarmHostLog(LONG lFindHandle, NET_DVR_ALARMHOST_LOG_RET *lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindAlarmHostLogClose(LONG lFindHandle);
//ATM DVR
NET_DVR_API LONG __stdcall NET_DVR_FindFileByCard(LONG lUserID,LONG lChannel,DWORD dwFileType, int nFindType, BYTE *sCardNumber, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime);

//Encoding
NET_DVR_API void* __stdcall NET_DVR_InitG722Encoder();
NET_DVR_API BOOL __stdcall NET_DVR_EncodeG722Frame(void *pEncodeHandle,BYTE* pInBuffer, BYTE* pOutBuffer);
NET_DVR_API void __stdcall NET_DVR_ReleaseG722Encoder(void *pEncodeHandle);
//2005-09-15
NET_DVR_API BOOL __stdcall NET_DVR_CaptureJPEGPicture(LONG lUserID, LONG lChannel, LPNET_DVR_JPEGPARA lpJpegPara, char *sPicFileName);
//Grab JPEG and save to RAM
NET_DVR_API BOOL __stdcall NET_DVR_CaptureJPEGPicture_NEW(LONG lUserID, LONG lChannel, LPNET_DVR_JPEGPARA lpJpegPara, char *sJpegPicBuffer, DWORD dwPicSize,  LPDWORD lpSizeReturned);

NET_DVR_API BOOL __stdcall NET_DVR_CapturePicture_V50(LONG lUserID, LONG lChannel, LPNET_DVR_PICPARAM_V50  lpPicParam, char *sPicBuffer, DWORD dwPicSize, LPDWORD lpSizeReturned);

//2006-02-16
NET_DVR_API LONG __stdcall NET_DVR_GetRealPlayerIndex(LONG lRealHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetPlayBackPlayerIndex(LONG lPlayHandle);

//2006-08-28 704-640 Scale
NET_DVR_API BOOL __stdcall NET_DVR_SetScaleCFG(LONG lUserID, DWORD dwScale);
NET_DVR_API BOOL __stdcall NET_DVR_GetScaleCFG(LONG lUserID, DWORD *lpOutScale);
NET_DVR_API BOOL __stdcall NET_DVR_SetScaleCFG_V30(LONG lUserID, LPNET_DVR_SCALECFG pScalecfg);
NET_DVR_API BOOL __stdcall NET_DVR_GetScaleCFG_V30(LONG lUserID, LPNET_DVR_SCALECFG pScalecfg);
//2006- 08- 28 Port of ATM
NET_DVR_API BOOL __stdcall NET_DVR_SetATMPortCFG(LONG lUserID, WORD wATMPort);
NET_DVR_API BOOL __stdcall NET_DVR_GetATMPortCFG(LONG lUserID, WORD *LPOutATMPort);

//2006- 11- 10 Display on Multi displayer
NET_DVR_API BOOL __stdcall NET_DVR_InitDDrawDevice();
NET_DVR_API BOOL __stdcall NET_DVR_ReleaseDDrawDevice();
NET_DVR_API LONG __stdcall NET_DVR_GetDDrawDeviceTotalNums();
NET_DVR_API BOOL __stdcall NET_DVR_SetDDrawDevice(LONG lPlayPort, DWORD nDeviceNum);

NET_DVR_API BOOL __stdcall NET_DVR_PTZSelZoomIn(LONG lRealHandle, LPNET_DVR_POINT_FRAME pStruPointFrame);
NET_DVR_API BOOL __stdcall NET_DVR_PTZSelZoomIn_EX(LONG lUserID, LONG lChannel, LPNET_DVR_POINT_FRAME pStruPointFrame);
//Decoder DS- 6001D/DS- 6001F
NET_DVR_API BOOL __stdcall NET_DVR_StartDecode(LONG lUserID, LONG lChannel, LPNET_DVR_DECODERINFO lpDecoderinfo);
NET_DVR_API BOOL __stdcall NET_DVR_StopDecode(LONG lUserID, LONG lChannel);
NET_DVR_API BOOL __stdcall NET_DVR_GetDecoderState(LONG lUserID, LONG lChannel, LPNET_DVR_DECODERSTATE lpDecoderState);
//2005-08-01
NET_DVR_API BOOL __stdcall NET_DVR_SetDecInfo(LONG lUserID, LONG lChannel, LPNET_DVR_DECCFG lpDecoderinfo);
NET_DVR_API BOOL __stdcall NET_DVR_GetDecInfo(LONG lUserID, LONG lChannel, LPNET_DVR_DECCFG lpDecoderinfo);
NET_DVR_API BOOL __stdcall NET_DVR_SetDecTransPort(LONG lUserID, LPNET_DVR_PORTCFG lpTransPort);
NET_DVR_API BOOL __stdcall NET_DVR_GetDecTransPort(LONG lUserID, LPNET_DVR_PORTCFG lpTransPort);
NET_DVR_API BOOL __stdcall NET_DVR_DecPlayBackCtrl(LONG lUserID, LONG lChannel, DWORD dwControlCode, DWORD dwInValue,DWORD *LPOutValue, LPNET_DVR_PLAYREMOTEFILE lpRemoteFileInfo);
NET_DVR_API BOOL __stdcall NET_DVR_StartDecSpecialCon(LONG lUserID, LONG lChannel, LPNET_DVR_DECCHANINFO lpDecChanInfo);
NET_DVR_API BOOL __stdcall NET_DVR_StopDecSpecialCon(LONG lUserID, LONG lChannel, LPNET_DVR_DECCHANINFO lpDecChanInfo);
NET_DVR_API BOOL __stdcall NET_DVR_DecCtrlDec(LONG lUserID, LONG lChannel, DWORD dwControlCode);
NET_DVR_API BOOL __stdcall NET_DVR_DecCtrlScreen(LONG lUserID, LONG lChannel, DWORD dwControl);
NET_DVR_API BOOL __stdcall NET_DVR_GetDecCurLinkStatus(LONG lUserID, LONG lChannel, LPNET_DVR_DECSTATUS lpDecStatus);

//Multi- channel decoder
//2007- 11- 30 V211 support the API below //11
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStartDynamic(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DYNAMIC_DEC lpDynamicInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStopDynamic(LONG lUserID, DWORD dwDecChanNum);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanInfo(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_CHAN_INFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetLoopDecChanInfo(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecChanInfo(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetLoopDecChanEnable(LONG lUserID, DWORD dwDecChanNum, DWORD dwEnable);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecChanEnable(LONG lUserID, DWORD dwDecChanNum, LPDWORD lpdwEnable);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecEnable(LONG lUserID, LPDWORD lpdwEnable);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetDecChanEnable(LONG lUserID, DWORD dwDecChanNum, DWORD dwEnable);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanEnable(LONG lUserID, DWORD dwDecChanNum, LPDWORD lpdwEnable);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanStatus(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_CHAN_STATUS lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetVideoStandard(LONG lUserID, DWORD dwDecChanNum, LPDWORD lpdwVideoStandard);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetVideoStandard(LONG lUserID, DWORD dwDecChanNum, DWORD dwVideoStandard);

//2007-12-22
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetTranInfo(LONG lUserID, LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG lpTranInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetTranInfo(LONG lUserID, LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG lpTranInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetRemotePlay(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_REMOTE_PLAY lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetRemotePlayControl(LONG lUserID, DWORD dwDecChanNum, DWORD dwControlCode, DWORD dwInValue, DWORD *LPOutValue);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetRemotePlayStatus(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS lpOuter);
//2009-4-13
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStartDynamic_V30(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_PU_STREAM_CFG lpDynamicInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetLoopDecChanInfo_V30(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_V30 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecChanInfo_V30(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_V30 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanInfo_V30(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_CHAN_INFO_V30 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetTranInfo_V30(LONG lUserID, LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30 lpTranInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetTranInfo_V30(LONG lUserID, LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30 lpTranInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDisplayCfg(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_VGA_DISP_CHAN_CFG lpDisplayCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetDisplayCfg(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_VGA_DISP_CHAN_CFG lpDisplayCfg);

NET_DVR_API LONG __stdcall NET_DVR_MatrixStartPassiveDecode(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_PASSIVEMODE lpPassiveMode /*, void(CALLBACK *fPassiveDataCallBack)(LONG lPassiveHandle, char * pSendBuf, DWORD dwBufSize, DWORD dwStatus, DWORD dwUser), DWORD dwUser*/);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSendData(LONG lPassiveHandle, char *pSendBuf, DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStopPassiveDecode(LONG lPassiveHandle);
NET_DVR_API BOOL __stdcall NET_DVR_UploadLogo(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_DISP_LOGOCFG lpDispLogoCfg, char *sLogoBuffer);
NET_DVR_API BOOL __stdcall NET_DVR_DownloadLogo(LONG lUserID, DWORD dwLogoNo, LPNET_DVR_MATRIX_LOGO_INFO lpLogoInfo, char *sLogoBuffer, DWORD dwLogoBufferSize);
#define    NET_DVR_SHOWLOGO            1        /*Show LOGO*/
#define    NET_DVR_HIDELOGO            2        /*Hide LOGO*/
NET_DVR_API BOOL __stdcall NET_DVR_LogoSwitch(LONG lUserID, DWORD dwDecChan, DWORD dwLogoSwitch);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDeviceStatus(LONG lUserID,  LPNET_DVR_DECODER_WORK_STATUS lpDecoderCfg);

#define    DISP_CMD_ENLARGE_WINDOW                1    /*Enlarge some region*/
#define    DISP_CMD_RENEW_WINDOW                2    /*Restore the region*/
#define    DISP_CMD_OPENAUDIO                    3    /*Open audio*/
#define    DISP_CMD_CLOSEAUDIO                    4    /*close audio*/

NET_DVR_API BOOL __stdcall NET_DVR_MatrixDiaplayControl(LONG lUserID, DWORD dwDispChanNum, DWORD dwDispChanCmd, DWORD dwCmdParam);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixPassiveDecodeControl(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_PASSIVEDECODE_CONTROL lpInter);
NET_DVR_API LONG __stdcall NET_DVR_MatrixGetPassiveDecodeStatus(LONG lPassiveHandle);

NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanCfg(LONG lUserID, DWORD dwDecChan, LPNET_DVR_MATRIX_DECCHAN_CONTROL lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetDecChanCfg(LONG lUserID, DWORD dwDecChan, LPNET_DVR_MATRIX_DECCHAN_CONTROL lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_RefreshPlay(LONG lPlayHandle);
//Restore default configuration
NET_DVR_API BOOL __stdcall NET_DVR_RestoreConfig(LONG lUserID);
//Save configuration
NET_DVR_API BOOL __stdcall NET_DVR_SaveConfig(LONG lUserID);
//Reboot
NET_DVR_API BOOL __stdcall NET_DVR_RebootDVR(LONG lUserID);
//Shutdown DVR
NET_DVR_API BOOL __stdcall NET_DVR_ShutDownDVR(LONG lUserID);

//config parameter begin
NET_DVR_API BOOL __stdcall NET_DVR_GetDVRConfig(LONG lUserID, DWORD dwCommand,LONG lChannel, LPVOID lpOutBuffer, DWORD dwOutBufferSize, LPDWORD lpBytesReturned);
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRConfig(LONG lUserID, DWORD dwCommand,LONG lChannel, LPVOID lpInBuffer, DWORD dwInBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetDVRWorkState_V30(LONG lUserID, LPNET_DVR_WORKSTATE_V30 lpWorkState);
NET_DVR_API BOOL __stdcall NET_DVR_GetDVRWorkState(LONG lUserID, LPNET_DVR_WORKSTATE lpWorkState);
NET_DVR_API BOOL __stdcall NET_DVR_SetVideoEffect(LONG lUserID, LONG lChannel, DWORD dwBrightValue, DWORD dwContrastValue, DWORD dwSaturationValue, DWORD dwHueValue);
NET_DVR_API BOOL __stdcall NET_DVR_GetVideoEffect(LONG lUserID, LONG lChannel, DWORD *pBrightValue, DWORD *pContrastValue, DWORD *pSaturationValue, DWORD *pHueValue);
NET_DVR_API BOOL __stdcall NET_DVR_ClientGetframeformat(LONG lUserID, LPNET_DVR_FRAMEFORMAT lpFrameFormat);
NET_DVR_API BOOL __stdcall NET_DVR_ClientSetframeformat(LONG lUserID, LPNET_DVR_FRAMEFORMAT lpFrameFormat);
NET_DVR_API BOOL __stdcall NET_DVR_GetAtmFrameFormat_V30(LONG lUserID, LONG lAtmChannel, LPNET_DVR_ATM_FRAMEFORMAT_V30 lpFrameFormat);
NET_DVR_API BOOL __stdcall NET_DVR_SetAtmFrameFormat_V30(LONG lUserID, LONG lAtmChannel, LPNET_DVR_ATM_FRAMEFORMAT_V30 lpFrameFormat);
NET_DVR_API BOOL __stdcall NET_DVR_GetAtmProtocol(LONG lUserID, LPNET_DVR_ATM_PROTOCOL lpAtmProtocol);
NET_DVR_API BOOL __stdcall NET_DVR_GetAlarmOut_V30(LONG lUserID, LPNET_DVR_ALARMOUTSTATUS_V30 lpAlarmOutState);
NET_DVR_API BOOL __stdcall NET_DVR_GetAlarmOut(LONG lUserID, LPNET_DVR_ALARMOUTSTATUS lpAlarmOutState);
NET_DVR_API BOOL __stdcall NET_DVR_SetAlarmOut(LONG lUserID, LONG lAlarmOutPort,LONG lAlarmOutStatic);

//Adjust video parameters
NET_DVR_API BOOL __stdcall NET_DVR_ClientSetVideoEffect(LONG lRealHandle,DWORD dwBrightValue,DWORD dwContrastValue, DWORD dwSaturationValue,DWORD dwHueValue);
NET_DVR_API BOOL __stdcall NET_DVR_ClientGetVideoEffect(LONG lRealHandle,DWORD *pBrightValue,DWORD *pContrastValue, DWORD *pSaturationValue,DWORD *pHueValue);

//Configuration File
NET_DVR_API BOOL __stdcall NET_DVR_GetConfigFile(LONG lUserID, char *sFileName);
NET_DVR_API BOOL __stdcall NET_DVR_SetConfigFile(LONG lUserID, char *sFileName);
NET_DVR_API BOOL __stdcall NET_DVR_GetConfigFile_V30(LONG lUserID, char *sOutBuffer, DWORD dwOutSize, DWORD *pReturnSize);

NET_DVR_API BOOL __stdcall NET_DVR_GetConfigFile_EX(LONG lUserID, char *sOutBuffer, DWORD dwOutSize);
NET_DVR_API BOOL __stdcall NET_DVR_SetConfigFile_EX(LONG lUserID, char *sInBuffer, DWORD dwInSize);

//write log file
NET_DVR_API BOOL __stdcall NET_DVR_SetLogToFile(DWORD nLogLevel = 0, char * strLogDir = NULL, BOOL bAutoDel = TRUE);
NET_DVR_API BOOL __stdcall NET_DVR_GetSDKState(LPNET_DVR_SDKSTATE pSDKState);
NET_DVR_API BOOL __stdcall NET_DVR_GetSDKAbility(LPNET_DVR_SDKABL pSDKAbl);
NET_DVR_API BOOL __stdcall NET_DVR_GetPTZProtocol(LONG lUserID, NET_DVR_PTZCFG *pPtzcfg);
//Lock Front Panel
NET_DVR_API BOOL __stdcall NET_DVR_LockPanel(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_UnLockPanel(LONG lUserID);

NET_DVR_API BOOL __stdcall NET_DVR_SetRtspConfig(LONG lUserID, DWORD dwCommand, LPNET_DVR_RTSPCFG lpInBuffer, DWORD dwInBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetRtspConfig(LONG lUserID, DWORD dwCommand, LPNET_DVR_RTSPCFG lpOutBuffer, DWORD dwOutBufferSize);

NET_DVR_API BOOL __stdcall NET_DVR_GetDeviceAbility(LONG lUserID, DWORD dwAbilityType, char* pInBuf, DWORD dwInLength, char* pOutBuf, DWORD dwOutLength);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSubSystemInfo(LONG lUserID, LPNET_DVR_ALLSUBSYSTEMINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetSubSystemInfo(LONG lUserID, LPNET_DVR_ALLSUBSYSTEMINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetCodeSplitter(LONG lUserID, DWORD dwCodeChan, LPNET_DVR_CODESPLITTERINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetCodeSplitter(LONG lUserID, DWORD dwCodeChan, LPNET_DVR_CODESPLITTERINFO lpInter);

// set/get vca behavior param key
NET_DVR_API BOOL __stdcall NET_DVR_SetBehaviorParamKey(LONG lUserID, LONG lChannel, DWORD dwParameterKey,int nValue);
NET_DVR_API BOOL __stdcall NET_DVR_GetBehaviorParamKey(LONG lUserID, LONG lChannel, DWORD dwParameterKey,int *pValue);

//add target API for Get/SetVCA
NET_DVR_API BOOL __stdcall NET_DVR_GetVCADrawMode(LONG lUserID, LONG lChannel, LPNET_VCA_DRAW_MODE lpDrawMode);
NET_DVR_API BOOL __stdcall NET_DVR_SetVCADrawMode(LONG lUserID, LONG lChannel, LPNET_VCA_DRAW_MODE lpDrawMode);

//Track mode configuration interface
NET_DVR_API BOOL __stdcall NET_DVR_SetTrackMode(LONG lUserID, LONG lChannel, LPNET_DVR_TRACK_MODE lpTrackMode);
NET_DVR_API BOOL __stdcall NET_DVR_GetTrackMode(LONG lUserID, LONG lChannel, LPNET_DVR_TRACK_MODE lpTrackMode);

//Restart VCA Lib
NET_DVR_API BOOL __stdcall NET_VCA_RestartLib(LONG lUserID, LONG lChannel);

NET_DVR_API BOOL __stdcall NET_DVR_SaveRealData_V30(LONG lRealHandle, DWORD dwTransType, char *sFileName);

NET_DVR_API BOOL __stdcall NET_DVR_EncodeG711Frame(DWORD iType, BYTE *pInBuffer, BYTE *pOutBuffer);
NET_DVR_API BOOL __stdcall NET_DVR_DecodeG711Frame(DWORD iType, BYTE *pInBuffer, BYTE *pOutBuffer);
NET_DVR_API LONG __stdcall NET_DVR_FindFileByEvent(LONG lUserID, LPNET_DVR_SEARCH_EVENT_PARAM  lpSearchEventParam);
NET_DVR_API LONG __stdcall NET_DVR_FindFileByEvent_V40(LONG lUserID, LPNET_DVR_SEARCH_EVENT_PARAM_V40  lpSearchEventParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextEvent(LONG lSearchHandle, LPNET_DVR_SEARCH_EVENT_RET lpSearchEventRet);
NET_DVR_API LONG __stdcall NET_DVR_FindNextEvent_V40(LONG lSearchHandle, LPNET_DVR_SEARCH_EVENT_RET_V40 lpSearchEventRet);

//NET_DVR_FindClose is invalid

NET_DVR_API LONG __stdcall NET_DVR_FindPDCInfo(LONG lUserID, LONG lChannel, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime);
NET_DVR_API LONG __stdcall NET_DVR_FindNextPDCInfo(LONG lFindHandle,LPNET_DVR_PDC_QUERY lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindPDCClose(LONG lFindHandle);

//Calibration
#define NET_DVR_PDC_VERIFY_CALIBRATION          1
#define NET_DVR_VERIFY_BEHAVIOR_CALIBRATION     2
#define NET_DVR_VERIFY_ITS_CALIBRATION            3
#define NET_DVR_VERIFY_BV_CALIBRATION            5

NET_DVR_API BOOL __stdcall  NET_DVR_VerifyCalibration(LONG lUserID, DWORD dwCommand, LONG lChannel, LPVOID lpInBuffer, DWORD dwInBufferSize, LPVOID lpOuterBuffer, DWORD dwOuterBufferSize);
NET_DVR_API BOOL __stdcall  NET_DVR_ResetCounter(LONG lUserID,LONG lChannel);

NET_DVR_API BOOL __stdcall NET_DVR_GetPtzPosition(LONG lUserID, LONG lChannel, LONG lPositionID, LPNET_DVR_PTZ_POSITION lpPtzPosition);
NET_DVR_API BOOL __stdcall NET_DVR_SetPtzPosition(LONG lUserID, LONG lChannel, LONG lPositionID, LPNET_DVR_PTZ_POSITION lpPtzPosition);
NET_DVR_API BOOL __stdcall NET_DVR_SetPatrolTrack(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_PATROL_TRACKCFG lpPatrolTrack);
NET_DVR_API BOOL __stdcall NET_DVR_GetPatrolTrack(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_PATROL_TRACKCFG lpPatrolTrack);
NET_DVR_API LONG __stdcall NET_DVR_FindNextLog_MATRIX(LONG lLogHandle, LPNET_DVR_LOG_MATRIX lpLogData);
NET_DVR_API LONG __stdcall NET_DVR_FindDVRLog_Matrix(LONG lUserID, LONG lSelectMode, DWORD dwMajorType, DWORD dwMinorType, LPNET_DVR_VEDIOPLATLOG lpVedioPlatLog, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime);

NET_DVR_API BOOL __stdcall NET_DVR_ManualSnap(LONG lUserID, NET_DVR_MANUALSNAP const* lpInter, LPNET_DVR_PLATE_RESULT lpOuter);
NET_DVR_API BOOL __stdcall NET_DVR_ContinuousShoot(LONG lUserID, LPNET_DVR_SNAPCFG lpInter);

NET_DVR_API BOOL __stdcall NET_DVR_GetPTZProtocol_Ex(LONG lUserID, LONG lChannel, NET_DVR_PTZCFG *pPtzcfg);

NET_DVR_API LONG __stdcall NET_DVR_StartEmailTest(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_StopEmailTest(LONG lEmailTestHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetEmailTestProgress(LONG lEmailTestHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_GetIPCProtoList(LONG lUserID, LPNET_DVR_IPC_PROTO_LIST lpProtoList);
NET_DVR_API BOOL __stdcall NET_DVR_GetIPCProtoList_V41(LONG lUserID, LPNET_DVR_IPC_PROTO_LIST_V41 lpProtoList);
NET_DVR_API LONG __stdcall NET_DVR_SmartSearch(LONG lUserID,  LPNET_DVR_SMART_SEARCH_PARAM lpSmartSearchParam);
NET_DVR_API LONG __stdcall NET_DVR_SmartSearch_V40(LONG lUserID,  LPNET_DVR_SMART_SEARCH_PARAM_V40 lpSmartSearchParam);
NET_DVR_API LONG __stdcall NET_DVR_SearchNextInfo(LONG lSearchHandle, LPNET_DVR_SMART_SEARCH_RET lpSmartSearchRet);
NET_DVR_API BOOL __stdcall NET_DVR_StopSearch(LONG lSearchHandle);

// IP San Directory search
NET_DVR_API LONG __stdcall NET_DVR_FindIpSanDirectory(LONG lUserID, LPNET_DVR_IPSAN_SERACH_PARAM lpIpsanSearchParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextDirectory(LONG lFindHandle, LPNET_DVR_IPSAN_SERACH_RET lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindDirectoryClose(LONG lFindHandle);

NET_DVR_API LONG __stdcall NET_DVR_ZeroStartPlay(LONG lUserID, LPNET_DVR_CLIENTINFO lpClientInfo, REALDATACALLBACK fRealDataCallBack_V30 = NULL, void* pUser = NULL, BOOL bBlocked = TRUE);

NET_DVR_API BOOL __stdcall NET_DVR_ZeroStopPlay(LONG lPlayHandle);
NET_DVR_API BOOL __stdcall NET_DVR_ZeroMakeKeyFrame(LONG lUserID, LONG lZeroChan);
NET_DVR_API BOOL __stdcall NET_DVR_PlayBackControl_V40(LONG lPlayHandle,DWORD dwControlCode, LPVOID lpInBuffer = NULL, DWORD dwInLen = 0, LPVOID lpOutBuffer = NULL, DWORD *lpOutLen = NULL);
NET_DVR_API BOOL __stdcall NET_DVR_ZeroTurnOver(LONG lUserID, LONG lChannel, BOOL bNextPreview);

NET_DVR_API BOOL __stdcall NET_DVR_GetDiskList(LONG lUserID, LPNET_DVR_DISKABILITY_LIST lpDiskList);
NET_DVR_API LONG __stdcall NET_DVR_Backup(LONG lUserID, DWORD dwBackupType, LPVOID lpBackupBuff, DWORD dwBackupBuffSize);
NET_DVR_API LONG __stdcall NET_DVR_BackupByName(LONG lUserID, LPNET_DVR_BACKUP_NAME_PARAM lpBackupByName);
NET_DVR_API LONG __stdcall NET_DVR_BackupByTime(LONG lUserID, LPNET_DVR_BACKUP_TIME_PARAM lpBackupBytime);
NET_DVR_API BOOL __stdcall NET_DVR_GetBackupProgress(LONG lHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_StopBackup(LONG lHandle);

NET_DVR_API BOOL __stdcall NET_DVR_GetSadpInfoList(LONG lUserID, LPNET_DVR_SADPINFO_LIST lpSadpInfoList);
NET_DVR_API BOOL __stdcall NET_DVR_UpdateSadpInfo(LONG lUserID, LPNET_DVR_SADP_VERIFY lpSadpVerify, LPNET_DVR_SADPINFO lpSadpInfo);

NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSubDecSystemJoinInfo(LONG lUserID, LPNET_DVR_ALLDECSUBSYSTEMJOININFO lpInter);

NET_DVR_API BOOL __stdcall NET_DVR_SetCodeSplitterAssociate(LONG lUserID, DWORD dwDecoderChan, DWORD dwSlotNum, LPNET_DVR_CODESPLITTERASSOCIATE lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_GetCodeSplitterAssociate(LONG lUserID, DWORD dwDecoderChan, DWORD dwSlotNum, LPNET_DVR_CODESPLITTERASSOCIATE lpInter);

NET_DVR_API BOOL __stdcall NET_DVR_InquestGetCDRWScheme(LONG lUserID, LPNET_DVR_INQUEST_CDRW_CFG lpCDRWCfg);
NET_DVR_API BOOL __stdcall NET_DVR_InquestSetCDRWScheme(LONG lUserID, LPNET_DVR_INQUEST_CDRW_CFG lpCDRWCfg);
NET_DVR_API BOOL __stdcall NET_DVR_InquestDeleteFile(LONG lUserID, LPNET_DVR_INQUEST_FILES lpDeleteFile);
NET_DVR_API BOOL __stdcall NET_DVR_InquestCDWByFile(LONG lUserID, LPNET_DVR_INQUEST_FILES lpCdrwFile);
NET_DVR_API LONG __stdcall NET_DVR_InquestUploadFile(LONG lUserID, char *sFileName);
NET_DVR_API BOOL __stdcall NET_DVR_InquestUploadClose(LONG lUploadHandle);
NET_DVR_API LONG __stdcall NET_DVR_InquestGetUploadState(LONG lUploadHandle, LPDWORD pProgress);
NET_DVR_API BOOL __stdcall NET_DVR_InquestStartCDW( LONG lUserID, BOOL bPause);
NET_DVR_API BOOL __stdcall NET_DVR_InquestStopCDW(LONG lUserID, BOOL bCancelWrite);
NET_DVR_API BOOL __stdcall NET_DVR_InquestGetCDWState(LONG lUserID, LPNET_DVR_INQUEST_CDRW_STATUS pStatus);
NET_DVR_API BOOL __stdcall NET_DVR_InquestGetPIPStatus(LONG lUserID, LPNET_DVR_INQUEST_PIP_STATUS pStatus);
NET_DVR_API BOOL __stdcall NET_DVR_InquestSetPIPStatus(LONG lUserID, LPNET_DVR_INQUEST_PIP_STATUS pStatus);
NET_DVR_API BOOL __stdcall NET_DVR_InquestCheckSecretKey(LONG lUserID, BOOL *bSecretSet);
NET_DVR_API BOOL __stdcall NET_DVR_InquestSetSecretKey(LONG lUserID, LPNET_DVR_INQUEST_SECRET_INFO pSecretInfo);
NET_DVR_API BOOL __stdcall NET_DVR_InquestStreamEncrypt(LONG lUserID, LONG lChannel, BOOL bEncrypt);
NET_DVR_API BOOL __stdcall NET_DVR_InquestGetEncryptState(LONG  lUserID, LONG lChannel, BOOL *bEncrypt);
NET_DVR_API LONG __stdcall NET_DVR_InquestFindFile(LONG lUserID);
NET_DVR_API LONG __stdcall NET_DVR_InquestFindNextFile(LONG lFindHandle, LPNET_DVR_INQUEST_FILEINFO lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_InquestFindClose(LONG lFindHandle);

// 9000RH
NET_DVR_API LONG __stdcall NET_DVR_RaidFastConfig(LONG lUserID, char *sName);
NET_DVR_API BOOL __stdcall NET_DVR_FastConfigProcess(LONG lHandle, DWORD *pState);
NET_DVR_API BOOL __stdcall NET_DVR_CloseFastConfig(LONG lHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetArraySpaceAlloc(LONG lUserID, DWORD dwSlot, LPNET_DVR_ARRAY_SPACE_ALLOC_INFO lpOutBuf);
NET_DVR_API BOOL __stdcall NET_DVR_DelArray(LONG lUserID, DWORD dwID);
NET_DVR_API BOOL __stdcall NET_DVR_CreateArray(LONG lUserID, LPNET_DVR_OPERATE_ARRAY_PARAM lpArrayParam);
NET_DVR_API BOOL __stdcall NET_DVR_CalcArraySize(LONG lUserID, LPNET_DVR_OPERATE_ARRAY_PARAM lpArrayParam, UINT64* lpArraySize);
NET_DVR_API BOOL __stdcall NET_DVR_MigrateArray(LONG lUserID, LPNET_DVR_OPERATE_ARRAY_PARAM lpArrayParam);
NET_DVR_API BOOL __stdcall NET_DVR_RebuildArray(LONG lUserID, LPNET_DVR_OPERATE_ARRAY_PARAM lpArrayParam);
NET_DVR_API BOOL __stdcall NET_DVR_CreateVD(LONG lUserID, LPNET_DVR_OPERATE_VD_PARAM lpVDParam);
NET_DVR_API BOOL __stdcall NET_DVR_CreateVDEx(LONG lUserID, LPNET_DVR_OPERATE_VD_PARAM_EX lpVDParamEx);
NET_DVR_API BOOL __stdcall NET_DVR_DelVD(LONG lUserID, DWORD dwID);
NET_DVR_API BOOL __stdcall NET_DVR_RepairVD(LONG lUserID, DWORD dwID);
NET_DVR_API BOOL __stdcall NET_DVR_SetSpareDisk(LONG lUserID, LPNET_DVR_SPARE_DISK_PARAM lpSpareDisk);
NET_DVR_API BOOL __stdcall NET_DVR_GetPDList(LONG lUserID,  LPNET_DVR_PHY_DISK_LIST lpPDList);
NET_DVR_API BOOL __stdcall NET_DVR_GetArrayList(LONG lUserID, LPNET_DVR_ARRAY_LIST lpArrayList);
NET_DVR_API BOOL __stdcall NET_DVR_GetVDList(LONG lUserID, LPNET_DVR_VD_LIST lpVDList);
NET_DVR_API LONG __stdcall NET_DVR_ExpandDisk(LONG    lUserID,DWORD dwVDSLot);
NET_DVR_API BOOL __stdcall NET_DVR_GetExpandProgress(LONG lExpandHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_CloseExpandHandle(LONG lExpandHandle);
NET_DVR_API LONG __stdcall NET_DVR_AlgoDebugStart(LONG lUserID, LONG lCHannel, void(CALLBACK *fAlgoLibInfoCallBack)(LONG lHandle, LONG lChannel,char *pRecvDataBuffer, DWORD dwBufSize, void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_AlgoDebugSend(LONG lHandle, LONG lChannel, char *pSendBuf, DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_AlgoDebugStop(LONG lHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetLogPrint(BOOL bLogPrint);
NET_DVR_API BOOL __stdcall NET_DVR_SetLogPrintAction(DWORD nLogLevel, DWORD nToDevice, BOOL bEnable, int Reserve1, int Reserve2);

NET_DVR_API BOOL __stdcall NET_DVR_GetPositionRule(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_POSITION_RULE_CFG lpPositionRule);
NET_DVR_API BOOL __stdcall NET_DVR_GetPositionRule_V41(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_POSITION_RULE_CFG_V41 lpPositionRule);
NET_DVR_API BOOL __stdcall NET_DVR_SetPositionRule(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_POSITION_RULE_CFG lpPositionRule);
NET_DVR_API BOOL __stdcall NET_DVR_SetPositionRule_V41(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_POSITION_RULE_CFG_V41 lpPositionRule);
NET_DVR_API BOOL __stdcall NET_DVR_SetPositionLimitAngle(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_LIMIT_ANGLE lpLimitAngle);
NET_DVR_API BOOL __stdcall NET_DVR_GetPositionLimitAngle(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_LIMIT_ANGLE lpLimitAngle);
NET_DVR_API BOOL __stdcall NET_DVR_GetPtzPosition(LONG lUserID, LONG lChannel, LONG lPositionID, LPNET_DVR_PTZ_POSITION lpPtzPosition);
NET_DVR_API BOOL __stdcall NET_DVR_SetPtzPosition(LONG lUserID, LONG lChannel, LONG lPositionID, LPNET_DVR_PTZ_POSITION lpPtzPosition);
NET_DVR_API BOOL __stdcall NET_DVR_SetPatrolTrack(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_PATROL_TRACKCFG lpPatrolTrack);
NET_DVR_API BOOL __stdcall NET_DVR_GetPatrolTrack(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_PATROL_TRACKCFG lpPatrolTrack);
NET_DVR_API BOOL __stdcall NET_DVR_SetPatrolLimitAngle(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_LIMIT_ANGLE lpLimitAngle);
NET_DVR_API BOOL __stdcall NET_DVR_GetPatrolLimitAngle(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_LIMIT_ANGLE lpLimitAngle);
NET_DVR_API BOOL __stdcall NET_DVR_SetSceneMode(LONG  lUserID, LONG lChannel, DWORD dwSceneMode);
NET_DVR_API BOOL __stdcall NET_DVR_GetSceneMode(LONG lUserID, LONG lChannel, DWORD  *pSceneMode);
NET_DVR_API BOOL __stdcall NET_DVR_GetVCAVersion(LONG lUserID, LONG lChannel, LPNET_DVR_VCA_VERSION lpVersion);

NET_DVR_API BOOL __stdcall NET_DVR_MatrixPicAdjust(LONG lUserID, DWORD dwDispChan, DWORD dwPicAdjust, DWORD dwCmdParam);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmJoinedRecord(LONG lUserID, DWORD dwChan, DWORD dwAlarmSeq, DWORD dwRecordTime, DWORD dwRes);

NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSetupAlarmChan(LONG lUserID, NET_DVR_ALARMIN_SETUP *lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostCloseAlarmChan(LONG lUserID, NET_DVR_ALARMIN_SETUP *lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_BypassAlarmChan(LONG lUserID, NET_DVR_ALARMIN_SETUP *lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_UnBypassAlarmChan(LONG lUserID, NET_DVR_ALARMIN_SETUP *lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostAssistantControl(LONG lUserID, DWORD dwType, DWORD dwNumber, DWORD dwCmdParam);
NET_DVR_API BOOL __stdcall NET_DVR_SetAirCondition(LONG lUserID, LONG l485Index, NET_DVR_AIR_CONDITION_PARAM* lpAirConditionParam);
NET_DVR_API BOOL __stdcall NET_DVR_GetAirCondition(LONG lUserID, LONG l485Index, NET_DVR_AIR_CONDITION_PARAM* lpAirConditionParam);
NET_DVR_API BOOL __stdcall NET_DVR_GetDeviceTypeList(LONG lUserID, NET_DVR_DEVICE_TYPE_LIST *lpDeviceTypeList);
NET_DVR_API BOOL __stdcall NET_DVR_GetDeviceProtoList(LONG lUserID, LONG lDeviceType, NET_DVR_DEVICE_PROTO_LIST *lpDeviceProtoList);
NET_DVR_API BOOL __stdcall NET_DVR_GetBatteryVoltage(LONG lUserID, float *pVoltage);
NET_DVR_API BOOL __stdcall NET_DVR_SetAlarmDeviceUser(LONG lUserID, LONG lUserIndex, NET_DVR_ALARM_DEVICE_USER* lpDeviceUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetAlarmDeviceUser(LONG lUserID, LONG lUserIndex, NET_DVR_ALARM_DEVICE_USER* lpDeviceUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetKeyboardUser(LONG lUserID, LONG lUserIndex, NET_DVR_KEYBOARD_USER* lpKeyboardUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetKeyboardUser(LONG lUserID, LONG lUserIndex, NET_DVR_KEYBOARD_USER* lpKeyboardUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetOperateUser(LONG lUserID, LONG lUserIndex, NET_DVR_OPERATE_USER* lpOperateUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetOperateUser(LONG lUserID, LONG lUserIndex, NET_DVR_OPERATE_USER* lpOperateUser);
NET_DVR_API BOOL __stdcall NET_DVR_ControlGateway(LONG lUserID, LONG lGatewayIndex, DWORD dwStaic);
NET_DVR_API BOOL __stdcall NET_DVR_SetAlarmHostOut(LONG lUserID, LONG lAlarmOutPort, LONG lAlarmOutStatic);
typedef void(CALLBACK *fAlarmHostSerialDataCallBack)
        (LONG lSerialHandle, LONG lPort, LONG lDateType, char *pRecvDataBuffer, DWORD  dwBufSize,void *pUser);
NET_DVR_API LONG __stdcall NET_DVR_AlarmHostSerialStart(LONG lUserID, LONG lSerialType, fAlarmHostSerialDataCallBack cbSerialDataCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSerialSend(LONG lSerialHandle,LONG lPort,char *pSendBuf,DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSerialStop(LONG  lSerialHandle);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAlarmOffMonitor(LONG lUserID, DWORD dwMonID, DWORD dwCamID);
NET_DVR_API BOOL __stdcall NET_DVR_GetGlobalNum(LONG lUserID, DWORD *dwCamNum, DWORD *dwMonNum);

typedef void (CALLBACK *FLOWTESTCALLBACK)(LONG lFlowHandle, LPNET_DVR_FLOW_INFO pFlowInfo, void *pUser);
NET_DVR_API LONG __stdcall NET_DVR_StartNetworkFlowTest(LONG lUserID, NET_DVR_FLOW_TEST_PARAM* pFlowTest,  FLOWTESTCALLBACK fFlowTestCallback, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_StopNetworkFlowTest(LONG lHandle);
NET_DVR_API LONG __stdcall NET_DVR_FindRecordLabel(LONG lUserID, LPNET_DVR_FIND_LABEL lpFindLabel);
NET_DVR_API LONG __stdcall NET_DVR_FindNextLabel(LONG lFindHandle, LPNET_DVR_FINDLABEL_DATA lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_StopFindLabel(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_InsertRecordLabel(LONG lPlayHandle, NET_DVR_RECORD_LABEL* lpRecordLabel, NET_DVR_LABEL_IDENTIFY *lpLableIdentify);
NET_DVR_API BOOL __stdcall NET_DVR_DelRecordLabel(LONG lUserID, NET_DVR_DEL_LABEL_PARAM* lpDelLabelParam);
NET_DVR_API BOOL __stdcall NET_DVR_ModifyRecordLabel(LONG lUserID, NET_DVR_MOD_LABEL_PARAM * lpModLabelParam);
NET_DVR_API BOOL __stdcall NET_DVR_CapturePlaybackPictureBlock(LONG lPlayHandle, char *sPicFileName, DWORD dwTimeOut);
NET_DVR_API BOOL __stdcall NET_DVR_CapturePlaybackPictureBlock_New(LONG lPlayHandle, char *pPicBuf, DWORD dwPicSize, DWORD *lpSizeReturned);
NET_DVR_API LONG __stdcall NET_DVR_FindPicture(LONG lUserID, NET_DVR_FIND_PICTURE_PARAM* pFindParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextPicture(LONG lFindHandle,LPNET_DVR_FIND_PICTURE lpFindData);
NET_DVR_API LONG __stdcall NET_DVR_FindNextPicture_V40(LONG lFindHandle,LPNET_DVR_FIND_PICTURE_V40 lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_CloseFindPicture(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetPicture(LONG lUserID,char *sDVRFileName,const char *sSavedFileName);
NET_DVR_API BOOL __stdcall NET_DVR_GetPicture_V30(LONG lUserID, char *sDVRFileName, char *sSavedFileBuf, DWORD dwBufLen, DWORD *lpdwRetLen);
NET_DVR_API LONG __stdcall NET_DVR_BackupPicture(LONG lUserID, NET_DVR_BACKUP_PICTURE_PARAM *lpBackupPicture);
NET_DVR_API LONG __stdcall NET_DVR_GetUpgradeStep(LONG lUpgradeHandle, LONG *pSubProgress);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetEncodeJoint(LONG lUserID, LONG lChannel, LPNET_DVR_ENCODE_JOINT_PARAM lpEncodeJoint);
NET_DVR_API BOOL  __stdcall NET_DVR_GetLocalIP(char strIP[16][16], DWORD *pValidNum, BOOL *pEnableBind);
NET_DVR_API BOOL  __stdcall NET_DVR_SetValidIP(DWORD dwIPIndex, BOOL bEnableBind);
NET_DVR_API BOOL __stdcall NET_DVR_GetVcaDevWorkState(LONG lUserID, LPNET_DVR_VCA_DEV_WORKSTATUS lpWorkState);
NET_DVR_API BOOL  __stdcall NET_DVR_SetRecvTimeOut(DWORD nRecvTimeOut = 5000);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDisplayCfg_V40(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_VGA_DISP_CHAN_CFG_V40 lpDisplayCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetDisplayCfg_V40(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_VGA_DISP_CHAN_CFG_V40 lpDisplayCfg);
NET_DVR_API BOOL __stdcall NET_DVR_ShutterCompensation(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_CorrectDeadPixel(LONG lUserID, LONG lChannel, LPNET_DVR_CORRECT_DEADPIXEL_PARAM lpInParam);
NET_DVR_API BOOL __stdcall NET_DVR_CustomConfig(LONG lUserID, LONG lChannel, LPVOID lpInBuffer, DWORD dwInBufferSize, LPVOID lpOutBuffer, DWORD dwOutBufferSize, LPDWORD lpBytesReturned);
NET_DVR_API BOOL __stdcall NET_DVR_GetHistoricDataInfo(LONG lUserID, LONG lChannel, LPNET_DVR_HISTORICDATACFG lpHisData);
NET_DVR_API BOOL __stdcall NET_DVR_GetHistoricData(LONG lUserID, LONG lChannel, LPNET_DVR_PLATE_RESULT lpOuter);
NET_DVR_API BOOL __stdcall NET_DVR_ClearHistoricData(LONG lUserID, LONG lChannel);
NET_DVR_API LONG  __stdcall NET_DVR_InquestUploadFile_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom,  char *sFileName);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestDeleteFile_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, LPNET_DVR_INQUEST_FILES lpDeleteFile);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestGetPIPStatus_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, LPNET_DVR_INQUEST_PIP_STATUS lpStatus);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestSetPIPStatus_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, LPNET_DVR_INQUEST_PIP_STATUS lpStatus);
NET_DVR_API BOOL __stdcall NET_DVR_InquestGetPIPStatus_V40(LONG lUserID, NET_DVR_INQUEST_ROOM const *lpInquestRoom, LPNET_DVR_INQUEST_PIP_STATUS_V40 lpStatus);
NET_DVR_API BOOL __stdcall NET_DVR_InquestSetPIPStatus_V40(LONG lUserID, NET_DVR_INQUEST_ROOM const *lpInquestRoom, LPNET_DVR_INQUEST_PIP_STATUS_V40 lpStatus);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestGetSystemInfo(LONG lUserID, LPNET_DVR_INQUEST_SYSTEM_INFO lpSystemInfo);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestSetSystemInfo(LONG lUserID, LPNET_DVR_INQUEST_SYSTEM_INFO lpSystemInfo);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestSendMessage(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, LPNET_DVR_INQUEST_MESSAGE lpInquestMessage);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestStartCDW_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, BOOL bNotBurn);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestStopCDW_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, BOOL bCancelWrite);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestGetCDWState_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, LPNET_DVR_INQUEST_CDRW_STATUS pStatus);
NET_DVR_API LONG  __stdcall NET_DVR_InquestResumeEvent(LONG lUserID, LPNET_DVR_INQUEST_RESUME_EVENT lpResumeEvent);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestGetResumeProgress(LONG lHandle, DWORD* pState);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestStopResume(LONG lHandle);
NET_DVR_API LONG  __stdcall NET_DVR_InquestFindFile_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM pInquestRoom);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestGetDeviceVersion(LONG lUserID, LPNET_DVR_INQUEST_DEVICE_VERSION lpVersionInfo);
NET_DVR_API BOOL  __stdcall NET_DVR_SetSDKSecretKey(LONG lUserID, char *sSecretKey);
NET_DVR_API BOOL __stdcall NET_DVR_LockFileByTime(LONG lUserID, LPNET_DVR_TIME_LOCK lpLockPara, LPNET_DVR_LOCK_RETURN lpLockReturn);
NET_DVR_API BOOL __stdcall NET_DVR_UnlockFileByTime(LONG lUserID, LPNET_DVR_TIME_LOCK lpLockPara, LPNET_DVR_LOCK_RETURN lpLockReturn);
NET_DVR_API BOOL __stdcall NET_DVR_ScreenZoomIn(LONG lUserID, LPNET_DVR_SCREENZOOM pStruScreen);

NET_DVR_API BOOL __stdcall NET_DVR_MatrixAddCamera(LONG lUserID, DWORD dwCameraNum, BYTE *pBuffer, DWORD dwBufLength);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixDelCamera(LONG lUserID, DWORD dwCameraId);

NET_DVR_API BOOL __stdcall NET_DVR_DetectImage_V50(LONG lUserID, LPNET_VCA_FD_PROCIMG_CFG lpFDProcImg,LPNET_VCA_FD_PROCIMG_RESULT_V50 lpOutBuf);

NET_DVR_API BOOL __stdcall NET_DVR_MatrixAddMonitor(LONG lUserID, DWORD dwMonitorNum, BYTE *pBuffer, DWORD dwBufLength);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixDelMonitor(LONG lUserID, DWORD dwMonitorId);
NET_DVR_API BOOL __stdcall NET_DVR_DelMatrix(LONG lUserID, DWORD dwMatrixId);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixDelUser(LONG lUserID, DWORD dwUserNum);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixDelResourceInfo(LONG lUserID, DWORD dwResourceNum);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixDelUserGroup (LONG lUserID, DWORD dwUserGroupNum);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixTrunkCtrl(LONG lUserID, DWORD dwTrunkNum, BYTE byCtrlMode);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixTrunkStatusQuery(LONG lUserID, DWORD dwTrunkNum, BYTE *byTrunkStatus);

NET_DVR_API BOOL __stdcall NET_DVR_FindBackgroundPic(LONG lUserID, DWORD dwPicID, BYTE *pPicBuffer, DWORD *lpPicLen);
NET_DVR_API BOOL __stdcall NET_DVR_DetectImage(LONG lUserID, LPNET_VCA_FD_PROCIMG_CFG lpFDProcImg,LPNET_VCA_FD_PROCIMG_RESULT lpOutBuf);
NET_DVR_API BOOL __stdcall NET_DVR_GetPictureModel(LONG lUserID, LPNET_VCA_REGISTER_PIC lpInBuf, LPNET_VCA_PICMODEL_RESULT lpOutBuf);
NET_DVR_API BOOL __stdcall NET_DVR_AddBlackList(LONG lUserID,LONG lChannel,LPNET_VCA_BLACKLIST_PARA lpInter);
NET_DVR_API LONG __stdcall NET_DVR_FindBlackList(LONG lUserID, LPNET_VCA_BLACKLIST_COND lpBlackListCond);
NET_DVR_API LONG __stdcall NET_DVR_FindNextBlackList(LONG lFindHandle,LPNET_VCA_BLACKLIST_INFO lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindBlackListClose(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetBlackListPicture(LONG lUserID, DWORD dwRegisterID, LPNET_VCA_BLACKLIST_PIC lpOutBuffer);
NET_DVR_API BOOL __stdcall NET_DVR_UpdateBlackList(LONG lUserID,LONG lChannel, LPNET_VCA_BLACKLIST_PARA lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_DelBlackList(LONG lUserID,LONG lChannel, DWORD dwRegisterID);
NET_DVR_API LONG __stdcall NET_DVR_FindSnapPicture(LONG lUserID, LPNET_VCA_FIND_PICTURECOND lpFindParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextSnapPic(LONG lFindHandle,LPNET_VCA_SUB_SNAPPIC_DATA lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindSnapPicClose(LONG lFindHandle);
NET_DVR_API LONG __stdcall NET_DVR_AdvanceFindSnapPicture(LONG lUserID, LPNET_VCA_FIND_PICTURECOND_ADVANCE lpFindParam);
NET_DVR_API LONG __stdcall NET_DVR_FindFaceMatchAlarm(LONG lUserID, LPNET_VCA_FIND_PICTURECOND lpFindParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextFaceMatchAlarm(LONG lFindHandle, LPNET_VCA_FACESNAP_MATCH_ALARM_LOG lpFaceMatchAlarmLog);
NET_DVR_API BOOL __stdcall NET_DVR_FindFaceMatchAlarmClose(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetFaceMatchPic(LONG lUserID, LPNET_VCA_FACEMATCH_PICCOND lpMatchCond, LPNET_VCA_FACEMATCH_PICTURE lpMatchPic);
NET_DVR_API BOOL __stdcall NET_DVR_FastAddBlackList(LONG lUserID,LONG lChannel,LPNET_VCA_BLACKLIST_FASTREGISTER_PARA lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetRemotePlay_V41(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_V41 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDisplayCfg_V41(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_MATRIX_VOUTCFG lpVoutCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetDisplayCfg_V41(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_MATRIX_VOUTCFG lpDisplayCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDeviceStatus_V41(LONG lUserID, LPNET_DVR_DECODER_WORK_STATUS_V41 lpDecoderCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSceneCfg(LONG lUserID, DWORD dwSceneNum, LPNET_DVR_MATRIX_SCENECFG lpSceneCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetSceneCfg(LONG lUserID, DWORD dwSceneNum, LPNET_DVR_MATRIX_SCENECFG lpSceneCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSceneControl(LONG lUserID, DWORD dwSceneNum, DWORD dwCmd, DWORD dwCmdParam);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetCurrentSceneMode(LONG lUserID, DWORD *dwSceneNum);
NET_DVR_API BOOL __stdcall NET_DVR_GetAllValidWinInfo(LONG lUserID, LPNET_DVR_WINLIST lpWinListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_ScreenWinCtrl(LONG lUserID, DWORD dwWinIndex, DWORD dwCommand, LPNET_DVR_SCREEN_WINCFG lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_GetScreenInputStatus(LONG lUserID, LPNET_DVR_SCREENINPUTSTATUS lpStatus);
NET_DVR_API LONG __stdcall NET_DVR_PicUpload(LONG lUserID, char const *sFileName, LPNET_DVR_PICTURECFG lpPictureCfg);
NET_DVR_API LONG __stdcall NET_DVR_GetPicUploadProgress(LONG lUploadHandle);
NET_DVR_API BOOL __stdcall  NET_DVR_CloseUploadHandle(LONG lUploadHandle);
NET_DVR_API BOOL __stdcall NET_DVR_PicControl(LONG lUserID, BYTE byUseType, BYTE byPicIndex, BYTE byCtrlCmd);
NET_DVR_API LONG __stdcall NET_DVR_GetPicUploadState(LONG lUploadHandle);
NET_DVR_API BOOL __stdcall NET_DVR_ScreenCtrl(LONG lUserID, DWORD dwDeviceNum, LPNET_DVR_SCREEN_CONTROL lpStruScreenCtrl);
typedef void (CALLBACK *SCREENPICDATACB)(LONG nScreenPicHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void *pUser);
NET_DVR_API LONG __stdcall NET_DVR_StartScreenPic(LONG nUserID, DWORD nInputNum, SCREENPICDATACB PicDataCallback, void *pUserData);
NET_DVR_API BOOL __stdcall NET_DVR_StopScreenPic(LONG nScreenPicHandle);
NET_DVR_API BOOL __stdcall NET_DVR_FocusOnePush(LONG lUserID, LONG lChannel);
NET_DVR_API BOOL __stdcall NET_DVR_ResetLens(LONG lUserID, LONG lChannel);

typedef void(CALLBACK *fRemoteConfigCallback)(DWORD dwType, void* lpBuffer, DWORD dwBufLen, void* pUserData);
NET_DVR_API LONG __stdcall NET_DVR_StartRemoteConfig(LONG lUserID, DWORD dwCommand, LPVOID lpInBuffer, DWORD dwInBufferLen, fRemoteConfigCallback cbStateCallback, LPVOID pUserData);
NET_DVR_API BOOL __stdcall NET_DVR_StopRemoteConfig(LONG lHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetNextRemoteConfig(LONG lHandle, void* lpOutBuff, DWORD dwOutBuffSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetRemoteConfigState(LONG lHandle, void *pState);
NET_DVR_API BOOL __stdcall NET_DVR_SendRemoteConfig(LONG lHandle, DWORD dwDataType, char *pSendBuf, DWORD dwBufSize);

typedef void(CALLBACK *fLongCfgStateCallback)(LONG lHandle,  DWORD dwState, LPVOID pUserData);
NET_DVR_API BOOL __stdcall NET_DVR_CloseLongCfgHandle(LONG lHandle);
NET_DVR_API LONG __stdcall NET_DVR_RaidPullDiskStart(LONG lUserID, LONG lRaidID, fLongCfgStateCallback cbStateCallback, LPVOID pUserData);
NET_DVR_API LONG __stdcall NET_DVR_ScanRaidStart(LONG lUserID, fLongCfgStateCallback cbStateCallback, LPVOID pUserData);
NET_DVR_API LONG __stdcall NET_DVR_SetAccessCameraInfo(LONG lUserID, DWORD dwChannel, LPNET_DVR_ACCESS_CAMERA_INFO lpCameraInfo, fLongCfgStateCallback cbStateCallback, LPVOID pUserData);

NET_DVR_API BOOL __stdcall NET_DVR_InquiryRecordTimeSpan(LONG lUserID, DWORD dwChannel,  NET_DVR_RECORD_TIME_SPAN_INQUIRY const *lpInquiry, LPNET_DVR_RECORD_TIME_SPAN lpResult);
NET_DVR_API BOOL __stdcall NET_DVR_UpdateRecordIndex(LONG lUserID, DWORD dwChannel);
NET_DVR_API BOOL __stdcall NET_DVR_GetUpnpNatState(LONG lUserID, LPNET_DVR_UPNP_NAT_STATE lpState);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetLoopDecChanInfo_EX(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_EX lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecChanInfo_EX(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_EX lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStartDynamic_EX(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_PU_STREAM_CFG_EX lpDynamicInfo);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSubSystemSetupAlarmChan(LONG lUserID, DWORD dwSubSystemNum);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSubSystemCloseAlarmChan(LONG lUserID, DWORD dwSubSystemNum);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostClearAlarm(LONG lUserID, DWORD dwSubSystemNum);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostArrayBypass(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostArrayBypassResume (LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSetReportMode(LONG lUserID, LONG lCenterNum, LPVOID lpInputBuf, DWORD dwInputBufLen);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostGetReportMode(LONG lUserID, LPVOID lpOutputBuf, DWORD dwOutputBufLen);
NET_DVR_API LONG __stdcall NET_DVR_StartUploadAudio(LONG lUserID, DWORD dwAudioNum, DWORD dwAudioType, char const *sAudioFileName);
NET_DVR_API LONG __stdcall NET_DVR_StartDownloadAudio(LONG lUserID, DWORD dwAudioNum, char const *sAudioFileName);
NET_DVR_API BOOL __stdcall NET_DVR_StopAudioOperate(LONG lAudioHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetAudioProgress(LONG lAudioHandle);
NET_DVR_API BOOL __stdcall NET_DVR_AudioCtrl(LONG lUserID, DWORD dwAudioNum, DWORD dwCtrlParam);
NET_DVR_API BOOL __stdcall NET_DVR_GetDeviceConfig(LONG lUserID, DWORD dwCommand, DWORD dwCount, LPVOID lpInBuffer, DWORD dwInBufferSize, LPVOID lpStatusList, LPVOID lpOutBuffer, DWORD dwOutBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_SetDeviceConfig(LONG lUserID, DWORD dwCommand, DWORD dwCount, LPVOID lpInBuffer, DWORD dwInBufferSize, LPVOID lpStatusList, LPVOID lpInParamBuffer, DWORD dwInParamBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_LockStreamFileByTime(LONG lUserID, LPNET_DVR_STREAM_TIME_LOCK lpLockPara, LPNET_DVR_LOCK_RETURN lpLockReturn);
NET_DVR_API BOOL __stdcall NET_DVR_UnlockStreamFileByTime(LONG lUserID, LPNET_DVR_STREAM_TIME_LOCK lpLockPara, LPNET_DVR_LOCK_RETURN lpLockReturn);
NET_DVR_API BOOL __stdcall NET_DVR_StartManualRecord(LONG lUserID, LPNET_DVR_MANUAL_RECORD_PARA lpManualRecPara);
NET_DVR_API BOOL __stdcall NET_DVR_StopManualRecord(LONG lUserID, LPNET_DVR_STREAM_INFO pIDInfo);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackReverseByName(LONG lUserID, char *sPlayBackFileName, HWND hWnd);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackByTime_V40(LONG lUserID, NET_DVR_VOD_PARA const* pVodPara);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackReverseByTime_V40(LONG lUserID, HWND hWnd, LPNET_DVR_PLAYCOND pPlayCond);
NET_DVR_API LONG __stdcall NET_DVR_GetFileByTime_V40(LONG lUserID, char *sSavedFileName, LPNET_DVR_PLAYCOND  pDownloadCond);
NET_DVR_API LONG __stdcall NET_DVR_FindFile_V40(LONG lUserID, LPNET_DVR_FILECOND_V40 pFindCond);
NET_DVR_API LONG __stdcall NET_DVR_SetupAlarmChan_V41(LONG lUserID, LPNET_DVR_SETUPALARM_PARAM lpSetupParam);
NET_DVR_API BOOL __stdcall NET_DVR_AddDataBase(LONG lUserID, LPNET_VCA_DATABASE_PARAM lpInBuf);
NET_DVR_API LONG __stdcall NET_DVR_FindDataBase(LONG lUserID, LPNET_VCA_FIND_DATABASE_COND lpInBuf);
NET_DVR_API LONG __stdcall NET_DVR_FindNextDataBase(LONG lFindHandle, LPNET_VCA_DATABASE_PARAM lpOutBuf);
NET_DVR_API BOOL __stdcall NET_DVR_FindDataBaseClose(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_UpdateDataBase(LONG lUserID, LPNET_VCA_DATABASE_PARAM lpInBuf);
NET_DVR_API BOOL __stdcall NET_DVR_DeleteDataBase(LONG lUserID, LPNET_VCA_DELETE_DATABASE_COND lpCond);
typedef void(CALLBACK *fSearchDBCallBack)(LONG lHandle, DWORD dwType, DWORD dwResultNum, BYTE* pBuffer, DWORD dwBufSize,void *pUser);
NET_DVR_API LONG __stdcall NET_DVR_InquireSnapDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_INQUIRE_SNAPDB_COND lpInBuf, fSearchDBCallBack cbSearchDBCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetInquireSnapDBProgress(LONG lInquireHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_DeleteSnapDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_DELETE_SNAPRECORD_COND lpInBuf);
NET_DVR_API LONG __stdcall NET_DVR_SearchSnapDB(LONG lUserID, LPNET_VCA_SEARCH_SNAPDB_COND lpInBuf, fSearchDBCallBack cbSearchDBCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetSearchSnapDBProgress(LONG lSearchHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_AddFaceDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_DATARECORD_INFO lpInBuf);
NET_DVR_API BOOL __stdcall NET_DVR_FastAddFaceDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_FAST_DATARECORD_INFO lpInBuf);
NET_DVR_API LONG __stdcall NET_DVR_InquireFaceDBRecord(LONG lUserID, LPNET_VCA_DATARECORD_COND lpInBuf,fSearchDBCallBack cbInquireDBCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetInquireFaceDBProgress(LONG lInquireHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_UpdateFaceDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_DATARECORD_INFO lpInBuf);
NET_DVR_API BOOL __stdcall NET_DVR_DeleteFaceDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_DELETE_RECORD_COND lpInBuf);
typedef void(CALLBACK *fSearchDBCallBack)(LONG lSearchHandle, DWORD dwType, DWORD dwResultNum, BYTE* pBuffer, DWORD dwBufSize,void *pUser);
NET_DVR_API LONG __stdcall NET_DVR_SearchFaceDB(LONG lUserID, LPNET_VCA_SEARCH_FACEDB_COND lpInBuf,fSearchDBCallBack cbSearchDBCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetSearchFaceDBProgress(LONG lSearchHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_StopSearchDB(LONG lHandle);
NET_DVR_API BOOL __stdcall NET_DVR_FindMatchPicture(LONG lUserID, LPNET_VCA_FIND_MATCHPIC_COND lpFindCond, LPNET_VCA_FIND_MATCHPIC_RESULT lpFindResult);
NET_DVR_API BOOL __stdcall NET_DVR_RemoteControl(LONG lUserID, DWORD dwCommand, LPVOID lpInBuffer, DWORD dwInBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_CommandDevice(LONG lUserID, DWORD dwOutCommand, LPVOID lpInBuffer, DWORD dwInBufferSize);

NET_DVR_API BOOL __stdcall NET_DVR_PicViewRequest(LONG lUserID, NET_DVR_PIC_VIEW_PARAM *lpPicViewParam);
typedef LONG (CALLBACK *PicViewCallBack)(LPNET_DVR_PICVIEW_CALLBACKPARAM pStruPicViewParam, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPicViewResponseCallBack(PicViewCallBack fPicViewResponseCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPicViewDataCallBack(LONG lPicViewHandle, SCREENPICDATACB fPicDataCallback, void *pUserData);
NET_DVR_API BOOL __stdcall NET_DVR_GetDevList(LONG lUserID, LPNET_DVR_DEVLIST lpDevListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_GetScreenList(LONG lUserID, LPNET_DVR_SCREENLIST lpScreenListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_SetScreenRelation(LONG lUserID, NET_DVR_DISP_SCREEN const* lpScreenInfo);
NET_DVR_API BOOL __stdcall NET_DVR_TextShowCtrl(LONG lUserID, DWORD dwDeviceIndex, LPNET_DVR_TEXTSHOW lpText);
NET_DVR_API BOOL __stdcall NET_DVR_StopUpgrade(LONG lUserID, LPNET_DVR_OPERATE_DEVICE lpStruOperate, LONG lUpgradeHandle);
NET_DVR_API BOOL __stdcall NET_DVR_AddNetSignal(LONG lUserID, LPNET_DVR_NETSIGNAL_INFO lpStruSignal, void* lpOutBuf , DWORD dwBufLen);
NET_DVR_API LONG __stdcall NET_DVR_StartPicPreview(LONG lUserID, NET_DVR_START_PIC_VIEW_INFO const* lpStruStartPicView, SCREENPICDATACB PicDataCallback, void *pUserData);
NET_DVR_API BOOL __stdcall NET_DVR_GetDeviceStatus(LONG iUserID, DWORD dwCommand, DWORD dwCount, LPVOID lpInBuffer, DWORD dwInBufferSize, LPVOID lpStatusList, LPVOID lpOutBuffer, DWORD dwOutBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetPlanList(LONG lUserID, DWORD dwDevNum, LPNET_DVR_PLAN_LIST lpPlanList);
NET_DVR_API BOOL __stdcall NET_DVR_GetInputSignalList(LONG lUserID, DWORD dwDevNum, LPNET_DVR_INPUT_SIGNAL_LIST lpInputSignalList);
NET_DVR_API BOOL __stdcall NET_DVR_GetInputSignalList_V40(LONG lUserID, DWORD dwDevNum, LPNET_DVR_INPUT_SIGNAL_LIST lpInputSignalList);

NET_DVR_API LONG __stdcall NET_DVR_UploadFile(LONG lUserID, DWORD dwUploadType, LPVOID lpInBuffer, DWORD dwInBufferSize, char* sFileName);
NET_DVR_API LONG __stdcall NET_DVR_UploadFile_V40(LONG lUserID, DWORD dwUploadType, LPVOID lpInBuffer, DWORD dwInBufferSize, char const * sFileName, LPVOID lpOutBuffer, DWORD dwOutBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetUploadResult(LONG lUploadHandle, LPVOID lpOutBuffer, DWORD dwOutBufferSize);
NET_DVR_API LONG __stdcall NET_DVR_GetUploadState(LONG lUploadHandle, LPDWORD pProgress);
NET_DVR_API BOOL __stdcall NET_DVR_UploadClose(LONG lUploadHandle);

NET_DVR_API LONG __stdcall NET_DVR_StartUploadFile(LONG lUserID, LPNET_DVR_UPLOAD_PARAM  lpStruUploadParam);
NET_DVR_API LONG __stdcall NET_DVR_GetUploadFileProgress(LONG lFileHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetUploadFileState(LONG lFileHandle);
NET_DVR_API BOOL __stdcall NET_DVR_StopUploadFile (LONG lFileHandle);
NET_DVR_API LONG __stdcall NET_DVR_StartDownloadFile(LONG lUserID, LPNET_DVR_DOWNLOAD_PARAM lpStruDownloadParam);
NET_DVR_API LONG __stdcall NET_DVR_GetDownloadFileProgress(LONG lFileHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetDownloadFileState(LONG lFileHandle);
NET_DVR_API BOOL __stdcall NET_DVR_StopDownloadFile (LONG lFileHandle);
NET_DVR_API BOOL __stdcall NET_DVR_DownloadControl(LONG lDownloadHandle, NET_SDK_DOWNLOAD_CONTROL_TYPE_ENUM enumDownloadType, void* lpInBuffer, DWORD dwInBufferLen, void* lpOutBuffer, DWORD dwOutBufferLen);
NET_DVR_API LONG __stdcall NET_DVR_UploadSend(LONG lUploadHandle, const NET_DVR_SEND_PARAM_IN *pstruSendParamIN, void* lpOutBuffer);


NET_DVR_API BOOL __stdcall NET_DVR_GetMobileDevStatus(LONG lUserID, DWORD dwStatusType, LPNET_DVR_MB_MOBILEDEV_STATUS lpstruMobileDevStatus);
NET_DVR_API BOOL __stdcall NET_DVR_SetVoiceDataCallBack(LONG lVoiceComHandle, BOOL bNeedCBNoEncData, void(CALLBACK *fVoiceDataCallBack)(LONG lVoiceComHandle, char *pRecvDataBuffer, DWORD dwBufSize, BYTE byAudioFlag, void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetTransparentParam(LONG lUserID, char *sInBuffer, DWORD dwInSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetTransparentParam(LONG lUserID, char *sInBuffer, DWORD dwInSize, char *sOutBuffer, DWORD dwOutSize);

NET_DVR_API LONG __stdcall NET_DVR_OpticalUpgrade(LONG lUserID, char const *sFileName, LPNET_DVR_OPTICAL_INFO lpOpticalInfo);
NET_DVR_API BOOL __stdcall NET_DVR_SetSDKLocalConfig(LPNET_DVR_SDKLOCAL_CFG lpSdkLocalCfg);
NET_DVR_API BOOL __stdcall NET_DVR_GetSDKLocalConfig(LPNET_DVR_SDKLOCAL_CFG lpSdkLocalCfg);

NET_DVR_API BOOL __stdcall NET_DVR_SetSDKLocalCfg(NET_SDK_LOCAL_CFG_TYPE enumType, const void *lpInBuff);
NET_DVR_API BOOL __stdcall NET_DVR_GetSDKLocalCfg(NET_SDK_LOCAL_CFG_TYPE enumType, void* lpOutBuff);

typedef void(CALLBACK *fGPSDataCallback)(LONG nHandle, DWORD dwState, void* lpBuffer, DWORD dwBufLen, void* pUserData);
NET_DVR_API LONG __stdcall NET_DVR_GetVehicleGpsInfo(LONG nUserID, LPNET_DVR_GET_GPS_DATA_PARAM lpGPSDataParam, fGPSDataCallback cbGPSDataCallback, void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_ClosePreview(LONG lUserID, DWORD nSessionID);
NET_DVR_API BOOL __stdcall NET_DVR_ClosePlayBack(LONG lUserID, DWORD nSessionID);

NET_DVR_API LONG __stdcall NET_DVR_StartDownload(LONG lUserID, DWORD dwDownloadType, LPVOID lpInBuffer, DWORD dwInBufferSize, const char *sFileName);
NET_DVR_API LONG __stdcall NET_DVR_GetDownloadState(LONG lDownloadHandle, LPDWORD pProgress);
NET_DVR_API int  __stdcall NET_DVR_GetDownloadStateInfo(LONG lDownloadHandle, void* pStatusInfo);
NET_DVR_API BOOL __stdcall NET_DVR_StopDownload(LONG lHandle);

NET_DVR_API BOOL __stdcall NET_DVR_MatrixStartDynamic_V41(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_PU_STREAM_CFG_V41 lpDynamicInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecChanInfo_V41(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_V41 lpOuter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetLoopDecChanInfo_V41(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_V41 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanInfo_V41(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_CHAN_INFO_V41 lpOuter);

NET_DVR_API LONG __stdcall NET_DVR_StartT1Test(LONG lUserID, LPNET_DVR_ALARMHOST_DOWNLOAD_PARAM lpStruDownloadParam);
NET_DVR_API BOOL __stdcall NET_DVR_StopTT1Test(BOOL lHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetT1TestStatus(LONG lHandle, LONG *pStatus);
NET_DVR_API BOOL __stdcall NET_DVR_SendT1TestData(LONG lHandle, DWORD dwDataType, char *pSendBuf, DWORD dwSendBufLen);

NET_DVR_API LONG __stdcall NET_DVR_StartPassiveTransCode(LONG lUserID, NET_DVR_STREAM_INFO const *pStreamInfo, NET_DVR_COMPRESSIONCFG_V30 const *pDstTransInfo, NET_DVR_PASSIVETRANSINFO const *pPassiveTransInfo, void(CALLBACK *fTransCodeDataCallBack) (LONG lPassiveHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void* pUser) = NULL, void* pUser = NULL);
NET_DVR_API BOOL __stdcall NET_DVR_TransCodeInputData(LONG lPassiveHandle, BYTE *pBuffer, DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_StopPassiveTransCode(LONG lPassiveHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetPassiveTransChanNum(LONG lPassiveHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetDeviceConfigEx(LONG iUserID, DWORD dwCommand, DWORD dwCount, NET_DVR_IN_PARAM *lpInParam, NET_DVR_OUT_PARAM *lpOutParam);

NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSubSystemInfo_V40(LONG lUserID, LPNET_DVR_ALLSUBSYSTEMINFO_V40 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetSubSystemInfo_V40(LONG lUserID, LPNET_DVR_ALLSUBSYSTEMINFO_V40 lpInter);

NET_DVR_API BOOL __stdcall NET_DVR_GetSTDConfig(LONG lUserID, DWORD dwCommand, LPNET_DVR_STD_CONFIG lpConfigParam);
NET_DVR_API BOOL __stdcall NET_DVR_SetSTDConfig(LONG lUserID, DWORD dwCommand, LPNET_DVR_STD_CONFIG lpConfigParam);
NET_DVR_API BOOL __stdcall NET_DVR_GetSTDAbility(LONG lUserID, DWORD dwAbilityType, LPNET_DVR_STD_ABILITY  lpAbilityParam);
NET_DVR_API BOOL __stdcall NET_DVR_STDControl(LONG lUserID, DWORD dwCommand, LPNET_DVR_STD_CONTROL lpControlParam);
NET_DVR_API BOOL __stdcall NET_DVR_STDXMLConfig(LONG lUserID, NET_DVR_XML_CONFIG_INPUT* lpInputParam, NET_DVR_XML_CONFIG_OUTPUT* lpOutputParam);
NET_DVR_API LONG __stdcall NET_DVR_Upgrade_V40(DWORD lUserID, DWORD dwUpgradeType, char const *sFileName, void *pInbuffer, DWORD dwBufferLen);

NET_DVR_API BOOL __stdcall NET_DVR_GetDialParam(LONG lUserID, LPNET_DVR_DIALREQUEST lpDialRequest, LPNET_DVR_DIALPARAM lpDialParam);
NET_DVR_API BOOL __stdcall NET_DVR_SetDialParam(LONG lUserID, LPNET_DVR_DIALREQUEST lpDialRequest, LPNET_DVR_DIALPARAM lpDialParam);
NET_DVR_API BOOL __stdcall NET_DVR_GetSmsListInfo(LONG lUserID, LPNET_DVR_TIME_EX lpStartTime, LPNET_DVR_TIME_EX lpStopTime, LPNET_DVR_SMSLISTINFO lpSmsListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_SendSms(LONG lUserID, LPNET_DVR_SMSCONTENT lpSmsContent);
NET_DVR_API BOOL __stdcall NET_DVR_GetSmsContent(LONG lUserID, DWORD dwSmsIndex, LPNET_DVR_SMSCONTENT lpSmsContent);
NET_DVR_API LONG __stdcall NET_DVR_SmartSearchPicture(LONG lUserID, NET_DVR_SMART_SEARCH_PIC_PARA * pFindParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextSmartPicture(LONG lFindHandle,LPNET_DVR_SMART_SEARCH_PIC_RET lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_CloseSmartSearchPicture(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSubDecSystemJoinInfo_V41(LONG lUserID, LPNET_DVR_ALLDECSUBSYSTEMJOININFO_V41 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_SetESCallBack(LONG iRealHandle, void (__stdcall *fnESCallback)(LONG lPreviewHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize,  void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetESRealPlayCallBack(LONG iRealHandle, void(__stdcall *fPlayESCallBack)(LONG lPreviewHandle, NET_DVR_PACKET_INFO_EX *pstruPackInfo, void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_ActivateDevice(char* sDVRIP, WORD wDVRPort, LPNET_DVR_ACTIVATECFG    lpActivateCfg);
NET_DVR_API BOOL __stdcall NET_DVR_GetAddrInfoByServer(DWORD     dwQueryType, void* pInBuf, DWORD dwInBufLen, void* pOutBuf, DWORD dwOutBufLen);
NET_DVR_API BOOL __stdcall NET_DVR_StartGetDevState(LPNET_DVR_CHECK_DEV_STATE pParams);
NET_DVR_API BOOL __stdcall NET_DVR_StopGetDevState();
NET_DVR_API BOOL __stdcall NET_DVR_RigisterPlayBackDrawFun(LONG lPlayHandle, void (__stdcall *fDrawFun)(LONG lPlayHandle, HDC hDc, DWORD dwUser), DWORD dwUser);

NET_DVR_API BOOL __stdcall NET_DVR_SetSDKInitCfg(NET_SDK_INIT_CFG_TYPE enumType, void* const lpInBuff);
NET_DVR_API BOOL __stdcall NET_DVR_ReleaseSDKMemPool(LPNET_DVR_SDKMEMPOOL_CFG lpSdkMemPoolCfg);

NET_DVR_API BOOL __stdcall NET_DVR_CapturePictureBlock(LONG iRealHandle, char const *sPicFileName, DWORD dwTimeOut);

NET_DVR_API BOOL __stdcall NET_DVR_CapturePictureBlock_New(LONG iRealHandle, char *pPicBuf, DWORD dwPicSize, DWORD *lpSizeReturned);

NET_DVR_API BOOL __stdcall NET_DVR_ChangeWndResolution(LONG iRealHandle);

#endif //